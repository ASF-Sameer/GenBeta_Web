var V5 = Object.defineProperty;
var k5 = (r, e, t) => e in r ? V5(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t;
var rn = (r, e, t) => k5(r, typeof e != "symbol" ? e + "" : e, t);
(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
        n(i);
    new MutationObserver(i => {
        for (const a of i)
            if (a.type === "childList")
                for (const s of a.addedNodes)
                    s.tagName === "LINK" && s.rel === "modulepreload" && n(s)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function t(i) {
        const a = {};
        return i.integrity && (a.integrity = i.integrity),
        i.referrerPolicy && (a.referrerPolicy = i.referrerPolicy),
        i.crossOrigin === "use-credentials" ? a.credentials = "include" : i.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin",
        a
    }
    function n(i) {
        if (i.ep)
            return;
        i.ep = !0;
        const a = t(i);
        fetch(i.href, a)
    }
}
)();
function jb(r) {
    return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r
}
var M2 = {
    exports: {}
}
  , av = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var WR;
function G5() {
    if (WR)
        return av;
    WR = 1;
    var r = Symbol.for("react.transitional.element")
      , e = Symbol.for("react.fragment");
    function t(n, i, a) {
        var s = null;
        if (a !== void 0 && (s = "" + a),
        i.key !== void 0 && (s = "" + i.key),
        "key"in i) {
            a = {};
            for (var l in i)
                l !== "key" && (a[l] = i[l])
        } else
            a = i;
        return i = a.ref,
        {
            $$typeof: r,
            type: n,
            key: s,
            ref: i !== void 0 ? i : null,
            props: a
        }
    }
    return av.Fragment = e,
    av.jsx = t,
    av.jsxs = t,
    av
}
var YR;
function X5() {
    return YR || (YR = 1,
    M2.exports = G5()),
    M2.exports
}
var ae = X5()
  , T2 = {
    exports: {}
}
  , sv = {}
  , E2 = {
    exports: {}
}
  , w2 = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qR;
function j5() {
    return qR || (qR = 1,
    function(r) {
        function e(H, q) {
            var Q = H.length;
            H.push(q);
            e: for (; 0 < Q; ) {
                var se = Q - 1 >>> 1
                  , B = H[se];
                if (0 < i(B, q))
                    H[se] = q,
                    H[Q] = B,
                    Q = se;
                else
                    break e
            }
        }
        function t(H) {
            return H.length === 0 ? null : H[0]
        }
        function n(H) {
            if (H.length === 0)
                return null;
            var q = H[0]
              , Q = H.pop();
            if (Q !== q) {
                H[0] = Q;
                e: for (var se = 0, B = H.length, W = B >>> 1; se < W; ) {
                    var te = 2 * (se + 1) - 1
                      , fe = H[te]
                      , pe = te + 1
                      , _e = H[pe];
                    if (0 > i(fe, Q))
                        pe < B && 0 > i(_e, fe) ? (H[se] = _e,
                        H[pe] = Q,
                        se = pe) : (H[se] = fe,
                        H[te] = Q,
                        se = te);
                    else if (pe < B && 0 > i(_e, Q))
                        H[se] = _e,
                        H[pe] = Q,
                        se = pe;
                    else
                        break e
                }
            }
            return q
        }
        function i(H, q) {
            var Q = H.sortIndex - q.sortIndex;
            return Q !== 0 ? Q : H.id - q.id
        }
        if (r.unstable_now = void 0,
        typeof performance == "object" && typeof performance.now == "function") {
            var a = performance;
            r.unstable_now = function() {
                return a.now()
            }
        } else {
            var s = Date
              , l = s.now();
            r.unstable_now = function() {
                return s.now() - l
            }
        }
        var u = []
          , f = []
          , d = 1
          , g = null
          , v = 3
          , y = !1
          , S = !1
          , T = !1
          , M = !1
          , b = typeof setTimeout == "function" ? setTimeout : null
          , A = typeof clearTimeout == "function" ? clearTimeout : null
          , C = typeof setImmediate < "u" ? setImmediate : null;
        function R(H) {
            for (var q = t(f); q !== null; ) {
                if (q.callback === null)
                    n(f);
                else if (q.startTime <= H)
                    n(f),
                    q.sortIndex = q.expirationTime,
                    e(u, q);
                else
                    break;
                q = t(f)
            }
        }
        function O(H) {
            if (T = !1,
            R(H),
            !S)
                if (t(u) !== null)
                    S = !0,
                    L || (L = !0,
                    V());
                else {
                    var q = t(f);
                    q !== null && oe(O, q.startTime - H)
                }
        }
        var L = !1
          , z = -1
          , I = 5
          , N = -1;
        function P() {
            return M ? !0 : !(r.unstable_now() - N < I)
        }
        function Y() {
            if (M = !1,
            L) {
                var H = r.unstable_now();
                N = H;
                var q = !0;
                try {
                    e: {
                        S = !1,
                        T && (T = !1,
                        A(z),
                        z = -1),
                        y = !0;
                        var Q = v;
                        try {
                            t: {
                                for (R(H),
                                g = t(u); g !== null && !(g.expirationTime > H && P()); ) {
                                    var se = g.callback;
                                    if (typeof se == "function") {
                                        g.callback = null,
                                        v = g.priorityLevel;
                                        var B = se(g.expirationTime <= H);
                                        if (H = r.unstable_now(),
                                        typeof B == "function") {
                                            g.callback = B,
                                            R(H),
                                            q = !0;
                                            break t
                                        }
                                        g === t(u) && n(u),
                                        R(H)
                                    } else
                                        n(u);
                                    g = t(u)
                                }
                                if (g !== null)
                                    q = !0;
                                else {
                                    var W = t(f);
                                    W !== null && oe(O, W.startTime - H),
                                    q = !1
                                }
                            }
                            break e
                        } finally {
                            g = null,
                            v = Q,
                            y = !1
                        }
                        q = void 0
                    }
                } finally {
                    q ? V() : L = !1
                }
            }
        }
        var V;
        if (typeof C == "function")
            V = function() {
                C(Y)
            }
            ;
        else if (typeof MessageChannel < "u") {
            var K = new MessageChannel
              , Z = K.port2;
            K.port1.onmessage = Y,
            V = function() {
                Z.postMessage(null)
            }
        } else
            V = function() {
                b(Y, 0)
            }
            ;
        function oe(H, q) {
            z = b(function() {
                H(r.unstable_now())
            }, q)
        }
        r.unstable_IdlePriority = 5,
        r.unstable_ImmediatePriority = 1,
        r.unstable_LowPriority = 4,
        r.unstable_NormalPriority = 3,
        r.unstable_Profiling = null,
        r.unstable_UserBlockingPriority = 2,
        r.unstable_cancelCallback = function(H) {
            H.callback = null
        }
        ,
        r.unstable_forceFrameRate = function(H) {
            0 > H || 125 < H ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : I = 0 < H ? Math.floor(1e3 / H) : 5
        }
        ,
        r.unstable_getCurrentPriorityLevel = function() {
            return v
        }
        ,
        r.unstable_next = function(H) {
            switch (v) {
            case 1:
            case 2:
            case 3:
                var q = 3;
                break;
            default:
                q = v
            }
            var Q = v;
            v = q;
            try {
                return H()
            } finally {
                v = Q
            }
        }
        ,
        r.unstable_requestPaint = function() {
            M = !0
        }
        ,
        r.unstable_runWithPriority = function(H, q) {
            switch (H) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                H = 3
            }
            var Q = v;
            v = H;
            try {
                return q()
            } finally {
                v = Q
            }
        }
        ,
        r.unstable_scheduleCallback = function(H, q, Q) {
            var se = r.unstable_now();
            switch (typeof Q == "object" && Q !== null ? (Q = Q.delay,
            Q = typeof Q == "number" && 0 < Q ? se + Q : se) : Q = se,
            H) {
            case 1:
                var B = -1;
                break;
            case 2:
                B = 250;
                break;
            case 5:
                B = 1073741823;
                break;
            case 4:
                B = 1e4;
                break;
            default:
                B = 5e3
            }
            return B = Q + B,
            H = {
                id: d++,
                callback: q,
                priorityLevel: H,
                startTime: Q,
                expirationTime: B,
                sortIndex: -1
            },
            Q > se ? (H.sortIndex = Q,
            e(f, H),
            t(u) === null && H === t(f) && (T ? (A(z),
            z = -1) : T = !0,
            oe(O, Q - se))) : (H.sortIndex = B,
            e(u, H),
            S || y || (S = !0,
            L || (L = !0,
            V()))),
            H
        }
        ,
        r.unstable_shouldYield = P,
        r.unstable_wrapCallback = function(H) {
            var q = v;
            return function() {
                var Q = v;
                v = q;
                try {
                    return H.apply(this, arguments)
                } finally {
                    v = Q
                }
            }
        }
    }(w2)),
    w2
}
var ZR;
function W5() {
    return ZR || (ZR = 1,
    E2.exports = j5()),
    E2.exports
}
var A2 = {
    exports: {}
}
  , Pn = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var KR;
function Y5() {
    if (KR)
        return Pn;
    KR = 1;
    var r = Symbol.for("react.transitional.element")
      , e = Symbol.for("react.portal")
      , t = Symbol.for("react.fragment")
      , n = Symbol.for("react.strict_mode")
      , i = Symbol.for("react.profiler")
      , a = Symbol.for("react.consumer")
      , s = Symbol.for("react.context")
      , l = Symbol.for("react.forward_ref")
      , u = Symbol.for("react.suspense")
      , f = Symbol.for("react.memo")
      , d = Symbol.for("react.lazy")
      , g = Symbol.iterator;
    function v(B) {
        return B === null || typeof B != "object" ? null : (B = g && B[g] || B["@@iterator"],
        typeof B == "function" ? B : null)
    }
    var y = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    }
      , S = Object.assign
      , T = {};
    function M(B, W, te) {
        this.props = B,
        this.context = W,
        this.refs = T,
        this.updater = te || y
    }
    M.prototype.isReactComponent = {},
    M.prototype.setState = function(B, W) {
        if (typeof B != "object" && typeof B != "function" && B != null)
            throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, B, W, "setState")
    }
    ,
    M.prototype.forceUpdate = function(B) {
        this.updater.enqueueForceUpdate(this, B, "forceUpdate")
    }
    ;
    function b() {}
    b.prototype = M.prototype;
    function A(B, W, te) {
        this.props = B,
        this.context = W,
        this.refs = T,
        this.updater = te || y
    }
    var C = A.prototype = new b;
    C.constructor = A,
    S(C, M.prototype),
    C.isPureReactComponent = !0;
    var R = Array.isArray
      , O = {
        H: null,
        A: null,
        T: null,
        S: null,
        V: null
    }
      , L = Object.prototype.hasOwnProperty;
    function z(B, W, te, fe, pe, _e) {
        return te = _e.ref,
        {
            $$typeof: r,
            type: B,
            key: W,
            ref: te !== void 0 ? te : null,
            props: _e
        }
    }
    function I(B, W) {
        return z(B.type, W, void 0, void 0, void 0, B.props)
    }
    function N(B) {
        return typeof B == "object" && B !== null && B.$$typeof === r
    }
    function P(B) {
        var W = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + B.replace(/[=:]/g, function(te) {
            return W[te]
        })
    }
    var Y = /\/+/g;
    function V(B, W) {
        return typeof B == "object" && B !== null && B.key != null ? P("" + B.key) : W.toString(36)
    }
    function K() {}
    function Z(B) {
        switch (B.status) {
        case "fulfilled":
            return B.value;
        case "rejected":
            throw B.reason;
        default:
            switch (typeof B.status == "string" ? B.then(K, K) : (B.status = "pending",
            B.then(function(W) {
                B.status === "pending" && (B.status = "fulfilled",
                B.value = W)
            }, function(W) {
                B.status === "pending" && (B.status = "rejected",
                B.reason = W)
            })),
            B.status) {
            case "fulfilled":
                return B.value;
            case "rejected":
                throw B.reason
            }
        }
        throw B
    }
    function oe(B, W, te, fe, pe) {
        var _e = typeof B;
        (_e === "undefined" || _e === "boolean") && (B = null);
        var ue = !1;
        if (B === null)
            ue = !0;
        else
            switch (_e) {
            case "bigint":
            case "string":
            case "number":
                ue = !0;
                break;
            case "object":
                switch (B.$$typeof) {
                case r:
                case e:
                    ue = !0;
                    break;
                case d:
                    return ue = B._init,
                    oe(ue(B._payload), W, te, fe, pe)
                }
            }
        if (ue)
            return pe = pe(B),
            ue = fe === "" ? "." + V(B, 0) : fe,
            R(pe) ? (te = "",
            ue != null && (te = ue.replace(Y, "$&/") + "/"),
            oe(pe, W, te, "", function(Ze) {
                return Ze
            })) : pe != null && (N(pe) && (pe = I(pe, te + (pe.key == null || B && B.key === pe.key ? "" : ("" + pe.key).replace(Y, "$&/") + "/") + ue)),
            W.push(pe)),
            1;
        ue = 0;
        var ge = fe === "" ? "." : fe + ":";
        if (R(B))
            for (var Te = 0; Te < B.length; Te++)
                fe = B[Te],
                _e = ge + V(fe, Te),
                ue += oe(fe, W, te, _e, pe);
        else if (Te = v(B),
        typeof Te == "function")
            for (B = Te.call(B),
            Te = 0; !(fe = B.next()).done; )
                fe = fe.value,
                _e = ge + V(fe, Te++),
                ue += oe(fe, W, te, _e, pe);
        else if (_e === "object") {
            if (typeof B.then == "function")
                return oe(Z(B), W, te, fe, pe);
            throw W = String(B),
            Error("Objects are not valid as a React child (found: " + (W === "[object Object]" ? "object with keys {" + Object.keys(B).join(", ") + "}" : W) + "). If you meant to render a collection of children, use an array instead.")
        }
        return ue
    }
    function H(B, W, te) {
        if (B == null)
            return B;
        var fe = []
          , pe = 0;
        return oe(B, fe, "", "", function(_e) {
            return W.call(te, _e, pe++)
        }),
        fe
    }
    function q(B) {
        if (B._status === -1) {
            var W = B._result;
            W = W(),
            W.then(function(te) {
                (B._status === 0 || B._status === -1) && (B._status = 1,
                B._result = te)
            }, function(te) {
                (B._status === 0 || B._status === -1) && (B._status = 2,
                B._result = te)
            }),
            B._status === -1 && (B._status = 0,
            B._result = W)
        }
        if (B._status === 1)
            return B._result.default;
        throw B._result
    }
    var Q = typeof reportError == "function" ? reportError : function(B) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
            var W = new window.ErrorEvent("error",{
                bubbles: !0,
                cancelable: !0,
                message: typeof B == "object" && B !== null && typeof B.message == "string" ? String(B.message) : String(B),
                error: B
            });
            if (!window.dispatchEvent(W))
                return
        } else if (typeof process == "object" && typeof process.emit == "function") {
            process.emit("uncaughtException", B);
            return
        }
        console.error(B)
    }
    ;
    function se() {}
    return Pn.Children = {
        map: H,
        forEach: function(B, W, te) {
            H(B, function() {
                W.apply(this, arguments)
            }, te)
        },
        count: function(B) {
            var W = 0;
            return H(B, function() {
                W++
            }),
            W
        },
        toArray: function(B) {
            return H(B, function(W) {
                return W
            }) || []
        },
        only: function(B) {
            if (!N(B))
                throw Error("React.Children.only expected to receive a single React element child.");
            return B
        }
    },
    Pn.Component = M,
    Pn.Fragment = t,
    Pn.Profiler = i,
    Pn.PureComponent = A,
    Pn.StrictMode = n,
    Pn.Suspense = u,
    Pn.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = O,
    Pn.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(B) {
            return O.H.useMemoCache(B)
        }
    },
    Pn.cache = function(B) {
        return function() {
            return B.apply(null, arguments)
        }
    }
    ,
    Pn.cloneElement = function(B, W, te) {
        if (B == null)
            throw Error("The argument must be a React element, but you passed " + B + ".");
        var fe = S({}, B.props)
          , pe = B.key
          , _e = void 0;
        if (W != null)
            for (ue in W.ref !== void 0 && (_e = void 0),
            W.key !== void 0 && (pe = "" + W.key),
            W)
                !L.call(W, ue) || ue === "key" || ue === "__self" || ue === "__source" || ue === "ref" && W.ref === void 0 || (fe[ue] = W[ue]);
        var ue = arguments.length - 2;
        if (ue === 1)
            fe.children = te;
        else if (1 < ue) {
            for (var ge = Array(ue), Te = 0; Te < ue; Te++)
                ge[Te] = arguments[Te + 2];
            fe.children = ge
        }
        return z(B.type, pe, void 0, void 0, _e, fe)
    }
    ,
    Pn.createContext = function(B) {
        return B = {
            $$typeof: s,
            _currentValue: B,
            _currentValue2: B,
            _threadCount: 0,
            Provider: null,
            Consumer: null
        },
        B.Provider = B,
        B.Consumer = {
            $$typeof: a,
            _context: B
        },
        B
    }
    ,
    Pn.createElement = function(B, W, te) {
        var fe, pe = {}, _e = null;
        if (W != null)
            for (fe in W.key !== void 0 && (_e = "" + W.key),
            W)
                L.call(W, fe) && fe !== "key" && fe !== "__self" && fe !== "__source" && (pe[fe] = W[fe]);
        var ue = arguments.length - 2;
        if (ue === 1)
            pe.children = te;
        else if (1 < ue) {
            for (var ge = Array(ue), Te = 0; Te < ue; Te++)
                ge[Te] = arguments[Te + 2];
            pe.children = ge
        }
        if (B && B.defaultProps)
            for (fe in ue = B.defaultProps,
            ue)
                pe[fe] === void 0 && (pe[fe] = ue[fe]);
        return z(B, _e, void 0, void 0, null, pe)
    }
    ,
    Pn.createRef = function() {
        return {
            current: null
        }
    }
    ,
    Pn.forwardRef = function(B) {
        return {
            $$typeof: l,
            render: B
        }
    }
    ,
    Pn.isValidElement = N,
    Pn.lazy = function(B) {
        return {
            $$typeof: d,
            _payload: {
                _status: -1,
                _result: B
            },
            _init: q
        }
    }
    ,
    Pn.memo = function(B, W) {
        return {
            $$typeof: f,
            type: B,
            compare: W === void 0 ? null : W
        }
    }
    ,
    Pn.startTransition = function(B) {
        var W = O.T
          , te = {};
        O.T = te;
        try {
            var fe = B()
              , pe = O.S;
            pe !== null && pe(te, fe),
            typeof fe == "object" && fe !== null && typeof fe.then == "function" && fe.then(se, Q)
        } catch (_e) {
            Q(_e)
        } finally {
            O.T = W
        }
    }
    ,
    Pn.unstable_useCacheRefresh = function() {
        return O.H.useCacheRefresh()
    }
    ,
    Pn.use = function(B) {
        return O.H.use(B)
    }
    ,
    Pn.useActionState = function(B, W, te) {
        return O.H.useActionState(B, W, te)
    }
    ,
    Pn.useCallback = function(B, W) {
        return O.H.useCallback(B, W)
    }
    ,
    Pn.useContext = function(B) {
        return O.H.useContext(B)
    }
    ,
    Pn.useDebugValue = function() {}
    ,
    Pn.useDeferredValue = function(B, W) {
        return O.H.useDeferredValue(B, W)
    }
    ,
    Pn.useEffect = function(B, W, te) {
        var fe = O.H;
        if (typeof te == "function")
            throw Error("useEffect CRUD overload is not enabled in this build of React.");
        return fe.useEffect(B, W)
    }
    ,
    Pn.useId = function() {
        return O.H.useId()
    }
    ,
    Pn.useImperativeHandle = function(B, W, te) {
        return O.H.useImperativeHandle(B, W, te)
    }
    ,
    Pn.useInsertionEffect = function(B, W) {
        return O.H.useInsertionEffect(B, W)
    }
    ,
    Pn.useLayoutEffect = function(B, W) {
        return O.H.useLayoutEffect(B, W)
    }
    ,
    Pn.useMemo = function(B, W) {
        return O.H.useMemo(B, W)
    }
    ,
    Pn.useOptimistic = function(B, W) {
        return O.H.useOptimistic(B, W)
    }
    ,
    Pn.useReducer = function(B, W, te) {
        return O.H.useReducer(B, W, te)
    }
    ,
    Pn.useRef = function(B) {
        return O.H.useRef(B)
    }
    ,
    Pn.useState = function(B) {
        return O.H.useState(B)
    }
    ,
    Pn.useSyncExternalStore = function(B, W, te) {
        return O.H.useSyncExternalStore(B, W, te)
    }
    ,
    Pn.useTransition = function() {
        return O.H.useTransition()
    }
    ,
    Pn.version = "19.1.0",
    Pn
}
var QR;
function zg() {
    return QR || (QR = 1,
    A2.exports = Y5()),
    A2.exports
}
var C2 = {
    exports: {}
}
  , Ra = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JR;
function q5() {
    if (JR)
        return Ra;
    JR = 1;
    var r = zg();
    function e(u) {
        var f = "https://react.dev/errors/" + u;
        if (1 < arguments.length) {
            f += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var d = 2; d < arguments.length; d++)
                f += "&args[]=" + encodeURIComponent(arguments[d])
        }
        return "Minified React error #" + u + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    function t() {}
    var n = {
        d: {
            f: t,
            r: function() {
                throw Error(e(522))
            },
            D: t,
            C: t,
            L: t,
            m: t,
            X: t,
            S: t,
            M: t
        },
        p: 0,
        findDOMNode: null
    }
      , i = Symbol.for("react.portal");
    function a(u, f, d) {
        var g = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: i,
            key: g == null ? null : "" + g,
            children: u,
            containerInfo: f,
            implementation: d
        }
    }
    var s = r.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function l(u, f) {
        if (u === "font")
            return "";
        if (typeof f == "string")
            return f === "use-credentials" ? f : ""
    }
    return Ra.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = n,
    Ra.createPortal = function(u, f) {
        var d = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!f || f.nodeType !== 1 && f.nodeType !== 9 && f.nodeType !== 11)
            throw Error(e(299));
        return a(u, f, null, d)
    }
    ,
    Ra.flushSync = function(u) {
        var f = s.T
          , d = n.p;
        try {
            if (s.T = null,
            n.p = 2,
            u)
                return u()
        } finally {
            s.T = f,
            n.p = d,
            n.d.f()
        }
    }
    ,
    Ra.preconnect = function(u, f) {
        typeof u == "string" && (f ? (f = f.crossOrigin,
        f = typeof f == "string" ? f === "use-credentials" ? f : "" : void 0) : f = null,
        n.d.C(u, f))
    }
    ,
    Ra.prefetchDNS = function(u) {
        typeof u == "string" && n.d.D(u)
    }
    ,
    Ra.preinit = function(u, f) {
        if (typeof u == "string" && f && typeof f.as == "string") {
            var d = f.as
              , g = l(d, f.crossOrigin)
              , v = typeof f.integrity == "string" ? f.integrity : void 0
              , y = typeof f.fetchPriority == "string" ? f.fetchPriority : void 0;
            d === "style" ? n.d.S(u, typeof f.precedence == "string" ? f.precedence : void 0, {
                crossOrigin: g,
                integrity: v,
                fetchPriority: y
            }) : d === "script" && n.d.X(u, {
                crossOrigin: g,
                integrity: v,
                fetchPriority: y,
                nonce: typeof f.nonce == "string" ? f.nonce : void 0
            })
        }
    }
    ,
    Ra.preinitModule = function(u, f) {
        if (typeof u == "string")
            if (typeof f == "object" && f !== null) {
                if (f.as == null || f.as === "script") {
                    var d = l(f.as, f.crossOrigin);
                    n.d.M(u, {
                        crossOrigin: d,
                        integrity: typeof f.integrity == "string" ? f.integrity : void 0,
                        nonce: typeof f.nonce == "string" ? f.nonce : void 0
                    })
                }
            } else
                f == null && n.d.M(u)
    }
    ,
    Ra.preload = function(u, f) {
        if (typeof u == "string" && typeof f == "object" && f !== null && typeof f.as == "string") {
            var d = f.as
              , g = l(d, f.crossOrigin);
            n.d.L(u, d, {
                crossOrigin: g,
                integrity: typeof f.integrity == "string" ? f.integrity : void 0,
                nonce: typeof f.nonce == "string" ? f.nonce : void 0,
                type: typeof f.type == "string" ? f.type : void 0,
                fetchPriority: typeof f.fetchPriority == "string" ? f.fetchPriority : void 0,
                referrerPolicy: typeof f.referrerPolicy == "string" ? f.referrerPolicy : void 0,
                imageSrcSet: typeof f.imageSrcSet == "string" ? f.imageSrcSet : void 0,
                imageSizes: typeof f.imageSizes == "string" ? f.imageSizes : void 0,
                media: typeof f.media == "string" ? f.media : void 0
            })
        }
    }
    ,
    Ra.preloadModule = function(u, f) {
        if (typeof u == "string")
            if (f) {
                var d = l(f.as, f.crossOrigin);
                n.d.m(u, {
                    as: typeof f.as == "string" && f.as !== "script" ? f.as : void 0,
                    crossOrigin: d,
                    integrity: typeof f.integrity == "string" ? f.integrity : void 0
                })
            } else
                n.d.m(u)
    }
    ,
    Ra.requestFormReset = function(u) {
        n.d.r(u)
    }
    ,
    Ra.unstable_batchedUpdates = function(u, f) {
        return u(f)
    }
    ,
    Ra.useFormState = function(u, f, d) {
        return s.H.useFormState(u, f, d)
    }
    ,
    Ra.useFormStatus = function() {
        return s.H.useHostTransitionStatus()
    }
    ,
    Ra.version = "19.1.0",
    Ra
}
var $R;
function Z5() {
    if ($R)
        return C2.exports;
    $R = 1;
    function r() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(r)
            } catch (e) {
                console.error(e)
            }
    }
    return r(),
    C2.exports = q5(),
    C2.exports
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e3;
function K5() {
    if (e3)
        return sv;
    e3 = 1;
    var r = W5()
      , e = zg()
      , t = Z5();
    function n(o) {
        var c = "https://react.dev/errors/" + o;
        if (1 < arguments.length) {
            c += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var m = 2; m < arguments.length; m++)
                c += "&args[]=" + encodeURIComponent(arguments[m])
        }
        return "Minified React error #" + o + "; visit " + c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    function i(o) {
        return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11)
    }
    function a(o) {
        var c = o
          , m = o;
        if (o.alternate)
            for (; c.return; )
                c = c.return;
        else {
            o = c;
            do
                c = o,
                (c.flags & 4098) !== 0 && (m = c.return),
                o = c.return;
            while (o)
        }
        return c.tag === 3 ? m : null
    }
    function s(o) {
        if (o.tag === 13) {
            var c = o.memoizedState;
            if (c === null && (o = o.alternate,
            o !== null && (c = o.memoizedState)),
            c !== null)
                return c.dehydrated
        }
        return null
    }
    function l(o) {
        if (a(o) !== o)
            throw Error(n(188))
    }
    function u(o) {
        var c = o.alternate;
        if (!c) {
            if (c = a(o),
            c === null)
                throw Error(n(188));
            return c !== o ? null : o
        }
        for (var m = o, _ = c; ; ) {
            var E = m.return;
            if (E === null)
                break;
            var D = E.alternate;
            if (D === null) {
                if (_ = E.return,
                _ !== null) {
                    m = _;
                    continue
                }
                break
            }
            if (E.child === D.child) {
                for (D = E.child; D; ) {
                    if (D === m)
                        return l(E),
                        o;
                    if (D === _)
                        return l(E),
                        c;
                    D = D.sibling
                }
                throw Error(n(188))
            }
            if (m.return !== _.return)
                m = E,
                _ = D;
            else {
                for (var X = !1, ee = E.child; ee; ) {
                    if (ee === m) {
                        X = !0,
                        m = E,
                        _ = D;
                        break
                    }
                    if (ee === _) {
                        X = !0,
                        _ = E,
                        m = D;
                        break
                    }
                    ee = ee.sibling
                }
                if (!X) {
                    for (ee = D.child; ee; ) {
                        if (ee === m) {
                            X = !0,
                            m = D,
                            _ = E;
                            break
                        }
                        if (ee === _) {
                            X = !0,
                            _ = D,
                            m = E;
                            break
                        }
                        ee = ee.sibling
                    }
                    if (!X)
                        throw Error(n(189))
                }
            }
            if (m.alternate !== _)
                throw Error(n(190))
        }
        if (m.tag !== 3)
            throw Error(n(188));
        return m.stateNode.current === m ? o : c
    }
    function f(o) {
        var c = o.tag;
        if (c === 5 || c === 26 || c === 27 || c === 6)
            return o;
        for (o = o.child; o !== null; ) {
            if (c = f(o),
            c !== null)
                return c;
            o = o.sibling
        }
        return null
    }
    var d = Object.assign
      , g = Symbol.for("react.element")
      , v = Symbol.for("react.transitional.element")
      , y = Symbol.for("react.portal")
      , S = Symbol.for("react.fragment")
      , T = Symbol.for("react.strict_mode")
      , M = Symbol.for("react.profiler")
      , b = Symbol.for("react.provider")
      , A = Symbol.for("react.consumer")
      , C = Symbol.for("react.context")
      , R = Symbol.for("react.forward_ref")
      , O = Symbol.for("react.suspense")
      , L = Symbol.for("react.suspense_list")
      , z = Symbol.for("react.memo")
      , I = Symbol.for("react.lazy")
      , N = Symbol.for("react.activity")
      , P = Symbol.for("react.memo_cache_sentinel")
      , Y = Symbol.iterator;
    function V(o) {
        return o === null || typeof o != "object" ? null : (o = Y && o[Y] || o["@@iterator"],
        typeof o == "function" ? o : null)
    }
    var K = Symbol.for("react.client.reference");
    function Z(o) {
        if (o == null)
            return null;
        if (typeof o == "function")
            return o.$$typeof === K ? null : o.displayName || o.name || null;
        if (typeof o == "string")
            return o;
        switch (o) {
        case S:
            return "Fragment";
        case M:
            return "Profiler";
        case T:
            return "StrictMode";
        case O:
            return "Suspense";
        case L:
            return "SuspenseList";
        case N:
            return "Activity"
        }
        if (typeof o == "object")
            switch (o.$$typeof) {
            case y:
                return "Portal";
            case C:
                return (o.displayName || "Context") + ".Provider";
            case A:
                return (o._context.displayName || "Context") + ".Consumer";
            case R:
                var c = o.render;
                return o = o.displayName,
                o || (o = c.displayName || c.name || "",
                o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"),
                o;
            case z:
                return c = o.displayName || null,
                c !== null ? c : Z(o.type) || "Memo";
            case I:
                c = o._payload,
                o = o._init;
                try {
                    return Z(o(c))
                } catch {}
            }
        return null
    }
    var oe = Array.isArray
      , H = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
      , q = t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
      , Q = {
        pending: !1,
        data: null,
        method: null,
        action: null
    }
      , se = []
      , B = -1;
    function W(o) {
        return {
            current: o
        }
    }
    function te(o) {
        0 > B || (o.current = se[B],
        se[B] = null,
        B--)
    }
    function fe(o, c) {
        B++,
        se[B] = o.current,
        o.current = c
    }
    var pe = W(null)
      , _e = W(null)
      , ue = W(null)
      , ge = W(null);
    function Te(o, c) {
        switch (fe(ue, c),
        fe(_e, o),
        fe(pe, null),
        c.nodeType) {
        case 9:
        case 11:
            o = (o = c.documentElement) && (o = o.namespaceURI) ? xR(o) : 0;
            break;
        default:
            if (o = c.tagName,
            c = c.namespaceURI)
                c = xR(c),
                o = SR(c, o);
            else
                switch (o) {
                case "svg":
                    o = 1;
                    break;
                case "math":
                    o = 2;
                    break;
                default:
                    o = 0
                }
        }
        te(pe),
        fe(pe, o)
    }
    function Ze() {
        te(pe),
        te(_e),
        te(ue)
    }
    function ot(o) {
        o.memoizedState !== null && fe(ge, o);
        var c = pe.current
          , m = SR(c, o.type);
        c !== m && (fe(_e, o),
        fe(pe, m))
    }
    function tt(o) {
        _e.current === o && (te(pe),
        te(_e)),
        ge.current === o && (te(ge),
        ev._currentValue = Q)
    }
    var $e = Object.prototype.hasOwnProperty
      , re = r.unstable_scheduleCallback
      , Le = r.unstable_cancelCallback
      , Ne = r.unstable_shouldYield
      , Oe = r.unstable_requestPaint
      , le = r.unstable_now
      , Pe = r.unstable_getCurrentPriorityLevel
      , He = r.unstable_ImmediatePriority
      , Ve = r.unstable_UserBlockingPriority
      , De = r.unstable_NormalPriority
      , vt = r.unstable_LowPriority
      , J = r.unstable_IdlePriority
      , j = r.log
      , ve = r.unstable_setDisableYieldValue
      , Be = null
      , we = null;
    function Ce(o) {
        if (typeof j == "function" && ve(o),
        we && typeof we.setStrictMode == "function")
            try {
                we.setStrictMode(Be, o)
            } catch {}
    }
    var it = Math.clz32 ? Math.clz32 : pt
      , lt = Math.log
      , Mt = Math.LN2;
    function pt(o) {
        return o >>>= 0,
        o === 0 ? 32 : 31 - (lt(o) / Mt | 0) | 0
    }
    var je = 256
      , Ye = 4194304;
    function ct(o) {
        var c = o & 42;
        if (c !== 0)
            return c;
        switch (o & -o) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
            return 64;
        case 128:
            return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return o & 4194048;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            return o & 62914560;
        case 67108864:
            return 67108864;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 0;
        default:
            return o
        }
    }
    function _t(o, c, m) {
        var _ = o.pendingLanes;
        if (_ === 0)
            return 0;
        var E = 0
          , D = o.suspendedLanes
          , X = o.pingedLanes;
        o = o.warmLanes;
        var ee = _ & 134217727;
        return ee !== 0 ? (_ = ee & ~D,
        _ !== 0 ? E = ct(_) : (X &= ee,
        X !== 0 ? E = ct(X) : m || (m = ee & ~o,
        m !== 0 && (E = ct(m))))) : (ee = _ & ~D,
        ee !== 0 ? E = ct(ee) : X !== 0 ? E = ct(X) : m || (m = _ & ~o,
        m !== 0 && (E = ct(m)))),
        E === 0 ? 0 : c !== 0 && c !== E && (c & D) === 0 && (D = E & -E,
        m = c & -c,
        D >= m || D === 32 && (m & 4194048) !== 0) ? c : E
    }
    function ut(o, c) {
        return (o.pendingLanes & ~(o.suspendedLanes & ~o.pingedLanes) & c) === 0
    }
    function Ut(o, c) {
        switch (o) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
            return c + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return c + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function me() {
        var o = je;
        return je <<= 1,
        (je & 4194048) === 0 && (je = 256),
        o
    }
    function Ee() {
        var o = Ye;
        return Ye <<= 1,
        (Ye & 62914560) === 0 && (Ye = 4194304),
        o
    }
    function at(o) {
        for (var c = [], m = 0; 31 > m; m++)
            c.push(o);
        return c
    }
    function Ct(o, c) {
        o.pendingLanes |= c,
        c !== 268435456 && (o.suspendedLanes = 0,
        o.pingedLanes = 0,
        o.warmLanes = 0)
    }
    function rt(o, c, m, _, E, D) {
        var X = o.pendingLanes;
        o.pendingLanes = m,
        o.suspendedLanes = 0,
        o.pingedLanes = 0,
        o.warmLanes = 0,
        o.expiredLanes &= m,
        o.entangledLanes &= m,
        o.errorRecoveryDisabledLanes &= m,
        o.shellSuspendCounter = 0;
        var ee = o.entanglements
          , be = o.expirationTimes
          , Xe = o.hiddenUpdates;
        for (m = X & ~m; 0 < m; ) {
            var dt = 31 - it(m)
              , St = 1 << dt;
            ee[dt] = 0,
            be[dt] = -1;
            var Qe = Xe[dt];
            if (Qe !== null)
                for (Xe[dt] = null,
                dt = 0; dt < Qe.length; dt++) {
                    var Je = Qe[dt];
                    Je !== null && (Je.lane &= -536870913)
                }
            m &= ~St
        }
        _ !== 0 && Ge(o, _, 0),
        D !== 0 && E === 0 && o.tag !== 0 && (o.suspendedLanes |= D & ~(X & ~c))
    }
    function Ge(o, c, m) {
        o.pendingLanes |= c,
        o.suspendedLanes &= ~c;
        var _ = 31 - it(c);
        o.entangledLanes |= c,
        o.entanglements[_] = o.entanglements[_] | 1073741824 | m & 4194090
    }
    function wt(o, c) {
        var m = o.entangledLanes |= c;
        for (o = o.entanglements; m; ) {
            var _ = 31 - it(m)
              , E = 1 << _;
            E & c | o[_] & c && (o[_] |= c),
            m &= ~E
        }
    }
    function Ot(o) {
        switch (o) {
        case 2:
            o = 1;
            break;
        case 8:
            o = 4;
            break;
        case 32:
            o = 16;
            break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            o = 128;
            break;
        case 268435456:
            o = 134217728;
            break;
        default:
            o = 0
        }
        return o
    }
    function Nt(o) {
        return o &= -o,
        2 < o ? 8 < o ? (o & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
    }
    function bt() {
        var o = q.p;
        return o !== 0 ? o : (o = window.event,
        o === void 0 ? 32 : HR(o.type))
    }
    function Bt(o, c) {
        var m = q.p;
        try {
            return q.p = o,
            c()
        } finally {
            q.p = m
        }
    }
    var Gt = Math.random().toString(36).slice(2)
      , mt = "__reactFiber$" + Gt
      , Lt = "__reactProps$" + Gt
      , zt = "__reactContainer$" + Gt
      , Wt = "__reactEvents$" + Gt
      , Ln = "__reactListeners$" + Gt
      , qt = "__reactHandles$" + Gt
      , Pt = "__reactResources$" + Gt
      , un = "__reactMarker$" + Gt;
    function $t(o) {
        delete o[mt],
        delete o[Lt],
        delete o[Wt],
        delete o[Ln],
        delete o[qt]
    }
    function k(o) {
        var c = o[mt];
        if (c)
            return c;
        for (var m = o.parentNode; m; ) {
            if (c = m[zt] || m[mt]) {
                if (m = c.alternate,
                c.child !== null || m !== null && m.child !== null)
                    for (o = ER(o); o !== null; ) {
                        if (m = o[mt])
                            return m;
                        o = ER(o)
                    }
                return c
            }
            o = m,
            m = o.parentNode
        }
        return null
    }
    function $(o) {
        if (o = o[mt] || o[zt]) {
            var c = o.tag;
            if (c === 5 || c === 6 || c === 13 || c === 26 || c === 27 || c === 3)
                return o
        }
        return null
    }
    function Se(o) {
        var c = o.tag;
        if (c === 5 || c === 26 || c === 27 || c === 6)
            return o.stateNode;
        throw Error(n(33))
    }
    function Ue(o) {
        var c = o[Pt];
        return c || (c = o[Pt] = {
            hoistableStyles: new Map,
            hoistableScripts: new Map
        }),
        c
    }
    function Fe(o) {
        o[un] = !0
    }
    var Ke = new Set
      , yt = {};
    function G(o, c) {
        ce(o, c),
        ce(o + "Capture", c)
    }
    function ce(o, c) {
        for (yt[o] = c,
        o = 0; o < c.length; o++)
            Ke.add(c[o])
    }
    var ye = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$")
      , xe = {}
      , ne = {};
    function nt(o) {
        return $e.call(ne, o) ? !0 : $e.call(xe, o) ? !1 : ye.test(o) ? ne[o] = !0 : (xe[o] = !0,
        !1)
    }
    function We(o, c, m) {
        if (nt(c))
            if (m === null)
                o.removeAttribute(c);
            else {
                switch (typeof m) {
                case "undefined":
                case "function":
                case "symbol":
                    o.removeAttribute(c);
                    return;
                case "boolean":
                    var _ = c.toLowerCase().slice(0, 5);
                    if (_ !== "data-" && _ !== "aria-") {
                        o.removeAttribute(c);
                        return
                    }
                }
                o.setAttribute(c, "" + m)
            }
    }
    function st(o, c, m) {
        if (m === null)
            o.removeAttribute(c);
        else {
            switch (typeof m) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                o.removeAttribute(c);
                return
            }
            o.setAttribute(c, "" + m)
        }
    }
    function ft(o, c, m, _) {
        if (_ === null)
            o.removeAttribute(m);
        else {
            switch (typeof _) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                o.removeAttribute(m);
                return
            }
            o.setAttributeNS(c, m, "" + _)
        }
    }
    var Tt, At;
    function Et(o) {
        if (Tt === void 0)
            try {
                throw Error()
            } catch (m) {
                var c = m.stack.trim().match(/\n( *(at )?)/);
                Tt = c && c[1] || "",
                At = -1 < m.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < m.stack.indexOf("@") ? "@unknown:0:0" : ""
            }
        return `
` + Tt + o + At
    }
    var Xt = !1;
    function Jt(o, c) {
        if (!o || Xt)
            return "";
        Xt = !0;
        var m = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            var _ = {
                DetermineComponentFrameRoot: function() {
                    try {
                        if (c) {
                            var St = function() {
                                throw Error()
                            };
                            if (Object.defineProperty(St.prototype, "props", {
                                set: function() {
                                    throw Error()
                                }
                            }),
                            typeof Reflect == "object" && Reflect.construct) {
                                try {
                                    Reflect.construct(St, [])
                                } catch (Je) {
                                    var Qe = Je
                                }
                                Reflect.construct(o, [], St)
                            } else {
                                try {
                                    St.call()
                                } catch (Je) {
                                    Qe = Je
                                }
                                o.call(St.prototype)
                            }
                        } else {
                            try {
                                throw Error()
                            } catch (Je) {
                                Qe = Je
                            }
                            (St = o()) && typeof St.catch == "function" && St.catch(function() {})
                        }
                    } catch (Je) {
                        if (Je && Qe && typeof Je.stack == "string")
                            return [Je.stack, Qe.stack]
                    }
                    return [null, null]
                }
            };
            _.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var E = Object.getOwnPropertyDescriptor(_.DetermineComponentFrameRoot, "name");
            E && E.configurable && Object.defineProperty(_.DetermineComponentFrameRoot, "name", {
                value: "DetermineComponentFrameRoot"
            });
            var D = _.DetermineComponentFrameRoot()
              , X = D[0]
              , ee = D[1];
            if (X && ee) {
                var be = X.split(`
`)
                  , Xe = ee.split(`
`);
                for (E = _ = 0; _ < be.length && !be[_].includes("DetermineComponentFrameRoot"); )
                    _++;
                for (; E < Xe.length && !Xe[E].includes("DetermineComponentFrameRoot"); )
                    E++;
                if (_ === be.length || E === Xe.length)
                    for (_ = be.length - 1,
                    E = Xe.length - 1; 1 <= _ && 0 <= E && be[_] !== Xe[E]; )
                        E--;
                for (; 1 <= _ && 0 <= E; _--,
                E--)
                    if (be[_] !== Xe[E]) {
                        if (_ !== 1 || E !== 1)
                            do
                                if (_--,
                                E--,
                                0 > E || be[_] !== Xe[E]) {
                                    var dt = `
` + be[_].replace(" at new ", " at ");
                                    return o.displayName && dt.includes("<anonymous>") && (dt = dt.replace("<anonymous>", o.displayName)),
                                    dt
                                }
                            while (1 <= _ && 0 <= E);
                        break
                    }
            }
        } finally {
            Xt = !1,
            Error.prepareStackTrace = m
        }
        return (m = o ? o.displayName || o.name : "") ? Et(m) : ""
    }
    function en(o) {
        switch (o.tag) {
        case 26:
        case 27:
        case 5:
            return Et(o.type);
        case 16:
            return Et("Lazy");
        case 13:
            return Et("Suspense");
        case 19:
            return Et("SuspenseList");
        case 0:
        case 15:
            return Jt(o.type, !1);
        case 11:
            return Jt(o.type.render, !1);
        case 1:
            return Jt(o.type, !0);
        case 31:
            return Et("Activity");
        default:
            return ""
        }
    }
    function Sn(o) {
        try {
            var c = "";
            do
                c += en(o),
                o = o.return;
            while (o);
            return c
        } catch (m) {
            return `
Error generating stack: ` + m.message + `
` + m.stack
        }
    }
    function Vt(o) {
        switch (typeof o) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return o;
        case "object":
            return o;
        default:
            return ""
        }
    }
    function It(o) {
        var c = o.type;
        return (o = o.nodeName) && o.toLowerCase() === "input" && (c === "checkbox" || c === "radio")
    }
    function Cn(o) {
        var c = It(o) ? "checked" : "value"
          , m = Object.getOwnPropertyDescriptor(o.constructor.prototype, c)
          , _ = "" + o[c];
        if (!o.hasOwnProperty(c) && typeof m < "u" && typeof m.get == "function" && typeof m.set == "function") {
            var E = m.get
              , D = m.set;
            return Object.defineProperty(o, c, {
                configurable: !0,
                get: function() {
                    return E.call(this)
                },
                set: function(X) {
                    _ = "" + X,
                    D.call(this, X)
                }
            }),
            Object.defineProperty(o, c, {
                enumerable: m.enumerable
            }),
            {
                getValue: function() {
                    return _
                },
                setValue: function(X) {
                    _ = "" + X
                },
                stopTracking: function() {
                    o._valueTracker = null,
                    delete o[c]
                }
            }
        }
    }
    function fn(o) {
        o._valueTracker || (o._valueTracker = Cn(o))
    }
    function In(o) {
        if (!o)
            return !1;
        var c = o._valueTracker;
        if (!c)
            return !0;
        var m = c.getValue()
          , _ = "";
        return o && (_ = It(o) ? o.checked ? "true" : "false" : o.value),
        o = _,
        o !== m ? (c.setValue(o),
        !0) : !1
    }
    function xn(o) {
        if (o = o || (typeof document < "u" ? document : void 0),
        typeof o > "u")
            return null;
        try {
            return o.activeElement || o.body
        } catch {
            return o.body
        }
    }
    var Bn = /[\n"\\]/g;
    function hn(o) {
        return o.replace(Bn, function(c) {
            return "\\" + c.charCodeAt(0).toString(16) + " "
        })
    }
    function Yt(o, c, m, _, E, D, X, ee) {
        o.name = "",
        X != null && typeof X != "function" && typeof X != "symbol" && typeof X != "boolean" ? o.type = X : o.removeAttribute("type"),
        c != null ? X === "number" ? (c === 0 && o.value === "" || o.value != c) && (o.value = "" + Vt(c)) : o.value !== "" + Vt(c) && (o.value = "" + Vt(c)) : X !== "submit" && X !== "reset" || o.removeAttribute("value"),
        c != null ? ri(o, X, Vt(c)) : m != null ? ri(o, X, Vt(m)) : _ != null && o.removeAttribute("value"),
        E == null && D != null && (o.defaultChecked = !!D),
        E != null && (o.checked = E && typeof E != "function" && typeof E != "symbol"),
        ee != null && typeof ee != "function" && typeof ee != "symbol" && typeof ee != "boolean" ? o.name = "" + Vt(ee) : o.removeAttribute("name")
    }
    function ti(o, c, m, _, E, D, X, ee) {
        if (D != null && typeof D != "function" && typeof D != "symbol" && typeof D != "boolean" && (o.type = D),
        c != null || m != null) {
            if (!(D !== "submit" && D !== "reset" || c != null))
                return;
            m = m != null ? "" + Vt(m) : "",
            c = c != null ? "" + Vt(c) : m,
            ee || c === o.value || (o.value = c),
            o.defaultValue = c
        }
        _ = _ ?? E,
        _ = typeof _ != "function" && typeof _ != "symbol" && !!_,
        o.checked = ee ? o.checked : !!_,
        o.defaultChecked = !!_,
        X != null && typeof X != "function" && typeof X != "symbol" && typeof X != "boolean" && (o.name = X)
    }
    function ri(o, c, m) {
        c === "number" && xn(o.ownerDocument) === o || o.defaultValue === "" + m || (o.defaultValue = "" + m)
    }
    function bn(o, c, m, _) {
        if (o = o.options,
        c) {
            c = {};
            for (var E = 0; E < m.length; E++)
                c["$" + m[E]] = !0;
            for (m = 0; m < o.length; m++)
                E = c.hasOwnProperty("$" + o[m].value),
                o[m].selected !== E && (o[m].selected = E),
                E && _ && (o[m].defaultSelected = !0)
        } else {
            for (m = "" + Vt(m),
            c = null,
            E = 0; E < o.length; E++) {
                if (o[E].value === m) {
                    o[E].selected = !0,
                    _ && (o[E].defaultSelected = !0);
                    return
                }
                c !== null || o[E].disabled || (c = o[E])
            }
            c !== null && (c.selected = !0)
        }
    }
    function ui(o, c, m) {
        if (c != null && (c = "" + Vt(c),
        c !== o.value && (o.value = c),
        m == null)) {
            o.defaultValue !== c && (o.defaultValue = c);
            return
        }
        o.defaultValue = m != null ? "" + Vt(m) : ""
    }
    function Ss(o, c, m, _) {
        if (c == null) {
            if (_ != null) {
                if (m != null)
                    throw Error(n(92));
                if (oe(_)) {
                    if (1 < _.length)
                        throw Error(n(93));
                    _ = _[0]
                }
                m = _
            }
            m == null && (m = ""),
            c = m
        }
        m = Vt(c),
        o.defaultValue = m,
        _ = o.textContent,
        _ === m && _ !== "" && _ !== null && (o.value = _)
    }
    function Di(o, c) {
        if (c) {
            var m = o.firstChild;
            if (m && m === o.lastChild && m.nodeType === 3) {
                m.nodeValue = c;
                return
            }
        }
        o.textContent = c
    }
    var rf = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
    function tu(o, c, m) {
        var _ = c.indexOf("--") === 0;
        m == null || typeof m == "boolean" || m === "" ? _ ? o.setProperty(c, "") : c === "float" ? o.cssFloat = "" : o[c] = "" : _ ? o.setProperty(c, m) : typeof m != "number" || m === 0 || rf.has(c) ? c === "float" ? o.cssFloat = m : o[c] = ("" + m).trim() : o[c] = m + "px"
    }
    function nu(o, c, m) {
        if (c != null && typeof c != "object")
            throw Error(n(62));
        if (o = o.style,
        m != null) {
            for (var _ in m)
                !m.hasOwnProperty(_) || c != null && c.hasOwnProperty(_) || (_.indexOf("--") === 0 ? o.setProperty(_, "") : _ === "float" ? o.cssFloat = "" : o[_] = "");
            for (var E in c)
                _ = c[E],
                c.hasOwnProperty(E) && m[E] !== _ && tu(o, E, _)
        } else
            for (var D in c)
                c.hasOwnProperty(D) && tu(o, D, c[D])
    }
    function iu(o) {
        if (o.indexOf("-") === -1)
            return !1;
        switch (o) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
        }
    }
    var ll = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]])
      , Ch = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function Ro(o) {
        return Ch.test("" + o) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : o
    }
    var Qs = null;
    function Js(o) {
        return o = o.target || o.srcElement || window,
        o.correspondingUseElement && (o = o.correspondingUseElement),
        o.nodeType === 3 ? o.parentNode : o
    }
    var ya = null
      , Do = null;
    function ul(o) {
        var c = $(o);
        if (c && (o = c.stateNode)) {
            var m = o[Lt] || null;
            e: switch (o = c.stateNode,
            c.type) {
            case "input":
                if (Yt(o, m.value, m.defaultValue, m.defaultValue, m.checked, m.defaultChecked, m.type, m.name),
                c = m.name,
                m.type === "radio" && c != null) {
                    for (m = o; m.parentNode; )
                        m = m.parentNode;
                    for (m = m.querySelectorAll('input[name="' + hn("" + c) + '"][type="radio"]'),
                    c = 0; c < m.length; c++) {
                        var _ = m[c];
                        if (_ !== o && _.form === o.form) {
                            var E = _[Lt] || null;
                            if (!E)
                                throw Error(n(90));
                            Yt(_, E.value, E.defaultValue, E.defaultValue, E.checked, E.defaultChecked, E.type, E.name)
                        }
                    }
                    for (c = 0; c < m.length; c++)
                        _ = m[c],
                        _.form === o.form && In(_)
                }
                break e;
            case "textarea":
                ui(o, m.value, m.defaultValue);
                break e;
            case "select":
                c = m.value,
                c != null && bn(o, !!m.multiple, c, !1)
            }
        }
    }
    var cl = !1;
    function uc(o, c, m) {
        if (cl)
            return o(c, m);
        cl = !0;
        try {
            var _ = o(c);
            return _
        } finally {
            if (cl = !1,
            (ya !== null || Do !== null) && (jo(),
            ya && (c = ya,
            o = Do,
            Do = ya = null,
            ul(c),
            o)))
                for (c = 0; c < o.length; c++)
                    ul(o[c])
        }
    }
    function fl(o, c) {
        var m = o.stateNode;
        if (m === null)
            return null;
        var _ = m[Lt] || null;
        if (_ === null)
            return null;
        m = _[c];
        e: switch (c) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (_ = !_.disabled) || (o = o.type,
            _ = !(o === "button" || o === "input" || o === "select" || o === "textarea")),
            o = !_;
            break e;
        default:
            o = !1
        }
        if (o)
            return null;
        if (m && typeof m != "function")
            throw Error(n(231, c, typeof m));
        return m
    }
    var ia = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
      , hl = !1;
    if (ia)
        try {
            var dl = {};
            Object.defineProperty(dl, "passive", {
                get: function() {
                    hl = !0
                }
            }),
            window.addEventListener("test", dl, dl),
            window.removeEventListener("test", dl, dl)
        } catch {
            hl = !1
        }
    var Xi = null
      , cc = null
      , fc = null;
    function af() {
        if (fc)
            return fc;
        var o, c = cc, m = c.length, _, E = "value"in Xi ? Xi.value : Xi.textContent, D = E.length;
        for (o = 0; o < m && c[o] === E[o]; o++)
            ;
        var X = m - o;
        for (_ = 1; _ <= X && c[m - _] === E[D - _]; _++)
            ;
        return fc = E.slice(o, 1 < _ ? 1 - _ : void 0)
    }
    function bs(o) {
        var c = o.keyCode;
        return "charCode"in o ? (o = o.charCode,
        o === 0 && c === 13 && (o = 13)) : o = c,
        o === 10 && (o = 13),
        32 <= o || o === 13 ? o : 0
    }
    function pl() {
        return !0
    }
    function ru() {
        return !1
    }
    function ji(o) {
        function c(m, _, E, D, X) {
            this._reactName = m,
            this._targetInst = E,
            this.type = _,
            this.nativeEvent = D,
            this.target = X,
            this.currentTarget = null;
            for (var ee in o)
                o.hasOwnProperty(ee) && (m = o[ee],
                this[ee] = m ? m(D) : D[ee]);
            return this.isDefaultPrevented = (D.defaultPrevented != null ? D.defaultPrevented : D.returnValue === !1) ? pl : ru,
            this.isPropagationStopped = ru,
            this
        }
        return d(c.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var m = this.nativeEvent;
                m && (m.preventDefault ? m.preventDefault() : typeof m.returnValue != "unknown" && (m.returnValue = !1),
                this.isDefaultPrevented = pl)
            },
            stopPropagation: function() {
                var m = this.nativeEvent;
                m && (m.stopPropagation ? m.stopPropagation() : typeof m.cancelBubble != "unknown" && (m.cancelBubble = !0),
                this.isPropagationStopped = pl)
            },
            persist: function() {},
            isPersistent: pl
        }),
        c
    }
    var _a = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(o) {
            return o.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    }, ra = ji(_a), ml = d({}, _a, {
        view: 0,
        detail: 0
    }), sf = ji(ml), ka, Ms, gl, Ts = d({}, ml, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: Uh,
        button: 0,
        buttons: 0,
        relatedTarget: function(o) {
            return o.relatedTarget === void 0 ? o.fromElement === o.srcElement ? o.toElement : o.fromElement : o.relatedTarget
        },
        movementX: function(o) {
            return "movementX"in o ? o.movementX : (o !== gl && (gl && o.type === "mousemove" ? (ka = o.screenX - gl.screenX,
            Ms = o.screenY - gl.screenY) : Ms = ka = 0,
            gl = o),
            ka)
        },
        movementY: function(o) {
            return "movementY"in o ? o.movementY : Ms
        }
    }), hc = ji(Ts), kr = d({}, Ts, {
        dataTransfer: 0
    }), Qg = ji(kr), zi = d({}, ml, {
        relatedTarget: 0
    }), vl = ji(zi), Rh = d({}, _a, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }), Sp = ji(Rh), Rr = d({}, _a, {
        clipboardData: function(o) {
            return "clipboardData"in o ? o.clipboardData : window.clipboardData
        }
    }), xa = ji(Rr), ir = d({}, _a, {
        data: 0
    }), Ga = ji(ir), Dh = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, A_ = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, C_ = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };
    function Jg(o) {
        var c = this.nativeEvent;
        return c.getModifierState ? c.getModifierState(o) : (o = C_[o]) ? !!c[o] : !1
    }
    function Uh() {
        return Jg
    }
    var R_ = d({}, ml, {
        key: function(o) {
            if (o.key) {
                var c = Dh[o.key] || o.key;
                if (c !== "Unidentified")
                    return c
            }
            return o.type === "keypress" ? (o = bs(o),
            o === 13 ? "Enter" : String.fromCharCode(o)) : o.type === "keydown" || o.type === "keyup" ? A_[o.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: Uh,
        charCode: function(o) {
            return o.type === "keypress" ? bs(o) : 0
        },
        keyCode: function(o) {
            return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0
        },
        which: function(o) {
            return o.type === "keypress" ? bs(o) : o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0
        }
    })
      , $g = ji(R_)
      , e0 = d({}, Ts, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    })
      , bp = ji(e0)
      , D_ = d({}, ml, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: Uh
    })
      , t0 = ji(D_)
      , U_ = d({}, _a, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    })
      , yl = ji(U_)
      , n0 = d({}, Ts, {
        deltaX: function(o) {
            return "deltaX"in o ? o.deltaX : "wheelDeltaX"in o ? -o.wheelDeltaX : 0
        },
        deltaY: function(o) {
            return "deltaY"in o ? o.deltaY : "wheelDeltaY"in o ? -o.wheelDeltaY : "wheelDelta"in o ? -o.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    })
      , kM = ji(n0)
      , O_ = d({}, _a, {
        newState: 0,
        oldState: 0
    })
      , au = ji(O_)
      , _l = [9, 13, 27, 32]
      , Oh = ia && "CompositionEvent"in window
      , dc = null;
    ia && "documentMode"in document && (dc = document.documentMode);
    var Nh = ia && "TextEvent"in window && !dc
      , Lh = ia && (!Oh || dc && 8 < dc && 11 >= dc)
      , su = " "
      , Dr = !1;
    function Ph(o, c) {
        switch (o) {
        case "keyup":
            return _l.indexOf(c.keyCode) !== -1;
        case "keydown":
            return c.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
        }
    }
    function i0(o) {
        return o = o.detail,
        typeof o == "object" && "data"in o ? o.data : null
    }
    var ou = !1;
    function Bh(o, c) {
        switch (o) {
        case "compositionend":
            return i0(c);
        case "keypress":
            return c.which !== 32 ? null : (Dr = !0,
            su);
        case "textInput":
            return o = c.data,
            o === su && Dr ? null : o;
        default:
            return null
        }
    }
    function r0(o, c) {
        if (ou)
            return o === "compositionend" || !Oh && Ph(o, c) ? (o = af(),
            fc = cc = Xi = null,
            ou = !1,
            o) : null;
        switch (o) {
        case "paste":
            return null;
        case "keypress":
            if (!(c.ctrlKey || c.altKey || c.metaKey) || c.ctrlKey && c.altKey) {
                if (c.char && 1 < c.char.length)
                    return c.char;
                if (c.which)
                    return String.fromCharCode(c.which)
            }
            return null;
        case "compositionend":
            return Lh && c.locale !== "ko" ? null : c.data;
        default:
            return null
        }
    }
    var Mp = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };
    function a0(o) {
        var c = o && o.nodeName && o.nodeName.toLowerCase();
        return c === "input" ? !!Mp[o.type] : c === "textarea"
    }
    function Sa(o, c, m, _) {
        ya ? Do ? Do.push(_) : Do = [_] : ya = _,
        c = U1(c, "onChange"),
        0 < c.length && (m = new ra("onChange","change",null,m,_),
        o.push({
            event: m,
            listeners: c
        }))
    }
    var of = null
      , pc = null;
    function N_(o) {
        mR(o, 0)
    }
    function zh(o) {
        var c = Se(o);
        if (In(c))
            return o
    }
    function Tp(o, c) {
        if (o === "change")
            return c
    }
    var Ep = !1;
    if (ia) {
        var wp;
        if (ia) {
            var lf = "oninput"in document;
            if (!lf) {
                var uf = document.createElement("div");
                uf.setAttribute("oninput", "return;"),
                lf = typeof uf.oninput == "function"
            }
            wp = lf
        } else
            wp = !1;
        Ep = wp && (!document.documentMode || 9 < document.documentMode)
    }
    function Ui() {
        of && (of.detachEvent("onpropertychange", L_),
        pc = of = null)
    }
    function L_(o) {
        if (o.propertyName === "value" && zh(pc)) {
            var c = [];
            Sa(c, pc, o, Js(o)),
            uc(N_, c)
        }
    }
    function GM(o, c, m) {
        o === "focusin" ? (Ui(),
        of = c,
        pc = m,
        of.attachEvent("onpropertychange", L_)) : o === "focusout" && Ui()
    }
    function P_(o) {
        if (o === "selectionchange" || o === "keyup" || o === "keydown")
            return zh(pc)
    }
    function Ih(o, c) {
        if (o === "click")
            return zh(c)
    }
    function lu(o, c) {
        if (o === "input" || o === "change")
            return zh(c)
    }
    function B_(o, c) {
        return o === c && (o !== 0 || 1 / o === 1 / c) || o !== o && c !== c
    }
    var ba = typeof Object.is == "function" ? Object.is : B_;
    function $s(o, c) {
        if (ba(o, c))
            return !0;
        if (typeof o != "object" || o === null || typeof c != "object" || c === null)
            return !1;
        var m = Object.keys(o)
          , _ = Object.keys(c);
        if (m.length !== _.length)
            return !1;
        for (_ = 0; _ < m.length; _++) {
            var E = m[_];
            if (!$e.call(c, E) || !ba(o[E], c[E]))
                return !1
        }
        return !0
    }
    function Ma(o) {
        for (; o && o.firstChild; )
            o = o.firstChild;
        return o
    }
    function s0(o, c) {
        var m = Ma(o);
        o = 0;
        for (var _; m; ) {
            if (m.nodeType === 3) {
                if (_ = o + m.textContent.length,
                o <= c && _ >= c)
                    return {
                        node: m,
                        offset: c - o
                    };
                o = _
            }
            e: {
                for (; m; ) {
                    if (m.nextSibling) {
                        m = m.nextSibling;
                        break e
                    }
                    m = m.parentNode
                }
                m = void 0
            }
            m = Ma(m)
        }
    }
    function o0(o, c) {
        return o && c ? o === c ? !0 : o && o.nodeType === 3 ? !1 : c && c.nodeType === 3 ? o0(o, c.parentNode) : "contains"in o ? o.contains(c) : o.compareDocumentPosition ? !!(o.compareDocumentPosition(c) & 16) : !1 : !1
    }
    function l0(o) {
        o = o != null && o.ownerDocument != null && o.ownerDocument.defaultView != null ? o.ownerDocument.defaultView : window;
        for (var c = xn(o.document); c instanceof o.HTMLIFrameElement; ) {
            try {
                var m = typeof c.contentWindow.location.href == "string"
            } catch {
                m = !1
            }
            if (m)
                o = c.contentWindow;
            else
                break;
            c = xn(o.document)
        }
        return c
    }
    function Fh(o) {
        var c = o && o.nodeName && o.nodeName.toLowerCase();
        return c && (c === "input" && (o.type === "text" || o.type === "search" || o.type === "tel" || o.type === "url" || o.type === "password") || c === "textarea" || o.contentEditable === "true")
    }
    var u0 = ia && "documentMode"in document && 11 >= document.documentMode
      , xl = null
      , Ap = null
      , Hh = null
      , Cp = !1;
    function c0(o, c, m) {
        var _ = m.window === m ? m.document : m.nodeType === 9 ? m : m.ownerDocument;
        Cp || xl == null || xl !== xn(_) || (_ = xl,
        "selectionStart"in _ && Fh(_) ? _ = {
            start: _.selectionStart,
            end: _.selectionEnd
        } : (_ = (_.ownerDocument && _.ownerDocument.defaultView || window).getSelection(),
        _ = {
            anchorNode: _.anchorNode,
            anchorOffset: _.anchorOffset,
            focusNode: _.focusNode,
            focusOffset: _.focusOffset
        }),
        Hh && $s(Hh, _) || (Hh = _,
        _ = U1(Ap, "onSelect"),
        0 < _.length && (c = new ra("onSelect","select",null,c,m),
        o.push({
            event: c,
            listeners: _
        }),
        c.target = xl)))
    }
    function Ur(o, c) {
        var m = {};
        return m[o.toLowerCase()] = c.toLowerCase(),
        m["Webkit" + o] = "webkit" + c,
        m["Moz" + o] = "moz" + c,
        m
    }
    var uu = {
        animationend: Ur("Animation", "AnimationEnd"),
        animationiteration: Ur("Animation", "AnimationIteration"),
        animationstart: Ur("Animation", "AnimationStart"),
        transitionrun: Ur("Transition", "TransitionRun"),
        transitionstart: Ur("Transition", "TransitionStart"),
        transitioncancel: Ur("Transition", "TransitionCancel"),
        transitionend: Ur("Transition", "TransitionEnd")
    }
      , Rp = {}
      , z_ = {};
    ia && (z_ = document.createElement("div").style,
    "AnimationEvent"in window || (delete uu.animationend.animation,
    delete uu.animationiteration.animation,
    delete uu.animationstart.animation),
    "TransitionEvent"in window || delete uu.transitionend.transition);
    function Sl(o) {
        if (Rp[o])
            return Rp[o];
        if (!uu[o])
            return o;
        var c = uu[o], m;
        for (m in c)
            if (c.hasOwnProperty(m) && m in z_)
                return Rp[o] = c[m];
        return o
    }
    var aa = Sl("animationend")
      , f0 = Sl("animationiteration")
      , Ta = Sl("animationstart")
      , I_ = Sl("transitionrun")
      , bl = Sl("transitionstart")
      , cf = Sl("transitioncancel")
      , Ml = Sl("transitionend")
      , Dp = new Map
      , Vh = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    Vh.push("scrollEnd");
    function _r(o, c) {
        Dp.set(o, c),
        G(c, [o])
    }
    var h0 = new WeakMap;
    function Or(o, c) {
        if (typeof o == "object" && o !== null) {
            var m = h0.get(o);
            return m !== void 0 ? m : (c = {
                value: o,
                source: c,
                stack: Sn(c)
            },
            h0.set(o, c),
            c)
        }
        return {
            value: o,
            source: c,
            stack: Sn(c)
        }
    }
    var Gr = []
      , Es = 0
      , Up = 0;
    function kh() {
        for (var o = Es, c = Up = Es = 0; c < o; ) {
            var m = Gr[c];
            Gr[c++] = null;
            var _ = Gr[c];
            Gr[c++] = null;
            var E = Gr[c];
            Gr[c++] = null;
            var D = Gr[c];
            if (Gr[c++] = null,
            _ !== null && E !== null) {
                var X = _.pending;
                X === null ? E.next = E : (E.next = X.next,
                X.next = E),
                _.pending = E
            }
            D !== 0 && d0(m, E, D)
        }
    }
    function cu(o, c, m, _) {
        Gr[Es++] = o,
        Gr[Es++] = c,
        Gr[Es++] = m,
        Gr[Es++] = _,
        Up |= _,
        o.lanes |= _,
        o = o.alternate,
        o !== null && (o.lanes |= _)
    }
    function Op(o, c, m, _) {
        return cu(o, c, m, _),
        ff(o)
    }
    function Tl(o, c) {
        return cu(o, null, null, c),
        ff(o)
    }
    function d0(o, c, m) {
        o.lanes |= m;
        var _ = o.alternate;
        _ !== null && (_.lanes |= m);
        for (var E = !1, D = o.return; D !== null; )
            D.childLanes |= m,
            _ = D.alternate,
            _ !== null && (_.childLanes |= m),
            D.tag === 22 && (o = D.stateNode,
            o === null || o._visibility & 1 || (E = !0)),
            o = D,
            D = D.return;
        return o.tag === 3 ? (D = o.stateNode,
        E && c !== null && (E = 31 - it(m),
        o = D.hiddenUpdates,
        _ = o[E],
        _ === null ? o[E] = [c] : _.push(c),
        c.lane = m | 536870912),
        D) : null
    }
    function ff(o) {
        if (50 < Xo)
            throw Xo = 0,
            Oc = null,
            Error(n(185));
        for (var c = o.return; c !== null; )
            o = c,
            c = o.return;
        return o.tag === 3 ? o.stateNode : null
    }
    var fu = {};
    function p0(o, c, m, _) {
        this.tag = o,
        this.key = m,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.refCleanup = this.ref = null,
        this.pendingProps = c,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = _,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function Ea(o, c, m, _) {
        return new p0(o,c,m,_)
    }
    function Gh(o) {
        return o = o.prototype,
        !(!o || !o.isReactComponent)
    }
    function Wi(o, c) {
        var m = o.alternate;
        return m === null ? (m = Ea(o.tag, c, o.key, o.mode),
        m.elementType = o.elementType,
        m.type = o.type,
        m.stateNode = o.stateNode,
        m.alternate = o,
        o.alternate = m) : (m.pendingProps = c,
        m.type = o.type,
        m.flags = 0,
        m.subtreeFlags = 0,
        m.deletions = null),
        m.flags = o.flags & 65011712,
        m.childLanes = o.childLanes,
        m.lanes = o.lanes,
        m.child = o.child,
        m.memoizedProps = o.memoizedProps,
        m.memoizedState = o.memoizedState,
        m.updateQueue = o.updateQueue,
        c = o.dependencies,
        m.dependencies = c === null ? null : {
            lanes: c.lanes,
            firstContext: c.firstContext
        },
        m.sibling = o.sibling,
        m.index = o.index,
        m.ref = o.ref,
        m.refCleanup = o.refCleanup,
        m
    }
    function m0(o, c) {
        o.flags &= 65011714;
        var m = o.alternate;
        return m === null ? (o.childLanes = 0,
        o.lanes = c,
        o.child = null,
        o.subtreeFlags = 0,
        o.memoizedProps = null,
        o.memoizedState = null,
        o.updateQueue = null,
        o.dependencies = null,
        o.stateNode = null) : (o.childLanes = m.childLanes,
        o.lanes = m.lanes,
        o.child = m.child,
        o.subtreeFlags = 0,
        o.deletions = null,
        o.memoizedProps = m.memoizedProps,
        o.memoizedState = m.memoizedState,
        o.updateQueue = m.updateQueue,
        o.type = m.type,
        c = m.dependencies,
        o.dependencies = c === null ? null : {
            lanes: c.lanes,
            firstContext: c.firstContext
        }),
        o
    }
    function xr(o, c, m, _, E, D) {
        var X = 0;
        if (_ = o,
        typeof o == "function")
            Gh(o) && (X = 1);
        else if (typeof o == "string")
            X = C5(o, m, pe.current) ? 26 : o === "html" || o === "head" || o === "body" ? 27 : 5;
        else
            e: switch (o) {
            case N:
                return o = Ea(31, m, c, E),
                o.elementType = N,
                o.lanes = D,
                o;
            case S:
                return hu(m.children, E, D, c);
            case T:
                X = 8,
                E |= 24;
                break;
            case M:
                return o = Ea(12, m, c, E | 2),
                o.elementType = M,
                o.lanes = D,
                o;
            case O:
                return o = Ea(13, m, c, E),
                o.elementType = O,
                o.lanes = D,
                o;
            case L:
                return o = Ea(19, m, c, E),
                o.elementType = L,
                o.lanes = D,
                o;
            default:
                if (typeof o == "object" && o !== null)
                    switch (o.$$typeof) {
                    case b:
                    case C:
                        X = 10;
                        break e;
                    case A:
                        X = 9;
                        break e;
                    case R:
                        X = 11;
                        break e;
                    case z:
                        X = 14;
                        break e;
                    case I:
                        X = 16,
                        _ = null;
                        break e
                    }
                X = 29,
                m = Error(n(130, o === null ? "null" : typeof o, "")),
                _ = null
            }
        return c = Ea(X, m, c, E),
        c.elementType = o,
        c.type = _,
        c.lanes = D,
        c
    }
    function hu(o, c, m, _) {
        return o = Ea(7, o, _, c),
        o.lanes = m,
        o
    }
    function Xh(o, c, m) {
        return o = Ea(6, o, null, c),
        o.lanes = m,
        o
    }
    function Np(o, c, m) {
        return c = Ea(4, o.children !== null ? o.children : [], o.key, c),
        c.lanes = m,
        c.stateNode = {
            containerInfo: o.containerInfo,
            pendingChildren: null,
            implementation: o.implementation
        },
        c
    }
    var hf = []
      , wa = 0
      , jh = null
      , df = 0
      , Nr = []
      , Xa = 0
      , du = null
      , Uo = 1
      , Oo = "";
    function El(o, c) {
        hf[wa++] = df,
        hf[wa++] = jh,
        jh = o,
        df = c
    }
    function Lp(o, c, m) {
        Nr[Xa++] = Uo,
        Nr[Xa++] = Oo,
        Nr[Xa++] = du,
        du = o;
        var _ = Uo;
        o = Oo;
        var E = 32 - it(_) - 1;
        _ &= ~(1 << E),
        m += 1;
        var D = 32 - it(c) + E;
        if (30 < D) {
            var X = E - E % 5;
            D = (_ & (1 << X) - 1).toString(32),
            _ >>= X,
            E -= X,
            Uo = 1 << 32 - it(c) + E | m << E | _,
            Oo = D + o
        } else
            Uo = 1 << D | m << E | _,
            Oo = o
    }
    function g0(o) {
        o.return !== null && (El(o, 1),
        Lp(o, 1, 0))
    }
    function v0(o) {
        for (; o === jh; )
            jh = hf[--wa],
            hf[wa] = null,
            df = hf[--wa],
            hf[wa] = null;
        for (; o === du; )
            du = Nr[--Xa],
            Nr[Xa] = null,
            Oo = Nr[--Xa],
            Nr[Xa] = null,
            Uo = Nr[--Xa],
            Nr[Xa] = null
    }
    var sa = null
      , Li = null
      , $n = !1
      , ws = null
      , ja = !1
      , Pp = Error(n(519));
    function pu(o) {
        var c = Error(n(418, ""));
        throw mc(Or(c, o)),
        Pp
    }
    function F_(o) {
        var c = o.stateNode
          , m = o.type
          , _ = o.memoizedProps;
        switch (c[mt] = o,
        c[Lt] = _,
        m) {
        case "dialog":
            Wn("cancel", c),
            Wn("close", c);
            break;
        case "iframe":
        case "object":
        case "embed":
            Wn("load", c);
            break;
        case "video":
        case "audio":
            for (m = 0; m < q0.length; m++)
                Wn(q0[m], c);
            break;
        case "source":
            Wn("error", c);
            break;
        case "img":
        case "image":
        case "link":
            Wn("error", c),
            Wn("load", c);
            break;
        case "details":
            Wn("toggle", c);
            break;
        case "input":
            Wn("invalid", c),
            ti(c, _.value, _.defaultValue, _.checked, _.defaultChecked, _.type, _.name, !0),
            fn(c);
            break;
        case "select":
            Wn("invalid", c);
            break;
        case "textarea":
            Wn("invalid", c),
            Ss(c, _.value, _.defaultValue, _.children),
            fn(c)
        }
        m = _.children,
        typeof m != "string" && typeof m != "number" && typeof m != "bigint" || c.textContent === "" + m || _.suppressHydrationWarning === !0 || _R(c.textContent, m) ? (_.popover != null && (Wn("beforetoggle", c),
        Wn("toggle", c)),
        _.onScroll != null && Wn("scroll", c),
        _.onScrollEnd != null && Wn("scrollend", c),
        _.onClick != null && (c.onclick = O1),
        c = !0) : c = !1,
        c || pu(o)
    }
    function y0(o) {
        for (sa = o.return; sa; )
            switch (sa.tag) {
            case 5:
            case 13:
                ja = !1;
                return;
            case 27:
            case 3:
                ja = !0;
                return;
            default:
                sa = sa.return
            }
    }
    function eo(o) {
        if (o !== sa)
            return !1;
        if (!$n)
            return y0(o),
            $n = !0,
            !1;
        var c = o.tag, m;
        if ((m = c !== 3 && c !== 27) && ((m = c === 5) && (m = o.type,
        m = !(m !== "form" && m !== "button") || u2(o.type, o.memoizedProps)),
        m = !m),
        m && Li && pu(o),
        y0(o),
        c === 13) {
            if (o = o.memoizedState,
            o = o !== null ? o.dehydrated : null,
            !o)
                throw Error(n(317));
            e: {
                for (o = o.nextSibling,
                c = 0; o; ) {
                    if (o.nodeType === 8)
                        if (m = o.data,
                        m === "/$") {
                            if (c === 0) {
                                Li = Fl(o.nextSibling);
                                break e
                            }
                            c--
                        } else
                            m !== "$" && m !== "$!" && m !== "$?" || c++;
                    o = o.nextSibling
                }
                Li = null
            }
        } else
            c === 27 ? (c = Li,
            If(o.type) ? (o = d2,
            d2 = null,
            Li = o) : Li = c) : Li = sa ? Fl(o.stateNode.nextSibling) : null;
        return !0
    }
    function pf() {
        Li = sa = null,
        $n = !1
    }
    function ai() {
        var o = ws;
        return o !== null && (on === null ? on = o : on.push.apply(on, o),
        ws = null),
        o
    }
    function mc(o) {
        ws === null ? ws = [o] : ws.push(o)
    }
    var _0 = W(null)
      , mu = null
      , wl = null;
    function gu(o, c, m) {
        fe(_0, c._currentValue),
        c._currentValue = m
    }
    function Al(o) {
        o._currentValue = _0.current,
        te(_0)
    }
    function x0(o, c, m) {
        for (; o !== null; ) {
            var _ = o.alternate;
            if ((o.childLanes & c) !== c ? (o.childLanes |= c,
            _ !== null && (_.childLanes |= c)) : _ !== null && (_.childLanes & c) !== c && (_.childLanes |= c),
            o === m)
                break;
            o = o.return
        }
    }
    function Wh(o, c, m, _) {
        var E = o.child;
        for (E !== null && (E.return = o); E !== null; ) {
            var D = E.dependencies;
            if (D !== null) {
                var X = E.child;
                D = D.firstContext;
                e: for (; D !== null; ) {
                    var ee = D;
                    D = E;
                    for (var be = 0; be < c.length; be++)
                        if (ee.context === c[be]) {
                            D.lanes |= m,
                            ee = D.alternate,
                            ee !== null && (ee.lanes |= m),
                            x0(D.return, m, o),
                            _ || (X = null);
                            break e
                        }
                    D = ee.next
                }
            } else if (E.tag === 18) {
                if (X = E.return,
                X === null)
                    throw Error(n(341));
                X.lanes |= m,
                D = X.alternate,
                D !== null && (D.lanes |= m),
                x0(X, m, o),
                X = null
            } else
                X = E.child;
            if (X !== null)
                X.return = E;
            else
                for (X = E; X !== null; ) {
                    if (X === o) {
                        X = null;
                        break
                    }
                    if (E = X.sibling,
                    E !== null) {
                        E.return = X.return,
                        X = E;
                        break
                    }
                    X = X.return
                }
            E = X
        }
    }
    function As(o, c, m, _) {
        o = null;
        for (var E = c, D = !1; E !== null; ) {
            if (!D) {
                if ((E.flags & 524288) !== 0)
                    D = !0;
                else if ((E.flags & 262144) !== 0)
                    break
            }
            if (E.tag === 10) {
                var X = E.alternate;
                if (X === null)
                    throw Error(n(387));
                if (X = X.memoizedProps,
                X !== null) {
                    var ee = E.type;
                    ba(E.pendingProps.value, X.value) || (o !== null ? o.push(ee) : o = [ee])
                }
            } else if (E === ge.current) {
                if (X = E.alternate,
                X === null)
                    throw Error(n(387));
                X.memoizedState.memoizedState !== E.memoizedState.memoizedState && (o !== null ? o.push(ev) : o = [ev])
            }
            E = E.return
        }
        o !== null && Wh(c, o, m, _),
        c.flags |= 262144
    }
    function Yh(o) {
        for (o = o.firstContext; o !== null; ) {
            if (!ba(o.context._currentValue, o.memoizedValue))
                return !0;
            o = o.next
        }
        return !1
    }
    function No(o) {
        mu = o,
        wl = null,
        o = o.dependencies,
        o !== null && (o.firstContext = null)
    }
    function Ii(o) {
        return Bp(mu, o)
    }
    function qh(o, c) {
        return mu === null && No(o),
        Bp(o, c)
    }
    function Bp(o, c) {
        var m = c._currentValue;
        if (c = {
            context: c,
            memoizedValue: m,
            next: null
        },
        wl === null) {
            if (o === null)
                throw Error(n(308));
            wl = c,
            o.dependencies = {
                lanes: 0,
                firstContext: c
            },
            o.flags |= 524288
        } else
            wl = wl.next = c;
        return m
    }
    var S0 = typeof AbortController < "u" ? AbortController : function() {
        var o = []
          , c = this.signal = {
            aborted: !1,
            addEventListener: function(m, _) {
                o.push(_)
            }
        };
        this.abort = function() {
            c.aborted = !0,
            o.forEach(function(m) {
                return m()
            })
        }
    }
      , XM = r.unstable_scheduleCallback
      , H_ = r.unstable_NormalPriority
      , rr = {
        $$typeof: C,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
    };
    function zp() {
        return {
            controller: new S0,
            data: new Map,
            refCount: 0
        }
    }
    function mf(o) {
        o.refCount--,
        o.refCount === 0 && XM(H_, function() {
            o.controller.abort()
        })
    }
    var gf = null
      , Zh = 0
      , En = 0
      , vf = null;
    function Wa(o, c) {
        if (gf === null) {
            var m = gf = [];
            Zh = 0,
            En = e2(),
            vf = {
                status: "pending",
                value: void 0,
                then: function(_) {
                    m.push(_)
                }
            }
        }
        return Zh++,
        c.then(Ip, Ip),
        c
    }
    function Ip() {
        if (--Zh === 0 && gf !== null) {
            vf !== null && (vf.status = "fulfilled");
            var o = gf;
            gf = null,
            En = 0,
            vf = null;
            for (var c = 0; c < o.length; c++)
                (0,
                o[c])()
        }
    }
    function jM(o, c) {
        var m = []
          , _ = {
            status: "pending",
            value: null,
            reason: null,
            then: function(E) {
                m.push(E)
            }
        };
        return o.then(function() {
            _.status = "fulfilled",
            _.value = c;
            for (var E = 0; E < m.length; E++)
                (0,
                m[E])(c)
        }, function(E) {
            for (_.status = "rejected",
            _.reason = E,
            E = 0; E < m.length; E++)
                (0,
                m[E])(void 0)
        }),
        _
    }
    var Kh = H.S;
    H.S = function(o, c) {
        typeof c == "object" && c !== null && typeof c.then == "function" && Wa(o, c),
        Kh !== null && Kh(o, c)
    }
    ;
    var Cs = W(null);
    function vu() {
        var o = Cs.current;
        return o !== null ? o : Mn.pooledCache
    }
    function Qh(o, c) {
        c === null ? fe(Cs, Cs.current) : fe(Cs, c.pool)
    }
    function Fp() {
        var o = vu();
        return o === null ? null : {
            parent: rr._currentValue,
            pool: o
        }
    }
    var Jh = Error(n(460))
      , b0 = Error(n(474))
      , to = Error(n(542))
      , $h = {
        then: function() {}
    };
    function Hp(o) {
        return o = o.status,
        o === "fulfilled" || o === "rejected"
    }
    function yf() {}
    function Vp(o, c, m) {
        switch (m = o[m],
        m === void 0 ? o.push(c) : m !== c && (c.then(yf, yf),
        c = m),
        c.status) {
        case "fulfilled":
            return c.value;
        case "rejected":
            throw o = c.reason,
            V_(o),
            o;
        default:
            if (typeof c.status == "string")
                c.then(yf, yf);
            else {
                if (o = Mn,
                o !== null && 100 < o.shellSuspendCounter)
                    throw Error(n(482));
                o = c,
                o.status = "pending",
                o.then(function(_) {
                    if (c.status === "pending") {
                        var E = c;
                        E.status = "fulfilled",
                        E.value = _
                    }
                }, function(_) {
                    if (c.status === "pending") {
                        var E = c;
                        E.status = "rejected",
                        E.reason = _
                    }
                })
            }
            switch (c.status) {
            case "fulfilled":
                return c.value;
            case "rejected":
                throw o = c.reason,
                V_(o),
                o
            }
            throw Rs = c,
            Jh
        }
    }
    var Rs = null;
    function M0() {
        if (Rs === null)
            throw Error(n(459));
        var o = Rs;
        return Rs = null,
        o
    }
    function V_(o) {
        if (o === Jh || o === to)
            throw Error(n(483))
    }
    var Cl = !1;
    function T0(o) {
        o.updateQueue = {
            baseState: o.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                lanes: 0,
                hiddenCallbacks: null
            },
            callbacks: null
        }
    }
    function pn(o, c) {
        o = o.updateQueue,
        c.updateQueue === o && (c.updateQueue = {
            baseState: o.baseState,
            firstBaseUpdate: o.firstBaseUpdate,
            lastBaseUpdate: o.lastBaseUpdate,
            shared: o.shared,
            callbacks: null
        })
    }
    function Lo(o) {
        return {
            lane: o,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function Rl(o, c, m) {
        var _ = o.updateQueue;
        if (_ === null)
            return null;
        if (_ = _.shared,
        (si & 2) !== 0) {
            var E = _.pending;
            return E === null ? c.next = c : (c.next = E.next,
            E.next = c),
            _.pending = c,
            c = ff(o),
            d0(o, null, m),
            c
        }
        return cu(o, _, c, m),
        ff(o)
    }
    function gc(o, c, m) {
        if (c = c.updateQueue,
        c !== null && (c = c.shared,
        (m & 4194048) !== 0)) {
            var _ = c.lanes;
            _ &= o.pendingLanes,
            m |= _,
            c.lanes = m,
            wt(o, m)
        }
    }
    function _f(o, c) {
        var m = o.updateQueue
          , _ = o.alternate;
        if (_ !== null && (_ = _.updateQueue,
        m === _)) {
            var E = null
              , D = null;
            if (m = m.firstBaseUpdate,
            m !== null) {
                do {
                    var X = {
                        lane: m.lane,
                        tag: m.tag,
                        payload: m.payload,
                        callback: null,
                        next: null
                    };
                    D === null ? E = D = X : D = D.next = X,
                    m = m.next
                } while (m !== null);
                D === null ? E = D = c : D = D.next = c
            } else
                E = D = c;
            m = {
                baseState: _.baseState,
                firstBaseUpdate: E,
                lastBaseUpdate: D,
                shared: _.shared,
                callbacks: _.callbacks
            },
            o.updateQueue = m;
            return
        }
        o = m.lastBaseUpdate,
        o === null ? m.firstBaseUpdate = c : o.next = c,
        m.lastBaseUpdate = c
    }
    var E0 = !1;
    function ed() {
        if (E0) {
            var o = vf;
            if (o !== null)
                throw o
        }
    }
    function xf(o, c, m, _) {
        E0 = !1;
        var E = o.updateQueue;
        Cl = !1;
        var D = E.firstBaseUpdate
          , X = E.lastBaseUpdate
          , ee = E.shared.pending;
        if (ee !== null) {
            E.shared.pending = null;
            var be = ee
              , Xe = be.next;
            be.next = null,
            X === null ? D = Xe : X.next = Xe,
            X = be;
            var dt = o.alternate;
            dt !== null && (dt = dt.updateQueue,
            ee = dt.lastBaseUpdate,
            ee !== X && (ee === null ? dt.firstBaseUpdate = Xe : ee.next = Xe,
            dt.lastBaseUpdate = be))
        }
        if (D !== null) {
            var St = E.baseState;
            X = 0,
            dt = Xe = be = null,
            ee = D;
            do {
                var Qe = ee.lane & -536870913
                  , Je = Qe !== ee.lane;
                if (Je ? (an & Qe) === Qe : (_ & Qe) === Qe) {
                    Qe !== 0 && Qe === En && (E0 = !0),
                    dt !== null && (dt = dt.next = {
                        lane: 0,
                        tag: ee.tag,
                        payload: ee.payload,
                        callback: null,
                        next: null
                    });
                    e: {
                        var yn = o
                          , cn = ee;
                        Qe = c;
                        var Ei = m;
                        switch (cn.tag) {
                        case 1:
                            if (yn = cn.payload,
                            typeof yn == "function") {
                                St = yn.call(Ei, St, Qe);
                                break e
                            }
                            St = yn;
                            break e;
                        case 3:
                            yn.flags = yn.flags & -65537 | 128;
                        case 0:
                            if (yn = cn.payload,
                            Qe = typeof yn == "function" ? yn.call(Ei, St, Qe) : yn,
                            Qe == null)
                                break e;
                            St = d({}, St, Qe);
                            break e;
                        case 2:
                            Cl = !0
                        }
                    }
                    Qe = ee.callback,
                    Qe !== null && (o.flags |= 64,
                    Je && (o.flags |= 8192),
                    Je = E.callbacks,
                    Je === null ? E.callbacks = [Qe] : Je.push(Qe))
                } else
                    Je = {
                        lane: Qe,
                        tag: ee.tag,
                        payload: ee.payload,
                        callback: ee.callback,
                        next: null
                    },
                    dt === null ? (Xe = dt = Je,
                    be = St) : dt = dt.next = Je,
                    X |= Qe;
                if (ee = ee.next,
                ee === null) {
                    if (ee = E.shared.pending,
                    ee === null)
                        break;
                    Je = ee,
                    ee = Je.next,
                    Je.next = null,
                    E.lastBaseUpdate = Je,
                    E.shared.pending = null
                }
            } while (!0);
            dt === null && (be = St),
            E.baseState = be,
            E.firstBaseUpdate = Xe,
            E.lastBaseUpdate = dt,
            D === null && (E.shared.lanes = 0),
            uo |= X,
            o.lanes = X,
            o.memoizedState = St
        }
    }
    function Sf(o, c) {
        if (typeof o != "function")
            throw Error(n(191, o));
        o.call(c)
    }
    function k_(o, c) {
        var m = o.callbacks;
        if (m !== null)
            for (o.callbacks = null,
            o = 0; o < m.length; o++)
                Sf(m[o], c)
    }
    var bf = W(null)
      , kp = W(0);
    function G_(o, c) {
        o = Ps,
        fe(kp, o),
        fe(bf, c),
        Ps = o | c.baseLanes
    }
    function w0() {
        fe(kp, Ps),
        fe(bf, bf.current)
    }
    function td() {
        Ps = kp.current,
        te(bf),
        te(kp)
    }
    var Dl = 0
      , wn = null
      , ci = null
      , ar = null
      , Gp = !1
      , yu = !1
      , oa = !1
      , cr = 0
      , Ds = 0
      , Lr = null
      , X_ = 0;
    function Yi() {
        throw Error(n(321))
    }
    function Xr(o, c) {
        if (c === null)
            return !1;
        for (var m = 0; m < c.length && m < o.length; m++)
            if (!ba(o[m], c[m]))
                return !1;
        return !0
    }
    function Ul(o, c, m, _, E, D) {
        return Dl = D,
        wn = c,
        c.memoizedState = null,
        c.updateQueue = null,
        c.lanes = 0,
        H.H = o === null || o.memoizedState === null ? Jp : k0,
        oa = !1,
        D = m(_, E),
        oa = !1,
        yu && (D = W_(c, m, _, E)),
        j_(o),
        D
    }
    function j_(o) {
        H.H = rd;
        var c = ci !== null && ci.next !== null;
        if (Dl = 0,
        ar = ci = wn = null,
        Gp = !1,
        Ds = 0,
        Lr = null,
        c)
            throw Error(n(300));
        o === null || Sr || (o = o.dependencies,
        o !== null && Yh(o) && (Sr = !0))
    }
    function W_(o, c, m, _) {
        wn = o;
        var E = 0;
        do {
            if (yu && (Lr = null),
            Ds = 0,
            yu = !1,
            25 <= E)
                throw Error(n(301));
            if (E += 1,
            ar = ci = null,
            o.updateQueue != null) {
                var D = o.updateQueue;
                D.lastEffect = null,
                D.events = null,
                D.stores = null,
                D.memoCache != null && (D.memoCache.index = 0)
            }
            H.H = y1,
            D = c(m, _)
        } while (yu);
        return D
    }
    function WM() {
        var o = H.H
          , c = o.useState()[0];
        return c = typeof c.then == "function" ? no(c) : c,
        o = o.useState()[0],
        (ci !== null ? ci.memoizedState : null) !== o && (wn.flags |= 1024),
        c
    }
    function A0() {
        var o = cr !== 0;
        return cr = 0,
        o
    }
    function Xp(o, c, m) {
        c.updateQueue = o.updateQueue,
        c.flags &= -2053,
        o.lanes &= ~m
    }
    function C0(o) {
        if (Gp) {
            for (o = o.memoizedState; o !== null; ) {
                var c = o.queue;
                c !== null && (c.pending = null),
                o = o.next
            }
            Gp = !1
        }
        Dl = 0,
        ar = ci = wn = null,
        yu = !1,
        Ds = cr = 0,
        Lr = null
    }
    function la() {
        var o = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return ar === null ? wn.memoizedState = ar = o : ar = ar.next = o,
        ar
    }
    function sr() {
        if (ci === null) {
            var o = wn.alternate;
            o = o !== null ? o.memoizedState : null
        } else
            o = ci.next;
        var c = ar === null ? wn.memoizedState : ar.next;
        if (c !== null)
            ar = c,
            ci = o;
        else {
            if (o === null)
                throw wn.alternate === null ? Error(n(467)) : Error(n(310));
            ci = o,
            o = {
                memoizedState: ci.memoizedState,
                baseState: ci.baseState,
                baseQueue: ci.baseQueue,
                queue: ci.queue,
                next: null
            },
            ar === null ? wn.memoizedState = ar = o : ar = ar.next = o
        }
        return ar
    }
    function _u() {
        return {
            lastEffect: null,
            events: null,
            stores: null,
            memoCache: null
        }
    }
    function no(o) {
        var c = Ds;
        return Ds += 1,
        Lr === null && (Lr = []),
        o = Vp(Lr, o, c),
        c = wn,
        (ar === null ? c.memoizedState : ar.next) === null && (c = c.alternate,
        H.H = c === null || c.memoizedState === null ? Jp : k0),
        o
    }
    function jp(o) {
        if (o !== null && typeof o == "object") {
            if (typeof o.then == "function")
                return no(o);
            if (o.$$typeof === C)
                return Ii(o)
        }
        throw Error(n(438, String(o)))
    }
    function R0(o) {
        var c = null
          , m = wn.updateQueue;
        if (m !== null && (c = m.memoCache),
        c == null) {
            var _ = wn.alternate;
            _ !== null && (_ = _.updateQueue,
            _ !== null && (_ = _.memoCache,
            _ != null && (c = {
                data: _.data.map(function(E) {
                    return E.slice()
                }),
                index: 0
            })))
        }
        if (c == null && (c = {
            data: [],
            index: 0
        }),
        m === null && (m = _u(),
        wn.updateQueue = m),
        m.memoCache = c,
        m = c.data[c.index],
        m === void 0)
            for (m = c.data[c.index] = Array(o),
            _ = 0; _ < o; _++)
                m[_] = P;
        return c.index++,
        m
    }
    function Ol(o, c) {
        return typeof c == "function" ? c(o) : c
    }
    function xu(o) {
        var c = sr();
        return D0(c, ci, o)
    }
    function D0(o, c, m) {
        var _ = o.queue;
        if (_ === null)
            throw Error(n(311));
        _.lastRenderedReducer = m;
        var E = o.baseQueue
          , D = _.pending;
        if (D !== null) {
            if (E !== null) {
                var X = E.next;
                E.next = D.next,
                D.next = X
            }
            c.baseQueue = E = D,
            _.pending = null
        }
        if (D = o.baseState,
        E === null)
            o.memoizedState = D;
        else {
            c = E.next;
            var ee = X = null
              , be = null
              , Xe = c
              , dt = !1;
            do {
                var St = Xe.lane & -536870913;
                if (St !== Xe.lane ? (an & St) === St : (Dl & St) === St) {
                    var Qe = Xe.revertLane;
                    if (Qe === 0)
                        be !== null && (be = be.next = {
                            lane: 0,
                            revertLane: 0,
                            action: Xe.action,
                            hasEagerState: Xe.hasEagerState,
                            eagerState: Xe.eagerState,
                            next: null
                        }),
                        St === En && (dt = !0);
                    else if ((Dl & Qe) === Qe) {
                        Xe = Xe.next,
                        Qe === En && (dt = !0);
                        continue
                    } else
                        St = {
                            lane: 0,
                            revertLane: Xe.revertLane,
                            action: Xe.action,
                            hasEagerState: Xe.hasEagerState,
                            eagerState: Xe.eagerState,
                            next: null
                        },
                        be === null ? (ee = be = St,
                        X = D) : be = be.next = St,
                        wn.lanes |= Qe,
                        uo |= Qe;
                    St = Xe.action,
                    oa && m(D, St),
                    D = Xe.hasEagerState ? Xe.eagerState : m(D, St)
                } else
                    Qe = {
                        lane: St,
                        revertLane: Xe.revertLane,
                        action: Xe.action,
                        hasEagerState: Xe.hasEagerState,
                        eagerState: Xe.eagerState,
                        next: null
                    },
                    be === null ? (ee = be = Qe,
                    X = D) : be = be.next = Qe,
                    wn.lanes |= St,
                    uo |= St;
                Xe = Xe.next
            } while (Xe !== null && Xe !== c);
            if (be === null ? X = D : be.next = ee,
            !ba(D, o.memoizedState) && (Sr = !0,
            dt && (m = vf,
            m !== null)))
                throw m;
            o.memoizedState = D,
            o.baseState = X,
            o.baseQueue = be,
            _.lastRenderedState = D
        }
        return E === null && (_.lanes = 0),
        [o.memoizedState, _.dispatch]
    }
    function U0(o) {
        var c = sr()
          , m = c.queue;
        if (m === null)
            throw Error(n(311));
        m.lastRenderedReducer = o;
        var _ = m.dispatch
          , E = m.pending
          , D = c.memoizedState;
        if (E !== null) {
            m.pending = null;
            var X = E = E.next;
            do
                D = o(D, X.action),
                X = X.next;
            while (X !== E);
            ba(D, c.memoizedState) || (Sr = !0),
            c.memoizedState = D,
            c.baseQueue === null && (c.baseState = D),
            m.lastRenderedState = D
        }
        return [D, _]
    }
    function Y_(o, c, m) {
        var _ = wn
          , E = sr()
          , D = $n;
        if (D) {
            if (m === void 0)
                throw Error(n(407));
            m = m()
        } else
            m = c();
        var X = !ba((ci || E).memoizedState, m);
        X && (E.memoizedState = m,
        Sr = !0),
        E = E.queue;
        var ee = Z_.bind(null, _, E, o);
        if (Ef(2048, 8, ee, [o]),
        E.getSnapshot !== c || X || ar !== null && ar.memoizedState.tag & 1) {
            if (_.flags |= 2048,
            Tf(9, nd(), q_.bind(null, _, E, m, c), null),
            Mn === null)
                throw Error(n(349));
            D || (Dl & 124) !== 0 || Mf(_, c, m)
        }
        return m
    }
    function Mf(o, c, m) {
        o.flags |= 16384,
        o = {
            getSnapshot: c,
            value: m
        },
        c = wn.updateQueue,
        c === null ? (c = _u(),
        wn.updateQueue = c,
        c.stores = [o]) : (m = c.stores,
        m === null ? c.stores = [o] : m.push(o))
    }
    function q_(o, c, m, _) {
        c.value = m,
        c.getSnapshot = _,
        K_(c) && Q_(o)
    }
    function Z_(o, c, m) {
        return m(function() {
            K_(c) && Q_(o)
        })
    }
    function K_(o) {
        var c = o.getSnapshot;
        o = o.value;
        try {
            var m = c();
            return !ba(o, m)
        } catch {
            return !0
        }
    }
    function Q_(o) {
        var c = Tl(o, 2);
        c !== null && fa(c, o, 2)
    }
    function O0(o) {
        var c = la();
        if (typeof o == "function") {
            var m = o;
            if (o = m(),
            oa) {
                Ce(!0);
                try {
                    m()
                } finally {
                    Ce(!1)
                }
            }
        }
        return c.memoizedState = c.baseState = o,
        c.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Ol,
            lastRenderedState: o
        },
        c
    }
    function J_(o, c, m, _) {
        return o.baseState = m,
        D0(o, ci, typeof _ == "function" ? _ : Ol)
    }
    function YM(o, c, m, _, E) {
        if (Qp(o))
            throw Error(n(485));
        if (o = c.action,
        o !== null) {
            var D = {
                payload: E,
                action: o,
                next: null,
                isTransition: !0,
                status: "pending",
                value: null,
                reason: null,
                listeners: [],
                then: function(X) {
                    D.listeners.push(X)
                }
            };
            H.T !== null ? m(!0) : D.isTransition = !1,
            _(D),
            m = c.pending,
            m === null ? (D.next = c.pending = D,
            $_(c, D)) : (D.next = m.next,
            c.pending = m.next = D)
        }
    }
    function $_(o, c) {
        var m = c.action
          , _ = c.payload
          , E = o.state;
        if (c.isTransition) {
            var D = H.T
              , X = {};
            H.T = X;
            try {
                var ee = m(E, _)
                  , be = H.S;
                be !== null && be(X, ee),
                e1(o, c, ee)
            } catch (Xe) {
                N0(o, c, Xe)
            } finally {
                H.T = D
            }
        } else
            try {
                D = m(E, _),
                e1(o, c, D)
            } catch (Xe) {
                N0(o, c, Xe)
            }
    }
    function e1(o, c, m) {
        m !== null && typeof m == "object" && typeof m.then == "function" ? m.then(function(_) {
            t1(o, c, _)
        }, function(_) {
            return N0(o, c, _)
        }) : t1(o, c, m)
    }
    function t1(o, c, m) {
        c.status = "fulfilled",
        c.value = m,
        n1(c),
        o.state = m,
        c = o.pending,
        c !== null && (m = c.next,
        m === c ? o.pending = null : (m = m.next,
        c.next = m,
        $_(o, m)))
    }
    function N0(o, c, m) {
        var _ = o.pending;
        if (o.pending = null,
        _ !== null) {
            _ = _.next;
            do
                c.status = "rejected",
                c.reason = m,
                n1(c),
                c = c.next;
            while (c !== _)
        }
        o.action = null
    }
    function n1(o) {
        o = o.listeners;
        for (var c = 0; c < o.length; c++)
            (0,
            o[c])()
    }
    function L0(o, c) {
        return c
    }
    function i1(o, c) {
        if ($n) {
            var m = Mn.formState;
            if (m !== null) {
                e: {
                    var _ = wn;
                    if ($n) {
                        if (Li) {
                            t: {
                                for (var E = Li, D = ja; E.nodeType !== 8; ) {
                                    if (!D) {
                                        E = null;
                                        break t
                                    }
                                    if (E = Fl(E.nextSibling),
                                    E === null) {
                                        E = null;
                                        break t
                                    }
                                }
                                D = E.data,
                                E = D === "F!" || D === "F" ? E : null
                            }
                            if (E) {
                                Li = Fl(E.nextSibling),
                                _ = E.data === "F!";
                                break e
                            }
                        }
                        pu(_)
                    }
                    _ = !1
                }
                _ && (c = m[0])
            }
        }
        return m = la(),
        m.memoizedState = m.baseState = c,
        _ = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: L0,
            lastRenderedState: c
        },
        m.queue = _,
        m = g1.bind(null, wn, _),
        _.dispatch = m,
        _ = O0(!1),
        D = Kp.bind(null, wn, !1, _.queue),
        _ = la(),
        E = {
            state: c,
            dispatch: null,
            action: o,
            pending: null
        },
        _.queue = E,
        m = YM.bind(null, wn, E, D, m),
        E.dispatch = m,
        _.memoizedState = o,
        [c, m, !1]
    }
    function r1(o) {
        var c = sr();
        return a1(c, ci, o)
    }
    function a1(o, c, m) {
        if (c = D0(o, c, L0)[0],
        o = xu(Ol)[0],
        typeof c == "object" && c !== null && typeof c.then == "function")
            try {
                var _ = no(c)
            } catch (X) {
                throw X === Jh ? to : X
            }
        else
            _ = c;
        c = sr();
        var E = c.queue
          , D = E.dispatch;
        return m !== c.memoizedState && (wn.flags |= 2048,
        Tf(9, nd(), qM.bind(null, E, m), null)),
        [_, D, o]
    }
    function qM(o, c) {
        o.action = c
    }
    function s1(o) {
        var c = sr()
          , m = ci;
        if (m !== null)
            return a1(c, m, o);
        sr(),
        c = c.memoizedState,
        m = sr();
        var _ = m.queue.dispatch;
        return m.memoizedState = o,
        [c, _, !1]
    }
    function Tf(o, c, m, _) {
        return o = {
            tag: o,
            create: m,
            deps: _,
            inst: c,
            next: null
        },
        c = wn.updateQueue,
        c === null && (c = _u(),
        wn.updateQueue = c),
        m = c.lastEffect,
        m === null ? c.lastEffect = o.next = o : (_ = m.next,
        m.next = o,
        o.next = _,
        c.lastEffect = o),
        o
    }
    function nd() {
        return {
            destroy: void 0,
            resource: void 0
        }
    }
    function P0() {
        return sr().memoizedState
    }
    function Wp(o, c, m, _) {
        var E = la();
        _ = _ === void 0 ? null : _,
        wn.flags |= o,
        E.memoizedState = Tf(1 | c, nd(), m, _)
    }
    function Ef(o, c, m, _) {
        var E = sr();
        _ = _ === void 0 ? null : _;
        var D = E.memoizedState.inst;
        ci !== null && _ !== null && Xr(_, ci.memoizedState.deps) ? E.memoizedState = Tf(c, D, m, _) : (wn.flags |= o,
        E.memoizedState = Tf(1 | c, D, m, _))
    }
    function B0(o, c) {
        Wp(8390656, 8, o, c)
    }
    function z0(o, c) {
        Ef(2048, 8, o, c)
    }
    function Yp(o, c) {
        return Ef(4, 2, o, c)
    }
    function qp(o, c) {
        return Ef(4, 4, o, c)
    }
    function o1(o, c) {
        if (typeof c == "function") {
            o = o();
            var m = c(o);
            return function() {
                typeof m == "function" ? m() : c(null)
            }
        }
        if (c != null)
            return o = o(),
            c.current = o,
            function() {
                c.current = null
            }
    }
    function l1(o, c, m) {
        m = m != null ? m.concat([o]) : null,
        Ef(4, 4, o1.bind(null, c, o), m)
    }
    function I0() {}
    function u1(o, c) {
        var m = sr();
        c = c === void 0 ? null : c;
        var _ = m.memoizedState;
        return c !== null && Xr(c, _[1]) ? _[0] : (m.memoizedState = [o, c],
        o)
    }
    function F0(o, c) {
        var m = sr();
        c = c === void 0 ? null : c;
        var _ = m.memoizedState;
        if (c !== null && Xr(c, _[1]))
            return _[0];
        if (_ = o(),
        oa) {
            Ce(!0);
            try {
                o()
            } finally {
                Ce(!1)
            }
        }
        return m.memoizedState = [_, c],
        _
    }
    function Zp(o, c, m) {
        return m === void 0 || (Dl & 1073741824) !== 0 ? o.memoizedState = c : (o.memoizedState = m,
        o = um(),
        wn.lanes |= o,
        uo |= o,
        m)
    }
    function c1(o, c, m, _) {
        return ba(m, c) ? m : bf.current !== null ? (o = Zp(o, m, _),
        ba(o, c) || (Sr = !0),
        o) : (Dl & 42) === 0 ? (Sr = !0,
        o.memoizedState = m) : (o = um(),
        wn.lanes |= o,
        uo |= o,
        c)
    }
    function f1(o, c, m, _, E) {
        var D = q.p;
        q.p = D !== 0 && 8 > D ? D : 8;
        var X = H.T
          , ee = {};
        H.T = ee,
        Kp(o, !1, c, m);
        try {
            var be = E()
              , Xe = H.S;
            if (Xe !== null && Xe(ee, be),
            be !== null && typeof be == "object" && typeof be.then == "function") {
                var dt = jM(be, _);
                id(o, c, dt, Vi(o))
            } else
                id(o, c, _, Vi(o))
        } catch (St) {
            id(o, c, {
                then: function() {},
                status: "rejected",
                reason: St
            }, Vi())
        } finally {
            q.p = D,
            H.T = X
        }
    }
    function ZM() {}
    function H0(o, c, m, _) {
        if (o.tag !== 5)
            throw Error(n(476));
        var E = h1(o).queue;
        f1(o, E, c, Q, m === null ? ZM : function() {
            return d1(o),
            m(_)
        }
        )
    }
    function h1(o) {
        var c = o.memoizedState;
        if (c !== null)
            return c;
        c = {
            memoizedState: Q,
            baseState: Q,
            baseQueue: null,
            queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Ol,
                lastRenderedState: Q
            },
            next: null
        };
        var m = {};
        return c.next = {
            memoizedState: m,
            baseState: m,
            baseQueue: null,
            queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Ol,
                lastRenderedState: m
            },
            next: null
        },
        o.memoizedState = c,
        o = o.alternate,
        o !== null && (o.memoizedState = c),
        c
    }
    function d1(o) {
        var c = h1(o).next.queue;
        id(o, c, {}, Vi())
    }
    function V0() {
        return Ii(ev)
    }
    function p1() {
        return sr().memoizedState
    }
    function m1() {
        return sr().memoizedState
    }
    function KM(o) {
        for (var c = o.return; c !== null; ) {
            switch (c.tag) {
            case 24:
            case 3:
                var m = Vi();
                o = Lo(m);
                var _ = Rl(c, o, m);
                _ !== null && (fa(_, c, m),
                gc(_, c, m)),
                c = {
                    cache: zp()
                },
                o.payload = c;
                return
            }
            c = c.return
        }
    }
    function QM(o, c, m) {
        var _ = Vi();
        m = {
            lane: _,
            revertLane: 0,
            action: m,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        Qp(o) ? v1(c, m) : (m = Op(o, c, m, _),
        m !== null && (fa(m, o, _),
        Ya(m, c, _)))
    }
    function g1(o, c, m) {
        var _ = Vi();
        id(o, c, m, _)
    }
    function id(o, c, m, _) {
        var E = {
            lane: _,
            revertLane: 0,
            action: m,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (Qp(o))
            v1(c, E);
        else {
            var D = o.alternate;
            if (o.lanes === 0 && (D === null || D.lanes === 0) && (D = c.lastRenderedReducer,
            D !== null))
                try {
                    var X = c.lastRenderedState
                      , ee = D(X, m);
                    if (E.hasEagerState = !0,
                    E.eagerState = ee,
                    ba(ee, X))
                        return cu(o, c, E, 0),
                        Mn === null && kh(),
                        !1
                } catch {} finally {}
            if (m = Op(o, c, E, _),
            m !== null)
                return fa(m, o, _),
                Ya(m, c, _),
                !0
        }
        return !1
    }
    function Kp(o, c, m, _) {
        if (_ = {
            lane: 2,
            revertLane: e2(),
            action: _,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        Qp(o)) {
            if (c)
                throw Error(n(479))
        } else
            c = Op(o, m, _, 2),
            c !== null && fa(c, o, 2)
    }
    function Qp(o) {
        var c = o.alternate;
        return o === wn || c !== null && c === wn
    }
    function v1(o, c) {
        yu = Gp = !0;
        var m = o.pending;
        m === null ? c.next = c : (c.next = m.next,
        m.next = c),
        o.pending = c
    }
    function Ya(o, c, m) {
        if ((m & 4194048) !== 0) {
            var _ = c.lanes;
            _ &= o.pendingLanes,
            m |= _,
            c.lanes = m,
            wt(o, m)
        }
    }
    var rd = {
        readContext: Ii,
        use: jp,
        useCallback: Yi,
        useContext: Yi,
        useEffect: Yi,
        useImperativeHandle: Yi,
        useLayoutEffect: Yi,
        useInsertionEffect: Yi,
        useMemo: Yi,
        useReducer: Yi,
        useRef: Yi,
        useState: Yi,
        useDebugValue: Yi,
        useDeferredValue: Yi,
        useTransition: Yi,
        useSyncExternalStore: Yi,
        useId: Yi,
        useHostTransitionStatus: Yi,
        useFormState: Yi,
        useActionState: Yi,
        useOptimistic: Yi,
        useMemoCache: Yi,
        useCacheRefresh: Yi
    }
      , Jp = {
        readContext: Ii,
        use: jp,
        useCallback: function(o, c) {
            return la().memoizedState = [o, c === void 0 ? null : c],
            o
        },
        useContext: Ii,
        useEffect: B0,
        useImperativeHandle: function(o, c, m) {
            m = m != null ? m.concat([o]) : null,
            Wp(4194308, 4, o1.bind(null, c, o), m)
        },
        useLayoutEffect: function(o, c) {
            return Wp(4194308, 4, o, c)
        },
        useInsertionEffect: function(o, c) {
            Wp(4, 2, o, c)
        },
        useMemo: function(o, c) {
            var m = la();
            c = c === void 0 ? null : c;
            var _ = o();
            if (oa) {
                Ce(!0);
                try {
                    o()
                } finally {
                    Ce(!1)
                }
            }
            return m.memoizedState = [_, c],
            _
        },
        useReducer: function(o, c, m) {
            var _ = la();
            if (m !== void 0) {
                var E = m(c);
                if (oa) {
                    Ce(!0);
                    try {
                        m(c)
                    } finally {
                        Ce(!1)
                    }
                }
            } else
                E = c;
            return _.memoizedState = _.baseState = E,
            o = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: o,
                lastRenderedState: E
            },
            _.queue = o,
            o = o.dispatch = QM.bind(null, wn, o),
            [_.memoizedState, o]
        },
        useRef: function(o) {
            var c = la();
            return o = {
                current: o
            },
            c.memoizedState = o
        },
        useState: function(o) {
            o = O0(o);
            var c = o.queue
              , m = g1.bind(null, wn, c);
            return c.dispatch = m,
            [o.memoizedState, m]
        },
        useDebugValue: I0,
        useDeferredValue: function(o, c) {
            var m = la();
            return Zp(m, o, c)
        },
        useTransition: function() {
            var o = O0(!1);
            return o = f1.bind(null, wn, o.queue, !0, !1),
            la().memoizedState = o,
            [!1, o]
        },
        useSyncExternalStore: function(o, c, m) {
            var _ = wn
              , E = la();
            if ($n) {
                if (m === void 0)
                    throw Error(n(407));
                m = m()
            } else {
                if (m = c(),
                Mn === null)
                    throw Error(n(349));
                (an & 124) !== 0 || Mf(_, c, m)
            }
            E.memoizedState = m;
            var D = {
                value: m,
                getSnapshot: c
            };
            return E.queue = D,
            B0(Z_.bind(null, _, D, o), [o]),
            _.flags |= 2048,
            Tf(9, nd(), q_.bind(null, _, D, m, c), null),
            m
        },
        useId: function() {
            var o = la()
              , c = Mn.identifierPrefix;
            if ($n) {
                var m = Oo
                  , _ = Uo;
                m = (_ & ~(1 << 32 - it(_) - 1)).toString(32) + m,
                c = "" + c + "R" + m,
                m = cr++,
                0 < m && (c += "H" + m.toString(32)),
                c += ""
            } else
                m = X_++,
                c = "" + c + "r" + m.toString(32) + "";
            return o.memoizedState = c
        },
        useHostTransitionStatus: V0,
        useFormState: i1,
        useActionState: i1,
        useOptimistic: function(o) {
            var c = la();
            c.memoizedState = c.baseState = o;
            var m = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: null,
                lastRenderedState: null
            };
            return c.queue = m,
            c = Kp.bind(null, wn, !0, m),
            m.dispatch = c,
            [o, c]
        },
        useMemoCache: R0,
        useCacheRefresh: function() {
            return la().memoizedState = KM.bind(null, wn)
        }
    }
      , k0 = {
        readContext: Ii,
        use: jp,
        useCallback: u1,
        useContext: Ii,
        useEffect: z0,
        useImperativeHandle: l1,
        useInsertionEffect: Yp,
        useLayoutEffect: qp,
        useMemo: F0,
        useReducer: xu,
        useRef: P0,
        useState: function() {
            return xu(Ol)
        },
        useDebugValue: I0,
        useDeferredValue: function(o, c) {
            var m = sr();
            return c1(m, ci.memoizedState, o, c)
        },
        useTransition: function() {
            var o = xu(Ol)[0]
              , c = sr().memoizedState;
            return [typeof o == "boolean" ? o : no(o), c]
        },
        useSyncExternalStore: Y_,
        useId: p1,
        useHostTransitionStatus: V0,
        useFormState: r1,
        useActionState: r1,
        useOptimistic: function(o, c) {
            var m = sr();
            return J_(m, ci, o, c)
        },
        useMemoCache: R0,
        useCacheRefresh: m1
    }
      , y1 = {
        readContext: Ii,
        use: jp,
        useCallback: u1,
        useContext: Ii,
        useEffect: z0,
        useImperativeHandle: l1,
        useInsertionEffect: Yp,
        useLayoutEffect: qp,
        useMemo: F0,
        useReducer: U0,
        useRef: P0,
        useState: function() {
            return U0(Ol)
        },
        useDebugValue: I0,
        useDeferredValue: function(o, c) {
            var m = sr();
            return ci === null ? Zp(m, o, c) : c1(m, ci.memoizedState, o, c)
        },
        useTransition: function() {
            var o = U0(Ol)[0]
              , c = sr().memoizedState;
            return [typeof o == "boolean" ? o : no(o), c]
        },
        useSyncExternalStore: Y_,
        useId: p1,
        useHostTransitionStatus: V0,
        useFormState: s1,
        useActionState: s1,
        useOptimistic: function(o, c) {
            var m = sr();
            return ci !== null ? J_(m, ci, o, c) : (m.baseState = o,
            [o, m.queue.dispatch])
        },
        useMemoCache: R0,
        useCacheRefresh: m1
    }
      , vc = null
      , ad = 0;
    function sd(o) {
        var c = ad;
        return ad += 1,
        vc === null && (vc = []),
        Vp(vc, o, c)
    }
    function wf(o, c) {
        c = c.props.ref,
        o.ref = c !== void 0 ? c : null
    }
    function $p(o, c) {
        throw c.$$typeof === g ? Error(n(525)) : (o = Object.prototype.toString.call(c),
        Error(n(31, o === "[object Object]" ? "object with keys {" + Object.keys(c).join(", ") + "}" : o)))
    }
    function _1(o) {
        var c = o._init;
        return c(o._payload)
    }
    function x1(o) {
        function c(ze, Re) {
            if (o) {
                var ke = ze.deletions;
                ke === null ? (ze.deletions = [Re],
                ze.flags |= 16) : ke.push(Re)
            }
        }
        function m(ze, Re) {
            if (!o)
                return null;
            for (; Re !== null; )
                c(ze, Re),
                Re = Re.sibling;
            return null
        }
        function _(ze) {
            for (var Re = new Map; ze !== null; )
                ze.key !== null ? Re.set(ze.key, ze) : Re.set(ze.index, ze),
                ze = ze.sibling;
            return Re
        }
        function E(ze, Re) {
            return ze = Wi(ze, Re),
            ze.index = 0,
            ze.sibling = null,
            ze
        }
        function D(ze, Re, ke) {
            return ze.index = ke,
            o ? (ke = ze.alternate,
            ke !== null ? (ke = ke.index,
            ke < Re ? (ze.flags |= 67108866,
            Re) : ke) : (ze.flags |= 67108866,
            Re)) : (ze.flags |= 1048576,
            Re)
        }
        function X(ze) {
            return o && ze.alternate === null && (ze.flags |= 67108866),
            ze
        }
        function ee(ze, Re, ke, gt) {
            return Re === null || Re.tag !== 6 ? (Re = Xh(ke, ze.mode, gt),
            Re.return = ze,
            Re) : (Re = E(Re, ke),
            Re.return = ze,
            Re)
        }
        function be(ze, Re, ke, gt) {
            var Kt = ke.type;
            return Kt === S ? dt(ze, Re, ke.props.children, gt, ke.key) : Re !== null && (Re.elementType === Kt || typeof Kt == "object" && Kt !== null && Kt.$$typeof === I && _1(Kt) === Re.type) ? (Re = E(Re, ke.props),
            wf(Re, ke),
            Re.return = ze,
            Re) : (Re = xr(ke.type, ke.key, ke.props, null, ze.mode, gt),
            wf(Re, ke),
            Re.return = ze,
            Re)
        }
        function Xe(ze, Re, ke, gt) {
            return Re === null || Re.tag !== 4 || Re.stateNode.containerInfo !== ke.containerInfo || Re.stateNode.implementation !== ke.implementation ? (Re = Np(ke, ze.mode, gt),
            Re.return = ze,
            Re) : (Re = E(Re, ke.children || []),
            Re.return = ze,
            Re)
        }
        function dt(ze, Re, ke, gt, Kt) {
            return Re === null || Re.tag !== 7 ? (Re = hu(ke, ze.mode, gt, Kt),
            Re.return = ze,
            Re) : (Re = E(Re, ke),
            Re.return = ze,
            Re)
        }
        function St(ze, Re, ke) {
            if (typeof Re == "string" && Re !== "" || typeof Re == "number" || typeof Re == "bigint")
                return Re = Xh("" + Re, ze.mode, ke),
                Re.return = ze,
                Re;
            if (typeof Re == "object" && Re !== null) {
                switch (Re.$$typeof) {
                case v:
                    return ke = xr(Re.type, Re.key, Re.props, null, ze.mode, ke),
                    wf(ke, Re),
                    ke.return = ze,
                    ke;
                case y:
                    return Re = Np(Re, ze.mode, ke),
                    Re.return = ze,
                    Re;
                case I:
                    var gt = Re._init;
                    return Re = gt(Re._payload),
                    St(ze, Re, ke)
                }
                if (oe(Re) || V(Re))
                    return Re = hu(Re, ze.mode, ke, null),
                    Re.return = ze,
                    Re;
                if (typeof Re.then == "function")
                    return St(ze, sd(Re), ke);
                if (Re.$$typeof === C)
                    return St(ze, qh(ze, Re), ke);
                $p(ze, Re)
            }
            return null
        }
        function Qe(ze, Re, ke, gt) {
            var Kt = Re !== null ? Re.key : null;
            if (typeof ke == "string" && ke !== "" || typeof ke == "number" || typeof ke == "bigint")
                return Kt !== null ? null : ee(ze, Re, "" + ke, gt);
            if (typeof ke == "object" && ke !== null) {
                switch (ke.$$typeof) {
                case v:
                    return ke.key === Kt ? be(ze, Re, ke, gt) : null;
                case y:
                    return ke.key === Kt ? Xe(ze, Re, ke, gt) : null;
                case I:
                    return Kt = ke._init,
                    ke = Kt(ke._payload),
                    Qe(ze, Re, ke, gt)
                }
                if (oe(ke) || V(ke))
                    return Kt !== null ? null : dt(ze, Re, ke, gt, null);
                if (typeof ke.then == "function")
                    return Qe(ze, Re, sd(ke), gt);
                if (ke.$$typeof === C)
                    return Qe(ze, Re, qh(ze, ke), gt);
                $p(ze, ke)
            }
            return null
        }
        function Je(ze, Re, ke, gt, Kt) {
            if (typeof gt == "string" && gt !== "" || typeof gt == "number" || typeof gt == "bigint")
                return ze = ze.get(ke) || null,
                ee(Re, ze, "" + gt, Kt);
            if (typeof gt == "object" && gt !== null) {
                switch (gt.$$typeof) {
                case v:
                    return ze = ze.get(gt.key === null ? ke : gt.key) || null,
                    be(Re, ze, gt, Kt);
                case y:
                    return ze = ze.get(gt.key === null ? ke : gt.key) || null,
                    Xe(Re, ze, gt, Kt);
                case I:
                    var kn = gt._init;
                    return gt = kn(gt._payload),
                    Je(ze, Re, ke, gt, Kt)
                }
                if (oe(gt) || V(gt))
                    return ze = ze.get(ke) || null,
                    dt(Re, ze, gt, Kt, null);
                if (typeof gt.then == "function")
                    return Je(ze, Re, ke, sd(gt), Kt);
                if (gt.$$typeof === C)
                    return Je(ze, Re, ke, qh(Re, gt), Kt);
                $p(Re, gt)
            }
            return null
        }
        function yn(ze, Re, ke, gt) {
            for (var Kt = null, kn = null, nn = Re, dn = Re = 0, Yr = null; nn !== null && dn < ke.length; dn++) {
                nn.index > dn ? (Yr = nn,
                nn = null) : Yr = nn.sibling;
                var li = Qe(ze, nn, ke[dn], gt);
                if (li === null) {
                    nn === null && (nn = Yr);
                    break
                }
                o && nn && li.alternate === null && c(ze, nn),
                Re = D(li, Re, dn),
                kn === null ? Kt = li : kn.sibling = li,
                kn = li,
                nn = Yr
            }
            if (dn === ke.length)
                return m(ze, nn),
                $n && El(ze, dn),
                Kt;
            if (nn === null) {
                for (; dn < ke.length; dn++)
                    nn = St(ze, ke[dn], gt),
                    nn !== null && (Re = D(nn, Re, dn),
                    kn === null ? Kt = nn : kn.sibling = nn,
                    kn = nn);
                return $n && El(ze, dn),
                Kt
            }
            for (nn = _(nn); dn < ke.length; dn++)
                Yr = Je(nn, ze, dn, ke[dn], gt),
                Yr !== null && (o && Yr.alternate !== null && nn.delete(Yr.key === null ? dn : Yr.key),
                Re = D(Yr, Re, dn),
                kn === null ? Kt = Yr : kn.sibling = Yr,
                kn = Yr);
            return o && nn.forEach(function(Gf) {
                return c(ze, Gf)
            }),
            $n && El(ze, dn),
            Kt
        }
        function cn(ze, Re, ke, gt) {
            if (ke == null)
                throw Error(n(151));
            for (var Kt = null, kn = null, nn = Re, dn = Re = 0, Yr = null, li = ke.next(); nn !== null && !li.done; dn++,
            li = ke.next()) {
                nn.index > dn ? (Yr = nn,
                nn = null) : Yr = nn.sibling;
                var Gf = Qe(ze, nn, li.value, gt);
                if (Gf === null) {
                    nn === null && (nn = Yr);
                    break
                }
                o && nn && Gf.alternate === null && c(ze, nn),
                Re = D(Gf, Re, dn),
                kn === null ? Kt = Gf : kn.sibling = Gf,
                kn = Gf,
                nn = Yr
            }
            if (li.done)
                return m(ze, nn),
                $n && El(ze, dn),
                Kt;
            if (nn === null) {
                for (; !li.done; dn++,
                li = ke.next())
                    li = St(ze, li.value, gt),
                    li !== null && (Re = D(li, Re, dn),
                    kn === null ? Kt = li : kn.sibling = li,
                    kn = li);
                return $n && El(ze, dn),
                Kt
            }
            for (nn = _(nn); !li.done; dn++,
            li = ke.next())
                li = Je(nn, ze, dn, li.value, gt),
                li !== null && (o && li.alternate !== null && nn.delete(li.key === null ? dn : li.key),
                Re = D(li, Re, dn),
                kn === null ? Kt = li : kn.sibling = li,
                kn = li);
            return o && nn.forEach(function(H5) {
                return c(ze, H5)
            }),
            $n && El(ze, dn),
            Kt
        }
        function Ei(ze, Re, ke, gt) {
            if (typeof ke == "object" && ke !== null && ke.type === S && ke.key === null && (ke = ke.props.children),
            typeof ke == "object" && ke !== null) {
                switch (ke.$$typeof) {
                case v:
                    e: {
                        for (var Kt = ke.key; Re !== null; ) {
                            if (Re.key === Kt) {
                                if (Kt = ke.type,
                                Kt === S) {
                                    if (Re.tag === 7) {
                                        m(ze, Re.sibling),
                                        gt = E(Re, ke.props.children),
                                        gt.return = ze,
                                        ze = gt;
                                        break e
                                    }
                                } else if (Re.elementType === Kt || typeof Kt == "object" && Kt !== null && Kt.$$typeof === I && _1(Kt) === Re.type) {
                                    m(ze, Re.sibling),
                                    gt = E(Re, ke.props),
                                    wf(gt, ke),
                                    gt.return = ze,
                                    ze = gt;
                                    break e
                                }
                                m(ze, Re);
                                break
                            } else
                                c(ze, Re);
                            Re = Re.sibling
                        }
                        ke.type === S ? (gt = hu(ke.props.children, ze.mode, gt, ke.key),
                        gt.return = ze,
                        ze = gt) : (gt = xr(ke.type, ke.key, ke.props, null, ze.mode, gt),
                        wf(gt, ke),
                        gt.return = ze,
                        ze = gt)
                    }
                    return X(ze);
                case y:
                    e: {
                        for (Kt = ke.key; Re !== null; ) {
                            if (Re.key === Kt)
                                if (Re.tag === 4 && Re.stateNode.containerInfo === ke.containerInfo && Re.stateNode.implementation === ke.implementation) {
                                    m(ze, Re.sibling),
                                    gt = E(Re, ke.children || []),
                                    gt.return = ze,
                                    ze = gt;
                                    break e
                                } else {
                                    m(ze, Re);
                                    break
                                }
                            else
                                c(ze, Re);
                            Re = Re.sibling
                        }
                        gt = Np(ke, ze.mode, gt),
                        gt.return = ze,
                        ze = gt
                    }
                    return X(ze);
                case I:
                    return Kt = ke._init,
                    ke = Kt(ke._payload),
                    Ei(ze, Re, ke, gt)
                }
                if (oe(ke))
                    return yn(ze, Re, ke, gt);
                if (V(ke)) {
                    if (Kt = V(ke),
                    typeof Kt != "function")
                        throw Error(n(150));
                    return ke = Kt.call(ke),
                    cn(ze, Re, ke, gt)
                }
                if (typeof ke.then == "function")
                    return Ei(ze, Re, sd(ke), gt);
                if (ke.$$typeof === C)
                    return Ei(ze, Re, qh(ze, ke), gt);
                $p(ze, ke)
            }
            return typeof ke == "string" && ke !== "" || typeof ke == "number" || typeof ke == "bigint" ? (ke = "" + ke,
            Re !== null && Re.tag === 6 ? (m(ze, Re.sibling),
            gt = E(Re, ke),
            gt.return = ze,
            ze = gt) : (m(ze, Re),
            gt = Xh(ke, ze.mode, gt),
            gt.return = ze,
            ze = gt),
            X(ze)) : m(ze, Re)
        }
        return function(ze, Re, ke, gt) {
            try {
                ad = 0;
                var Kt = Ei(ze, Re, ke, gt);
                return vc = null,
                Kt
            } catch (nn) {
                if (nn === Jh || nn === to)
                    throw nn;
                var kn = Ea(29, nn, null, ze.mode);
                return kn.lanes = gt,
                kn.return = ze,
                kn
            } finally {}
        }
    }
    var yc = x1(!0)
      , S1 = x1(!1)
      , pi = W(null)
      , io = null;
    function Su(o) {
        var c = o.alternate;
        fe(qi, qi.current & 1),
        fe(pi, o),
        io === null && (c === null || bf.current !== null || c.memoizedState !== null) && (io = o)
    }
    function b1(o) {
        if (o.tag === 22) {
            if (fe(qi, qi.current),
            fe(pi, o),
            io === null) {
                var c = o.alternate;
                c !== null && c.memoizedState !== null && (io = o)
            }
        } else
            bu()
    }
    function bu() {
        fe(qi, qi.current),
        fe(pi, pi.current)
    }
    function Po(o) {
        te(pi),
        io === o && (io = null),
        te(qi)
    }
    var qi = W(0);
    function Nl(o) {
        for (var c = o; c !== null; ) {
            if (c.tag === 13) {
                var m = c.memoizedState;
                if (m !== null && (m = m.dehydrated,
                m === null || m.data === "$?" || h2(m)))
                    return c
            } else if (c.tag === 19 && c.memoizedProps.revealOrder !== void 0) {
                if ((c.flags & 128) !== 0)
                    return c
            } else if (c.child !== null) {
                c.child.return = c,
                c = c.child;
                continue
            }
            if (c === o)
                break;
            for (; c.sibling === null; ) {
                if (c.return === null || c.return === o)
                    return null;
                c = c.return
            }
            c.sibling.return = c.return,
            c = c.sibling
        }
        return null
    }
    function Mu(o, c, m, _) {
        c = o.memoizedState,
        m = m(_, c),
        m = m == null ? c : d({}, c, m),
        o.memoizedState = m,
        o.lanes === 0 && (o.updateQueue.baseState = m)
    }
    var ua = {
        enqueueSetState: function(o, c, m) {
            o = o._reactInternals;
            var _ = Vi()
              , E = Lo(_);
            E.payload = c,
            m != null && (E.callback = m),
            c = Rl(o, E, _),
            c !== null && (fa(c, o, _),
            gc(c, o, _))
        },
        enqueueReplaceState: function(o, c, m) {
            o = o._reactInternals;
            var _ = Vi()
              , E = Lo(_);
            E.tag = 1,
            E.payload = c,
            m != null && (E.callback = m),
            c = Rl(o, E, _),
            c !== null && (fa(c, o, _),
            gc(c, o, _))
        },
        enqueueForceUpdate: function(o, c) {
            o = o._reactInternals;
            var m = Vi()
              , _ = Lo(m);
            _.tag = 2,
            c != null && (_.callback = c),
            c = Rl(o, _, m),
            c !== null && (fa(c, o, m),
            gc(c, o, m))
        }
    };
    function M1(o, c, m, _, E, D, X) {
        return o = o.stateNode,
        typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(_, D, X) : c.prototype && c.prototype.isPureReactComponent ? !$s(m, _) || !$s(E, D) : !0
    }
    function T1(o, c, m, _) {
        o = c.state,
        typeof c.componentWillReceiveProps == "function" && c.componentWillReceiveProps(m, _),
        typeof c.UNSAFE_componentWillReceiveProps == "function" && c.UNSAFE_componentWillReceiveProps(m, _),
        c.state !== o && ua.enqueueReplaceState(c, c.state, null)
    }
    function Bo(o, c) {
        var m = c;
        if ("ref"in c) {
            m = {};
            for (var _ in c)
                _ !== "ref" && (m[_] = c[_])
        }
        if (o = o.defaultProps) {
            m === c && (m = d({}, m));
            for (var E in o)
                m[E] === void 0 && (m[E] = o[E])
        }
        return m
    }
    var _c = typeof reportError == "function" ? reportError : function(o) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
            var c = new window.ErrorEvent("error",{
                bubbles: !0,
                cancelable: !0,
                message: typeof o == "object" && o !== null && typeof o.message == "string" ? String(o.message) : String(o),
                error: o
            });
            if (!window.dispatchEvent(c))
                return
        } else if (typeof process == "object" && typeof process.emit == "function") {
            process.emit("uncaughtException", o);
            return
        }
        console.error(o)
    }
    ;
    function od(o) {
        _c(o)
    }
    function em(o) {
        console.error(o)
    }
    function E1(o) {
        _c(o)
    }
    function tm(o, c) {
        try {
            var m = o.onUncaughtError;
            m(c.value, {
                componentStack: c.stack
            })
        } catch (_) {
            setTimeout(function() {
                throw _
            })
        }
    }
    function Us(o, c, m) {
        try {
            var _ = o.onCaughtError;
            _(m.value, {
                componentStack: m.stack,
                errorBoundary: c.tag === 1 ? c.stateNode : null
            })
        } catch (E) {
            setTimeout(function() {
                throw E
            })
        }
    }
    function nm(o, c, m) {
        return m = Lo(m),
        m.tag = 3,
        m.payload = {
            element: null
        },
        m.callback = function() {
            tm(o, c)
        }
        ,
        m
    }
    function w1(o) {
        return o = Lo(o),
        o.tag = 3,
        o
    }
    function im(o, c, m, _) {
        var E = m.type.getDerivedStateFromError;
        if (typeof E == "function") {
            var D = _.value;
            o.payload = function() {
                return E(D)
            }
            ,
            o.callback = function() {
                Us(c, m, _)
            }
        }
        var X = m.stateNode;
        X !== null && typeof X.componentDidCatch == "function" && (o.callback = function() {
            Us(c, m, _),
            typeof E != "function" && (ts === null ? ts = new Set([this]) : ts.add(this));
            var ee = _.stack;
            this.componentDidCatch(_.value, {
                componentStack: ee !== null ? ee : ""
            })
        }
        )
    }
    function JM(o, c, m, _, E) {
        if (m.flags |= 32768,
        _ !== null && typeof _ == "object" && typeof _.then == "function") {
            if (c = m.alternate,
            c !== null && As(c, m, E, !0),
            m = pi.current,
            m !== null) {
                switch (m.tag) {
                case 13:
                    return io === null ? h() : m.alternate === null && Ai === 0 && (Ai = 3),
                    m.flags &= -257,
                    m.flags |= 65536,
                    m.lanes = E,
                    _ === $h ? m.flags |= 16384 : (c = m.updateQueue,
                    c === null ? m.updateQueue = new Set([_]) : c.add(_),
                    et(o, _, E)),
                    !1;
                case 22:
                    return m.flags |= 65536,
                    _ === $h ? m.flags |= 16384 : (c = m.updateQueue,
                    c === null ? (c = {
                        transitions: null,
                        markerInstances: null,
                        retryQueue: new Set([_])
                    },
                    m.updateQueue = c) : (m = c.retryQueue,
                    m === null ? c.retryQueue = new Set([_]) : m.add(_)),
                    et(o, _, E)),
                    !1
                }
                throw Error(n(435, m.tag))
            }
            return et(o, _, E),
            h(),
            !1
        }
        if ($n)
            return c = pi.current,
            c !== null ? ((c.flags & 65536) === 0 && (c.flags |= 256),
            c.flags |= 65536,
            c.lanes = E,
            _ !== Pp && (o = Error(n(422), {
                cause: _
            }),
            mc(Or(o, m)))) : (_ !== Pp && (c = Error(n(423), {
                cause: _
            }),
            mc(Or(c, m))),
            o = o.current.alternate,
            o.flags |= 65536,
            E &= -E,
            o.lanes |= E,
            _ = Or(_, m),
            E = nm(o.stateNode, _, E),
            _f(o, E),
            Ai !== 4 && (Ai = 2)),
            !1;
        var D = Error(n(520), {
            cause: _
        });
        if (D = Or(D, m),
        oi === null ? oi = [D] : oi.push(D),
        Ai !== 4 && (Ai = 2),
        c === null)
            return !0;
        _ = Or(_, m),
        m = c;
        do {
            switch (m.tag) {
            case 3:
                return m.flags |= 65536,
                o = E & -E,
                m.lanes |= o,
                o = nm(m.stateNode, _, o),
                _f(m, o),
                !1;
            case 1:
                if (c = m.type,
                D = m.stateNode,
                (m.flags & 128) === 0 && (typeof c.getDerivedStateFromError == "function" || D !== null && typeof D.componentDidCatch == "function" && (ts === null || !ts.has(D))))
                    return m.flags |= 65536,
                    E &= -E,
                    m.lanes |= E,
                    E = w1(E),
                    im(E, o, m, _),
                    _f(m, E),
                    !1
            }
            m = m.return
        } while (m !== null);
        return !1
    }
    var A1 = Error(n(461))
      , Sr = !1;
    function Zi(o, c, m, _) {
        c.child = o === null ? S1(c, null, m, _) : yc(c, o.child, m, _)
    }
    function Aa(o, c, m, _, E) {
        m = m.render;
        var D = c.ref;
        if ("ref"in _) {
            var X = {};
            for (var ee in _)
                ee !== "ref" && (X[ee] = _[ee])
        } else
            X = _;
        return No(c),
        _ = Ul(o, c, m, X, D, E),
        ee = A0(),
        o !== null && !Sr ? (Xp(o, c, E),
        br(o, c, E)) : ($n && ee && g0(c),
        c.flags |= 1,
        Zi(o, c, _, E),
        c.child)
    }
    function Ca(o, c, m, _, E) {
        if (o === null) {
            var D = m.type;
            return typeof D == "function" && !Gh(D) && D.defaultProps === void 0 && m.compare === null ? (c.tag = 15,
            c.type = D,
            G0(o, c, D, _, E)) : (o = xr(m.type, null, _, c, c.mode, E),
            o.ref = c.ref,
            o.return = c,
            c.child = o)
        }
        if (D = o.child,
        !ld(o, E)) {
            var X = D.memoizedProps;
            if (m = m.compare,
            m = m !== null ? m : $s,
            m(X, _) && o.ref === c.ref)
                return br(o, c, E)
        }
        return c.flags |= 1,
        o = Wi(D, _),
        o.ref = c.ref,
        o.return = c,
        c.child = o
    }
    function G0(o, c, m, _, E) {
        if (o !== null) {
            var D = o.memoizedProps;
            if ($s(D, _) && o.ref === c.ref)
                if (Sr = !1,
                c.pendingProps = _ = D,
                ld(o, E))
                    (o.flags & 131072) !== 0 && (Sr = !0);
                else
                    return c.lanes = o.lanes,
                    br(o, c, E)
        }
        return Af(o, c, m, _, E)
    }
    function xc(o, c, m) {
        var _ = c.pendingProps
          , E = _.children
          , D = o !== null ? o.memoizedState : null;
        if (_.mode === "hidden") {
            if ((c.flags & 128) !== 0) {
                if (_ = D !== null ? D.baseLanes | m : m,
                o !== null) {
                    for (E = c.child = o.child,
                    D = 0; E !== null; )
                        D = D | E.lanes | E.childLanes,
                        E = E.sibling;
                    c.childLanes = D & ~_
                } else
                    c.childLanes = 0,
                    c.child = null;
                return Sc(o, c, _, m)
            }
            if ((m & 536870912) !== 0)
                c.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                o !== null && Qh(c, D !== null ? D.cachePool : null),
                D !== null ? G_(c, D) : w0(),
                b1(c);
            else
                return c.lanes = c.childLanes = 536870912,
                Sc(o, c, D !== null ? D.baseLanes | m : m, m)
        } else
            D !== null ? (Qh(c, D.cachePool),
            G_(c, D),
            bu(),
            c.memoizedState = null) : (o !== null && Qh(c, null),
            w0(),
            bu());
        return Zi(o, c, E, m),
        c.child
    }
    function Sc(o, c, m, _) {
        var E = vu();
        return E = E === null ? null : {
            parent: rr._currentValue,
            pool: E
        },
        c.memoizedState = {
            baseLanes: m,
            cachePool: E
        },
        o !== null && Qh(c, null),
        w0(),
        b1(c),
        o !== null && As(o, c, _, !0),
        null
    }
    function bc(o, c) {
        var m = c.ref;
        if (m === null)
            o !== null && o.ref !== null && (c.flags |= 4194816);
        else {
            if (typeof m != "function" && typeof m != "object")
                throw Error(n(284));
            (o === null || o.ref !== m) && (c.flags |= 4194816)
        }
    }
    function Af(o, c, m, _, E) {
        return No(c),
        m = Ul(o, c, m, _, void 0, E),
        _ = A0(),
        o !== null && !Sr ? (Xp(o, c, E),
        br(o, c, E)) : ($n && _ && g0(c),
        c.flags |= 1,
        Zi(o, c, m, E),
        c.child)
    }
    function qa(o, c, m, _, E, D) {
        return No(c),
        c.updateQueue = null,
        m = W_(c, _, m, E),
        j_(o),
        _ = A0(),
        o !== null && !Sr ? (Xp(o, c, D),
        br(o, c, D)) : ($n && _ && g0(c),
        c.flags |= 1,
        Zi(o, c, m, D),
        c.child)
    }
    function Za(o, c, m, _, E) {
        if (No(c),
        c.stateNode === null) {
            var D = fu
              , X = m.contextType;
            typeof X == "object" && X !== null && (D = Ii(X)),
            D = new m(_,D),
            c.memoizedState = D.state !== null && D.state !== void 0 ? D.state : null,
            D.updater = ua,
            c.stateNode = D,
            D._reactInternals = c,
            D = c.stateNode,
            D.props = _,
            D.state = c.memoizedState,
            D.refs = {},
            T0(c),
            X = m.contextType,
            D.context = typeof X == "object" && X !== null ? Ii(X) : fu,
            D.state = c.memoizedState,
            X = m.getDerivedStateFromProps,
            typeof X == "function" && (Mu(c, m, X, _),
            D.state = c.memoizedState),
            typeof m.getDerivedStateFromProps == "function" || typeof D.getSnapshotBeforeUpdate == "function" || typeof D.UNSAFE_componentWillMount != "function" && typeof D.componentWillMount != "function" || (X = D.state,
            typeof D.componentWillMount == "function" && D.componentWillMount(),
            typeof D.UNSAFE_componentWillMount == "function" && D.UNSAFE_componentWillMount(),
            X !== D.state && ua.enqueueReplaceState(D, D.state, null),
            xf(c, _, D, E),
            ed(),
            D.state = c.memoizedState),
            typeof D.componentDidMount == "function" && (c.flags |= 4194308),
            _ = !0
        } else if (o === null) {
            D = c.stateNode;
            var ee = c.memoizedProps
              , be = Bo(m, ee);
            D.props = be;
            var Xe = D.context
              , dt = m.contextType;
            X = fu,
            typeof dt == "object" && dt !== null && (X = Ii(dt));
            var St = m.getDerivedStateFromProps;
            dt = typeof St == "function" || typeof D.getSnapshotBeforeUpdate == "function",
            ee = c.pendingProps !== ee,
            dt || typeof D.UNSAFE_componentWillReceiveProps != "function" && typeof D.componentWillReceiveProps != "function" || (ee || Xe !== X) && T1(c, D, _, X),
            Cl = !1;
            var Qe = c.memoizedState;
            D.state = Qe,
            xf(c, _, D, E),
            ed(),
            Xe = c.memoizedState,
            ee || Qe !== Xe || Cl ? (typeof St == "function" && (Mu(c, m, St, _),
            Xe = c.memoizedState),
            (be = Cl || M1(c, m, be, _, Qe, Xe, X)) ? (dt || typeof D.UNSAFE_componentWillMount != "function" && typeof D.componentWillMount != "function" || (typeof D.componentWillMount == "function" && D.componentWillMount(),
            typeof D.UNSAFE_componentWillMount == "function" && D.UNSAFE_componentWillMount()),
            typeof D.componentDidMount == "function" && (c.flags |= 4194308)) : (typeof D.componentDidMount == "function" && (c.flags |= 4194308),
            c.memoizedProps = _,
            c.memoizedState = Xe),
            D.props = _,
            D.state = Xe,
            D.context = X,
            _ = be) : (typeof D.componentDidMount == "function" && (c.flags |= 4194308),
            _ = !1)
        } else {
            D = c.stateNode,
            pn(o, c),
            X = c.memoizedProps,
            dt = Bo(m, X),
            D.props = dt,
            St = c.pendingProps,
            Qe = D.context,
            Xe = m.contextType,
            be = fu,
            typeof Xe == "object" && Xe !== null && (be = Ii(Xe)),
            ee = m.getDerivedStateFromProps,
            (Xe = typeof ee == "function" || typeof D.getSnapshotBeforeUpdate == "function") || typeof D.UNSAFE_componentWillReceiveProps != "function" && typeof D.componentWillReceiveProps != "function" || (X !== St || Qe !== be) && T1(c, D, _, be),
            Cl = !1,
            Qe = c.memoizedState,
            D.state = Qe,
            xf(c, _, D, E),
            ed();
            var Je = c.memoizedState;
            X !== St || Qe !== Je || Cl || o !== null && o.dependencies !== null && Yh(o.dependencies) ? (typeof ee == "function" && (Mu(c, m, ee, _),
            Je = c.memoizedState),
            (dt = Cl || M1(c, m, dt, _, Qe, Je, be) || o !== null && o.dependencies !== null && Yh(o.dependencies)) ? (Xe || typeof D.UNSAFE_componentWillUpdate != "function" && typeof D.componentWillUpdate != "function" || (typeof D.componentWillUpdate == "function" && D.componentWillUpdate(_, Je, be),
            typeof D.UNSAFE_componentWillUpdate == "function" && D.UNSAFE_componentWillUpdate(_, Je, be)),
            typeof D.componentDidUpdate == "function" && (c.flags |= 4),
            typeof D.getSnapshotBeforeUpdate == "function" && (c.flags |= 1024)) : (typeof D.componentDidUpdate != "function" || X === o.memoizedProps && Qe === o.memoizedState || (c.flags |= 4),
            typeof D.getSnapshotBeforeUpdate != "function" || X === o.memoizedProps && Qe === o.memoizedState || (c.flags |= 1024),
            c.memoizedProps = _,
            c.memoizedState = Je),
            D.props = _,
            D.state = Je,
            D.context = be,
            _ = dt) : (typeof D.componentDidUpdate != "function" || X === o.memoizedProps && Qe === o.memoizedState || (c.flags |= 4),
            typeof D.getSnapshotBeforeUpdate != "function" || X === o.memoizedProps && Qe === o.memoizedState || (c.flags |= 1024),
            _ = !1)
        }
        return D = _,
        bc(o, c),
        _ = (c.flags & 128) !== 0,
        D || _ ? (D = c.stateNode,
        m = _ && typeof m.getDerivedStateFromError != "function" ? null : D.render(),
        c.flags |= 1,
        o !== null && _ ? (c.child = yc(c, o.child, null, E),
        c.child = yc(c, null, m, E)) : Zi(o, c, m, E),
        c.memoizedState = D.state,
        o = c.child) : o = br(o, c, E),
        o
    }
    function Tu(o, c, m, _) {
        return pf(),
        c.flags |= 256,
        Zi(o, c, m, _),
        c.child
    }
    var ro = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
    };
    function ao(o) {
        return {
            baseLanes: o,
            cachePool: Fp()
        }
    }
    function fr(o, c, m) {
        return o = o !== null ? o.childLanes & ~m : 0,
        c && (o |= Bs),
        o
    }
    function Cf(o, c, m) {
        var _ = c.pendingProps, E = !1, D = (c.flags & 128) !== 0, X;
        if ((X = D) || (X = o !== null && o.memoizedState === null ? !1 : (qi.current & 2) !== 0),
        X && (E = !0,
        c.flags &= -129),
        X = (c.flags & 32) !== 0,
        c.flags &= -33,
        o === null) {
            if ($n) {
                if (E ? Su(c) : bu(),
                $n) {
                    var ee = Li, be;
                    if (be = ee) {
                        e: {
                            for (be = ee,
                            ee = ja; be.nodeType !== 8; ) {
                                if (!ee) {
                                    ee = null;
                                    break e
                                }
                                if (be = Fl(be.nextSibling),
                                be === null) {
                                    ee = null;
                                    break e
                                }
                            }
                            ee = be
                        }
                        ee !== null ? (c.memoizedState = {
                            dehydrated: ee,
                            treeContext: du !== null ? {
                                id: Uo,
                                overflow: Oo
                            } : null,
                            retryLane: 536870912,
                            hydrationErrors: null
                        },
                        be = Ea(18, null, null, 0),
                        be.stateNode = ee,
                        be.return = c,
                        c.child = be,
                        sa = c,
                        Li = null,
                        be = !0) : be = !1
                    }
                    be || pu(c)
                }
                if (ee = c.memoizedState,
                ee !== null && (ee = ee.dehydrated,
                ee !== null))
                    return h2(ee) ? c.lanes = 32 : c.lanes = 536870912,
                    null;
                Po(c)
            }
            return ee = _.children,
            _ = _.fallback,
            E ? (bu(),
            E = c.mode,
            ee = Mc({
                mode: "hidden",
                children: ee
            }, E),
            _ = hu(_, E, m, null),
            ee.return = c,
            _.return = c,
            ee.sibling = _,
            c.child = ee,
            E = c.child,
            E.memoizedState = ao(m),
            E.childLanes = fr(o, X, m),
            c.memoizedState = ro,
            _) : (Su(c),
            zo(c, ee))
        }
        if (be = o.memoizedState,
        be !== null && (ee = be.dehydrated,
        ee !== null)) {
            if (D)
                c.flags & 256 ? (Su(c),
                c.flags &= -257,
                c = Pr(o, c, m)) : c.memoizedState !== null ? (bu(),
                c.child = o.child,
                c.flags |= 128,
                c = null) : (bu(),
                E = _.fallback,
                ee = c.mode,
                _ = Mc({
                    mode: "visible",
                    children: _.children
                }, ee),
                E = hu(E, ee, m, null),
                E.flags |= 2,
                _.return = c,
                E.return = c,
                _.sibling = E,
                c.child = _,
                yc(c, o.child, null, m),
                _ = c.child,
                _.memoizedState = ao(m),
                _.childLanes = fr(o, X, m),
                c.memoizedState = ro,
                c = E);
            else if (Su(c),
            h2(ee)) {
                if (X = ee.nextSibling && ee.nextSibling.dataset,
                X)
                    var Xe = X.dgst;
                X = Xe,
                _ = Error(n(419)),
                _.stack = "",
                _.digest = X,
                mc({
                    value: _,
                    source: null,
                    stack: null
                }),
                c = Pr(o, c, m)
            } else if (Sr || As(o, c, m, !1),
            X = (m & o.childLanes) !== 0,
            Sr || X) {
                if (X = Mn,
                X !== null && (_ = m & -m,
                _ = (_ & 42) !== 0 ? 1 : Ot(_),
                _ = (_ & (X.suspendedLanes | m)) !== 0 ? 0 : _,
                _ !== 0 && _ !== be.retryLane))
                    throw be.retryLane = _,
                    Tl(o, _),
                    fa(X, o, _),
                    A1;
                ee.data === "$?" || h(),
                c = Pr(o, c, m)
            } else
                ee.data === "$?" ? (c.flags |= 192,
                c.child = o.child,
                c = null) : (o = be.treeContext,
                Li = Fl(ee.nextSibling),
                sa = c,
                $n = !0,
                ws = null,
                ja = !1,
                o !== null && (Nr[Xa++] = Uo,
                Nr[Xa++] = Oo,
                Nr[Xa++] = du,
                Uo = o.id,
                Oo = o.overflow,
                du = c),
                c = zo(c, _.children),
                c.flags |= 4096);
            return c
        }
        return E ? (bu(),
        E = _.fallback,
        ee = c.mode,
        be = o.child,
        Xe = be.sibling,
        _ = Wi(be, {
            mode: "hidden",
            children: _.children
        }),
        _.subtreeFlags = be.subtreeFlags & 65011712,
        Xe !== null ? E = Wi(Xe, E) : (E = hu(E, ee, m, null),
        E.flags |= 2),
        E.return = c,
        _.return = c,
        _.sibling = E,
        c.child = _,
        _ = E,
        E = c.child,
        ee = o.child.memoizedState,
        ee === null ? ee = ao(m) : (be = ee.cachePool,
        be !== null ? (Xe = rr._currentValue,
        be = be.parent !== Xe ? {
            parent: Xe,
            pool: Xe
        } : be) : be = Fp(),
        ee = {
            baseLanes: ee.baseLanes | m,
            cachePool: be
        }),
        E.memoizedState = ee,
        E.childLanes = fr(o, X, m),
        c.memoizedState = ro,
        _) : (Su(c),
        m = o.child,
        o = m.sibling,
        m = Wi(m, {
            mode: "visible",
            children: _.children
        }),
        m.return = c,
        m.sibling = null,
        o !== null && (X = c.deletions,
        X === null ? (c.deletions = [o],
        c.flags |= 16) : X.push(o)),
        c.child = m,
        c.memoizedState = null,
        m)
    }
    function zo(o, c) {
        return c = Mc({
            mode: "visible",
            children: c
        }, o.mode),
        c.return = o,
        o.child = c
    }
    function Mc(o, c) {
        return o = Ea(22, o, null, c),
        o.lanes = 0,
        o.stateNode = {
            _visibility: 1,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
        },
        o
    }
    function Pr(o, c, m) {
        return yc(c, o.child, null, m),
        o = zo(c, c.pendingProps.children),
        o.flags |= 2,
        c.memoizedState = null,
        o
    }
    function Br(o, c, m) {
        o.lanes |= c;
        var _ = o.alternate;
        _ !== null && (_.lanes |= c),
        x0(o.return, c, m)
    }
    function Yn(o, c, m, _, E) {
        var D = o.memoizedState;
        D === null ? o.memoizedState = {
            isBackwards: c,
            rendering: null,
            renderingStartTime: 0,
            last: _,
            tail: m,
            tailMode: E
        } : (D.isBackwards = c,
        D.rendering = null,
        D.renderingStartTime = 0,
        D.last = _,
        D.tail = m,
        D.tailMode = E)
    }
    function Os(o, c, m) {
        var _ = c.pendingProps
          , E = _.revealOrder
          , D = _.tail;
        if (Zi(o, c, _.children, m),
        _ = qi.current,
        (_ & 2) !== 0)
            _ = _ & 1 | 2,
            c.flags |= 128;
        else {
            if (o !== null && (o.flags & 128) !== 0)
                e: for (o = c.child; o !== null; ) {
                    if (o.tag === 13)
                        o.memoizedState !== null && Br(o, m, c);
                    else if (o.tag === 19)
                        Br(o, m, c);
                    else if (o.child !== null) {
                        o.child.return = o,
                        o = o.child;
                        continue
                    }
                    if (o === c)
                        break e;
                    for (; o.sibling === null; ) {
                        if (o.return === null || o.return === c)
                            break e;
                        o = o.return
                    }
                    o.sibling.return = o.return,
                    o = o.sibling
                }
            _ &= 1
        }
        switch (fe(qi, _),
        E) {
        case "forwards":
            for (m = c.child,
            E = null; m !== null; )
                o = m.alternate,
                o !== null && Nl(o) === null && (E = m),
                m = m.sibling;
            m = E,
            m === null ? (E = c.child,
            c.child = null) : (E = m.sibling,
            m.sibling = null),
            Yn(c, !1, E, m, D);
            break;
        case "backwards":
            for (m = null,
            E = c.child,
            c.child = null; E !== null; ) {
                if (o = E.alternate,
                o !== null && Nl(o) === null) {
                    c.child = E;
                    break
                }
                o = E.sibling,
                E.sibling = m,
                m = E,
                E = o
            }
            Yn(c, !0, m, null, D);
            break;
        case "together":
            Yn(c, !1, null, null, void 0);
            break;
        default:
            c.memoizedState = null
        }
        return c.child
    }
    function br(o, c, m) {
        if (o !== null && (c.dependencies = o.dependencies),
        uo |= c.lanes,
        (m & c.childLanes) === 0)
            if (o !== null) {
                if (As(o, c, m, !1),
                (m & c.childLanes) === 0)
                    return null
            } else
                return null;
        if (o !== null && c.child !== o.child)
            throw Error(n(153));
        if (c.child !== null) {
            for (o = c.child,
            m = Wi(o, o.pendingProps),
            c.child = m,
            m.return = c; o.sibling !== null; )
                o = o.sibling,
                m = m.sibling = Wi(o, o.pendingProps),
                m.return = c;
            m.sibling = null
        }
        return c.child
    }
    function ld(o, c) {
        return (o.lanes & c) !== 0 ? !0 : (o = o.dependencies,
        !!(o !== null && Yh(o)))
    }
    function Ns(o, c, m) {
        switch (c.tag) {
        case 3:
            Te(c, c.stateNode.containerInfo),
            gu(c, rr, o.memoizedState.cache),
            pf();
            break;
        case 27:
        case 5:
            ot(c);
            break;
        case 4:
            Te(c, c.stateNode.containerInfo);
            break;
        case 10:
            gu(c, c.type, c.memoizedProps.value);
            break;
        case 13:
            var _ = c.memoizedState;
            if (_ !== null)
                return _.dehydrated !== null ? (Su(c),
                c.flags |= 128,
                null) : (m & c.child.childLanes) !== 0 ? Cf(o, c, m) : (Su(c),
                o = br(o, c, m),
                o !== null ? o.sibling : null);
            Su(c);
            break;
        case 19:
            var E = (o.flags & 128) !== 0;
            if (_ = (m & c.childLanes) !== 0,
            _ || (As(o, c, m, !1),
            _ = (m & c.childLanes) !== 0),
            E) {
                if (_)
                    return Os(o, c, m);
                c.flags |= 128
            }
            if (E = c.memoizedState,
            E !== null && (E.rendering = null,
            E.tail = null,
            E.lastEffect = null),
            fe(qi, qi.current),
            _)
                break;
            return null;
        case 22:
        case 23:
            return c.lanes = 0,
            xc(o, c, m);
        case 24:
            gu(c, rr, o.memoizedState.cache)
        }
        return br(o, c, m)
    }
    function Tc(o, c, m) {
        if (o !== null)
            if (o.memoizedProps !== c.pendingProps)
                Sr = !0;
            else {
                if (!ld(o, m) && (c.flags & 128) === 0)
                    return Sr = !1,
                    Ns(o, c, m);
                Sr = (o.flags & 131072) !== 0
            }
        else
            Sr = !1,
            $n && (c.flags & 1048576) !== 0 && Lp(c, df, c.index);
        switch (c.lanes = 0,
        c.tag) {
        case 16:
            e: {
                o = c.pendingProps;
                var _ = c.elementType
                  , E = _._init;
                if (_ = E(_._payload),
                c.type = _,
                typeof _ == "function")
                    Gh(_) ? (o = Bo(_, o),
                    c.tag = 1,
                    c = Za(null, c, _, o, m)) : (c.tag = 0,
                    c = Af(null, c, _, o, m));
                else {
                    if (_ != null) {
                        if (E = _.$$typeof,
                        E === R) {
                            c.tag = 11,
                            c = Aa(null, c, _, o, m);
                            break e
                        } else if (E === z) {
                            c.tag = 14,
                            c = Ca(null, c, _, o, m);
                            break e
                        }
                    }
                    throw c = Z(_) || _,
                    Error(n(306, c, ""))
                }
            }
            return c;
        case 0:
            return Af(o, c, c.type, c.pendingProps, m);
        case 1:
            return _ = c.type,
            E = Bo(_, c.pendingProps),
            Za(o, c, _, E, m);
        case 3:
            e: {
                if (Te(c, c.stateNode.containerInfo),
                o === null)
                    throw Error(n(387));
                _ = c.pendingProps;
                var D = c.memoizedState;
                E = D.element,
                pn(o, c),
                xf(c, _, null, m);
                var X = c.memoizedState;
                if (_ = X.cache,
                gu(c, rr, _),
                _ !== D.cache && Wh(c, [rr], m, !0),
                ed(),
                _ = X.element,
                D.isDehydrated)
                    if (D = {
                        element: _,
                        isDehydrated: !1,
                        cache: X.cache
                    },
                    c.updateQueue.baseState = D,
                    c.memoizedState = D,
                    c.flags & 256) {
                        c = Tu(o, c, _, m);
                        break e
                    } else if (_ !== E) {
                        E = Or(Error(n(424)), c),
                        mc(E),
                        c = Tu(o, c, _, m);
                        break e
                    } else {
                        switch (o = c.stateNode.containerInfo,
                        o.nodeType) {
                        case 9:
                            o = o.body;
                            break;
                        default:
                            o = o.nodeName === "HTML" ? o.ownerDocument.body : o
                        }
                        for (Li = Fl(o.firstChild),
                        sa = c,
                        $n = !0,
                        ws = null,
                        ja = !0,
                        m = S1(c, null, _, m),
                        c.child = m; m; )
                            m.flags = m.flags & -3 | 4096,
                            m = m.sibling
                    }
                else {
                    if (pf(),
                    _ === E) {
                        c = br(o, c, m);
                        break e
                    }
                    Zi(o, c, _, m)
                }
                c = c.child
            }
            return c;
        case 26:
            return bc(o, c),
            o === null ? (m = RR(c.type, null, c.pendingProps, null)) ? c.memoizedState = m : $n || (m = c.type,
            o = c.pendingProps,
            _ = N1(ue.current).createElement(m),
            _[mt] = c,
            _[Lt] = o,
            ha(_, m, o),
            Fe(_),
            c.stateNode = _) : c.memoizedState = RR(c.type, o.memoizedProps, c.pendingProps, o.memoizedState),
            null;
        case 27:
            return ot(c),
            o === null && $n && (_ = c.stateNode = wR(c.type, c.pendingProps, ue.current),
            sa = c,
            ja = !0,
            E = Li,
            If(c.type) ? (d2 = E,
            Li = Fl(_.firstChild)) : Li = E),
            Zi(o, c, c.pendingProps.children, m),
            bc(o, c),
            o === null && (c.flags |= 4194304),
            c.child;
        case 5:
            return o === null && $n && ((E = _ = Li) && (_ = m5(_, c.type, c.pendingProps, ja),
            _ !== null ? (c.stateNode = _,
            sa = c,
            Li = Fl(_.firstChild),
            ja = !1,
            E = !0) : E = !1),
            E || pu(c)),
            ot(c),
            E = c.type,
            D = c.pendingProps,
            X = o !== null ? o.memoizedProps : null,
            _ = D.children,
            u2(E, D) ? _ = null : X !== null && u2(E, X) && (c.flags |= 32),
            c.memoizedState !== null && (E = Ul(o, c, WM, null, null, m),
            ev._currentValue = E),
            bc(o, c),
            Zi(o, c, _, m),
            c.child;
        case 6:
            return o === null && $n && ((o = m = Li) && (m = g5(m, c.pendingProps, ja),
            m !== null ? (c.stateNode = m,
            sa = c,
            Li = null,
            o = !0) : o = !1),
            o || pu(c)),
            null;
        case 13:
            return Cf(o, c, m);
        case 4:
            return Te(c, c.stateNode.containerInfo),
            _ = c.pendingProps,
            o === null ? c.child = yc(c, null, _, m) : Zi(o, c, _, m),
            c.child;
        case 11:
            return Aa(o, c, c.type, c.pendingProps, m);
        case 7:
            return Zi(o, c, c.pendingProps, m),
            c.child;
        case 8:
            return Zi(o, c, c.pendingProps.children, m),
            c.child;
        case 12:
            return Zi(o, c, c.pendingProps.children, m),
            c.child;
        case 10:
            return _ = c.pendingProps,
            gu(c, c.type, _.value),
            Zi(o, c, _.children, m),
            c.child;
        case 9:
            return E = c.type._context,
            _ = c.pendingProps.children,
            No(c),
            E = Ii(E),
            _ = _(E),
            c.flags |= 1,
            Zi(o, c, _, m),
            c.child;
        case 14:
            return Ca(o, c, c.type, c.pendingProps, m);
        case 15:
            return G0(o, c, c.type, c.pendingProps, m);
        case 19:
            return Os(o, c, m);
        case 31:
            return _ = c.pendingProps,
            m = c.mode,
            _ = {
                mode: _.mode,
                children: _.children
            },
            o === null ? (m = Mc(_, m),
            m.ref = c.ref,
            c.child = m,
            m.return = c,
            c = m) : (m = Wi(o.child, _),
            m.ref = c.ref,
            c.child = m,
            m.return = c,
            c = m),
            c;
        case 22:
            return xc(o, c, m);
        case 24:
            return No(c),
            _ = Ii(rr),
            o === null ? (E = vu(),
            E === null && (E = Mn,
            D = zp(),
            E.pooledCache = D,
            D.refCount++,
            D !== null && (E.pooledCacheLanes |= m),
            E = D),
            c.memoizedState = {
                parent: _,
                cache: E
            },
            T0(c),
            gu(c, rr, E)) : ((o.lanes & m) !== 0 && (pn(o, c),
            xf(c, null, null, m),
            ed()),
            E = o.memoizedState,
            D = c.memoizedState,
            E.parent !== _ ? (E = {
                parent: _,
                cache: _
            },
            c.memoizedState = E,
            c.lanes === 0 && (c.memoizedState = c.updateQueue.baseState = E),
            gu(c, rr, _)) : (_ = D.cache,
            gu(c, rr, _),
            _ !== E.cache && Wh(c, [rr], m, !0))),
            Zi(o, c, c.pendingProps.children, m),
            c.child;
        case 29:
            throw c.pendingProps
        }
        throw Error(n(156, c.tag))
    }
    function so(o) {
        o.flags |= 4
    }
    function ud(o, c) {
        if (c.type !== "stylesheet" || (c.state.loading & 4) !== 0)
            o.flags &= -16777217;
        else if (o.flags |= 16777216,
        !LR(c)) {
            if (c = pi.current,
            c !== null && ((an & 4194048) === an ? io !== null : (an & 62914560) !== an && (an & 536870912) === 0 || c !== io))
                throw Rs = $h,
                b0;
            o.flags |= 8192
        }
    }
    function Ll(o, c) {
        c !== null && (o.flags |= 4),
        o.flags & 16384 && (c = o.tag !== 22 ? Ee() : 536870912,
        o.lanes |= c,
        Zn |= c)
    }
    function Ec(o, c) {
        if (!$n)
            switch (o.tailMode) {
            case "hidden":
                c = o.tail;
                for (var m = null; c !== null; )
                    c.alternate !== null && (m = c),
                    c = c.sibling;
                m === null ? o.tail = null : m.sibling = null;
                break;
            case "collapsed":
                m = o.tail;
                for (var _ = null; m !== null; )
                    m.alternate !== null && (_ = m),
                    m = m.sibling;
                _ === null ? c || o.tail === null ? o.tail = null : o.tail.sibling = null : _.sibling = null
            }
    }
    function Si(o) {
        var c = o.alternate !== null && o.alternate.child === o.child
          , m = 0
          , _ = 0;
        if (c)
            for (var E = o.child; E !== null; )
                m |= E.lanes | E.childLanes,
                _ |= E.subtreeFlags & 65011712,
                _ |= E.flags & 65011712,
                E.return = o,
                E = E.sibling;
        else
            for (E = o.child; E !== null; )
                m |= E.lanes | E.childLanes,
                _ |= E.subtreeFlags,
                _ |= E.flags,
                E.return = o,
                E = E.sibling;
        return o.subtreeFlags |= _,
        o.childLanes = m,
        c
    }
    function X0(o, c, m) {
        var _ = c.pendingProps;
        switch (v0(c),
        c.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return Si(c),
            null;
        case 1:
            return Si(c),
            null;
        case 3:
            return m = c.stateNode,
            _ = null,
            o !== null && (_ = o.memoizedState.cache),
            c.memoizedState.cache !== _ && (c.flags |= 2048),
            Al(rr),
            Ze(),
            m.pendingContext && (m.context = m.pendingContext,
            m.pendingContext = null),
            (o === null || o.child === null) && (eo(c) ? so(c) : o === null || o.memoizedState.isDehydrated && (c.flags & 256) === 0 || (c.flags |= 1024,
            ai())),
            Si(c),
            null;
        case 26:
            return m = c.memoizedState,
            o === null ? (so(c),
            m !== null ? (Si(c),
            ud(c, m)) : (Si(c),
            c.flags &= -16777217)) : m ? m !== o.memoizedState ? (so(c),
            Si(c),
            ud(c, m)) : (Si(c),
            c.flags &= -16777217) : (o.memoizedProps !== _ && so(c),
            Si(c),
            c.flags &= -16777217),
            null;
        case 27:
            tt(c),
            m = ue.current;
            var E = c.type;
            if (o !== null && c.stateNode != null)
                o.memoizedProps !== _ && so(c);
            else {
                if (!_) {
                    if (c.stateNode === null)
                        throw Error(n(166));
                    return Si(c),
                    null
                }
                o = pe.current,
                eo(c) ? F_(c) : (o = wR(E, _, m),
                c.stateNode = o,
                so(c))
            }
            return Si(c),
            null;
        case 5:
            if (tt(c),
            m = c.type,
            o !== null && c.stateNode != null)
                o.memoizedProps !== _ && so(c);
            else {
                if (!_) {
                    if (c.stateNode === null)
                        throw Error(n(166));
                    return Si(c),
                    null
                }
                if (o = pe.current,
                eo(c))
                    F_(c);
                else {
                    switch (E = N1(ue.current),
                    o) {
                    case 1:
                        o = E.createElementNS("http://www.w3.org/2000/svg", m);
                        break;
                    case 2:
                        o = E.createElementNS("http://www.w3.org/1998/Math/MathML", m);
                        break;
                    default:
                        switch (m) {
                        case "svg":
                            o = E.createElementNS("http://www.w3.org/2000/svg", m);
                            break;
                        case "math":
                            o = E.createElementNS("http://www.w3.org/1998/Math/MathML", m);
                            break;
                        case "script":
                            o = E.createElement("div"),
                            o.innerHTML = "<script><\/script>",
                            o = o.removeChild(o.firstChild);
                            break;
                        case "select":
                            o = typeof _.is == "string" ? E.createElement("select", {
                                is: _.is
                            }) : E.createElement("select"),
                            _.multiple ? o.multiple = !0 : _.size && (o.size = _.size);
                            break;
                        default:
                            o = typeof _.is == "string" ? E.createElement(m, {
                                is: _.is
                            }) : E.createElement(m)
                        }
                    }
                    o[mt] = c,
                    o[Lt] = _;
                    e: for (E = c.child; E !== null; ) {
                        if (E.tag === 5 || E.tag === 6)
                            o.appendChild(E.stateNode);
                        else if (E.tag !== 4 && E.tag !== 27 && E.child !== null) {
                            E.child.return = E,
                            E = E.child;
                            continue
                        }
                        if (E === c)
                            break e;
                        for (; E.sibling === null; ) {
                            if (E.return === null || E.return === c)
                                break e;
                            E = E.return
                        }
                        E.sibling.return = E.return,
                        E = E.sibling
                    }
                    c.stateNode = o;
                    e: switch (ha(o, m, _),
                    m) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        o = !!_.autoFocus;
                        break e;
                    case "img":
                        o = !0;
                        break e;
                    default:
                        o = !1
                    }
                    o && so(c)
                }
            }
            return Si(c),
            c.flags &= -16777217,
            null;
        case 6:
            if (o && c.stateNode != null)
                o.memoizedProps !== _ && so(c);
            else {
                if (typeof _ != "string" && c.stateNode === null)
                    throw Error(n(166));
                if (o = ue.current,
                eo(c)) {
                    if (o = c.stateNode,
                    m = c.memoizedProps,
                    _ = null,
                    E = sa,
                    E !== null)
                        switch (E.tag) {
                        case 27:
                        case 5:
                            _ = E.memoizedProps
                        }
                    o[mt] = c,
                    o = !!(o.nodeValue === m || _ !== null && _.suppressHydrationWarning === !0 || _R(o.nodeValue, m)),
                    o || pu(c)
                } else
                    o = N1(o).createTextNode(_),
                    o[mt] = c,
                    c.stateNode = o
            }
            return Si(c),
            null;
        case 13:
            if (_ = c.memoizedState,
            o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) {
                if (E = eo(c),
                _ !== null && _.dehydrated !== null) {
                    if (o === null) {
                        if (!E)
                            throw Error(n(318));
                        if (E = c.memoizedState,
                        E = E !== null ? E.dehydrated : null,
                        !E)
                            throw Error(n(317));
                        E[mt] = c
                    } else
                        pf(),
                        (c.flags & 128) === 0 && (c.memoizedState = null),
                        c.flags |= 4;
                    Si(c),
                    E = !1
                } else
                    E = ai(),
                    o !== null && o.memoizedState !== null && (o.memoizedState.hydrationErrors = E),
                    E = !0;
                if (!E)
                    return c.flags & 256 ? (Po(c),
                    c) : (Po(c),
                    null)
            }
            if (Po(c),
            (c.flags & 128) !== 0)
                return c.lanes = m,
                c;
            if (m = _ !== null,
            o = o !== null && o.memoizedState !== null,
            m) {
                _ = c.child,
                E = null,
                _.alternate !== null && _.alternate.memoizedState !== null && _.alternate.memoizedState.cachePool !== null && (E = _.alternate.memoizedState.cachePool.pool);
                var D = null;
                _.memoizedState !== null && _.memoizedState.cachePool !== null && (D = _.memoizedState.cachePool.pool),
                D !== E && (_.flags |= 2048)
            }
            return m !== o && m && (c.child.flags |= 8192),
            Ll(c, c.updateQueue),
            Si(c),
            null;
        case 4:
            return Ze(),
            o === null && r2(c.stateNode.containerInfo),
            Si(c),
            null;
        case 10:
            return Al(c.type),
            Si(c),
            null;
        case 19:
            if (te(qi),
            E = c.memoizedState,
            E === null)
                return Si(c),
                null;
            if (_ = (c.flags & 128) !== 0,
            D = E.rendering,
            D === null)
                if (_)
                    Ec(E, !1);
                else {
                    if (Ai !== 0 || o !== null && (o.flags & 128) !== 0)
                        for (o = c.child; o !== null; ) {
                            if (D = Nl(o),
                            D !== null) {
                                for (c.flags |= 128,
                                Ec(E, !1),
                                o = D.updateQueue,
                                c.updateQueue = o,
                                Ll(c, o),
                                c.subtreeFlags = 0,
                                o = m,
                                m = c.child; m !== null; )
                                    m0(m, o),
                                    m = m.sibling;
                                return fe(qi, qi.current & 1 | 2),
                                c.child
                            }
                            o = o.sibling
                        }
                    E.tail !== null && le() > jr && (c.flags |= 128,
                    _ = !0,
                    Ec(E, !1),
                    c.lanes = 4194304)
                }
            else {
                if (!_)
                    if (o = Nl(D),
                    o !== null) {
                        if (c.flags |= 128,
                        _ = !0,
                        o = o.updateQueue,
                        c.updateQueue = o,
                        Ll(c, o),
                        Ec(E, !0),
                        E.tail === null && E.tailMode === "hidden" && !D.alternate && !$n)
                            return Si(c),
                            null
                    } else
                        2 * le() - E.renderingStartTime > jr && m !== 536870912 && (c.flags |= 128,
                        _ = !0,
                        Ec(E, !1),
                        c.lanes = 4194304);
                E.isBackwards ? (D.sibling = c.child,
                c.child = D) : (o = E.last,
                o !== null ? o.sibling = D : c.child = D,
                E.last = D)
            }
            return E.tail !== null ? (c = E.tail,
            E.rendering = c,
            E.tail = c.sibling,
            E.renderingStartTime = le(),
            c.sibling = null,
            o = qi.current,
            fe(qi, _ ? o & 1 | 2 : o & 1),
            c) : (Si(c),
            null);
        case 22:
        case 23:
            return Po(c),
            td(),
            _ = c.memoizedState !== null,
            o !== null ? o.memoizedState !== null !== _ && (c.flags |= 8192) : _ && (c.flags |= 8192),
            _ ? (m & 536870912) !== 0 && (c.flags & 128) === 0 && (Si(c),
            c.subtreeFlags & 6 && (c.flags |= 8192)) : Si(c),
            m = c.updateQueue,
            m !== null && Ll(c, m.retryQueue),
            m = null,
            o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (m = o.memoizedState.cachePool.pool),
            _ = null,
            c.memoizedState !== null && c.memoizedState.cachePool !== null && (_ = c.memoizedState.cachePool.pool),
            _ !== m && (c.flags |= 2048),
            o !== null && te(Cs),
            null;
        case 24:
            return m = null,
            o !== null && (m = o.memoizedState.cache),
            c.memoizedState.cache !== m && (c.flags |= 2048),
            Al(rr),
            Si(c),
            null;
        case 25:
            return null;
        case 30:
            return null
        }
        throw Error(n(156, c.tag))
    }
    function Rf(o, c) {
        switch (v0(c),
        c.tag) {
        case 1:
            return o = c.flags,
            o & 65536 ? (c.flags = o & -65537 | 128,
            c) : null;
        case 3:
            return Al(rr),
            Ze(),
            o = c.flags,
            (o & 65536) !== 0 && (o & 128) === 0 ? (c.flags = o & -65537 | 128,
            c) : null;
        case 26:
        case 27:
        case 5:
            return tt(c),
            null;
        case 13:
            if (Po(c),
            o = c.memoizedState,
            o !== null && o.dehydrated !== null) {
                if (c.alternate === null)
                    throw Error(n(340));
                pf()
            }
            return o = c.flags,
            o & 65536 ? (c.flags = o & -65537 | 128,
            c) : null;
        case 19:
            return te(qi),
            null;
        case 4:
            return Ze(),
            null;
        case 10:
            return Al(c.type),
            null;
        case 22:
        case 23:
            return Po(c),
            td(),
            o !== null && te(Cs),
            o = c.flags,
            o & 65536 ? (c.flags = o & -65537 | 128,
            c) : null;
        case 24:
            return Al(rr),
            null;
        case 25:
            return null;
        default:
            return null
        }
    }
    function Df(o, c) {
        switch (v0(c),
        c.tag) {
        case 3:
            Al(rr),
            Ze();
            break;
        case 26:
        case 27:
        case 5:
            tt(c);
            break;
        case 4:
            Ze();
            break;
        case 13:
            Po(c);
            break;
        case 19:
            te(qi);
            break;
        case 10:
            Al(c.type);
            break;
        case 22:
        case 23:
            Po(c),
            td(),
            o !== null && te(Cs);
            break;
        case 24:
            Al(rr)
        }
    }
    function wc(o, c) {
        try {
            var m = c.updateQueue
              , _ = m !== null ? m.lastEffect : null;
            if (_ !== null) {
                var E = _.next;
                m = E;
                do {
                    if ((m.tag & o) === o) {
                        _ = void 0;
                        var D = m.create
                          , X = m.inst;
                        _ = D(),
                        X.destroy = _
                    }
                    m = m.next
                } while (m !== E)
            }
        } catch (ee) {
            Ae(c, c.return, ee)
        }
    }
    function Ka(o, c, m) {
        try {
            var _ = c.updateQueue
              , E = _ !== null ? _.lastEffect : null;
            if (E !== null) {
                var D = E.next;
                _ = D;
                do {
                    if ((_.tag & o) === o) {
                        var X = _.inst
                          , ee = X.destroy;
                        if (ee !== void 0) {
                            X.destroy = void 0,
                            E = c;
                            var be = m
                              , Xe = ee;
                            try {
                                Xe()
                            } catch (dt) {
                                Ae(E, be, dt)
                            }
                        }
                    }
                    _ = _.next
                } while (_ !== D)
            }
        } catch (dt) {
            Ae(c, c.return, dt)
        }
    }
    function Ac(o) {
        var c = o.updateQueue;
        if (c !== null) {
            var m = o.stateNode;
            try {
                k_(c, m)
            } catch (_) {
                Ae(o, o.return, _)
            }
        }
    }
    function Pl(o, c, m) {
        m.props = Bo(o.type, o.memoizedProps),
        m.state = o.memoizedState;
        try {
            m.componentWillUnmount()
        } catch (_) {
            Ae(o, c, _)
        }
    }
    function Cc(o, c) {
        try {
            var m = o.ref;
            if (m !== null) {
                switch (o.tag) {
                case 26:
                case 27:
                case 5:
                    var _ = o.stateNode;
                    break;
                case 30:
                    _ = o.stateNode;
                    break;
                default:
                    _ = o.stateNode
                }
                typeof m == "function" ? o.refCleanup = m(_) : m.current = _
            }
        } catch (E) {
            Ae(o, c, E)
        }
    }
    function Io(o, c) {
        var m = o.ref
          , _ = o.refCleanup;
        if (m !== null)
            if (typeof _ == "function")
                try {
                    _()
                } catch (E) {
                    Ae(o, c, E)
                } finally {
                    o.refCleanup = null,
                    o = o.alternate,
                    o != null && (o.refCleanup = null)
                }
            else if (typeof m == "function")
                try {
                    m(null)
                } catch (E) {
                    Ae(o, c, E)
                }
            else
                m.current = null
    }
    function Uf(o) {
        var c = o.type
          , m = o.memoizedProps
          , _ = o.stateNode;
        try {
            e: switch (c) {
            case "button":
            case "input":
            case "select":
            case "textarea":
                m.autoFocus && _.focus();
                break e;
            case "img":
                m.src ? _.src = m.src : m.srcSet && (_.srcset = m.srcSet)
            }
        } catch (E) {
            Ae(o, o.return, E)
        }
    }
    function cd(o, c, m) {
        try {
            var _ = o.stateNode;
            c5(_, o.type, m, c),
            _[Lt] = c
        } catch (E) {
            Ae(o, o.return, E)
        }
    }
    function fd(o) {
        return o.tag === 5 || o.tag === 3 || o.tag === 26 || o.tag === 27 && If(o.type) || o.tag === 4
    }
    function Eu(o) {
        e: for (; ; ) {
            for (; o.sibling === null; ) {
                if (o.return === null || fd(o.return))
                    return null;
                o = o.return
            }
            for (o.sibling.return = o.return,
            o = o.sibling; o.tag !== 5 && o.tag !== 6 && o.tag !== 18; ) {
                if (o.tag === 27 && If(o.type) || o.flags & 2 || o.child === null || o.tag === 4)
                    continue e;
                o.child.return = o,
                o = o.child
            }
            if (!(o.flags & 2))
                return o.stateNode
        }
    }
    function wu(o, c, m) {
        var _ = o.tag;
        if (_ === 5 || _ === 6)
            o = o.stateNode,
            c ? (m.nodeType === 9 ? m.body : m.nodeName === "HTML" ? m.ownerDocument.body : m).insertBefore(o, c) : (c = m.nodeType === 9 ? m.body : m.nodeName === "HTML" ? m.ownerDocument.body : m,
            c.appendChild(o),
            m = m._reactRootContainer,
            m != null || c.onclick !== null || (c.onclick = O1));
        else if (_ !== 4 && (_ === 27 && If(o.type) && (m = o.stateNode,
        c = null),
        o = o.child,
        o !== null))
            for (wu(o, c, m),
            o = o.sibling; o !== null; )
                wu(o, c, m),
                o = o.sibling
    }
    function Au(o, c, m) {
        var _ = o.tag;
        if (_ === 5 || _ === 6)
            o = o.stateNode,
            c ? m.insertBefore(o, c) : m.appendChild(o);
        else if (_ !== 4 && (_ === 27 && If(o.type) && (m = o.stateNode),
        o = o.child,
        o !== null))
            for (Au(o, c, m),
            o = o.sibling; o !== null; )
                Au(o, c, m),
                o = o.sibling
    }
    function Cu(o) {
        var c = o.stateNode
          , m = o.memoizedProps;
        try {
            for (var _ = o.type, E = c.attributes; E.length; )
                c.removeAttributeNode(E[0]);
            ha(c, _, m),
            c[mt] = o,
            c[Lt] = m
        } catch (D) {
            Ae(o, o.return, D)
        }
    }
    var Fo = !1
      , bi = !1
      , Of = !1
      , Qa = typeof WeakSet == "function" ? WeakSet : Set
      , mi = null;
    function hr(o, c) {
        if (o = o.containerInfo,
        o2 = F1,
        o = l0(o),
        Fh(o)) {
            if ("selectionStart"in o)
                var m = {
                    start: o.selectionStart,
                    end: o.selectionEnd
                };
            else
                e: {
                    m = (m = o.ownerDocument) && m.defaultView || window;
                    var _ = m.getSelection && m.getSelection();
                    if (_ && _.rangeCount !== 0) {
                        m = _.anchorNode;
                        var E = _.anchorOffset
                          , D = _.focusNode;
                        _ = _.focusOffset;
                        try {
                            m.nodeType,
                            D.nodeType
                        } catch {
                            m = null;
                            break e
                        }
                        var X = 0
                          , ee = -1
                          , be = -1
                          , Xe = 0
                          , dt = 0
                          , St = o
                          , Qe = null;
                        t: for (; ; ) {
                            for (var Je; St !== m || E !== 0 && St.nodeType !== 3 || (ee = X + E),
                            St !== D || _ !== 0 && St.nodeType !== 3 || (be = X + _),
                            St.nodeType === 3 && (X += St.nodeValue.length),
                            (Je = St.firstChild) !== null; )
                                Qe = St,
                                St = Je;
                            for (; ; ) {
                                if (St === o)
                                    break t;
                                if (Qe === m && ++Xe === E && (ee = X),
                                Qe === D && ++dt === _ && (be = X),
                                (Je = St.nextSibling) !== null)
                                    break;
                                St = Qe,
                                Qe = St.parentNode
                            }
                            St = Je
                        }
                        m = ee === -1 || be === -1 ? null : {
                            start: ee,
                            end: be
                        }
                    } else
                        m = null
                }
            m = m || {
                start: 0,
                end: 0
            }
        } else
            m = null;
        for (l2 = {
            focusedElem: o,
            selectionRange: m
        },
        F1 = !1,
        mi = c; mi !== null; )
            if (c = mi,
            o = c.child,
            (c.subtreeFlags & 1024) !== 0 && o !== null)
                o.return = c,
                mi = o;
            else
                for (; mi !== null; ) {
                    switch (c = mi,
                    D = c.alternate,
                    o = c.flags,
                    c.tag) {
                    case 0:
                        break;
                    case 11:
                    case 15:
                        break;
                    case 1:
                        if ((o & 1024) !== 0 && D !== null) {
                            o = void 0,
                            m = c,
                            E = D.memoizedProps,
                            D = D.memoizedState,
                            _ = m.stateNode;
                            try {
                                var yn = Bo(m.type, E, m.elementType === m.type);
                                o = _.getSnapshotBeforeUpdate(yn, D),
                                _.__reactInternalSnapshotBeforeUpdate = o
                            } catch (cn) {
                                Ae(m, m.return, cn)
                            }
                        }
                        break;
                    case 3:
                        if ((o & 1024) !== 0) {
                            if (o = c.stateNode.containerInfo,
                            m = o.nodeType,
                            m === 9)
                                f2(o);
                            else if (m === 1)
                                switch (o.nodeName) {
                                case "HEAD":
                                case "HTML":
                                case "BODY":
                                    f2(o);
                                    break;
                                default:
                                    o.textContent = ""
                                }
                        }
                        break;
                    case 5:
                    case 26:
                    case 27:
                    case 6:
                    case 4:
                    case 17:
                        break;
                    default:
                        if ((o & 1024) !== 0)
                            throw Error(n(163))
                    }
                    if (o = c.sibling,
                    o !== null) {
                        o.return = c.return,
                        mi = o;
                        break
                    }
                    mi = c.return
                }
    }
    function Bl(o, c, m) {
        var _ = m.flags;
        switch (m.tag) {
        case 0:
        case 11:
        case 15:
            ca(o, m),
            _ & 4 && wc(5, m);
            break;
        case 1:
            if (ca(o, m),
            _ & 4)
                if (o = m.stateNode,
                c === null)
                    try {
                        o.componentDidMount()
                    } catch (X) {
                        Ae(m, m.return, X)
                    }
                else {
                    var E = Bo(m.type, c.memoizedProps);
                    c = c.memoizedState;
                    try {
                        o.componentDidUpdate(E, c, o.__reactInternalSnapshotBeforeUpdate)
                    } catch (X) {
                        Ae(m, m.return, X)
                    }
                }
            _ & 64 && Ac(m),
            _ & 512 && Cc(m, m.return);
            break;
        case 3:
            if (ca(o, m),
            _ & 64 && (o = m.updateQueue,
            o !== null)) {
                if (c = null,
                m.child !== null)
                    switch (m.child.tag) {
                    case 27:
                    case 5:
                        c = m.child.stateNode;
                        break;
                    case 1:
                        c = m.child.stateNode
                    }
                try {
                    k_(o, c)
                } catch (X) {
                    Ae(m, m.return, X)
                }
            }
            break;
        case 27:
            c === null && _ & 4 && Cu(m);
        case 26:
        case 5:
            ca(o, m),
            c === null && _ & 4 && Uf(m),
            _ & 512 && Cc(m, m.return);
            break;
        case 12:
            ca(o, m);
            break;
        case 13:
            ca(o, m),
            _ & 4 && Ru(o, m),
            _ & 64 && (o = m.memoizedState,
            o !== null && (o = o.dehydrated,
            o !== null && (m = Ci.bind(null, m),
            v5(o, m))));
            break;
        case 22:
            if (_ = m.memoizedState !== null || Fo,
            !_) {
                c = c !== null && c.memoizedState !== null || bi,
                E = Fo;
                var D = bi;
                Fo = _,
                (bi = c) && !D ? Ho(o, m, (m.subtreeFlags & 8772) !== 0) : ca(o, m),
                Fo = E,
                bi = D
            }
            break;
        case 30:
            break;
        default:
            ca(o, m)
        }
    }
    function Dn(o) {
        var c = o.alternate;
        c !== null && (o.alternate = null,
        Dn(c)),
        o.child = null,
        o.deletions = null,
        o.sibling = null,
        o.tag === 5 && (c = o.stateNode,
        c !== null && $t(c)),
        o.stateNode = null,
        o.return = null,
        o.dependencies = null,
        o.memoizedProps = null,
        o.memoizedState = null,
        o.pendingProps = null,
        o.stateNode = null,
        o.updateQueue = null
    }
    var sn = null
      , qn = !1;
    function Ls(o, c, m) {
        for (m = m.child; m !== null; )
            Rc(o, c, m),
            m = m.sibling
    }
    function Rc(o, c, m) {
        if (we && typeof we.onCommitFiberUnmount == "function")
            try {
                we.onCommitFiberUnmount(Be, m)
            } catch {}
        switch (m.tag) {
        case 26:
            bi || Io(m, c),
            Ls(o, c, m),
            m.memoizedState ? m.memoizedState.count-- : m.stateNode && (m = m.stateNode,
            m.parentNode.removeChild(m));
            break;
        case 27:
            bi || Io(m, c);
            var _ = sn
              , E = qn;
            If(m.type) && (sn = m.stateNode,
            qn = !1),
            Ls(o, c, m),
            K0(m.stateNode),
            sn = _,
            qn = E;
            break;
        case 5:
            bi || Io(m, c);
        case 6:
            if (_ = sn,
            E = qn,
            sn = null,
            Ls(o, c, m),
            sn = _,
            qn = E,
            sn !== null)
                if (qn)
                    try {
                        (sn.nodeType === 9 ? sn.body : sn.nodeName === "HTML" ? sn.ownerDocument.body : sn).removeChild(m.stateNode)
                    } catch (D) {
                        Ae(m, c, D)
                    }
                else
                    try {
                        sn.removeChild(m.stateNode)
                    } catch (D) {
                        Ae(m, c, D)
                    }
            break;
        case 18:
            sn !== null && (qn ? (o = sn,
            TR(o.nodeType === 9 ? o.body : o.nodeName === "HTML" ? o.ownerDocument.body : o, m.stateNode),
            rv(o)) : TR(sn, m.stateNode));
            break;
        case 4:
            _ = sn,
            E = qn,
            sn = m.stateNode.containerInfo,
            qn = !0,
            Ls(o, c, m),
            sn = _,
            qn = E;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            bi || Ka(2, m, c),
            bi || Ka(4, m, c),
            Ls(o, c, m);
            break;
        case 1:
            bi || (Io(m, c),
            _ = m.stateNode,
            typeof _.componentWillUnmount == "function" && Pl(m, c, _)),
            Ls(o, c, m);
            break;
        case 21:
            Ls(o, c, m);
            break;
        case 22:
            bi = (_ = bi) || m.memoizedState !== null,
            Ls(o, c, m),
            bi = _;
            break;
        default:
            Ls(o, c, m)
        }
    }
    function Ru(o, c) {
        if (c.memoizedState === null && (o = c.alternate,
        o !== null && (o = o.memoizedState,
        o !== null && (o = o.dehydrated,
        o !== null))))
            try {
                rv(o)
            } catch (m) {
                Ae(c, c.return, m)
            }
    }
    function rm(o) {
        switch (o.tag) {
        case 13:
        case 19:
            var c = o.stateNode;
            return c === null && (c = o.stateNode = new Qa),
            c;
        case 22:
            return o = o.stateNode,
            c = o._retryCache,
            c === null && (c = o._retryCache = new Qa),
            c;
        default:
            throw Error(n(435, o.tag))
        }
    }
    function Dc(o, c) {
        var m = rm(o);
        c.forEach(function(_) {
            var E = mn.bind(null, o, _);
            m.has(_) || (m.add(_),
            _.then(E, E))
        })
    }
    function Mr(o, c) {
        var m = c.deletions;
        if (m !== null)
            for (var _ = 0; _ < m.length; _++) {
                var E = m[_]
                  , D = o
                  , X = c
                  , ee = X;
                e: for (; ee !== null; ) {
                    switch (ee.tag) {
                    case 27:
                        if (If(ee.type)) {
                            sn = ee.stateNode,
                            qn = !1;
                            break e
                        }
                        break;
                    case 5:
                        sn = ee.stateNode,
                        qn = !1;
                        break e;
                    case 3:
                    case 4:
                        sn = ee.stateNode.containerInfo,
                        qn = !0;
                        break e
                    }
                    ee = ee.return
                }
                if (sn === null)
                    throw Error(n(160));
                Rc(D, X, E),
                sn = null,
                qn = !1,
                D = E.alternate,
                D !== null && (D.return = null),
                E.return = null
            }
        if (c.subtreeFlags & 13878)
            for (c = c.child; c !== null; )
                am(c, o),
                c = c.sibling
    }
    var oo = null;
    function am(o, c) {
        var m = o.alternate
          , _ = o.flags;
        switch (o.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            Mr(c, o),
            Fi(o),
            _ & 4 && (Ka(3, o, o.return),
            wc(3, o),
            Ka(5, o, o.return));
            break;
        case 1:
            Mr(c, o),
            Fi(o),
            _ & 512 && (bi || m === null || Io(m, m.return)),
            _ & 64 && Fo && (o = o.updateQueue,
            o !== null && (_ = o.callbacks,
            _ !== null && (m = o.shared.hiddenCallbacks,
            o.shared.hiddenCallbacks = m === null ? _ : m.concat(_))));
            break;
        case 26:
            var E = oo;
            if (Mr(c, o),
            Fi(o),
            _ & 512 && (bi || m === null || Io(m, m.return)),
            _ & 4) {
                var D = m !== null ? m.memoizedState : null;
                if (_ = o.memoizedState,
                m === null)
                    if (_ === null)
                        if (o.stateNode === null) {
                            e: {
                                _ = o.type,
                                m = o.memoizedProps,
                                E = E.ownerDocument || E;
                                t: switch (_) {
                                case "title":
                                    D = E.getElementsByTagName("title")[0],
                                    (!D || D[un] || D[mt] || D.namespaceURI === "http://www.w3.org/2000/svg" || D.hasAttribute("itemprop")) && (D = E.createElement(_),
                                    E.head.insertBefore(D, E.querySelector("head > title"))),
                                    ha(D, _, m),
                                    D[mt] = o,
                                    Fe(D),
                                    _ = D;
                                    break e;
                                case "link":
                                    var X = OR("link", "href", E).get(_ + (m.href || ""));
                                    if (X) {
                                        for (var ee = 0; ee < X.length; ee++)
                                            if (D = X[ee],
                                            D.getAttribute("href") === (m.href == null || m.href === "" ? null : m.href) && D.getAttribute("rel") === (m.rel == null ? null : m.rel) && D.getAttribute("title") === (m.title == null ? null : m.title) && D.getAttribute("crossorigin") === (m.crossOrigin == null ? null : m.crossOrigin)) {
                                                X.splice(ee, 1);
                                                break t
                                            }
                                    }
                                    D = E.createElement(_),
                                    ha(D, _, m),
                                    E.head.appendChild(D);
                                    break;
                                case "meta":
                                    if (X = OR("meta", "content", E).get(_ + (m.content || ""))) {
                                        for (ee = 0; ee < X.length; ee++)
                                            if (D = X[ee],
                                            D.getAttribute("content") === (m.content == null ? null : "" + m.content) && D.getAttribute("name") === (m.name == null ? null : m.name) && D.getAttribute("property") === (m.property == null ? null : m.property) && D.getAttribute("http-equiv") === (m.httpEquiv == null ? null : m.httpEquiv) && D.getAttribute("charset") === (m.charSet == null ? null : m.charSet)) {
                                                X.splice(ee, 1);
                                                break t
                                            }
                                    }
                                    D = E.createElement(_),
                                    ha(D, _, m),
                                    E.head.appendChild(D);
                                    break;
                                default:
                                    throw Error(n(468, _))
                                }
                                D[mt] = o,
                                Fe(D),
                                _ = D
                            }
                            o.stateNode = _
                        } else
                            NR(E, o.type, o.stateNode);
                    else
                        o.stateNode = UR(E, _, o.memoizedProps);
                else
                    D !== _ ? (D === null ? m.stateNode !== null && (m = m.stateNode,
                    m.parentNode.removeChild(m)) : D.count--,
                    _ === null ? NR(E, o.type, o.stateNode) : UR(E, _, o.memoizedProps)) : _ === null && o.stateNode !== null && cd(o, o.memoizedProps, m.memoizedProps)
            }
            break;
        case 27:
            Mr(c, o),
            Fi(o),
            _ & 512 && (bi || m === null || Io(m, m.return)),
            m !== null && _ & 4 && cd(o, o.memoizedProps, m.memoizedProps);
            break;
        case 5:
            if (Mr(c, o),
            Fi(o),
            _ & 512 && (bi || m === null || Io(m, m.return)),
            o.flags & 32) {
                E = o.stateNode;
                try {
                    Di(E, "")
                } catch (Je) {
                    Ae(o, o.return, Je)
                }
            }
            _ & 4 && o.stateNode != null && (E = o.memoizedProps,
            cd(o, E, m !== null ? m.memoizedProps : E)),
            _ & 1024 && (Of = !0);
            break;
        case 6:
            if (Mr(c, o),
            Fi(o),
            _ & 4) {
                if (o.stateNode === null)
                    throw Error(n(162));
                _ = o.memoizedProps,
                m = o.stateNode;
                try {
                    m.nodeValue = _
                } catch (Je) {
                    Ae(o, o.return, Je)
                }
            }
            break;
        case 3:
            if (B1 = null,
            E = oo,
            oo = L1(c.containerInfo),
            Mr(c, o),
            oo = E,
            Fi(o),
            _ & 4 && m !== null && m.memoizedState.isDehydrated)
                try {
                    rv(c.containerInfo)
                } catch (Je) {
                    Ae(o, o.return, Je)
                }
            Of && (Of = !1,
            Du(o));
            break;
        case 4:
            _ = oo,
            oo = L1(o.stateNode.containerInfo),
            Mr(c, o),
            Fi(o),
            oo = _;
            break;
        case 12:
            Mr(c, o),
            Fi(o);
            break;
        case 13:
            Mr(c, o),
            Fi(o),
            o.child.flags & 8192 && o.memoizedState !== null != (m !== null && m.memoizedState !== null) && (hi = le()),
            _ & 4 && (_ = o.updateQueue,
            _ !== null && (o.updateQueue = null,
            Dc(o, _)));
            break;
        case 22:
            E = o.memoizedState !== null;
            var be = m !== null && m.memoizedState !== null
              , Xe = Fo
              , dt = bi;
            if (Fo = Xe || E,
            bi = dt || be,
            Mr(c, o),
            bi = dt,
            Fo = Xe,
            Fi(o),
            _ & 8192)
                e: for (c = o.stateNode,
                c._visibility = E ? c._visibility & -2 : c._visibility | 1,
                E && (m === null || be || Fo || bi || Ja(o)),
                m = null,
                c = o; ; ) {
                    if (c.tag === 5 || c.tag === 26) {
                        if (m === null) {
                            be = m = c;
                            try {
                                if (D = be.stateNode,
                                E)
                                    X = D.style,
                                    typeof X.setProperty == "function" ? X.setProperty("display", "none", "important") : X.display = "none";
                                else {
                                    ee = be.stateNode;
                                    var St = be.memoizedProps.style
                                      , Qe = St != null && St.hasOwnProperty("display") ? St.display : null;
                                    ee.style.display = Qe == null || typeof Qe == "boolean" ? "" : ("" + Qe).trim()
                                }
                            } catch (Je) {
                                Ae(be, be.return, Je)
                            }
                        }
                    } else if (c.tag === 6) {
                        if (m === null) {
                            be = c;
                            try {
                                be.stateNode.nodeValue = E ? "" : be.memoizedProps
                            } catch (Je) {
                                Ae(be, be.return, Je)
                            }
                        }
                    } else if ((c.tag !== 22 && c.tag !== 23 || c.memoizedState === null || c === o) && c.child !== null) {
                        c.child.return = c,
                        c = c.child;
                        continue
                    }
                    if (c === o)
                        break e;
                    for (; c.sibling === null; ) {
                        if (c.return === null || c.return === o)
                            break e;
                        m === c && (m = null),
                        c = c.return
                    }
                    m === c && (m = null),
                    c.sibling.return = c.return,
                    c = c.sibling
                }
            _ & 4 && (_ = o.updateQueue,
            _ !== null && (m = _.retryQueue,
            m !== null && (_.retryQueue = null,
            Dc(o, m))));
            break;
        case 19:
            Mr(c, o),
            Fi(o),
            _ & 4 && (_ = o.updateQueue,
            _ !== null && (o.updateQueue = null,
            Dc(o, _)));
            break;
        case 30:
            break;
        case 21:
            break;
        default:
            Mr(c, o),
            Fi(o)
        }
    }
    function Fi(o) {
        var c = o.flags;
        if (c & 2) {
            try {
                for (var m, _ = o.return; _ !== null; ) {
                    if (fd(_)) {
                        m = _;
                        break
                    }
                    _ = _.return
                }
                if (m == null)
                    throw Error(n(160));
                switch (m.tag) {
                case 27:
                    var E = m.stateNode
                      , D = Eu(o);
                    Au(o, D, E);
                    break;
                case 5:
                    var X = m.stateNode;
                    m.flags & 32 && (Di(X, ""),
                    m.flags &= -33);
                    var ee = Eu(o);
                    Au(o, ee, X);
                    break;
                case 3:
                case 4:
                    var be = m.stateNode.containerInfo
                      , Xe = Eu(o);
                    wu(o, Xe, be);
                    break;
                default:
                    throw Error(n(161))
                }
            } catch (dt) {
                Ae(o, o.return, dt)
            }
            o.flags &= -3
        }
        c & 4096 && (o.flags &= -4097)
    }
    function Du(o) {
        if (o.subtreeFlags & 1024)
            for (o = o.child; o !== null; ) {
                var c = o;
                Du(c),
                c.tag === 5 && c.flags & 1024 && c.stateNode.reset(),
                o = o.sibling
            }
    }
    function ca(o, c) {
        if (c.subtreeFlags & 8772)
            for (c = c.child; c !== null; )
                Bl(o, c.alternate, c),
                c = c.sibling
    }
    function Ja(o) {
        for (o = o.child; o !== null; ) {
            var c = o;
            switch (c.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                Ka(4, c, c.return),
                Ja(c);
                break;
            case 1:
                Io(c, c.return);
                var m = c.stateNode;
                typeof m.componentWillUnmount == "function" && Pl(c, c.return, m),
                Ja(c);
                break;
            case 27:
                K0(c.stateNode);
            case 26:
            case 5:
                Io(c, c.return),
                Ja(c);
                break;
            case 22:
                c.memoizedState === null && Ja(c);
                break;
            case 30:
                Ja(c);
                break;
            default:
                Ja(c)
            }
            o = o.sibling
        }
    }
    function Ho(o, c, m) {
        for (m = m && (c.subtreeFlags & 8772) !== 0,
        c = c.child; c !== null; ) {
            var _ = c.alternate
              , E = o
              , D = c
              , X = D.flags;
            switch (D.tag) {
            case 0:
            case 11:
            case 15:
                Ho(E, D, m),
                wc(4, D);
                break;
            case 1:
                if (Ho(E, D, m),
                _ = D,
                E = _.stateNode,
                typeof E.componentDidMount == "function")
                    try {
                        E.componentDidMount()
                    } catch (Xe) {
                        Ae(_, _.return, Xe)
                    }
                if (_ = D,
                E = _.updateQueue,
                E !== null) {
                    var ee = _.stateNode;
                    try {
                        var be = E.shared.hiddenCallbacks;
                        if (be !== null)
                            for (E.shared.hiddenCallbacks = null,
                            E = 0; E < be.length; E++)
                                Sf(be[E], ee)
                    } catch (Xe) {
                        Ae(_, _.return, Xe)
                    }
                }
                m && X & 64 && Ac(D),
                Cc(D, D.return);
                break;
            case 27:
                Cu(D);
            case 26:
            case 5:
                Ho(E, D, m),
                m && _ === null && X & 4 && Uf(D),
                Cc(D, D.return);
                break;
            case 12:
                Ho(E, D, m);
                break;
            case 13:
                Ho(E, D, m),
                m && X & 4 && Ru(E, D);
                break;
            case 22:
                D.memoizedState === null && Ho(E, D, m),
                Cc(D, D.return);
                break;
            case 30:
                break;
            default:
                Ho(E, D, m)
            }
            c = c.sibling
        }
    }
    function sm(o, c) {
        var m = null;
        o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (m = o.memoizedState.cachePool.pool),
        o = null,
        c.memoizedState !== null && c.memoizedState.cachePool !== null && (o = c.memoizedState.cachePool.pool),
        o !== m && (o != null && o.refCount++,
        m != null && mf(m))
    }
    function om(o, c) {
        o = null,
        c.alternate !== null && (o = c.alternate.memoizedState.cache),
        c = c.memoizedState.cache,
        c !== o && (c.refCount++,
        o != null && mf(o))
    }
    function gi(o, c, m, _) {
        if (c.subtreeFlags & 10256)
            for (c = c.child; c !== null; )
                lm(o, c, m, _),
                c = c.sibling
    }
    function lm(o, c, m, _) {
        var E = c.flags;
        switch (c.tag) {
        case 0:
        case 11:
        case 15:
            gi(o, c, m, _),
            E & 2048 && wc(9, c);
            break;
        case 1:
            gi(o, c, m, _);
            break;
        case 3:
            gi(o, c, m, _),
            E & 2048 && (o = null,
            c.alternate !== null && (o = c.alternate.memoizedState.cache),
            c = c.memoizedState.cache,
            c !== o && (c.refCount++,
            o != null && mf(o)));
            break;
        case 12:
            if (E & 2048) {
                gi(o, c, m, _),
                o = c.stateNode;
                try {
                    var D = c.memoizedProps
                      , X = D.id
                      , ee = D.onPostCommit;
                    typeof ee == "function" && ee(X, c.alternate === null ? "mount" : "update", o.passiveEffectDuration, -0)
                } catch (be) {
                    Ae(c, c.return, be)
                }
            } else
                gi(o, c, m, _);
            break;
        case 13:
            gi(o, c, m, _);
            break;
        case 23:
            break;
        case 22:
            D = c.stateNode,
            X = c.alternate,
            c.memoizedState !== null ? D._visibility & 2 ? gi(o, c, m, _) : lo(o, c) : D._visibility & 2 ? gi(o, c, m, _) : (D._visibility |= 2,
            zl(o, c, m, _, (c.subtreeFlags & 10256) !== 0)),
            E & 2048 && sm(X, c);
            break;
        case 24:
            gi(o, c, m, _),
            E & 2048 && om(c.alternate, c);
            break;
        default:
            gi(o, c, m, _)
        }
    }
    function zl(o, c, m, _, E) {
        for (E = E && (c.subtreeFlags & 10256) !== 0,
        c = c.child; c !== null; ) {
            var D = o
              , X = c
              , ee = m
              , be = _
              , Xe = X.flags;
            switch (X.tag) {
            case 0:
            case 11:
            case 15:
                zl(D, X, ee, be, E),
                wc(8, X);
                break;
            case 23:
                break;
            case 22:
                var dt = X.stateNode;
                X.memoizedState !== null ? dt._visibility & 2 ? zl(D, X, ee, be, E) : lo(D, X) : (dt._visibility |= 2,
                zl(D, X, ee, be, E)),
                E && Xe & 2048 && sm(X.alternate, X);
                break;
            case 24:
                zl(D, X, ee, be, E),
                E && Xe & 2048 && om(X.alternate, X);
                break;
            default:
                zl(D, X, ee, be, E)
            }
            c = c.sibling
        }
    }
    function lo(o, c) {
        if (c.subtreeFlags & 10256)
            for (c = c.child; c !== null; ) {
                var m = o
                  , _ = c
                  , E = _.flags;
                switch (_.tag) {
                case 22:
                    lo(m, _),
                    E & 2048 && sm(_.alternate, _);
                    break;
                case 24:
                    lo(m, _),
                    E & 2048 && om(_.alternate, _);
                    break;
                default:
                    lo(m, _)
                }
                c = c.sibling
            }
    }
    var $a = 8192;
    function Nf(o) {
        if (o.subtreeFlags & $a)
            for (o = o.child; o !== null; )
                C1(o),
                o = o.sibling
    }
    function C1(o) {
        switch (o.tag) {
        case 26:
            Nf(o),
            o.flags & $a && o.memoizedState !== null && D5(oo, o.memoizedState, o.memoizedProps);
            break;
        case 5:
            Nf(o);
            break;
        case 3:
        case 4:
            var c = oo;
            oo = L1(o.stateNode.containerInfo),
            Nf(o),
            oo = c;
            break;
        case 22:
            o.memoizedState === null && (c = o.alternate,
            c !== null && c.memoizedState !== null ? (c = $a,
            $a = 16777216,
            Nf(o),
            $a = c) : Nf(o));
            break;
        default:
            Nf(o)
        }
    }
    function R1(o) {
        var c = o.alternate;
        if (c !== null && (o = c.child,
        o !== null)) {
            c.child = null;
            do
                c = o.sibling,
                o.sibling = null,
                o = c;
            while (o !== null)
        }
    }
    function Mi(o) {
        var c = o.deletions;
        if ((o.flags & 16) !== 0) {
            if (c !== null)
                for (var m = 0; m < c.length; m++) {
                    var _ = c[m];
                    mi = _,
                    ko(_, o)
                }
            R1(o)
        }
        if (o.subtreeFlags & 10256)
            for (o = o.child; o !== null; )
                j0(o),
                o = o.sibling
    }
    function j0(o) {
        switch (o.tag) {
        case 0:
        case 11:
        case 15:
            Mi(o),
            o.flags & 2048 && Ka(9, o, o.return);
            break;
        case 3:
            Mi(o);
            break;
        case 12:
            Mi(o);
            break;
        case 22:
            var c = o.stateNode;
            o.memoizedState !== null && c._visibility & 2 && (o.return === null || o.return.tag !== 13) ? (c._visibility &= -3,
            Vo(o)) : Mi(o);
            break;
        default:
            Mi(o)
        }
    }
    function Vo(o) {
        var c = o.deletions;
        if ((o.flags & 16) !== 0) {
            if (c !== null)
                for (var m = 0; m < c.length; m++) {
                    var _ = c[m];
                    mi = _,
                    ko(_, o)
                }
            R1(o)
        }
        for (o = o.child; o !== null; ) {
            switch (c = o,
            c.tag) {
            case 0:
            case 11:
            case 15:
                Ka(8, c, c.return),
                Vo(c);
                break;
            case 22:
                m = c.stateNode,
                m._visibility & 2 && (m._visibility &= -3,
                Vo(c));
                break;
            default:
                Vo(c)
            }
            o = o.sibling
        }
    }
    function ko(o, c) {
        for (; mi !== null; ) {
            var m = mi;
            switch (m.tag) {
            case 0:
            case 11:
            case 15:
                Ka(8, m, c);
                break;
            case 23:
            case 22:
                if (m.memoizedState !== null && m.memoizedState.cachePool !== null) {
                    var _ = m.memoizedState.cachePool.pool;
                    _ != null && _.refCount++
                }
                break;
            case 24:
                mf(m.memoizedState.cache)
            }
            if (_ = m.child,
            _ !== null)
                _.return = m,
                mi = _;
            else
                e: for (m = o; mi !== null; ) {
                    _ = mi;
                    var E = _.sibling
                      , D = _.return;
                    if (Dn(_),
                    _ === m) {
                        mi = null;
                        break e
                    }
                    if (E !== null) {
                        E.return = D,
                        mi = E;
                        break e
                    }
                    mi = D
                }
        }
    }
    var Hi = {
        getCacheForType: function(o) {
            var c = Ii(rr)
              , m = c.data.get(o);
            return m === void 0 && (m = o(),
            c.data.set(o, m)),
            m
        }
    }
      , W0 = typeof WeakMap == "function" ? WeakMap : Map
      , si = 0
      , Mn = null
      , zn = null
      , an = 0
      , Rn = 0
      , Pi = null
      , es = !1
      , Lf = !1
      , Pf = !1
      , Ps = 0
      , Ai = 0
      , uo = 0
      , Go = 0
      , Uc = 0
      , Bs = 0
      , Zn = 0
      , oi = null
      , on = null
      , Vn = !1
      , hi = 0
      , jr = 1 / 0
      , zs = null
      , ts = null
      , dr = 0
      , Wr = null
      , vi = null
      , ns = 0
      , Il = 0
      , hd = null
      , is = null
      , Xo = 0
      , Oc = null;
    function Vi() {
        if ((si & 2) !== 0 && an !== 0)
            return an & -an;
        if (H.T !== null) {
            var o = En;
            return o !== 0 ? o : e2()
        }
        return bt()
    }
    function um() {
        Bs === 0 && (Bs = (an & 536870912) === 0 || $n ? me() : 536870912);
        var o = pi.current;
        return o !== null && (o.flags |= 32),
        Bs
    }
    function fa(o, c, m) {
        (o === Mn && (Rn === 2 || Rn === 9) || o.cancelPendingCommit !== null) && (Ou(o, 0),
        co(o, an, Bs, !1)),
        Ct(o, m),
        ((si & 2) === 0 || o !== Mn) && (o === Mn && ((si & 2) === 0 && (Go |= m),
        Ai === 4 && co(o, an, Bs, !1)),
        Pu(o))
    }
    function Bf(o, c, m) {
        if ((si & 6) !== 0)
            throw Error(n(327));
        var _ = !m && (c & 124) === 0 && (c & o.expiredLanes) === 0 || ut(o, c)
          , E = _ ? w(o, c) : p(o, c, !0)
          , D = _;
        do {
            if (E === 0) {
                Lf && !_ && co(o, c, 0, !1);
                break
            } else {
                if (m = o.current.alternate,
                D && !Uu(m)) {
                    E = p(o, c, !1),
                    D = !1;
                    continue
                }
                if (E === 2) {
                    if (D = c,
                    o.errorRecoveryDisabledLanes & D)
                        var X = 0;
                    else
                        X = o.pendingLanes & -536870913,
                        X = X !== 0 ? X : X & 536870912 ? 536870912 : 0;
                    if (X !== 0) {
                        c = X;
                        e: {
                            var ee = o;
                            E = oi;
                            var be = ee.current.memoizedState.isDehydrated;
                            if (be && (Ou(ee, X).flags |= 256),
                            X = p(ee, X, !1),
                            X !== 2) {
                                if (Pf && !be) {
                                    ee.errorRecoveryDisabledLanes |= D,
                                    Go |= D,
                                    E = 4;
                                    break e
                                }
                                D = on,
                                on = E,
                                D !== null && (on === null ? on = D : on.push.apply(on, D))
                            }
                            E = X
                        }
                        if (D = !1,
                        E !== 2)
                            continue
                    }
                }
                if (E === 1) {
                    Ou(o, 0),
                    co(o, c, 0, !0);
                    break
                }
                e: {
                    switch (_ = o,
                    D = E,
                    D) {
                    case 0:
                    case 1:
                        throw Error(n(345));
                    case 4:
                        if ((c & 4194048) !== c)
                            break;
                    case 6:
                        co(_, c, Bs, !es);
                        break e;
                    case 2:
                        on = null;
                        break;
                    case 3:
                    case 5:
                        break;
                    default:
                        throw Error(n(329))
                    }
                    if ((c & 62914560) === c && (E = hi + 300 - le(),
                    10 < E)) {
                        if (co(_, c, Bs, !es),
                        _t(_, 0, !0) !== 0)
                            break e;
                        _.timeoutHandle = bR(dd.bind(null, _, m, on, zs, Vn, c, Bs, Go, Zn, es, D, 2, -0, 0), E);
                        break e
                    }
                    dd(_, m, on, zs, Vn, c, Bs, Go, Zn, es, D, 0, -0, 0)
                }
            }
            break
        } while (!0);
        Pu(o)
    }
    function dd(o, c, m, _, E, D, X, ee, be, Xe, dt, St, Qe, Je) {
        if (o.timeoutHandle = -1,
        St = c.subtreeFlags,
        (St & 8192 || (St & 16785408) === 16785408) && ($0 = {
            stylesheets: null,
            count: 0,
            unsuspend: R5
        },
        C1(c),
        St = U5(),
        St !== null)) {
            o.cancelPendingCommit = St(Dt.bind(null, o, c, D, m, _, E, X, ee, be, dt, 1, Qe, Je)),
            co(o, D, X, !Xe);
            return
        }
        Dt(o, c, D, m, _, E, X, ee, be)
    }
    function Uu(o) {
        for (var c = o; ; ) {
            var m = c.tag;
            if ((m === 0 || m === 11 || m === 15) && c.flags & 16384 && (m = c.updateQueue,
            m !== null && (m = m.stores,
            m !== null)))
                for (var _ = 0; _ < m.length; _++) {
                    var E = m[_]
                      , D = E.getSnapshot;
                    E = E.value;
                    try {
                        if (!ba(D(), E))
                            return !1
                    } catch {
                        return !1
                    }
                }
            if (m = c.child,
            c.subtreeFlags & 16384 && m !== null)
                m.return = c,
                c = m;
            else {
                if (c === o)
                    break;
                for (; c.sibling === null; ) {
                    if (c.return === null || c.return === o)
                        return !0;
                    c = c.return
                }
                c.sibling.return = c.return,
                c = c.sibling
            }
        }
        return !0
    }
    function co(o, c, m, _) {
        c &= ~Uc,
        c &= ~Go,
        o.suspendedLanes |= c,
        o.pingedLanes &= ~c,
        _ && (o.warmLanes |= c),
        _ = o.expirationTimes;
        for (var E = c; 0 < E; ) {
            var D = 31 - it(E)
              , X = 1 << D;
            _[D] = -1,
            E &= ~X
        }
        m !== 0 && Ge(o, m, c)
    }
    function jo() {
        return (si & 6) === 0 ? (Y0(0),
        !1) : !0
    }
    function Nc() {
        if (zn !== null) {
            if (Rn === 0)
                var o = zn.return;
            else
                o = zn,
                wl = mu = null,
                C0(o),
                vc = null,
                ad = 0,
                o = zn;
            for (; o !== null; )
                Df(o.alternate, o),
                o = o.return;
            zn = null
        }
    }
    function Ou(o, c) {
        var m = o.timeoutHandle;
        m !== -1 && (o.timeoutHandle = -1,
        h5(m)),
        m = o.cancelPendingCommit,
        m !== null && (o.cancelPendingCommit = null,
        m()),
        Nc(),
        Mn = o,
        zn = m = Wi(o.current, null),
        an = c,
        Rn = 0,
        Pi = null,
        es = !1,
        Lf = ut(o, c),
        Pf = !1,
        Zn = Bs = Uc = Go = uo = Ai = 0,
        on = oi = null,
        Vn = !1,
        (c & 8) !== 0 && (c |= c & 32);
        var _ = o.entangledLanes;
        if (_ !== 0)
            for (o = o.entanglements,
            _ &= c; 0 < _; ) {
                var E = 31 - it(_)
                  , D = 1 << E;
                c |= o[E],
                _ &= ~D
            }
        return Ps = c,
        kh(),
        m
    }
    function cm(o, c) {
        wn = null,
        H.H = rd,
        c === Jh || c === to ? (c = M0(),
        Rn = 3) : c === b0 ? (c = M0(),
        Rn = 4) : Rn = c === A1 ? 8 : c !== null && typeof c == "object" && typeof c.then == "function" ? 6 : 1,
        Pi = c,
        zn === null && (Ai = 1,
        tm(o, Or(c, o.current)))
    }
    function zf() {
        var o = H.H;
        return H.H = rd,
        o === null ? rd : o
    }
    function fm() {
        var o = H.A;
        return H.A = Hi,
        o
    }
    function h() {
        Ai = 4,
        es || (an & 4194048) !== an && pi.current !== null || (Lf = !0),
        (uo & 134217727) === 0 && (Go & 134217727) === 0 || Mn === null || co(Mn, an, Bs, !1)
    }
    function p(o, c, m) {
        var _ = si;
        si |= 2;
        var E = zf()
          , D = fm();
        (Mn !== o || an !== c) && (zs = null,
        Ou(o, c)),
        c = !1;
        var X = Ai;
        e: do
            try {
                if (Rn !== 0 && zn !== null) {
                    var ee = zn
                      , be = Pi;
                    switch (Rn) {
                    case 8:
                        Nc(),
                        X = 6;
                        break e;
                    case 3:
                    case 2:
                    case 9:
                    case 6:
                        pi.current === null && (c = !0);
                        var Xe = Rn;
                        if (Rn = 0,
                        Pi = null,
                        Me(o, ee, be, Xe),
                        m && Lf) {
                            X = 0;
                            break e
                        }
                        break;
                    default:
                        Xe = Rn,
                        Rn = 0,
                        Pi = null,
                        Me(o, ee, be, Xe)
                    }
                }
                x(),
                X = Ai;
                break
            } catch (dt) {
                cm(o, dt)
            }
        while (!0);
        return c && o.shellSuspendCounter++,
        wl = mu = null,
        si = _,
        H.H = E,
        H.A = D,
        zn === null && (Mn = null,
        an = 0,
        kh()),
        X
    }
    function x() {
        for (; zn !== null; )
            F(zn)
    }
    function w(o, c) {
        var m = si;
        si |= 2;
        var _ = zf()
          , E = fm();
        Mn !== o || an !== c ? (zs = null,
        jr = le() + 500,
        Ou(o, c)) : Lf = ut(o, c);
        e: do
            try {
                if (Rn !== 0 && zn !== null) {
                    c = zn;
                    var D = Pi;
                    t: switch (Rn) {
                    case 1:
                        Rn = 0,
                        Pi = null,
                        Me(o, c, D, 1);
                        break;
                    case 2:
                    case 9:
                        if (Hp(D)) {
                            Rn = 0,
                            Pi = null,
                            ie(c);
                            break
                        }
                        c = function() {
                            Rn !== 2 && Rn !== 9 || Mn !== o || (Rn = 7),
                            Pu(o)
                        }
                        ,
                        D.then(c, c);
                        break e;
                    case 3:
                        Rn = 7;
                        break e;
                    case 4:
                        Rn = 5;
                        break e;
                    case 7:
                        Hp(D) ? (Rn = 0,
                        Pi = null,
                        ie(c)) : (Rn = 0,
                        Pi = null,
                        Me(o, c, D, 7));
                        break;
                    case 5:
                        var X = null;
                        switch (zn.tag) {
                        case 26:
                            X = zn.memoizedState;
                        case 5:
                        case 27:
                            var ee = zn;
                            if (!X || LR(X)) {
                                Rn = 0,
                                Pi = null;
                                var be = ee.sibling;
                                if (be !== null)
                                    zn = be;
                                else {
                                    var Xe = ee.return;
                                    Xe !== null ? (zn = Xe,
                                    Ie(Xe)) : zn = null
                                }
                                break t
                            }
                        }
                        Rn = 0,
                        Pi = null,
                        Me(o, c, D, 5);
                        break;
                    case 6:
                        Rn = 0,
                        Pi = null,
                        Me(o, c, D, 6);
                        break;
                    case 8:
                        Nc(),
                        Ai = 6;
                        break e;
                    default:
                        throw Error(n(462))
                    }
                }
                U();
                break
            } catch (dt) {
                cm(o, dt)
            }
        while (!0);
        return wl = mu = null,
        H.H = _,
        H.A = E,
        si = m,
        zn !== null ? 0 : (Mn = null,
        an = 0,
        kh(),
        Ai)
    }
    function U() {
        for (; zn !== null && !Ne(); )
            F(zn)
    }
    function F(o) {
        var c = Tc(o.alternate, o, Ps);
        o.memoizedProps = o.pendingProps,
        c === null ? Ie(o) : zn = c
    }
    function ie(o) {
        var c = o
          , m = c.alternate;
        switch (c.tag) {
        case 15:
        case 0:
            c = qa(m, c, c.pendingProps, c.type, void 0, an);
            break;
        case 11:
            c = qa(m, c, c.pendingProps, c.type.render, c.ref, an);
            break;
        case 5:
            C0(c);
        default:
            Df(m, c),
            c = zn = m0(c, Ps),
            c = Tc(m, c, Ps)
        }
        o.memoizedProps = o.pendingProps,
        c === null ? Ie(o) : zn = c
    }
    function Me(o, c, m, _) {
        wl = mu = null,
        C0(c),
        vc = null,
        ad = 0;
        var E = c.return;
        try {
            if (JM(o, E, c, m, an)) {
                Ai = 1,
                tm(o, Or(m, o.current)),
                zn = null;
                return
            }
        } catch (D) {
            if (E !== null)
                throw zn = E,
                D;
            Ai = 1,
            tm(o, Or(m, o.current)),
            zn = null;
            return
        }
        c.flags & 32768 ? ($n || _ === 1 ? o = !0 : Lf || (an & 536870912) !== 0 ? o = !1 : (es = o = !0,
        (_ === 2 || _ === 9 || _ === 3 || _ === 6) && (_ = pi.current,
        _ !== null && _.tag === 13 && (_.flags |= 16384))),
        ht(c, o)) : Ie(c)
    }
    function Ie(o) {
        var c = o;
        do {
            if ((c.flags & 32768) !== 0) {
                ht(c, es);
                return
            }
            o = c.return;
            var m = X0(c.alternate, c, Ps);
            if (m !== null) {
                zn = m;
                return
            }
            if (c = c.sibling,
            c !== null) {
                zn = c;
                return
            }
            zn = c = o
        } while (c !== null);
        Ai === 0 && (Ai = 5)
    }
    function ht(o, c) {
        do {
            var m = Rf(o.alternate, o);
            if (m !== null) {
                m.flags &= 32767,
                zn = m;
                return
            }
            if (m = o.return,
            m !== null && (m.flags |= 32768,
            m.subtreeFlags = 0,
            m.deletions = null),
            !c && (o = o.sibling,
            o !== null)) {
                zn = o;
                return
            }
            zn = o = m
        } while (o !== null);
        Ai = 6,
        zn = null
    }
    function Dt(o, c, m, _, E, D, X, ee, be) {
        o.cancelPendingCommit = null;
        do
            Nu();
        while (dr !== 0);
        if ((si & 6) !== 0)
            throw Error(n(327));
        if (c !== null) {
            if (c === o.current)
                throw Error(n(177));
            if (D = c.lanes | c.childLanes,
            D |= Up,
            rt(o, m, D, X, ee, be),
            o === Mn && (zn = Mn = null,
            an = 0),
            vi = c,
            Wr = o,
            ns = m,
            Il = D,
            hd = E,
            is = _,
            (c.subtreeFlags & 10256) !== 0 || (c.flags & 10256) !== 0 ? (o.callbackNode = null,
            o.callbackPriority = 0,
            ei(De, function() {
                return Lu(),
                null
            })) : (o.callbackNode = null,
            o.callbackPriority = 0),
            _ = (c.flags & 13878) !== 0,
            (c.subtreeFlags & 13878) !== 0 || _) {
                _ = H.T,
                H.T = null,
                E = q.p,
                q.p = 2,
                X = si,
                si |= 4;
                try {
                    hr(o, c, m)
                } finally {
                    si = X,
                    q.p = E,
                    H.T = _
                }
            }
            dr = 1,
            Ft(),
            jt(),
            Tn()
        }
    }
    function Ft() {
        if (dr === 1) {
            dr = 0;
            var o = Wr
              , c = vi
              , m = (c.flags & 13878) !== 0;
            if ((c.subtreeFlags & 13878) !== 0 || m) {
                m = H.T,
                H.T = null;
                var _ = q.p;
                q.p = 2;
                var E = si;
                si |= 4;
                try {
                    am(c, o);
                    var D = l2
                      , X = l0(o.containerInfo)
                      , ee = D.focusedElem
                      , be = D.selectionRange;
                    if (X !== ee && ee && ee.ownerDocument && o0(ee.ownerDocument.documentElement, ee)) {
                        if (be !== null && Fh(ee)) {
                            var Xe = be.start
                              , dt = be.end;
                            if (dt === void 0 && (dt = Xe),
                            "selectionStart"in ee)
                                ee.selectionStart = Xe,
                                ee.selectionEnd = Math.min(dt, ee.value.length);
                            else {
                                var St = ee.ownerDocument || document
                                  , Qe = St && St.defaultView || window;
                                if (Qe.getSelection) {
                                    var Je = Qe.getSelection()
                                      , yn = ee.textContent.length
                                      , cn = Math.min(be.start, yn)
                                      , Ei = be.end === void 0 ? cn : Math.min(be.end, yn);
                                    !Je.extend && cn > Ei && (X = Ei,
                                    Ei = cn,
                                    cn = X);
                                    var ze = s0(ee, cn)
                                      , Re = s0(ee, Ei);
                                    if (ze && Re && (Je.rangeCount !== 1 || Je.anchorNode !== ze.node || Je.anchorOffset !== ze.offset || Je.focusNode !== Re.node || Je.focusOffset !== Re.offset)) {
                                        var ke = St.createRange();
                                        ke.setStart(ze.node, ze.offset),
                                        Je.removeAllRanges(),
                                        cn > Ei ? (Je.addRange(ke),
                                        Je.extend(Re.node, Re.offset)) : (ke.setEnd(Re.node, Re.offset),
                                        Je.addRange(ke))
                                    }
                                }
                            }
                        }
                        for (St = [],
                        Je = ee; Je = Je.parentNode; )
                            Je.nodeType === 1 && St.push({
                                element: Je,
                                left: Je.scrollLeft,
                                top: Je.scrollTop
                            });
                        for (typeof ee.focus == "function" && ee.focus(),
                        ee = 0; ee < St.length; ee++) {
                            var gt = St[ee];
                            gt.element.scrollLeft = gt.left,
                            gt.element.scrollTop = gt.top
                        }
                    }
                    F1 = !!o2,
                    l2 = o2 = null
                } finally {
                    si = E,
                    q.p = _,
                    H.T = m
                }
            }
            o.current = c,
            dr = 2
        }
    }
    function jt() {
        if (dr === 2) {
            dr = 0;
            var o = Wr
              , c = vi
              , m = (c.flags & 8772) !== 0;
            if ((c.subtreeFlags & 8772) !== 0 || m) {
                m = H.T,
                H.T = null;
                var _ = q.p;
                q.p = 2;
                var E = si;
                si |= 4;
                try {
                    Bl(o, c.alternate, c)
                } finally {
                    si = E,
                    q.p = _,
                    H.T = m
                }
            }
            dr = 3
        }
    }
    function Tn() {
        if (dr === 4 || dr === 3) {
            dr = 0,
            Oe();
            var o = Wr
              , c = vi
              , m = ns
              , _ = is;
            (c.subtreeFlags & 10256) !== 0 || (c.flags & 10256) !== 0 ? dr = 5 : (dr = 0,
            vi = Wr = null,
            rs(o, o.pendingLanes));
            var E = o.pendingLanes;
            if (E === 0 && (ts = null),
            Nt(m),
            c = c.stateNode,
            we && typeof we.onCommitFiberRoot == "function")
                try {
                    we.onCommitFiberRoot(Be, c, void 0, (c.current.flags & 128) === 128)
                } catch {}
            if (_ !== null) {
                c = H.T,
                E = q.p,
                q.p = 2,
                H.T = null;
                try {
                    for (var D = o.onRecoverableError, X = 0; X < _.length; X++) {
                        var ee = _[X];
                        D(ee.value, {
                            componentStack: ee.stack
                        })
                    }
                } finally {
                    H.T = c,
                    q.p = E
                }
            }
            (ns & 3) !== 0 && Nu(),
            Pu(o),
            E = o.pendingLanes,
            (m & 4194090) !== 0 && (E & 42) !== 0 ? o === Oc ? Xo++ : (Xo = 0,
            Oc = o) : Xo = 0,
            Y0(0)
        }
    }
    function rs(o, c) {
        (o.pooledCacheLanes &= c) === 0 && (c = o.pooledCache,
        c != null && (o.pooledCache = null,
        mf(c)))
    }
    function Nu(o) {
        return Ft(),
        jt(),
        Tn(),
        Lu()
    }
    function Lu() {
        if (dr !== 5)
            return !1;
        var o = Wr
          , c = Il;
        Il = 0;
        var m = Nt(ns)
          , _ = H.T
          , E = q.p;
        try {
            q.p = 32 > m ? 32 : m,
            H.T = null,
            m = hd,
            hd = null;
            var D = Wr
              , X = ns;
            if (dr = 0,
            vi = Wr = null,
            ns = 0,
            (si & 6) !== 0)
                throw Error(n(331));
            var ee = si;
            if (si |= 4,
            j0(D.current),
            lm(D, D.current, X, m),
            si = ee,
            Y0(0, !1),
            we && typeof we.onPostCommitFiberRoot == "function")
                try {
                    we.onPostCommitFiberRoot(Be, D)
                } catch {}
            return !0
        } finally {
            q.p = E,
            H.T = _,
            rs(o, c)
        }
    }
    function qe(o, c, m) {
        c = Or(m, c),
        c = nm(o.stateNode, c, 2),
        o = Rl(o, c, 2),
        o !== null && (Ct(o, 2),
        Pu(o))
    }
    function Ae(o, c, m) {
        if (o.tag === 3)
            qe(o, o, m);
        else
            for (; c !== null; ) {
                if (c.tag === 3) {
                    qe(c, o, m);
                    break
                } else if (c.tag === 1) {
                    var _ = c.stateNode;
                    if (typeof c.type.getDerivedStateFromError == "function" || typeof _.componentDidCatch == "function" && (ts === null || !ts.has(_))) {
                        o = Or(m, o),
                        m = w1(2),
                        _ = Rl(c, m, 2),
                        _ !== null && (im(m, _, c, o),
                        Ct(_, 2),
                        Pu(_));
                        break
                    }
                }
                c = c.return
            }
    }
    function et(o, c, m) {
        var _ = o.pingCache;
        if (_ === null) {
            _ = o.pingCache = new W0;
            var E = new Set;
            _.set(c, E)
        } else
            E = _.get(c),
            E === void 0 && (E = new Set,
            _.set(c, E));
        E.has(m) || (Pf = !0,
        E.add(m),
        o = Rt.bind(null, o, c, m),
        c.then(o, o))
    }
    function Rt(o, c, m) {
        var _ = o.pingCache;
        _ !== null && _.delete(c),
        o.pingedLanes |= o.suspendedLanes & m,
        o.warmLanes &= ~m,
        Mn === o && (an & m) === m && (Ai === 4 || Ai === 3 && (an & 62914560) === an && 300 > le() - hi ? (si & 2) === 0 && Ou(o, 0) : Uc |= m,
        Zn === an && (Zn = 0)),
        Pu(o)
    }
    function tn(o, c) {
        c === 0 && (c = Ee()),
        o = Tl(o, c),
        o !== null && (Ct(o, c),
        Pu(o))
    }
    function Ci(o) {
        var c = o.memoizedState
          , m = 0;
        c !== null && (m = c.retryLane),
        tn(o, m)
    }
    function mn(o, c) {
        var m = 0;
        switch (o.tag) {
        case 13:
            var _ = o.stateNode
              , E = o.memoizedState;
            E !== null && (m = E.retryLane);
            break;
        case 19:
            _ = o.stateNode;
            break;
        case 22:
            _ = o.stateNode._retryCache;
            break;
        default:
            throw Error(n(314))
        }
        _ !== null && _.delete(c),
        tn(o, m)
    }
    function ei(o, c) {
        return re(o, c)
    }
    var Ki = null
      , Fn = null
      , Wo = !1
      , hm = !1
      , $M = !1
      , pd = 0;
    function Pu(o) {
        o !== Fn && o.next === null && (Fn === null ? Ki = Fn = o : Fn = Fn.next = o),
        hm = !0,
        Wo || (Wo = !0,
        i5())
    }
    function Y0(o, c) {
        if (!$M && hm) {
            $M = !0;
            do
                for (var m = !1, _ = Ki; _ !== null; ) {
                    if (o !== 0) {
                        var E = _.pendingLanes;
                        if (E === 0)
                            var D = 0;
                        else {
                            var X = _.suspendedLanes
                              , ee = _.pingedLanes;
                            D = (1 << 31 - it(42 | o) + 1) - 1,
                            D &= E & ~(X & ~ee),
                            D = D & 201326741 ? D & 201326741 | 1 : D ? D | 2 : 0
                        }
                        D !== 0 && (m = !0,
                        hR(_, D))
                    } else
                        D = an,
                        D = _t(_, _ === Mn ? D : 0, _.cancelPendingCommit !== null || _.timeoutHandle !== -1),
                        (D & 3) === 0 || ut(_, D) || (m = !0,
                        hR(_, D));
                    _ = _.next
                }
            while (m);
            $M = !1
        }
    }
    function n5() {
        uR()
    }
    function uR() {
        hm = Wo = !1;
        var o = 0;
        pd !== 0 && (f5() && (o = pd),
        pd = 0);
        for (var c = le(), m = null, _ = Ki; _ !== null; ) {
            var E = _.next
              , D = cR(_, c);
            D === 0 ? (_.next = null,
            m === null ? Ki = E : m.next = E,
            E === null && (Fn = m)) : (m = _,
            (o !== 0 || (D & 3) !== 0) && (hm = !0)),
            _ = E
        }
        Y0(o)
    }
    function cR(o, c) {
        for (var m = o.suspendedLanes, _ = o.pingedLanes, E = o.expirationTimes, D = o.pendingLanes & -62914561; 0 < D; ) {
            var X = 31 - it(D)
              , ee = 1 << X
              , be = E[X];
            be === -1 ? ((ee & m) === 0 || (ee & _) !== 0) && (E[X] = Ut(ee, c)) : be <= c && (o.expiredLanes |= ee),
            D &= ~ee
        }
        if (c = Mn,
        m = an,
        m = _t(o, o === c ? m : 0, o.cancelPendingCommit !== null || o.timeoutHandle !== -1),
        _ = o.callbackNode,
        m === 0 || o === c && (Rn === 2 || Rn === 9) || o.cancelPendingCommit !== null)
            return _ !== null && _ !== null && Le(_),
            o.callbackNode = null,
            o.callbackPriority = 0;
        if ((m & 3) === 0 || ut(o, m)) {
            if (c = m & -m,
            c === o.callbackPriority)
                return c;
            switch (_ !== null && Le(_),
            Nt(m)) {
            case 2:
            case 8:
                m = Ve;
                break;
            case 32:
                m = De;
                break;
            case 268435456:
                m = J;
                break;
            default:
                m = De
            }
            return _ = fR.bind(null, o),
            m = re(m, _),
            o.callbackPriority = c,
            o.callbackNode = m,
            c
        }
        return _ !== null && _ !== null && Le(_),
        o.callbackPriority = 2,
        o.callbackNode = null,
        2
    }
    function fR(o, c) {
        if (dr !== 0 && dr !== 5)
            return o.callbackNode = null,
            o.callbackPriority = 0,
            null;
        var m = o.callbackNode;
        if (Nu() && o.callbackNode !== m)
            return null;
        var _ = an;
        return _ = _t(o, o === Mn ? _ : 0, o.cancelPendingCommit !== null || o.timeoutHandle !== -1),
        _ === 0 ? null : (Bf(o, _, c),
        cR(o, le()),
        o.callbackNode != null && o.callbackNode === m ? fR.bind(null, o) : null)
    }
    function hR(o, c) {
        if (Nu())
            return null;
        Bf(o, c, !0)
    }
    function i5() {
        d5(function() {
            (si & 6) !== 0 ? re(He, n5) : uR()
        })
    }
    function e2() {
        return pd === 0 && (pd = me()),
        pd
    }
    function dR(o) {
        return o == null || typeof o == "symbol" || typeof o == "boolean" ? null : typeof o == "function" ? o : Ro("" + o)
    }
    function pR(o, c) {
        var m = c.ownerDocument.createElement("input");
        return m.name = c.name,
        m.value = c.value,
        o.id && m.setAttribute("form", o.id),
        c.parentNode.insertBefore(m, c),
        o = new FormData(o),
        m.parentNode.removeChild(m),
        o
    }
    function r5(o, c, m, _, E) {
        if (c === "submit" && m && m.stateNode === E) {
            var D = dR((E[Lt] || null).action)
              , X = _.submitter;
            X && (c = (c = X[Lt] || null) ? dR(c.formAction) : X.getAttribute("formAction"),
            c !== null && (D = c,
            X = null));
            var ee = new ra("action","action",null,_,E);
            o.push({
                event: ee,
                listeners: [{
                    instance: null,
                    listener: function() {
                        if (_.defaultPrevented) {
                            if (pd !== 0) {
                                var be = X ? pR(E, X) : new FormData(E);
                                H0(m, {
                                    pending: !0,
                                    data: be,
                                    method: E.method,
                                    action: D
                                }, null, be)
                            }
                        } else
                            typeof D == "function" && (ee.preventDefault(),
                            be = X ? pR(E, X) : new FormData(E),
                            H0(m, {
                                pending: !0,
                                data: be,
                                method: E.method,
                                action: D
                            }, D, be))
                    },
                    currentTarget: E
                }]
            })
        }
    }
    for (var t2 = 0; t2 < Vh.length; t2++) {
        var n2 = Vh[t2]
          , a5 = n2.toLowerCase()
          , s5 = n2[0].toUpperCase() + n2.slice(1);
        _r(a5, "on" + s5)
    }
    _r(aa, "onAnimationEnd"),
    _r(f0, "onAnimationIteration"),
    _r(Ta, "onAnimationStart"),
    _r("dblclick", "onDoubleClick"),
    _r("focusin", "onFocus"),
    _r("focusout", "onBlur"),
    _r(I_, "onTransitionRun"),
    _r(bl, "onTransitionStart"),
    _r(cf, "onTransitionCancel"),
    _r(Ml, "onTransitionEnd"),
    ce("onMouseEnter", ["mouseout", "mouseover"]),
    ce("onMouseLeave", ["mouseout", "mouseover"]),
    ce("onPointerEnter", ["pointerout", "pointerover"]),
    ce("onPointerLeave", ["pointerout", "pointerover"]),
    G("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
    G("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
    G("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    G("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
    G("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
    G("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var q0 = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
      , o5 = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(q0));
    function mR(o, c) {
        c = (c & 4) !== 0;
        for (var m = 0; m < o.length; m++) {
            var _ = o[m]
              , E = _.event;
            _ = _.listeners;
            e: {
                var D = void 0;
                if (c)
                    for (var X = _.length - 1; 0 <= X; X--) {
                        var ee = _[X]
                          , be = ee.instance
                          , Xe = ee.currentTarget;
                        if (ee = ee.listener,
                        be !== D && E.isPropagationStopped())
                            break e;
                        D = ee,
                        E.currentTarget = Xe;
                        try {
                            D(E)
                        } catch (dt) {
                            _c(dt)
                        }
                        E.currentTarget = null,
                        D = be
                    }
                else
                    for (X = 0; X < _.length; X++) {
                        if (ee = _[X],
                        be = ee.instance,
                        Xe = ee.currentTarget,
                        ee = ee.listener,
                        be !== D && E.isPropagationStopped())
                            break e;
                        D = ee,
                        E.currentTarget = Xe;
                        try {
                            D(E)
                        } catch (dt) {
                            _c(dt)
                        }
                        E.currentTarget = null,
                        D = be
                    }
            }
        }
    }
    function Wn(o, c) {
        var m = c[Wt];
        m === void 0 && (m = c[Wt] = new Set);
        var _ = o + "__bubble";
        m.has(_) || (gR(c, o, 2, !1),
        m.add(_))
    }
    function i2(o, c, m) {
        var _ = 0;
        c && (_ |= 4),
        gR(m, o, _, c)
    }
    var D1 = "_reactListening" + Math.random().toString(36).slice(2);
    function r2(o) {
        if (!o[D1]) {
            o[D1] = !0,
            Ke.forEach(function(m) {
                m !== "selectionchange" && (o5.has(m) || i2(m, !1, o),
                i2(m, !0, o))
            });
            var c = o.nodeType === 9 ? o : o.ownerDocument;
            c === null || c[D1] || (c[D1] = !0,
            i2("selectionchange", !1, c))
        }
    }
    function gR(o, c, m, _) {
        switch (HR(c)) {
        case 2:
            var E = L5;
            break;
        case 8:
            E = P5;
            break;
        default:
            E = y2
        }
        m = E.bind(null, c, m, o),
        E = void 0,
        !hl || c !== "touchstart" && c !== "touchmove" && c !== "wheel" || (E = !0),
        _ ? E !== void 0 ? o.addEventListener(c, m, {
            capture: !0,
            passive: E
        }) : o.addEventListener(c, m, !0) : E !== void 0 ? o.addEventListener(c, m, {
            passive: E
        }) : o.addEventListener(c, m, !1)
    }
    function a2(o, c, m, _, E) {
        var D = _;
        if ((c & 1) === 0 && (c & 2) === 0 && _ !== null)
            e: for (; ; ) {
                if (_ === null)
                    return;
                var X = _.tag;
                if (X === 3 || X === 4) {
                    var ee = _.stateNode.containerInfo;
                    if (ee === E)
                        break;
                    if (X === 4)
                        for (X = _.return; X !== null; ) {
                            var be = X.tag;
                            if ((be === 3 || be === 4) && X.stateNode.containerInfo === E)
                                return;
                            X = X.return
                        }
                    for (; ee !== null; ) {
                        if (X = k(ee),
                        X === null)
                            return;
                        if (be = X.tag,
                        be === 5 || be === 6 || be === 26 || be === 27) {
                            _ = D = X;
                            continue e
                        }
                        ee = ee.parentNode
                    }
                }
                _ = _.return
            }
        uc(function() {
            var Xe = D
              , dt = Js(m)
              , St = [];
            e: {
                var Qe = Dp.get(o);
                if (Qe !== void 0) {
                    var Je = ra
                      , yn = o;
                    switch (o) {
                    case "keypress":
                        if (bs(m) === 0)
                            break e;
                    case "keydown":
                    case "keyup":
                        Je = $g;
                        break;
                    case "focusin":
                        yn = "focus",
                        Je = vl;
                        break;
                    case "focusout":
                        yn = "blur",
                        Je = vl;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        Je = vl;
                        break;
                    case "click":
                        if (m.button === 2)
                            break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        Je = hc;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        Je = Qg;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        Je = t0;
                        break;
                    case aa:
                    case f0:
                    case Ta:
                        Je = Sp;
                        break;
                    case Ml:
                        Je = yl;
                        break;
                    case "scroll":
                    case "scrollend":
                        Je = sf;
                        break;
                    case "wheel":
                        Je = kM;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        Je = xa;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        Je = bp;
                        break;
                    case "toggle":
                    case "beforetoggle":
                        Je = au
                    }
                    var cn = (c & 4) !== 0
                      , Ei = !cn && (o === "scroll" || o === "scrollend")
                      , ze = cn ? Qe !== null ? Qe + "Capture" : null : Qe;
                    cn = [];
                    for (var Re = Xe, ke; Re !== null; ) {
                        var gt = Re;
                        if (ke = gt.stateNode,
                        gt = gt.tag,
                        gt !== 5 && gt !== 26 && gt !== 27 || ke === null || ze === null || (gt = fl(Re, ze),
                        gt != null && cn.push(Z0(Re, gt, ke))),
                        Ei)
                            break;
                        Re = Re.return
                    }
                    0 < cn.length && (Qe = new Je(Qe,yn,null,m,dt),
                    St.push({
                        event: Qe,
                        listeners: cn
                    }))
                }
            }
            if ((c & 7) === 0) {
                e: {
                    if (Qe = o === "mouseover" || o === "pointerover",
                    Je = o === "mouseout" || o === "pointerout",
                    Qe && m !== Qs && (yn = m.relatedTarget || m.fromElement) && (k(yn) || yn[zt]))
                        break e;
                    if ((Je || Qe) && (Qe = dt.window === dt ? dt : (Qe = dt.ownerDocument) ? Qe.defaultView || Qe.parentWindow : window,
                    Je ? (yn = m.relatedTarget || m.toElement,
                    Je = Xe,
                    yn = yn ? k(yn) : null,
                    yn !== null && (Ei = a(yn),
                    cn = yn.tag,
                    yn !== Ei || cn !== 5 && cn !== 27 && cn !== 6) && (yn = null)) : (Je = null,
                    yn = Xe),
                    Je !== yn)) {
                        if (cn = hc,
                        gt = "onMouseLeave",
                        ze = "onMouseEnter",
                        Re = "mouse",
                        (o === "pointerout" || o === "pointerover") && (cn = bp,
                        gt = "onPointerLeave",
                        ze = "onPointerEnter",
                        Re = "pointer"),
                        Ei = Je == null ? Qe : Se(Je),
                        ke = yn == null ? Qe : Se(yn),
                        Qe = new cn(gt,Re + "leave",Je,m,dt),
                        Qe.target = Ei,
                        Qe.relatedTarget = ke,
                        gt = null,
                        k(dt) === Xe && (cn = new cn(ze,Re + "enter",yn,m,dt),
                        cn.target = ke,
                        cn.relatedTarget = Ei,
                        gt = cn),
                        Ei = gt,
                        Je && yn)
                            t: {
                                for (cn = Je,
                                ze = yn,
                                Re = 0,
                                ke = cn; ke; ke = dm(ke))
                                    Re++;
                                for (ke = 0,
                                gt = ze; gt; gt = dm(gt))
                                    ke++;
                                for (; 0 < Re - ke; )
                                    cn = dm(cn),
                                    Re--;
                                for (; 0 < ke - Re; )
                                    ze = dm(ze),
                                    ke--;
                                for (; Re--; ) {
                                    if (cn === ze || ze !== null && cn === ze.alternate)
                                        break t;
                                    cn = dm(cn),
                                    ze = dm(ze)
                                }
                                cn = null
                            }
                        else
                            cn = null;
                        Je !== null && vR(St, Qe, Je, cn, !1),
                        yn !== null && Ei !== null && vR(St, Ei, yn, cn, !0)
                    }
                }
                e: {
                    if (Qe = Xe ? Se(Xe) : window,
                    Je = Qe.nodeName && Qe.nodeName.toLowerCase(),
                    Je === "select" || Je === "input" && Qe.type === "file")
                        var Kt = Tp;
                    else if (a0(Qe))
                        if (Ep)
                            Kt = lu;
                        else {
                            Kt = P_;
                            var kn = GM
                        }
                    else
                        Je = Qe.nodeName,
                        !Je || Je.toLowerCase() !== "input" || Qe.type !== "checkbox" && Qe.type !== "radio" ? Xe && iu(Xe.elementType) && (Kt = Tp) : Kt = Ih;
                    if (Kt && (Kt = Kt(o, Xe))) {
                        Sa(St, Kt, m, dt);
                        break e
                    }
                    kn && kn(o, Qe, Xe),
                    o === "focusout" && Xe && Qe.type === "number" && Xe.memoizedProps.value != null && ri(Qe, "number", Qe.value)
                }
                switch (kn = Xe ? Se(Xe) : window,
                o) {
                case "focusin":
                    (a0(kn) || kn.contentEditable === "true") && (xl = kn,
                    Ap = Xe,
                    Hh = null);
                    break;
                case "focusout":
                    Hh = Ap = xl = null;
                    break;
                case "mousedown":
                    Cp = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    Cp = !1,
                    c0(St, m, dt);
                    break;
                case "selectionchange":
                    if (u0)
                        break;
                case "keydown":
                case "keyup":
                    c0(St, m, dt)
                }
                var nn;
                if (Oh)
                    e: {
                        switch (o) {
                        case "compositionstart":
                            var dn = "onCompositionStart";
                            break e;
                        case "compositionend":
                            dn = "onCompositionEnd";
                            break e;
                        case "compositionupdate":
                            dn = "onCompositionUpdate";
                            break e
                        }
                        dn = void 0
                    }
                else
                    ou ? Ph(o, m) && (dn = "onCompositionEnd") : o === "keydown" && m.keyCode === 229 && (dn = "onCompositionStart");
                dn && (Lh && m.locale !== "ko" && (ou || dn !== "onCompositionStart" ? dn === "onCompositionEnd" && ou && (nn = af()) : (Xi = dt,
                cc = "value"in Xi ? Xi.value : Xi.textContent,
                ou = !0)),
                kn = U1(Xe, dn),
                0 < kn.length && (dn = new Ga(dn,o,null,m,dt),
                St.push({
                    event: dn,
                    listeners: kn
                }),
                nn ? dn.data = nn : (nn = i0(m),
                nn !== null && (dn.data = nn)))),
                (nn = Nh ? Bh(o, m) : r0(o, m)) && (dn = U1(Xe, "onBeforeInput"),
                0 < dn.length && (kn = new Ga("onBeforeInput","beforeinput",null,m,dt),
                St.push({
                    event: kn,
                    listeners: dn
                }),
                kn.data = nn)),
                r5(St, o, Xe, m, dt)
            }
            mR(St, c)
        })
    }
    function Z0(o, c, m) {
        return {
            instance: o,
            listener: c,
            currentTarget: m
        }
    }
    function U1(o, c) {
        for (var m = c + "Capture", _ = []; o !== null; ) {
            var E = o
              , D = E.stateNode;
            if (E = E.tag,
            E !== 5 && E !== 26 && E !== 27 || D === null || (E = fl(o, m),
            E != null && _.unshift(Z0(o, E, D)),
            E = fl(o, c),
            E != null && _.push(Z0(o, E, D))),
            o.tag === 3)
                return _;
            o = o.return
        }
        return []
    }
    function dm(o) {
        if (o === null)
            return null;
        do
            o = o.return;
        while (o && o.tag !== 5 && o.tag !== 27);
        return o || null
    }
    function vR(o, c, m, _, E) {
        for (var D = c._reactName, X = []; m !== null && m !== _; ) {
            var ee = m
              , be = ee.alternate
              , Xe = ee.stateNode;
            if (ee = ee.tag,
            be !== null && be === _)
                break;
            ee !== 5 && ee !== 26 && ee !== 27 || Xe === null || (be = Xe,
            E ? (Xe = fl(m, D),
            Xe != null && X.unshift(Z0(m, Xe, be))) : E || (Xe = fl(m, D),
            Xe != null && X.push(Z0(m, Xe, be)))),
            m = m.return
        }
        X.length !== 0 && o.push({
            event: c,
            listeners: X
        })
    }
    var l5 = /\r\n?/g
      , u5 = /\u0000|\uFFFD/g;
    function yR(o) {
        return (typeof o == "string" ? o : "" + o).replace(l5, `
`).replace(u5, "")
    }
    function _R(o, c) {
        return c = yR(c),
        yR(o) === c
    }
    function O1() {}
    function Ti(o, c, m, _, E, D) {
        switch (m) {
        case "children":
            typeof _ == "string" ? c === "body" || c === "textarea" && _ === "" || Di(o, _) : (typeof _ == "number" || typeof _ == "bigint") && c !== "body" && Di(o, "" + _);
            break;
        case "className":
            st(o, "class", _);
            break;
        case "tabIndex":
            st(o, "tabindex", _);
            break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
            st(o, m, _);
            break;
        case "style":
            nu(o, _, D);
            break;
        case "data":
            if (c !== "object") {
                st(o, "data", _);
                break
            }
        case "src":
        case "href":
            if (_ === "" && (c !== "a" || m !== "href")) {
                o.removeAttribute(m);
                break
            }
            if (_ == null || typeof _ == "function" || typeof _ == "symbol" || typeof _ == "boolean") {
                o.removeAttribute(m);
                break
            }
            _ = Ro("" + _),
            o.setAttribute(m, _);
            break;
        case "action":
        case "formAction":
            if (typeof _ == "function") {
                o.setAttribute(m, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                break
            } else
                typeof D == "function" && (m === "formAction" ? (c !== "input" && Ti(o, c, "name", E.name, E, null),
                Ti(o, c, "formEncType", E.formEncType, E, null),
                Ti(o, c, "formMethod", E.formMethod, E, null),
                Ti(o, c, "formTarget", E.formTarget, E, null)) : (Ti(o, c, "encType", E.encType, E, null),
                Ti(o, c, "method", E.method, E, null),
                Ti(o, c, "target", E.target, E, null)));
            if (_ == null || typeof _ == "symbol" || typeof _ == "boolean") {
                o.removeAttribute(m);
                break
            }
            _ = Ro("" + _),
            o.setAttribute(m, _);
            break;
        case "onClick":
            _ != null && (o.onclick = O1);
            break;
        case "onScroll":
            _ != null && Wn("scroll", o);
            break;
        case "onScrollEnd":
            _ != null && Wn("scrollend", o);
            break;
        case "dangerouslySetInnerHTML":
            if (_ != null) {
                if (typeof _ != "object" || !("__html"in _))
                    throw Error(n(61));
                if (m = _.__html,
                m != null) {
                    if (E.children != null)
                        throw Error(n(60));
                    o.innerHTML = m
                }
            }
            break;
        case "multiple":
            o.multiple = _ && typeof _ != "function" && typeof _ != "symbol";
            break;
        case "muted":
            o.muted = _ && typeof _ != "function" && typeof _ != "symbol";
            break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
            break;
        case "autoFocus":
            break;
        case "xlinkHref":
            if (_ == null || typeof _ == "function" || typeof _ == "boolean" || typeof _ == "symbol") {
                o.removeAttribute("xlink:href");
                break
            }
            m = Ro("" + _),
            o.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", m);
            break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
            _ != null && typeof _ != "function" && typeof _ != "symbol" ? o.setAttribute(m, "" + _) : o.removeAttribute(m);
            break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
            _ && typeof _ != "function" && typeof _ != "symbol" ? o.setAttribute(m, "") : o.removeAttribute(m);
            break;
        case "capture":
        case "download":
            _ === !0 ? o.setAttribute(m, "") : _ !== !1 && _ != null && typeof _ != "function" && typeof _ != "symbol" ? o.setAttribute(m, _) : o.removeAttribute(m);
            break;
        case "cols":
        case "rows":
        case "size":
        case "span":
            _ != null && typeof _ != "function" && typeof _ != "symbol" && !isNaN(_) && 1 <= _ ? o.setAttribute(m, _) : o.removeAttribute(m);
            break;
        case "rowSpan":
        case "start":
            _ == null || typeof _ == "function" || typeof _ == "symbol" || isNaN(_) ? o.removeAttribute(m) : o.setAttribute(m, _);
            break;
        case "popover":
            Wn("beforetoggle", o),
            Wn("toggle", o),
            We(o, "popover", _);
            break;
        case "xlinkActuate":
            ft(o, "http://www.w3.org/1999/xlink", "xlink:actuate", _);
            break;
        case "xlinkArcrole":
            ft(o, "http://www.w3.org/1999/xlink", "xlink:arcrole", _);
            break;
        case "xlinkRole":
            ft(o, "http://www.w3.org/1999/xlink", "xlink:role", _);
            break;
        case "xlinkShow":
            ft(o, "http://www.w3.org/1999/xlink", "xlink:show", _);
            break;
        case "xlinkTitle":
            ft(o, "http://www.w3.org/1999/xlink", "xlink:title", _);
            break;
        case "xlinkType":
            ft(o, "http://www.w3.org/1999/xlink", "xlink:type", _);
            break;
        case "xmlBase":
            ft(o, "http://www.w3.org/XML/1998/namespace", "xml:base", _);
            break;
        case "xmlLang":
            ft(o, "http://www.w3.org/XML/1998/namespace", "xml:lang", _);
            break;
        case "xmlSpace":
            ft(o, "http://www.w3.org/XML/1998/namespace", "xml:space", _);
            break;
        case "is":
            We(o, "is", _);
            break;
        case "innerText":
        case "textContent":
            break;
        default:
            (!(2 < m.length) || m[0] !== "o" && m[0] !== "O" || m[1] !== "n" && m[1] !== "N") && (m = ll.get(m) || m,
            We(o, m, _))
        }
    }
    function s2(o, c, m, _, E, D) {
        switch (m) {
        case "style":
            nu(o, _, D);
            break;
        case "dangerouslySetInnerHTML":
            if (_ != null) {
                if (typeof _ != "object" || !("__html"in _))
                    throw Error(n(61));
                if (m = _.__html,
                m != null) {
                    if (E.children != null)
                        throw Error(n(60));
                    o.innerHTML = m
                }
            }
            break;
        case "children":
            typeof _ == "string" ? Di(o, _) : (typeof _ == "number" || typeof _ == "bigint") && Di(o, "" + _);
            break;
        case "onScroll":
            _ != null && Wn("scroll", o);
            break;
        case "onScrollEnd":
            _ != null && Wn("scrollend", o);
            break;
        case "onClick":
            _ != null && (o.onclick = O1);
            break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
            break;
        case "innerText":
        case "textContent":
            break;
        default:
            if (!yt.hasOwnProperty(m))
                e: {
                    if (m[0] === "o" && m[1] === "n" && (E = m.endsWith("Capture"),
                    c = m.slice(2, E ? m.length - 7 : void 0),
                    D = o[Lt] || null,
                    D = D != null ? D[m] : null,
                    typeof D == "function" && o.removeEventListener(c, D, E),
                    typeof _ == "function")) {
                        typeof D != "function" && D !== null && (m in o ? o[m] = null : o.hasAttribute(m) && o.removeAttribute(m)),
                        o.addEventListener(c, _, E);
                        break e
                    }
                    m in o ? o[m] = _ : _ === !0 ? o.setAttribute(m, "") : We(o, m, _)
                }
        }
    }
    function ha(o, c, m) {
        switch (c) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
            break;
        case "img":
            Wn("error", o),
            Wn("load", o);
            var _ = !1, E = !1, D;
            for (D in m)
                if (m.hasOwnProperty(D)) {
                    var X = m[D];
                    if (X != null)
                        switch (D) {
                        case "src":
                            _ = !0;
                            break;
                        case "srcSet":
                            E = !0;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            throw Error(n(137, c));
                        default:
                            Ti(o, c, D, X, m, null)
                        }
                }
            E && Ti(o, c, "srcSet", m.srcSet, m, null),
            _ && Ti(o, c, "src", m.src, m, null);
            return;
        case "input":
            Wn("invalid", o);
            var ee = D = X = E = null
              , be = null
              , Xe = null;
            for (_ in m)
                if (m.hasOwnProperty(_)) {
                    var dt = m[_];
                    if (dt != null)
                        switch (_) {
                        case "name":
                            E = dt;
                            break;
                        case "type":
                            X = dt;
                            break;
                        case "checked":
                            be = dt;
                            break;
                        case "defaultChecked":
                            Xe = dt;
                            break;
                        case "value":
                            D = dt;
                            break;
                        case "defaultValue":
                            ee = dt;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            if (dt != null)
                                throw Error(n(137, c));
                            break;
                        default:
                            Ti(o, c, _, dt, m, null)
                        }
                }
            ti(o, D, ee, be, Xe, X, E, !1),
            fn(o);
            return;
        case "select":
            Wn("invalid", o),
            _ = X = D = null;
            for (E in m)
                if (m.hasOwnProperty(E) && (ee = m[E],
                ee != null))
                    switch (E) {
                    case "value":
                        D = ee;
                        break;
                    case "defaultValue":
                        X = ee;
                        break;
                    case "multiple":
                        _ = ee;
                    default:
                        Ti(o, c, E, ee, m, null)
                    }
            c = D,
            m = X,
            o.multiple = !!_,
            c != null ? bn(o, !!_, c, !1) : m != null && bn(o, !!_, m, !0);
            return;
        case "textarea":
            Wn("invalid", o),
            D = E = _ = null;
            for (X in m)
                if (m.hasOwnProperty(X) && (ee = m[X],
                ee != null))
                    switch (X) {
                    case "value":
                        _ = ee;
                        break;
                    case "defaultValue":
                        E = ee;
                        break;
                    case "children":
                        D = ee;
                        break;
                    case "dangerouslySetInnerHTML":
                        if (ee != null)
                            throw Error(n(91));
                        break;
                    default:
                        Ti(o, c, X, ee, m, null)
                    }
            Ss(o, _, E, D),
            fn(o);
            return;
        case "option":
            for (be in m)
                if (m.hasOwnProperty(be) && (_ = m[be],
                _ != null))
                    switch (be) {
                    case "selected":
                        o.selected = _ && typeof _ != "function" && typeof _ != "symbol";
                        break;
                    default:
                        Ti(o, c, be, _, m, null)
                    }
            return;
        case "dialog":
            Wn("beforetoggle", o),
            Wn("toggle", o),
            Wn("cancel", o),
            Wn("close", o);
            break;
        case "iframe":
        case "object":
            Wn("load", o);
            break;
        case "video":
        case "audio":
            for (_ = 0; _ < q0.length; _++)
                Wn(q0[_], o);
            break;
        case "image":
            Wn("error", o),
            Wn("load", o);
            break;
        case "details":
            Wn("toggle", o);
            break;
        case "embed":
        case "source":
        case "link":
            Wn("error", o),
            Wn("load", o);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
            for (Xe in m)
                if (m.hasOwnProperty(Xe) && (_ = m[Xe],
                _ != null))
                    switch (Xe) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                        throw Error(n(137, c));
                    default:
                        Ti(o, c, Xe, _, m, null)
                    }
            return;
        default:
            if (iu(c)) {
                for (dt in m)
                    m.hasOwnProperty(dt) && (_ = m[dt],
                    _ !== void 0 && s2(o, c, dt, _, m, void 0));
                return
            }
        }
        for (ee in m)
            m.hasOwnProperty(ee) && (_ = m[ee],
            _ != null && Ti(o, c, ee, _, m, null))
    }
    function c5(o, c, m, _) {
        switch (c) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
            break;
        case "input":
            var E = null
              , D = null
              , X = null
              , ee = null
              , be = null
              , Xe = null
              , dt = null;
            for (Je in m) {
                var St = m[Je];
                if (m.hasOwnProperty(Je) && St != null)
                    switch (Je) {
                    case "checked":
                        break;
                    case "value":
                        break;
                    case "defaultValue":
                        be = St;
                    default:
                        _.hasOwnProperty(Je) || Ti(o, c, Je, null, _, St)
                    }
            }
            for (var Qe in _) {
                var Je = _[Qe];
                if (St = m[Qe],
                _.hasOwnProperty(Qe) && (Je != null || St != null))
                    switch (Qe) {
                    case "type":
                        D = Je;
                        break;
                    case "name":
                        E = Je;
                        break;
                    case "checked":
                        Xe = Je;
                        break;
                    case "defaultChecked":
                        dt = Je;
                        break;
                    case "value":
                        X = Je;
                        break;
                    case "defaultValue":
                        ee = Je;
                        break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if (Je != null)
                            throw Error(n(137, c));
                        break;
                    default:
                        Je !== St && Ti(o, c, Qe, Je, _, St)
                    }
            }
            Yt(o, X, ee, be, Xe, dt, D, E);
            return;
        case "select":
            Je = X = ee = Qe = null;
            for (D in m)
                if (be = m[D],
                m.hasOwnProperty(D) && be != null)
                    switch (D) {
                    case "value":
                        break;
                    case "multiple":
                        Je = be;
                    default:
                        _.hasOwnProperty(D) || Ti(o, c, D, null, _, be)
                    }
            for (E in _)
                if (D = _[E],
                be = m[E],
                _.hasOwnProperty(E) && (D != null || be != null))
                    switch (E) {
                    case "value":
                        Qe = D;
                        break;
                    case "defaultValue":
                        ee = D;
                        break;
                    case "multiple":
                        X = D;
                    default:
                        D !== be && Ti(o, c, E, D, _, be)
                    }
            c = ee,
            m = X,
            _ = Je,
            Qe != null ? bn(o, !!m, Qe, !1) : !!_ != !!m && (c != null ? bn(o, !!m, c, !0) : bn(o, !!m, m ? [] : "", !1));
            return;
        case "textarea":
            Je = Qe = null;
            for (ee in m)
                if (E = m[ee],
                m.hasOwnProperty(ee) && E != null && !_.hasOwnProperty(ee))
                    switch (ee) {
                    case "value":
                        break;
                    case "children":
                        break;
                    default:
                        Ti(o, c, ee, null, _, E)
                    }
            for (X in _)
                if (E = _[X],
                D = m[X],
                _.hasOwnProperty(X) && (E != null || D != null))
                    switch (X) {
                    case "value":
                        Qe = E;
                        break;
                    case "defaultValue":
                        Je = E;
                        break;
                    case "children":
                        break;
                    case "dangerouslySetInnerHTML":
                        if (E != null)
                            throw Error(n(91));
                        break;
                    default:
                        E !== D && Ti(o, c, X, E, _, D)
                    }
            ui(o, Qe, Je);
            return;
        case "option":
            for (var yn in m)
                if (Qe = m[yn],
                m.hasOwnProperty(yn) && Qe != null && !_.hasOwnProperty(yn))
                    switch (yn) {
                    case "selected":
                        o.selected = !1;
                        break;
                    default:
                        Ti(o, c, yn, null, _, Qe)
                    }
            for (be in _)
                if (Qe = _[be],
                Je = m[be],
                _.hasOwnProperty(be) && Qe !== Je && (Qe != null || Je != null))
                    switch (be) {
                    case "selected":
                        o.selected = Qe && typeof Qe != "function" && typeof Qe != "symbol";
                        break;
                    default:
                        Ti(o, c, be, Qe, _, Je)
                    }
            return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
            for (var cn in m)
                Qe = m[cn],
                m.hasOwnProperty(cn) && Qe != null && !_.hasOwnProperty(cn) && Ti(o, c, cn, null, _, Qe);
            for (Xe in _)
                if (Qe = _[Xe],
                Je = m[Xe],
                _.hasOwnProperty(Xe) && Qe !== Je && (Qe != null || Je != null))
                    switch (Xe) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if (Qe != null)
                            throw Error(n(137, c));
                        break;
                    default:
                        Ti(o, c, Xe, Qe, _, Je)
                    }
            return;
        default:
            if (iu(c)) {
                for (var Ei in m)
                    Qe = m[Ei],
                    m.hasOwnProperty(Ei) && Qe !== void 0 && !_.hasOwnProperty(Ei) && s2(o, c, Ei, void 0, _, Qe);
                for (dt in _)
                    Qe = _[dt],
                    Je = m[dt],
                    !_.hasOwnProperty(dt) || Qe === Je || Qe === void 0 && Je === void 0 || s2(o, c, dt, Qe, _, Je);
                return
            }
        }
        for (var ze in m)
            Qe = m[ze],
            m.hasOwnProperty(ze) && Qe != null && !_.hasOwnProperty(ze) && Ti(o, c, ze, null, _, Qe);
        for (St in _)
            Qe = _[St],
            Je = m[St],
            !_.hasOwnProperty(St) || Qe === Je || Qe == null && Je == null || Ti(o, c, St, Qe, _, Je)
    }
    var o2 = null
      , l2 = null;
    function N1(o) {
        return o.nodeType === 9 ? o : o.ownerDocument
    }
    function xR(o) {
        switch (o) {
        case "http://www.w3.org/2000/svg":
            return 1;
        case "http://www.w3.org/1998/Math/MathML":
            return 2;
        default:
            return 0
        }
    }
    function SR(o, c) {
        if (o === 0)
            switch (c) {
            case "svg":
                return 1;
            case "math":
                return 2;
            default:
                return 0
            }
        return o === 1 && c === "foreignObject" ? 0 : o
    }
    function u2(o, c) {
        return o === "textarea" || o === "noscript" || typeof c.children == "string" || typeof c.children == "number" || typeof c.children == "bigint" || typeof c.dangerouslySetInnerHTML == "object" && c.dangerouslySetInnerHTML !== null && c.dangerouslySetInnerHTML.__html != null
    }
    var c2 = null;
    function f5() {
        var o = window.event;
        return o && o.type === "popstate" ? o === c2 ? !1 : (c2 = o,
        !0) : (c2 = null,
        !1)
    }
    var bR = typeof setTimeout == "function" ? setTimeout : void 0
      , h5 = typeof clearTimeout == "function" ? clearTimeout : void 0
      , MR = typeof Promise == "function" ? Promise : void 0
      , d5 = typeof queueMicrotask == "function" ? queueMicrotask : typeof MR < "u" ? function(o) {
        return MR.resolve(null).then(o).catch(p5)
    }
    : bR;
    function p5(o) {
        setTimeout(function() {
            throw o
        })
    }
    function If(o) {
        return o === "head"
    }
    function TR(o, c) {
        var m = c
          , _ = 0
          , E = 0;
        do {
            var D = m.nextSibling;
            if (o.removeChild(m),
            D && D.nodeType === 8)
                if (m = D.data,
                m === "/$") {
                    if (0 < _ && 8 > _) {
                        m = _;
                        var X = o.ownerDocument;
                        if (m & 1 && K0(X.documentElement),
                        m & 2 && K0(X.body),
                        m & 4)
                            for (m = X.head,
                            K0(m),
                            X = m.firstChild; X; ) {
                                var ee = X.nextSibling
                                  , be = X.nodeName;
                                X[un] || be === "SCRIPT" || be === "STYLE" || be === "LINK" && X.rel.toLowerCase() === "stylesheet" || m.removeChild(X),
                                X = ee
                            }
                    }
                    if (E === 0) {
                        o.removeChild(D),
                        rv(c);
                        return
                    }
                    E--
                } else
                    m === "$" || m === "$?" || m === "$!" ? E++ : _ = m.charCodeAt(0) - 48;
            else
                _ = 0;
            m = D
        } while (m);
        rv(c)
    }
    function f2(o) {
        var c = o.firstChild;
        for (c && c.nodeType === 10 && (c = c.nextSibling); c; ) {
            var m = c;
            switch (c = c.nextSibling,
            m.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
                f2(m),
                $t(m);
                continue;
            case "SCRIPT":
            case "STYLE":
                continue;
            case "LINK":
                if (m.rel.toLowerCase() === "stylesheet")
                    continue
            }
            o.removeChild(m)
        }
    }
    function m5(o, c, m, _) {
        for (; o.nodeType === 1; ) {
            var E = m;
            if (o.nodeName.toLowerCase() !== c.toLowerCase()) {
                if (!_ && (o.nodeName !== "INPUT" || o.type !== "hidden"))
                    break
            } else if (_) {
                if (!o[un])
                    switch (c) {
                    case "meta":
                        if (!o.hasAttribute("itemprop"))
                            break;
                        return o;
                    case "link":
                        if (D = o.getAttribute("rel"),
                        D === "stylesheet" && o.hasAttribute("data-precedence"))
                            break;
                        if (D !== E.rel || o.getAttribute("href") !== (E.href == null || E.href === "" ? null : E.href) || o.getAttribute("crossorigin") !== (E.crossOrigin == null ? null : E.crossOrigin) || o.getAttribute("title") !== (E.title == null ? null : E.title))
                            break;
                        return o;
                    case "style":
                        if (o.hasAttribute("data-precedence"))
                            break;
                        return o;
                    case "script":
                        if (D = o.getAttribute("src"),
                        (D !== (E.src == null ? null : E.src) || o.getAttribute("type") !== (E.type == null ? null : E.type) || o.getAttribute("crossorigin") !== (E.crossOrigin == null ? null : E.crossOrigin)) && D && o.hasAttribute("async") && !o.hasAttribute("itemprop"))
                            break;
                        return o;
                    default:
                        return o
                    }
            } else if (c === "input" && o.type === "hidden") {
                var D = E.name == null ? null : "" + E.name;
                if (E.type === "hidden" && o.getAttribute("name") === D)
                    return o
            } else
                return o;
            if (o = Fl(o.nextSibling),
            o === null)
                break
        }
        return null
    }
    function g5(o, c, m) {
        if (c === "")
            return null;
        for (; o.nodeType !== 3; )
            if ((o.nodeType !== 1 || o.nodeName !== "INPUT" || o.type !== "hidden") && !m || (o = Fl(o.nextSibling),
            o === null))
                return null;
        return o
    }
    function h2(o) {
        return o.data === "$!" || o.data === "$?" && o.ownerDocument.readyState === "complete"
    }
    function v5(o, c) {
        var m = o.ownerDocument;
        if (o.data !== "$?" || m.readyState === "complete")
            c();
        else {
            var _ = function() {
                c(),
                m.removeEventListener("DOMContentLoaded", _)
            };
            m.addEventListener("DOMContentLoaded", _),
            o._reactRetry = _
        }
    }
    function Fl(o) {
        for (; o != null; o = o.nextSibling) {
            var c = o.nodeType;
            if (c === 1 || c === 3)
                break;
            if (c === 8) {
                if (c = o.data,
                c === "$" || c === "$!" || c === "$?" || c === "F!" || c === "F")
                    break;
                if (c === "/$")
                    return null
            }
        }
        return o
    }
    var d2 = null;
    function ER(o) {
        o = o.previousSibling;
        for (var c = 0; o; ) {
            if (o.nodeType === 8) {
                var m = o.data;
                if (m === "$" || m === "$!" || m === "$?") {
                    if (c === 0)
                        return o;
                    c--
                } else
                    m === "/$" && c++
            }
            o = o.previousSibling
        }
        return null
    }
    function wR(o, c, m) {
        switch (c = N1(m),
        o) {
        case "html":
            if (o = c.documentElement,
            !o)
                throw Error(n(452));
            return o;
        case "head":
            if (o = c.head,
            !o)
                throw Error(n(453));
            return o;
        case "body":
            if (o = c.body,
            !o)
                throw Error(n(454));
            return o;
        default:
            throw Error(n(451))
        }
    }
    function K0(o) {
        for (var c = o.attributes; c.length; )
            o.removeAttributeNode(c[0]);
        $t(o)
    }
    var Yo = new Map
      , AR = new Set;
    function L1(o) {
        return typeof o.getRootNode == "function" ? o.getRootNode() : o.nodeType === 9 ? o : o.ownerDocument
    }
    var Lc = q.d;
    q.d = {
        f: y5,
        r: _5,
        D: x5,
        C: S5,
        L: b5,
        m: M5,
        X: E5,
        S: T5,
        M: w5
    };
    function y5() {
        var o = Lc.f()
          , c = jo();
        return o || c
    }
    function _5(o) {
        var c = $(o);
        c !== null && c.tag === 5 && c.type === "form" ? d1(c) : Lc.r(o)
    }
    var pm = typeof document > "u" ? null : document;
    function CR(o, c, m) {
        var _ = pm;
        if (_ && typeof c == "string" && c) {
            var E = hn(c);
            E = 'link[rel="' + o + '"][href="' + E + '"]',
            typeof m == "string" && (E += '[crossorigin="' + m + '"]'),
            AR.has(E) || (AR.add(E),
            o = {
                rel: o,
                crossOrigin: m,
                href: c
            },
            _.querySelector(E) === null && (c = _.createElement("link"),
            ha(c, "link", o),
            Fe(c),
            _.head.appendChild(c)))
        }
    }
    function x5(o) {
        Lc.D(o),
        CR("dns-prefetch", o, null)
    }
    function S5(o, c) {
        Lc.C(o, c),
        CR("preconnect", o, c)
    }
    function b5(o, c, m) {
        Lc.L(o, c, m);
        var _ = pm;
        if (_ && o && c) {
            var E = 'link[rel="preload"][as="' + hn(c) + '"]';
            c === "image" && m && m.imageSrcSet ? (E += '[imagesrcset="' + hn(m.imageSrcSet) + '"]',
            typeof m.imageSizes == "string" && (E += '[imagesizes="' + hn(m.imageSizes) + '"]')) : E += '[href="' + hn(o) + '"]';
            var D = E;
            switch (c) {
            case "style":
                D = mm(o);
                break;
            case "script":
                D = gm(o)
            }
            Yo.has(D) || (o = d({
                rel: "preload",
                href: c === "image" && m && m.imageSrcSet ? void 0 : o,
                as: c
            }, m),
            Yo.set(D, o),
            _.querySelector(E) !== null || c === "style" && _.querySelector(Q0(D)) || c === "script" && _.querySelector(J0(D)) || (c = _.createElement("link"),
            ha(c, "link", o),
            Fe(c),
            _.head.appendChild(c)))
        }
    }
    function M5(o, c) {
        Lc.m(o, c);
        var m = pm;
        if (m && o) {
            var _ = c && typeof c.as == "string" ? c.as : "script"
              , E = 'link[rel="modulepreload"][as="' + hn(_) + '"][href="' + hn(o) + '"]'
              , D = E;
            switch (_) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
                D = gm(o)
            }
            if (!Yo.has(D) && (o = d({
                rel: "modulepreload",
                href: o
            }, c),
            Yo.set(D, o),
            m.querySelector(E) === null)) {
                switch (_) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                    if (m.querySelector(J0(D)))
                        return
                }
                _ = m.createElement("link"),
                ha(_, "link", o),
                Fe(_),
                m.head.appendChild(_)
            }
        }
    }
    function T5(o, c, m) {
        Lc.S(o, c, m);
        var _ = pm;
        if (_ && o) {
            var E = Ue(_).hoistableStyles
              , D = mm(o);
            c = c || "default";
            var X = E.get(D);
            if (!X) {
                var ee = {
                    loading: 0,
                    preload: null
                };
                if (X = _.querySelector(Q0(D)))
                    ee.loading = 5;
                else {
                    o = d({
                        rel: "stylesheet",
                        href: o,
                        "data-precedence": c
                    }, m),
                    (m = Yo.get(D)) && p2(o, m);
                    var be = X = _.createElement("link");
                    Fe(be),
                    ha(be, "link", o),
                    be._p = new Promise(function(Xe, dt) {
                        be.onload = Xe,
                        be.onerror = dt
                    }
                    ),
                    be.addEventListener("load", function() {
                        ee.loading |= 1
                    }),
                    be.addEventListener("error", function() {
                        ee.loading |= 2
                    }),
                    ee.loading |= 4,
                    P1(X, c, _)
                }
                X = {
                    type: "stylesheet",
                    instance: X,
                    count: 1,
                    state: ee
                },
                E.set(D, X)
            }
        }
    }
    function E5(o, c) {
        Lc.X(o, c);
        var m = pm;
        if (m && o) {
            var _ = Ue(m).hoistableScripts
              , E = gm(o)
              , D = _.get(E);
            D || (D = m.querySelector(J0(E)),
            D || (o = d({
                src: o,
                async: !0
            }, c),
            (c = Yo.get(E)) && m2(o, c),
            D = m.createElement("script"),
            Fe(D),
            ha(D, "link", o),
            m.head.appendChild(D)),
            D = {
                type: "script",
                instance: D,
                count: 1,
                state: null
            },
            _.set(E, D))
        }
    }
    function w5(o, c) {
        Lc.M(o, c);
        var m = pm;
        if (m && o) {
            var _ = Ue(m).hoistableScripts
              , E = gm(o)
              , D = _.get(E);
            D || (D = m.querySelector(J0(E)),
            D || (o = d({
                src: o,
                async: !0,
                type: "module"
            }, c),
            (c = Yo.get(E)) && m2(o, c),
            D = m.createElement("script"),
            Fe(D),
            ha(D, "link", o),
            m.head.appendChild(D)),
            D = {
                type: "script",
                instance: D,
                count: 1,
                state: null
            },
            _.set(E, D))
        }
    }
    function RR(o, c, m, _) {
        var E = (E = ue.current) ? L1(E) : null;
        if (!E)
            throw Error(n(446));
        switch (o) {
        case "meta":
        case "title":
            return null;
        case "style":
            return typeof m.precedence == "string" && typeof m.href == "string" ? (c = mm(m.href),
            m = Ue(E).hoistableStyles,
            _ = m.get(c),
            _ || (_ = {
                type: "style",
                instance: null,
                count: 0,
                state: null
            },
            m.set(c, _)),
            _) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
            };
        case "link":
            if (m.rel === "stylesheet" && typeof m.href == "string" && typeof m.precedence == "string") {
                o = mm(m.href);
                var D = Ue(E).hoistableStyles
                  , X = D.get(o);
                if (X || (E = E.ownerDocument || E,
                X = {
                    type: "stylesheet",
                    instance: null,
                    count: 0,
                    state: {
                        loading: 0,
                        preload: null
                    }
                },
                D.set(o, X),
                (D = E.querySelector(Q0(o))) && !D._p && (X.instance = D,
                X.state.loading = 5),
                Yo.has(o) || (m = {
                    rel: "preload",
                    as: "style",
                    href: m.href,
                    crossOrigin: m.crossOrigin,
                    integrity: m.integrity,
                    media: m.media,
                    hrefLang: m.hrefLang,
                    referrerPolicy: m.referrerPolicy
                },
                Yo.set(o, m),
                D || A5(E, o, m, X.state))),
                c && _ === null)
                    throw Error(n(528, ""));
                return X
            }
            if (c && _ !== null)
                throw Error(n(529, ""));
            return null;
        case "script":
            return c = m.async,
            m = m.src,
            typeof m == "string" && c && typeof c != "function" && typeof c != "symbol" ? (c = gm(m),
            m = Ue(E).hoistableScripts,
            _ = m.get(c),
            _ || (_ = {
                type: "script",
                instance: null,
                count: 0,
                state: null
            },
            m.set(c, _)),
            _) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
            };
        default:
            throw Error(n(444, o))
        }
    }
    function mm(o) {
        return 'href="' + hn(o) + '"'
    }
    function Q0(o) {
        return 'link[rel="stylesheet"][' + o + "]"
    }
    function DR(o) {
        return d({}, o, {
            "data-precedence": o.precedence,
            precedence: null
        })
    }
    function A5(o, c, m, _) {
        o.querySelector('link[rel="preload"][as="style"][' + c + "]") ? _.loading = 1 : (c = o.createElement("link"),
        _.preload = c,
        c.addEventListener("load", function() {
            return _.loading |= 1
        }),
        c.addEventListener("error", function() {
            return _.loading |= 2
        }),
        ha(c, "link", m),
        Fe(c),
        o.head.appendChild(c))
    }
    function gm(o) {
        return '[src="' + hn(o) + '"]'
    }
    function J0(o) {
        return "script[async]" + o
    }
    function UR(o, c, m) {
        if (c.count++,
        c.instance === null)
            switch (c.type) {
            case "style":
                var _ = o.querySelector('style[data-href~="' + hn(m.href) + '"]');
                if (_)
                    return c.instance = _,
                    Fe(_),
                    _;
                var E = d({}, m, {
                    "data-href": m.href,
                    "data-precedence": m.precedence,
                    href: null,
                    precedence: null
                });
                return _ = (o.ownerDocument || o).createElement("style"),
                Fe(_),
                ha(_, "style", E),
                P1(_, m.precedence, o),
                c.instance = _;
            case "stylesheet":
                E = mm(m.href);
                var D = o.querySelector(Q0(E));
                if (D)
                    return c.state.loading |= 4,
                    c.instance = D,
                    Fe(D),
                    D;
                _ = DR(m),
                (E = Yo.get(E)) && p2(_, E),
                D = (o.ownerDocument || o).createElement("link"),
                Fe(D);
                var X = D;
                return X._p = new Promise(function(ee, be) {
                    X.onload = ee,
                    X.onerror = be
                }
                ),
                ha(D, "link", _),
                c.state.loading |= 4,
                P1(D, m.precedence, o),
                c.instance = D;
            case "script":
                return D = gm(m.src),
                (E = o.querySelector(J0(D))) ? (c.instance = E,
                Fe(E),
                E) : (_ = m,
                (E = Yo.get(D)) && (_ = d({}, m),
                m2(_, E)),
                o = o.ownerDocument || o,
                E = o.createElement("script"),
                Fe(E),
                ha(E, "link", _),
                o.head.appendChild(E),
                c.instance = E);
            case "void":
                return null;
            default:
                throw Error(n(443, c.type))
            }
        else
            c.type === "stylesheet" && (c.state.loading & 4) === 0 && (_ = c.instance,
            c.state.loading |= 4,
            P1(_, m.precedence, o));
        return c.instance
    }
    function P1(o, c, m) {
        for (var _ = m.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), E = _.length ? _[_.length - 1] : null, D = E, X = 0; X < _.length; X++) {
            var ee = _[X];
            if (ee.dataset.precedence === c)
                D = ee;
            else if (D !== E)
                break
        }
        D ? D.parentNode.insertBefore(o, D.nextSibling) : (c = m.nodeType === 9 ? m.head : m,
        c.insertBefore(o, c.firstChild))
    }
    function p2(o, c) {
        o.crossOrigin == null && (o.crossOrigin = c.crossOrigin),
        o.referrerPolicy == null && (o.referrerPolicy = c.referrerPolicy),
        o.title == null && (o.title = c.title)
    }
    function m2(o, c) {
        o.crossOrigin == null && (o.crossOrigin = c.crossOrigin),
        o.referrerPolicy == null && (o.referrerPolicy = c.referrerPolicy),
        o.integrity == null && (o.integrity = c.integrity)
    }
    var B1 = null;
    function OR(o, c, m) {
        if (B1 === null) {
            var _ = new Map
              , E = B1 = new Map;
            E.set(m, _)
        } else
            E = B1,
            _ = E.get(m),
            _ || (_ = new Map,
            E.set(m, _));
        if (_.has(o))
            return _;
        for (_.set(o, null),
        m = m.getElementsByTagName(o),
        E = 0; E < m.length; E++) {
            var D = m[E];
            if (!(D[un] || D[mt] || o === "link" && D.getAttribute("rel") === "stylesheet") && D.namespaceURI !== "http://www.w3.org/2000/svg") {
                var X = D.getAttribute(c) || "";
                X = o + X;
                var ee = _.get(X);
                ee ? ee.push(D) : _.set(X, [D])
            }
        }
        return _
    }
    function NR(o, c, m) {
        o = o.ownerDocument || o,
        o.head.insertBefore(m, c === "title" ? o.querySelector("head > title") : null)
    }
    function C5(o, c, m) {
        if (m === 1 || c.itemProp != null)
            return !1;
        switch (o) {
        case "meta":
        case "title":
            return !0;
        case "style":
            if (typeof c.precedence != "string" || typeof c.href != "string" || c.href === "")
                break;
            return !0;
        case "link":
            if (typeof c.rel != "string" || typeof c.href != "string" || c.href === "" || c.onLoad || c.onError)
                break;
            switch (c.rel) {
            case "stylesheet":
                return o = c.disabled,
                typeof c.precedence == "string" && o == null;
            default:
                return !0
            }
        case "script":
            if (c.async && typeof c.async != "function" && typeof c.async != "symbol" && !c.onLoad && !c.onError && c.src && typeof c.src == "string")
                return !0
        }
        return !1
    }
    function LR(o) {
        return !(o.type === "stylesheet" && (o.state.loading & 3) === 0)
    }
    var $0 = null;
    function R5() {}
    function D5(o, c, m) {
        if ($0 === null)
            throw Error(n(475));
        var _ = $0;
        if (c.type === "stylesheet" && (typeof m.media != "string" || matchMedia(m.media).matches !== !1) && (c.state.loading & 4) === 0) {
            if (c.instance === null) {
                var E = mm(m.href)
                  , D = o.querySelector(Q0(E));
                if (D) {
                    o = D._p,
                    o !== null && typeof o == "object" && typeof o.then == "function" && (_.count++,
                    _ = z1.bind(_),
                    o.then(_, _)),
                    c.state.loading |= 4,
                    c.instance = D,
                    Fe(D);
                    return
                }
                D = o.ownerDocument || o,
                m = DR(m),
                (E = Yo.get(E)) && p2(m, E),
                D = D.createElement("link"),
                Fe(D);
                var X = D;
                X._p = new Promise(function(ee, be) {
                    X.onload = ee,
                    X.onerror = be
                }
                ),
                ha(D, "link", m),
                c.instance = D
            }
            _.stylesheets === null && (_.stylesheets = new Map),
            _.stylesheets.set(c, o),
            (o = c.state.preload) && (c.state.loading & 3) === 0 && (_.count++,
            c = z1.bind(_),
            o.addEventListener("load", c),
            o.addEventListener("error", c))
        }
    }
    function U5() {
        if ($0 === null)
            throw Error(n(475));
        var o = $0;
        return o.stylesheets && o.count === 0 && g2(o, o.stylesheets),
        0 < o.count ? function(c) {
            var m = setTimeout(function() {
                if (o.stylesheets && g2(o, o.stylesheets),
                o.unsuspend) {
                    var _ = o.unsuspend;
                    o.unsuspend = null,
                    _()
                }
            }, 6e4);
            return o.unsuspend = c,
            function() {
                o.unsuspend = null,
                clearTimeout(m)
            }
        }
        : null
    }
    function z1() {
        if (this.count--,
        this.count === 0) {
            if (this.stylesheets)
                g2(this, this.stylesheets);
            else if (this.unsuspend) {
                var o = this.unsuspend;
                this.unsuspend = null,
                o()
            }
        }
    }
    var I1 = null;
    function g2(o, c) {
        o.stylesheets = null,
        o.unsuspend !== null && (o.count++,
        I1 = new Map,
        c.forEach(O5, o),
        I1 = null,
        z1.call(o))
    }
    function O5(o, c) {
        if (!(c.state.loading & 4)) {
            var m = I1.get(o);
            if (m)
                var _ = m.get(null);
            else {
                m = new Map,
                I1.set(o, m);
                for (var E = o.querySelectorAll("link[data-precedence],style[data-precedence]"), D = 0; D < E.length; D++) {
                    var X = E[D];
                    (X.nodeName === "LINK" || X.getAttribute("media") !== "not all") && (m.set(X.dataset.precedence, X),
                    _ = X)
                }
                _ && m.set(null, _)
            }
            E = c.instance,
            X = E.getAttribute("data-precedence"),
            D = m.get(X) || _,
            D === _ && m.set(null, E),
            m.set(X, E),
            this.count++,
            _ = z1.bind(this),
            E.addEventListener("load", _),
            E.addEventListener("error", _),
            D ? D.parentNode.insertBefore(E, D.nextSibling) : (o = o.nodeType === 9 ? o.head : o,
            o.insertBefore(E, o.firstChild)),
            c.state.loading |= 4
        }
    }
    var ev = {
        $$typeof: C,
        Provider: null,
        Consumer: null,
        _currentValue: Q,
        _currentValue2: Q,
        _threadCount: 0
    };
    function N5(o, c, m, _, E, D, X, ee) {
        this.tag = 1,
        this.containerInfo = o,
        this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = -1,
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
        this.callbackPriority = 0,
        this.expirationTimes = at(-1),
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = at(0),
        this.hiddenUpdates = at(null),
        this.identifierPrefix = _,
        this.onUncaughtError = E,
        this.onCaughtError = D,
        this.onRecoverableError = X,
        this.pooledCache = null,
        this.pooledCacheLanes = 0,
        this.formState = ee,
        this.incompleteTransitions = new Map
    }
    function PR(o, c, m, _, E, D, X, ee, be, Xe, dt, St) {
        return o = new N5(o,c,m,X,ee,be,Xe,St),
        c = 1,
        D === !0 && (c |= 24),
        D = Ea(3, null, null, c),
        o.current = D,
        D.stateNode = o,
        c = zp(),
        c.refCount++,
        o.pooledCache = c,
        c.refCount++,
        D.memoizedState = {
            element: _,
            isDehydrated: m,
            cache: c
        },
        T0(D),
        o
    }
    function BR(o) {
        return o ? (o = fu,
        o) : fu
    }
    function zR(o, c, m, _, E, D) {
        E = BR(E),
        _.context === null ? _.context = E : _.pendingContext = E,
        _ = Lo(c),
        _.payload = {
            element: m
        },
        D = D === void 0 ? null : D,
        D !== null && (_.callback = D),
        m = Rl(o, _, c),
        m !== null && (fa(m, o, c),
        gc(m, o, c))
    }
    function IR(o, c) {
        if (o = o.memoizedState,
        o !== null && o.dehydrated !== null) {
            var m = o.retryLane;
            o.retryLane = m !== 0 && m < c ? m : c
        }
    }
    function v2(o, c) {
        IR(o, c),
        (o = o.alternate) && IR(o, c)
    }
    function FR(o) {
        if (o.tag === 13) {
            var c = Tl(o, 67108864);
            c !== null && fa(c, o, 67108864),
            v2(o, 67108864)
        }
    }
    var F1 = !0;
    function L5(o, c, m, _) {
        var E = H.T;
        H.T = null;
        var D = q.p;
        try {
            q.p = 2,
            y2(o, c, m, _)
        } finally {
            q.p = D,
            H.T = E
        }
    }
    function P5(o, c, m, _) {
        var E = H.T;
        H.T = null;
        var D = q.p;
        try {
            q.p = 8,
            y2(o, c, m, _)
        } finally {
            q.p = D,
            H.T = E
        }
    }
    function y2(o, c, m, _) {
        if (F1) {
            var E = _2(_);
            if (E === null)
                a2(o, c, _, H1, m),
                VR(o, _);
            else if (z5(E, o, c, m, _))
                _.stopPropagation();
            else if (VR(o, _),
            c & 4 && -1 < B5.indexOf(o)) {
                for (; E !== null; ) {
                    var D = $(E);
                    if (D !== null)
                        switch (D.tag) {
                        case 3:
                            if (D = D.stateNode,
                            D.current.memoizedState.isDehydrated) {
                                var X = ct(D.pendingLanes);
                                if (X !== 0) {
                                    var ee = D;
                                    for (ee.pendingLanes |= 2,
                                    ee.entangledLanes |= 2; X; ) {
                                        var be = 1 << 31 - it(X);
                                        ee.entanglements[1] |= be,
                                        X &= ~be
                                    }
                                    Pu(D),
                                    (si & 6) === 0 && (jr = le() + 500,
                                    Y0(0))
                                }
                            }
                            break;
                        case 13:
                            ee = Tl(D, 2),
                            ee !== null && fa(ee, D, 2),
                            jo(),
                            v2(D, 2)
                        }
                    if (D = _2(_),
                    D === null && a2(o, c, _, H1, m),
                    D === E)
                        break;
                    E = D
                }
                E !== null && _.stopPropagation()
            } else
                a2(o, c, _, null, m)
        }
    }
    function _2(o) {
        return o = Js(o),
        x2(o)
    }
    var H1 = null;
    function x2(o) {
        if (H1 = null,
        o = k(o),
        o !== null) {
            var c = a(o);
            if (c === null)
                o = null;
            else {
                var m = c.tag;
                if (m === 13) {
                    if (o = s(c),
                    o !== null)
                        return o;
                    o = null
                } else if (m === 3) {
                    if (c.stateNode.current.memoizedState.isDehydrated)
                        return c.tag === 3 ? c.stateNode.containerInfo : null;
                    o = null
                } else
                    c !== o && (o = null)
            }
        }
        return H1 = o,
        null
    }
    function HR(o) {
        switch (o) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 8;
        case "message":
            switch (Pe()) {
            case He:
                return 2;
            case Ve:
                return 8;
            case De:
            case vt:
                return 32;
            case J:
                return 268435456;
            default:
                return 32
            }
        default:
            return 32
        }
    }
    var S2 = !1
      , Ff = null
      , Hf = null
      , Vf = null
      , tv = new Map
      , nv = new Map
      , kf = []
      , B5 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
    function VR(o, c) {
        switch (o) {
        case "focusin":
        case "focusout":
            Ff = null;
            break;
        case "dragenter":
        case "dragleave":
            Hf = null;
            break;
        case "mouseover":
        case "mouseout":
            Vf = null;
            break;
        case "pointerover":
        case "pointerout":
            tv.delete(c.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            nv.delete(c.pointerId)
        }
    }
    function iv(o, c, m, _, E, D) {
        return o === null || o.nativeEvent !== D ? (o = {
            blockedOn: c,
            domEventName: m,
            eventSystemFlags: _,
            nativeEvent: D,
            targetContainers: [E]
        },
        c !== null && (c = $(c),
        c !== null && FR(c)),
        o) : (o.eventSystemFlags |= _,
        c = o.targetContainers,
        E !== null && c.indexOf(E) === -1 && c.push(E),
        o)
    }
    function z5(o, c, m, _, E) {
        switch (c) {
        case "focusin":
            return Ff = iv(Ff, o, c, m, _, E),
            !0;
        case "dragenter":
            return Hf = iv(Hf, o, c, m, _, E),
            !0;
        case "mouseover":
            return Vf = iv(Vf, o, c, m, _, E),
            !0;
        case "pointerover":
            var D = E.pointerId;
            return tv.set(D, iv(tv.get(D) || null, o, c, m, _, E)),
            !0;
        case "gotpointercapture":
            return D = E.pointerId,
            nv.set(D, iv(nv.get(D) || null, o, c, m, _, E)),
            !0
        }
        return !1
    }
    function kR(o) {
        var c = k(o.target);
        if (c !== null) {
            var m = a(c);
            if (m !== null) {
                if (c = m.tag,
                c === 13) {
                    if (c = s(m),
                    c !== null) {
                        o.blockedOn = c,
                        Bt(o.priority, function() {
                            if (m.tag === 13) {
                                var _ = Vi();
                                _ = Ot(_);
                                var E = Tl(m, _);
                                E !== null && fa(E, m, _),
                                v2(m, _)
                            }
                        });
                        return
                    }
                } else if (c === 3 && m.stateNode.current.memoizedState.isDehydrated) {
                    o.blockedOn = m.tag === 3 ? m.stateNode.containerInfo : null;
                    return
                }
            }
        }
        o.blockedOn = null
    }
    function V1(o) {
        if (o.blockedOn !== null)
            return !1;
        for (var c = o.targetContainers; 0 < c.length; ) {
            var m = _2(o.nativeEvent);
            if (m === null) {
                m = o.nativeEvent;
                var _ = new m.constructor(m.type,m);
                Qs = _,
                m.target.dispatchEvent(_),
                Qs = null
            } else
                return c = $(m),
                c !== null && FR(c),
                o.blockedOn = m,
                !1;
            c.shift()
        }
        return !0
    }
    function GR(o, c, m) {
        V1(o) && m.delete(c)
    }
    function I5() {
        S2 = !1,
        Ff !== null && V1(Ff) && (Ff = null),
        Hf !== null && V1(Hf) && (Hf = null),
        Vf !== null && V1(Vf) && (Vf = null),
        tv.forEach(GR),
        nv.forEach(GR)
    }
    function k1(o, c) {
        o.blockedOn === c && (o.blockedOn = null,
        S2 || (S2 = !0,
        r.unstable_scheduleCallback(r.unstable_NormalPriority, I5)))
    }
    var G1 = null;
    function XR(o) {
        G1 !== o && (G1 = o,
        r.unstable_scheduleCallback(r.unstable_NormalPriority, function() {
            G1 === o && (G1 = null);
            for (var c = 0; c < o.length; c += 3) {
                var m = o[c]
                  , _ = o[c + 1]
                  , E = o[c + 2];
                if (typeof _ != "function") {
                    if (x2(_ || m) === null)
                        continue;
                    break
                }
                var D = $(m);
                D !== null && (o.splice(c, 3),
                c -= 3,
                H0(D, {
                    pending: !0,
                    data: E,
                    method: m.method,
                    action: _
                }, _, E))
            }
        }))
    }
    function rv(o) {
        function c(be) {
            return k1(be, o)
        }
        Ff !== null && k1(Ff, o),
        Hf !== null && k1(Hf, o),
        Vf !== null && k1(Vf, o),
        tv.forEach(c),
        nv.forEach(c);
        for (var m = 0; m < kf.length; m++) {
            var _ = kf[m];
            _.blockedOn === o && (_.blockedOn = null)
        }
        for (; 0 < kf.length && (m = kf[0],
        m.blockedOn === null); )
            kR(m),
            m.blockedOn === null && kf.shift();
        if (m = (o.ownerDocument || o).$$reactFormReplay,
        m != null)
            for (_ = 0; _ < m.length; _ += 3) {
                var E = m[_]
                  , D = m[_ + 1]
                  , X = E[Lt] || null;
                if (typeof D == "function")
                    X || XR(m);
                else if (X) {
                    var ee = null;
                    if (D && D.hasAttribute("formAction")) {
                        if (E = D,
                        X = D[Lt] || null)
                            ee = X.formAction;
                        else if (x2(E) !== null)
                            continue
                    } else
                        ee = X.action;
                    typeof ee == "function" ? m[_ + 1] = ee : (m.splice(_, 3),
                    _ -= 3),
                    XR(m)
                }
            }
    }
    function b2(o) {
        this._internalRoot = o
    }
    X1.prototype.render = b2.prototype.render = function(o) {
        var c = this._internalRoot;
        if (c === null)
            throw Error(n(409));
        var m = c.current
          , _ = Vi();
        zR(m, _, o, c, null, null)
    }
    ,
    X1.prototype.unmount = b2.prototype.unmount = function() {
        var o = this._internalRoot;
        if (o !== null) {
            this._internalRoot = null;
            var c = o.containerInfo;
            zR(o.current, 2, null, o, null, null),
            jo(),
            c[zt] = null
        }
    }
    ;
    function X1(o) {
        this._internalRoot = o
    }
    X1.prototype.unstable_scheduleHydration = function(o) {
        if (o) {
            var c = bt();
            o = {
                blockedOn: null,
                target: o,
                priority: c
            };
            for (var m = 0; m < kf.length && c !== 0 && c < kf[m].priority; m++)
                ;
            kf.splice(m, 0, o),
            m === 0 && kR(o)
        }
    }
    ;
    var jR = e.version;
    if (jR !== "19.1.0")
        throw Error(n(527, jR, "19.1.0"));
    q.findDOMNode = function(o) {
        var c = o._reactInternals;
        if (c === void 0)
            throw typeof o.render == "function" ? Error(n(188)) : (o = Object.keys(o).join(","),
            Error(n(268, o)));
        return o = u(c),
        o = o !== null ? f(o) : null,
        o = o === null ? null : o.stateNode,
        o
    }
    ;
    var F5 = {
        bundleType: 0,
        version: "19.1.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: H,
        reconcilerVersion: "19.1.0"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var j1 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!j1.isDisabled && j1.supportsFiber)
            try {
                Be = j1.inject(F5),
                we = j1
            } catch {}
    }
    return sv.createRoot = function(o, c) {
        if (!i(o))
            throw Error(n(299));
        var m = !1
          , _ = ""
          , E = od
          , D = em
          , X = E1
          , ee = null;
        return c != null && (c.unstable_strictMode === !0 && (m = !0),
        c.identifierPrefix !== void 0 && (_ = c.identifierPrefix),
        c.onUncaughtError !== void 0 && (E = c.onUncaughtError),
        c.onCaughtError !== void 0 && (D = c.onCaughtError),
        c.onRecoverableError !== void 0 && (X = c.onRecoverableError),
        c.unstable_transitionCallbacks !== void 0 && (ee = c.unstable_transitionCallbacks)),
        c = PR(o, 1, !1, null, null, m, _, E, D, X, ee, null),
        o[zt] = c.current,
        r2(o),
        new b2(c)
    }
    ,
    sv.hydrateRoot = function(o, c, m) {
        if (!i(o))
            throw Error(n(299));
        var _ = !1
          , E = ""
          , D = od
          , X = em
          , ee = E1
          , be = null
          , Xe = null;
        return m != null && (m.unstable_strictMode === !0 && (_ = !0),
        m.identifierPrefix !== void 0 && (E = m.identifierPrefix),
        m.onUncaughtError !== void 0 && (D = m.onUncaughtError),
        m.onCaughtError !== void 0 && (X = m.onCaughtError),
        m.onRecoverableError !== void 0 && (ee = m.onRecoverableError),
        m.unstable_transitionCallbacks !== void 0 && (be = m.unstable_transitionCallbacks),
        m.formState !== void 0 && (Xe = m.formState)),
        c = PR(o, 1, !0, c, m ?? null, _, E, D, X, ee, be, Xe),
        c.context = BR(null),
        m = c.current,
        _ = Vi(),
        _ = Ot(_),
        E = Lo(_),
        E.callback = null,
        Rl(m, E, _),
        m = _,
        c.current.lanes = m,
        Ct(c, m),
        Pu(c),
        o[zt] = c.current,
        r2(o),
        new X1(c)
    }
    ,
    sv.version = "19.1.0",
    sv
}
var t3;
function Q5() {
    if (t3)
        return T2.exports;
    t3 = 1;
    function r() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(r)
            } catch (e) {
                console.error(e)
            }
    }
    return r(),
    T2.exports = K5(),
    T2.exports
}
var J5 = Q5();
const $5 = jb(J5);
var de = zg();
const ln = jb(de);
var UN = {
    color: void 0,
    size: void 0,
    className: void 0,
    style: void 0,
    attr: void 0
}
  , n3 = ln.createContext && ln.createContext(UN)
  , eF = ["attr", "size", "title"];
function tF(r, e) {
    if (r == null)
        return {};
    var t = nF(r, e), n, i;
    if (Object.getOwnPropertySymbols) {
        var a = Object.getOwnPropertySymbols(r);
        for (i = 0; i < a.length; i++)
            n = a[i],
            !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(r, n) && (t[n] = r[n])
    }
    return t
}
function nF(r, e) {
    if (r == null)
        return {};
    var t = {};
    for (var n in r)
        if (Object.prototype.hasOwnProperty.call(r, n)) {
            if (e.indexOf(n) >= 0)
                continue;
            t[n] = r[n]
        }
    return t
}
function US() {
    return US = Object.assign ? Object.assign.bind() : function(r) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var n in t)
                Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n])
        }
        return r
    }
    ,
    US.apply(this, arguments)
}
function i3(r, e) {
    var t = Object.keys(r);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(r);
        e && (n = n.filter(function(i) {
            return Object.getOwnPropertyDescriptor(r, i).enumerable
        })),
        t.push.apply(t, n)
    }
    return t
}
function OS(r) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? i3(Object(t), !0).forEach(function(n) {
            iF(r, n, t[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : i3(Object(t)).forEach(function(n) {
            Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n))
        })
    }
    return r
}
function iF(r, e, t) {
    return e = rF(e),
    e in r ? Object.defineProperty(r, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : r[e] = t,
    r
}
function rF(r) {
    var e = aF(r, "string");
    return typeof e == "symbol" ? e : e + ""
}
function aF(r, e) {
    if (typeof r != "object" || !r)
        return r;
    var t = r[Symbol.toPrimitive];
    if (t !== void 0) {
        var n = t.call(r, e);
        if (typeof n != "object")
            return n;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(r)
}
function ON(r) {
    return r && r.map( (e, t) => ln.createElement(e.tag, OS({
        key: t
    }, e.attr), ON(e.child)))
}
function Vr(r) {
    return e => ln.createElement(sF, US({
        attr: OS({}, r.attr)
    }, e), ON(r.child))
}
function sF(r) {
    var e = t => {
        var {attr: n, size: i, title: a} = r, s = tF(r, eF), l = i || t.size || "1em", u;
        return t.className && (u = t.className),
        r.className && (u = (u ? u + " " : "") + r.className),
        ln.createElement("svg", US({
            stroke: "currentColor",
            fill: "currentColor",
            strokeWidth: "0"
        }, t.attr, n, s, {
            className: u,
            style: OS(OS({
                color: r.color || t.color
            }, t.style), r.style),
            height: l,
            width: l,
            xmlns: "http://www.w3.org/2000/svg"
        }), a && ln.createElement("title", null, a), r.children)
    }
    ;
    return n3 !== void 0 ? ln.createElement(n3.Consumer, null, t => e(t)) : e(UN)
}
function oF(r) {
    return Vr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "circle",
            attr: {
                cx: "12",
                cy: "8",
                r: "7"
            },
            child: []
        }, {
            tag: "polyline",
            attr: {
                points: "8.21 13.89 7 23 12 20 17 23 15.79 13.88"
            },
            child: []
        }]
    })(r)
}
function kw(r) {
    return Vr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "rect",
            attr: {
                x: "3",
                y: "4",
                width: "18",
                height: "18",
                rx: "2",
                ry: "2"
            },
            child: []
        }, {
            tag: "line",
            attr: {
                x1: "16",
                y1: "2",
                x2: "16",
                y2: "6"
            },
            child: []
        }, {
            tag: "line",
            attr: {
                x1: "8",
                y1: "2",
                x2: "8",
                y2: "6"
            },
            child: []
        }, {
            tag: "line",
            attr: {
                x1: "3",
                y1: "10",
                x2: "21",
                y2: "10"
            },
            child: []
        }]
    })(r)
}
function lF(r) {
    return Vr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "polyline",
            attr: {
                points: "15 18 9 12 15 6"
            },
            child: []
        }]
    })(r)
}
function uF(r) {
    return Vr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "polyline",
            attr: {
                points: "9 18 15 12 9 6"
            },
            child: []
        }]
    })(r)
}
function cF(r) {
    return Vr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"
            },
            child: []
        }]
    })(r)
}
function fF(r) {
    return Vr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "rect",
            attr: {
                x: "2",
                y: "2",
                width: "20",
                height: "20",
                rx: "5",
                ry: "5"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"
            },
            child: []
        }, {
            tag: "line",
            attr: {
                x1: "17.5",
                y1: "6.5",
                x2: "17.51",
                y2: "6.5"
            },
            child: []
        }]
    })(r)
}
function Gw(r) {
    return Vr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"
            },
            child: []
        }, {
            tag: "circle",
            attr: {
                cx: "12",
                cy: "10",
                r: "3"
            },
            child: []
        }]
    })(r)
}
function hF(r) {
    return Vr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "line",
            attr: {
                x1: "3",
                y1: "12",
                x2: "21",
                y2: "12"
            },
            child: []
        }, {
            tag: "line",
            attr: {
                x1: "3",
                y1: "6",
                x2: "21",
                y2: "6"
            },
            child: []
        }, {
            tag: "line",
            attr: {
                x1: "3",
                y1: "18",
                x2: "21",
                y2: "18"
            },
            child: []
        }]
    })(r)
}
function NN(r) {
    return Vr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "line",
            attr: {
                x1: "18",
                y1: "6",
                x2: "6",
                y2: "18"
            },
            child: []
        }, {
            tag: "line",
            attr: {
                x1: "6",
                y1: "6",
                x2: "18",
                y2: "18"
            },
            child: []
        }]
    })(r)
}
function dF(r) {
    return Vr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"
            },
            child: []
        }, {
            tag: "polygon",
            attr: {
                points: "9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"
            },
            child: []
        }]
    })(r)
}
const Xw = de.createContext({});
function Ig(r) {
    const e = de.useRef(null);
    return e.current === null && (e.current = r()),
    e.current
}
const jw = typeof window < "u"
  , Wb = jw ? de.useLayoutEffect : de.useEffect
  , Yb = de.createContext(null);
function Ww(r, e) {
    r.indexOf(e) === -1 && r.push(e)
}
function Yw(r, e) {
    const t = r.indexOf(e);
    t > -1 && r.splice(t, 1)
}
const ec = (r, e, t) => t > e ? e : t < r ? r : t;
let pF = () => {}
  , qw = () => {}
;
const Qc = {}
  , LN = r => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(r);
function PN(r) {
    return typeof r == "object" && r !== null
}
const BN = r => /^0[^.\s]+$/u.test(r);
function Zw(r) {
    let e;
    return () => (e === void 0 && (e = r()),
    e)
}
const Gs = r => r
  , mF = (r, e) => t => e(r(t))
  , t_ = (...r) => r.reduce(mF)
  , pg = (r, e, t) => {
    const n = e - r;
    return n === 0 ? 1 : (t - r) / n
}
;
class Kw {
    constructor() {
        this.subscriptions = []
    }
    add(e) {
        return Ww(this.subscriptions, e),
        () => Yw(this.subscriptions, e)
    }
    notify(e, t, n) {
        const i = this.subscriptions.length;
        if (i)
            if (i === 1)
                this.subscriptions[0](e, t, n);
            else
                for (let a = 0; a < i; a++) {
                    const s = this.subscriptions[a];
                    s && s(e, t, n)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
const Wu = r => r * 1e3
  , Yu = r => r / 1e3;
function Qw(r, e) {
    return e ? r * (1e3 / e) : 0
}
const zN = (r, e, t) => (((1 - 3 * t + 3 * e) * r + (3 * t - 6 * e)) * r + 3 * e) * r
  , gF = 1e-7
  , vF = 12;
function yF(r, e, t, n, i) {
    let a, s, l = 0;
    do
        s = e + (t - e) / 2,
        a = zN(s, n, i) - r,
        a > 0 ? t = s : e = s;
    while (Math.abs(a) > gF && ++l < vF);
    return s
}
function n_(r, e, t, n) {
    if (r === e && t === n)
        return Gs;
    const i = a => yF(a, 0, 1, r, t);
    return a => a === 0 || a === 1 ? a : zN(i(a), e, n)
}
const IN = r => e => e <= .5 ? r(2 * e) / 2 : (2 - r(2 * (1 - e))) / 2
  , FN = r => e => 1 - r(1 - e)
  , HN = n_(.33, 1.53, .69, .99)
  , Jw = FN(HN)
  , VN = IN(Jw)
  , kN = r => (r *= 2) < 1 ? .5 * Jw(r) : .5 * (2 - Math.pow(2, -10 * (r - 1)))
  , $w = r => 1 - Math.sin(Math.acos(r))
  , GN = FN($w)
  , XN = IN($w)
  , _F = n_(.42, 0, 1, 1)
  , xF = n_(0, 0, .58, 1)
  , jN = n_(.42, 0, .58, 1)
  , SF = r => Array.isArray(r) && typeof r[0] != "number"
  , WN = r => Array.isArray(r) && typeof r[0] == "number"
  , bF = {
    linear: Gs,
    easeIn: _F,
    easeInOut: jN,
    easeOut: xF,
    circIn: $w,
    circInOut: XN,
    circOut: GN,
    backIn: Jw,
    backInOut: VN,
    backOut: HN,
    anticipate: kN
}
  , MF = r => typeof r == "string"
  , r3 = r => {
    if (WN(r)) {
        qw(r.length === 4);
        const [e,t,n,i] = r;
        return n_(e, t, n, i)
    } else if (MF(r))
        return bF[r];
    return r
}
  , W1 = ["setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender"];
function TF(r, e) {
    let t = new Set
      , n = new Set
      , i = !1
      , a = !1;
    const s = new WeakSet;
    let l = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    };
    function u(d) {
        s.has(d) && (f.schedule(d),
        r()),
        d(l)
    }
    const f = {
        schedule: (d, g=!1, v=!1) => {
            const S = v && i ? t : n;
            return g && s.add(d),
            S.has(d) || S.add(d),
            d
        }
        ,
        cancel: d => {
            n.delete(d),
            s.delete(d)
        }
        ,
        process: d => {
            if (l = d,
            i) {
                a = !0;
                return
            }
            i = !0,
            [t,n] = [n, t],
            t.forEach(u),
            t.clear(),
            i = !1,
            a && (a = !1,
            f.process(d))
        }
    };
    return f
}
const EF = 40;
function YN(r, e) {
    let t = !1
      , n = !0;
    const i = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    }
      , a = () => t = !0
      , s = W1.reduce( (C, R) => (C[R] = TF(a),
    C), {})
      , {setup: l, read: u, resolveKeyframes: f, preUpdate: d, update: g, preRender: v, render: y, postRender: S} = s
      , T = () => {
        const C = Qc.useManualTiming ? i.timestamp : performance.now();
        t = !1,
        Qc.useManualTiming || (i.delta = n ? 1e3 / 60 : Math.max(Math.min(C - i.timestamp, EF), 1)),
        i.timestamp = C,
        i.isProcessing = !0,
        l.process(i),
        u.process(i),
        f.process(i),
        d.process(i),
        g.process(i),
        v.process(i),
        y.process(i),
        S.process(i),
        i.isProcessing = !1,
        t && e && (n = !1,
        r(T))
    }
      , M = () => {
        t = !0,
        n = !0,
        i.isProcessing || r(T)
    }
    ;
    return {
        schedule: W1.reduce( (C, R) => {
            const O = s[R];
            return C[R] = (L, z=!1, I=!1) => (t || M(),
            O.schedule(L, z, I)),
            C
        }
        , {}),
        cancel: C => {
            for (let R = 0; R < W1.length; R++)
                s[W1[R]].cancel(C)
        }
        ,
        state: i,
        steps: s
    }
}
const {schedule: wi, cancel: Ql, state: Qr, steps: R2} = YN(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Gs, !0);
let oS;
function wF() {
    oS = void 0
}
const ks = {
    now: () => (oS === void 0 && ks.set(Qr.isProcessing || Qc.useManualTiming ? Qr.timestamp : performance.now()),
    oS),
    set: r => {
        oS = r,
        queueMicrotask(wF)
    }
}
  , qN = r => e => typeof e == "string" && e.startsWith(r)
  , eA = qN("--")
  , AF = qN("var(--")
  , tA = r => AF(r) ? CF.test(r.split("/*")[0].trim()) : !1
  , CF = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu
  , Fg = {
    test: r => typeof r == "number",
    parse: parseFloat,
    transform: r => r
}
  , Sy = {
    ...Fg,
    transform: r => ec(0, 1, r)
}
  , Y1 = {
    ...Fg,
    default: 1
}
  , Vv = r => Math.round(r * 1e5) / 1e5
  , nA = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function RF(r) {
    return r == null
}
const DF = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu
  , iA = (r, e) => t => !!(typeof t == "string" && DF.test(t) && t.startsWith(r) || e && !RF(t) && Object.prototype.hasOwnProperty.call(t, e))
  , ZN = (r, e, t) => n => {
    if (typeof n != "string")
        return n;
    const [i,a,s,l] = n.match(nA);
    return {
        [r]: parseFloat(i),
        [e]: parseFloat(a),
        [t]: parseFloat(s),
        alpha: l !== void 0 ? parseFloat(l) : 1
    }
}
  , UF = r => ec(0, 255, r)
  , D2 = {
    ...Fg,
    transform: r => Math.round(UF(r))
}
  , Hd = {
    test: iA("rgb", "red"),
    parse: ZN("red", "green", "blue"),
    transform: ({red: r, green: e, blue: t, alpha: n=1}) => "rgba(" + D2.transform(r) + ", " + D2.transform(e) + ", " + D2.transform(t) + ", " + Vv(Sy.transform(n)) + ")"
};
function OF(r) {
    let e = ""
      , t = ""
      , n = ""
      , i = "";
    return r.length > 5 ? (e = r.substring(1, 3),
    t = r.substring(3, 5),
    n = r.substring(5, 7),
    i = r.substring(7, 9)) : (e = r.substring(1, 2),
    t = r.substring(2, 3),
    n = r.substring(3, 4),
    i = r.substring(4, 5),
    e += e,
    t += t,
    n += n,
    i += i),
    {
        red: parseInt(e, 16),
        green: parseInt(t, 16),
        blue: parseInt(n, 16),
        alpha: i ? parseInt(i, 16) / 255 : 1
    }
}
const xE = {
    test: iA("#"),
    parse: OF,
    transform: Hd.transform
}
  , i_ = r => ({
    test: e => typeof e == "string" && e.endsWith(r) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: e => `${e}${r}`
})
  , $f = i_("deg")
  , qu = i_("%")
  , _n = i_("px")
  , NF = i_("vh")
  , LF = i_("vw")
  , a3 = {
    ...qu,
    parse: r => qu.parse(r) / 100,
    transform: r => qu.transform(r * 100)
}
  , qm = {
    test: iA("hsl", "hue"),
    parse: ZN("hue", "saturation", "lightness"),
    transform: ({hue: r, saturation: e, lightness: t, alpha: n=1}) => "hsla(" + Math.round(r) + ", " + qu.transform(Vv(e)) + ", " + qu.transform(Vv(t)) + ", " + Vv(Sy.transform(n)) + ")"
}
  , La = {
    test: r => Hd.test(r) || xE.test(r) || qm.test(r),
    parse: r => Hd.test(r) ? Hd.parse(r) : qm.test(r) ? qm.parse(r) : xE.parse(r),
    transform: r => typeof r == "string" ? r : r.hasOwnProperty("red") ? Hd.transform(r) : qm.transform(r)
}
  , PF = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function BF(r) {
    var e, t;
    return isNaN(r) && typeof r == "string" && (((e = r.match(nA)) == null ? void 0 : e.length) || 0) + (((t = r.match(PF)) == null ? void 0 : t.length) || 0) > 0
}
const KN = "number"
  , QN = "color"
  , zF = "var"
  , IF = "var("
  , s3 = "${}"
  , FF = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function by(r) {
    const e = r.toString()
      , t = []
      , n = {
        color: [],
        number: [],
        var: []
    }
      , i = [];
    let a = 0;
    const l = e.replace(FF, u => (La.test(u) ? (n.color.push(a),
    i.push(QN),
    t.push(La.parse(u))) : u.startsWith(IF) ? (n.var.push(a),
    i.push(zF),
    t.push(u)) : (n.number.push(a),
    i.push(KN),
    t.push(parseFloat(u))),
    ++a,
    s3)).split(s3);
    return {
        values: t,
        split: l,
        indexes: n,
        types: i
    }
}
function JN(r) {
    return by(r).values
}
function $N(r) {
    const {split: e, types: t} = by(r)
      , n = e.length;
    return i => {
        let a = "";
        for (let s = 0; s < n; s++)
            if (a += e[s],
            i[s] !== void 0) {
                const l = t[s];
                l === KN ? a += Vv(i[s]) : l === QN ? a += La.transform(i[s]) : a += i[s]
            }
        return a
    }
}
const HF = r => typeof r == "number" ? 0 : r;
function VF(r) {
    const e = JN(r);
    return $N(r)(e.map(HF))
}
const mh = {
    test: BF,
    parse: JN,
    createTransformer: $N,
    getAnimatableNone: VF
};
function U2(r, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? r + (e - r) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? r + (e - r) * (2 / 3 - t) * 6 : r
}
function kF({hue: r, saturation: e, lightness: t, alpha: n}) {
    r /= 360,
    e /= 100,
    t /= 100;
    let i = 0
      , a = 0
      , s = 0;
    if (!e)
        i = a = s = t;
    else {
        const l = t < .5 ? t * (1 + e) : t + e - t * e
          , u = 2 * t - l;
        i = U2(u, l, r + 1 / 3),
        a = U2(u, l, r),
        s = U2(u, l, r - 1 / 3)
    }
    return {
        red: Math.round(i * 255),
        green: Math.round(a * 255),
        blue: Math.round(s * 255),
        alpha: n
    }
}
function NS(r, e) {
    return t => t > 0 ? e : r
}
const Ji = (r, e, t) => r + (e - r) * t
  , O2 = (r, e, t) => {
    const n = r * r
      , i = t * (e * e - n) + n;
    return i < 0 ? 0 : Math.sqrt(i)
}
  , GF = [xE, Hd, qm]
  , XF = r => GF.find(e => e.test(r));
function o3(r) {
    const e = XF(r);
    if (!e)
        return !1;
    let t = e.parse(r);
    return e === qm && (t = kF(t)),
    t
}
const l3 = (r, e) => {
    const t = o3(r)
      , n = o3(e);
    if (!t || !n)
        return NS(r, e);
    const i = {
        ...t
    };
    return a => (i.red = O2(t.red, n.red, a),
    i.green = O2(t.green, n.green, a),
    i.blue = O2(t.blue, n.blue, a),
    i.alpha = Ji(t.alpha, n.alpha, a),
    Hd.transform(i))
}
  , SE = new Set(["none", "hidden"]);
function jF(r, e) {
    return SE.has(r) ? t => t <= 0 ? r : e : t => t >= 1 ? e : r
}
function WF(r, e) {
    return t => Ji(r, e, t)
}
function rA(r) {
    return typeof r == "number" ? WF : typeof r == "string" ? tA(r) ? NS : La.test(r) ? l3 : ZF : Array.isArray(r) ? eL : typeof r == "object" ? La.test(r) ? l3 : YF : NS
}
function eL(r, e) {
    const t = [...r]
      , n = t.length
      , i = r.map( (a, s) => rA(a)(a, e[s]));
    return a => {
        for (let s = 0; s < n; s++)
            t[s] = i[s](a);
        return t
    }
}
function YF(r, e) {
    const t = {
        ...r,
        ...e
    }
      , n = {};
    for (const i in t)
        r[i] !== void 0 && e[i] !== void 0 && (n[i] = rA(r[i])(r[i], e[i]));
    return i => {
        for (const a in n)
            t[a] = n[a](i);
        return t
    }
}
function qF(r, e) {
    const t = []
      , n = {
        color: 0,
        var: 0,
        number: 0
    };
    for (let i = 0; i < e.values.length; i++) {
        const a = e.types[i]
          , s = r.indexes[a][n[a]]
          , l = r.values[s] ?? 0;
        t[i] = l,
        n[a]++
    }
    return t
}
const ZF = (r, e) => {
    const t = mh.createTransformer(e)
      , n = by(r)
      , i = by(e);
    return n.indexes.var.length === i.indexes.var.length && n.indexes.color.length === i.indexes.color.length && n.indexes.number.length >= i.indexes.number.length ? SE.has(r) && !i.values.length || SE.has(e) && !n.values.length ? jF(r, e) : t_(eL(qF(n, i), i.values), t) : NS(r, e)
}
;
function tL(r, e, t) {
    return typeof r == "number" && typeof e == "number" && typeof t == "number" ? Ji(r, e, t) : rA(r)(r, e)
}
const KF = r => {
    const e = ({timestamp: t}) => r(t);
    return {
        start: (t=!0) => wi.update(e, t),
        stop: () => Ql(e),
        now: () => Qr.isProcessing ? Qr.timestamp : ks.now()
    }
}
  , nL = (r, e, t=10) => {
    let n = "";
    const i = Math.max(Math.round(e / t), 2);
    for (let a = 0; a < i; a++)
        n += r(a / (i - 1)) + ", ";
    return `linear(${n.substring(0, n.length - 2)})`
}
  , LS = 2e4;
function aA(r) {
    let e = 0;
    const t = 50;
    let n = r.next(e);
    for (; !n.done && e < LS; )
        e += t,
        n = r.next(e);
    return e >= LS ? 1 / 0 : e
}
function QF(r, e=100, t) {
    const n = t({
        ...r,
        keyframes: [0, e]
    })
      , i = Math.min(aA(n), LS);
    return {
        type: "keyframes",
        ease: a => n.next(i * a).value / e,
        duration: Yu(i)
    }
}
const JF = 5;
function iL(r, e, t) {
    const n = Math.max(e - JF, 0);
    return Qw(t - r(n), e - n)
}
const lr = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: .3,
    visualDuration: .3,
    restSpeed: {
        granular: .01,
        default: 2
    },
    restDelta: {
        granular: .005,
        default: .5
    },
    minDuration: .01,
    maxDuration: 10,
    minDamping: .05,
    maxDamping: 1
}
  , u3 = .001;
function $F({duration: r=lr.duration, bounce: e=lr.bounce, velocity: t=lr.velocity, mass: n=lr.mass}) {
    let i, a, s = 1 - e;
    s = ec(lr.minDamping, lr.maxDamping, s),
    r = ec(lr.minDuration, lr.maxDuration, Yu(r)),
    s < 1 ? (i = f => {
        const d = f * s
          , g = d * r
          , v = d - t
          , y = bE(f, s)
          , S = Math.exp(-g);
        return u3 - v / y * S
    }
    ,
    a = f => {
        const g = f * s * r
          , v = g * t + t
          , y = Math.pow(s, 2) * Math.pow(f, 2) * r
          , S = Math.exp(-g)
          , T = bE(Math.pow(f, 2), s);
        return (-i(f) + u3 > 0 ? -1 : 1) * ((v - y) * S) / T
    }
    ) : (i = f => {
        const d = Math.exp(-f * r)
          , g = (f - t) * r + 1;
        return -.001 + d * g
    }
    ,
    a = f => {
        const d = Math.exp(-f * r)
          , g = (t - f) * (r * r);
        return d * g
    }
    );
    const l = 5 / r
      , u = t6(i, a, l);
    if (r = Wu(r),
    isNaN(u))
        return {
            stiffness: lr.stiffness,
            damping: lr.damping,
            duration: r
        };
    {
        const f = Math.pow(u, 2) * n;
        return {
            stiffness: f,
            damping: s * 2 * Math.sqrt(n * f),
            duration: r
        }
    }
}
const e6 = 12;
function t6(r, e, t) {
    let n = t;
    for (let i = 1; i < e6; i++)
        n = n - r(n) / e(n);
    return n
}
function bE(r, e) {
    return r * Math.sqrt(1 - e * e)
}
const n6 = ["duration", "bounce"]
  , i6 = ["stiffness", "damping", "mass"];
function c3(r, e) {
    return e.some(t => r[t] !== void 0)
}
function r6(r) {
    let e = {
        velocity: lr.velocity,
        stiffness: lr.stiffness,
        damping: lr.damping,
        mass: lr.mass,
        isResolvedFromDuration: !1,
        ...r
    };
    if (!c3(r, i6) && c3(r, n6))
        if (r.visualDuration) {
            const t = r.visualDuration
              , n = 2 * Math.PI / (t * 1.2)
              , i = n * n
              , a = 2 * ec(.05, 1, 1 - (r.bounce || 0)) * Math.sqrt(i);
            e = {
                ...e,
                mass: lr.mass,
                stiffness: i,
                damping: a
            }
        } else {
            const t = $F(r);
            e = {
                ...e,
                ...t,
                mass: lr.mass
            },
            e.isResolvedFromDuration = !0
        }
    return e
}
function Zu(r=lr.visualDuration, e=lr.bounce) {
    const t = typeof r != "object" ? {
        visualDuration: r,
        keyframes: [0, 1],
        bounce: e
    } : r;
    let {restSpeed: n, restDelta: i} = t;
    const a = t.keyframes[0]
      , s = t.keyframes[t.keyframes.length - 1]
      , l = {
        done: !1,
        value: a
    }
      , {stiffness: u, damping: f, mass: d, duration: g, velocity: v, isResolvedFromDuration: y} = r6({
        ...t,
        velocity: -Yu(t.velocity || 0)
    })
      , S = v || 0
      , T = f / (2 * Math.sqrt(u * d))
      , M = s - a
      , b = Yu(Math.sqrt(u / d))
      , A = Math.abs(M) < 5;
    n || (n = A ? lr.restSpeed.granular : lr.restSpeed.default),
    i || (i = A ? lr.restDelta.granular : lr.restDelta.default);
    let C;
    if (T < 1) {
        const O = bE(b, T);
        C = L => {
            const z = Math.exp(-T * b * L);
            return s - z * ((S + T * b * M) / O * Math.sin(O * L) + M * Math.cos(O * L))
        }
    } else if (T === 1)
        C = O => s - Math.exp(-b * O) * (M + (S + b * M) * O);
    else {
        const O = b * Math.sqrt(T * T - 1);
        C = L => {
            const z = Math.exp(-T * b * L)
              , I = Math.min(O * L, 300);
            return s - z * ((S + T * b * M) * Math.sinh(I) + O * M * Math.cosh(I)) / O
        }
    }
    const R = {
        calculatedDuration: y && g || null,
        next: O => {
            const L = C(O);
            if (y)
                l.done = O >= g;
            else {
                let z = O === 0 ? S : 0;
                T < 1 && (z = O === 0 ? Wu(S) : iL(C, O, L));
                const I = Math.abs(z) <= n
                  , N = Math.abs(s - L) <= i;
                l.done = I && N
            }
            return l.value = l.done ? s : L,
            l
        }
        ,
        toString: () => {
            const O = Math.min(aA(R), LS)
              , L = nL(z => R.next(O * z).value, O, 30);
            return O + "ms " + L
        }
        ,
        toTransition: () => {}
    };
    return R
}
Zu.applyToOptions = r => {
    const e = QF(r, 100, Zu);
    return r.ease = e.ease,
    r.duration = Wu(e.duration),
    r.type = "keyframes",
    r
}
;
function ME({keyframes: r, velocity: e=0, power: t=.8, timeConstant: n=325, bounceDamping: i=10, bounceStiffness: a=500, modifyTarget: s, min: l, max: u, restDelta: f=.5, restSpeed: d}) {
    const g = r[0]
      , v = {
        done: !1,
        value: g
    }
      , y = I => l !== void 0 && I < l || u !== void 0 && I > u
      , S = I => l === void 0 ? u : u === void 0 || Math.abs(l - I) < Math.abs(u - I) ? l : u;
    let T = t * e;
    const M = g + T
      , b = s === void 0 ? M : s(M);
    b !== M && (T = b - g);
    const A = I => -T * Math.exp(-I / n)
      , C = I => b + A(I)
      , R = I => {
        const N = A(I)
          , P = C(I);
        v.done = Math.abs(N) <= f,
        v.value = v.done ? b : P
    }
    ;
    let O, L;
    const z = I => {
        y(v.value) && (O = I,
        L = Zu({
            keyframes: [v.value, S(v.value)],
            velocity: iL(C, I, v.value),
            damping: i,
            stiffness: a,
            restDelta: f,
            restSpeed: d
        }))
    }
    ;
    return z(0),
    {
        calculatedDuration: null,
        next: I => {
            let N = !1;
            return !L && O === void 0 && (N = !0,
            R(I),
            z(I)),
            O !== void 0 && I >= O ? L.next(I - O) : (!N && R(I),
            v)
        }
    }
}
function a6(r, e, t) {
    const n = []
      , i = t || Qc.mix || tL
      , a = r.length - 1;
    for (let s = 0; s < a; s++) {
        let l = i(r[s], r[s + 1]);
        if (e) {
            const u = Array.isArray(e) ? e[s] || Gs : e;
            l = t_(u, l)
        }
        n.push(l)
    }
    return n
}
function sA(r, e, {clamp: t=!0, ease: n, mixer: i}={}) {
    const a = r.length;
    if (qw(a === e.length),
    a === 1)
        return () => e[0];
    if (a === 2 && e[0] === e[1])
        return () => e[1];
    const s = r[0] === r[1];
    r[0] > r[a - 1] && (r = [...r].reverse(),
    e = [...e].reverse());
    const l = a6(e, n, i)
      , u = l.length
      , f = d => {
        if (s && d < r[0])
            return e[0];
        let g = 0;
        if (u > 1)
            for (; g < r.length - 2 && !(d < r[g + 1]); g++)
                ;
        const v = pg(r[g], r[g + 1], d);
        return l[g](v)
    }
    ;
    return t ? d => f(ec(r[0], r[a - 1], d)) : f
}
function s6(r, e) {
    const t = r[r.length - 1];
    for (let n = 1; n <= e; n++) {
        const i = pg(0, e, n);
        r.push(Ji(t, 1, i))
    }
}
function rL(r) {
    const e = [0];
    return s6(e, r.length - 1),
    e
}
function o6(r, e) {
    return r.map(t => t * e)
}
function l6(r, e) {
    return r.map( () => e || jN).splice(0, r.length - 1)
}
function kv({duration: r=300, keyframes: e, times: t, ease: n="easeInOut"}) {
    const i = SF(n) ? n.map(r3) : r3(n)
      , a = {
        done: !1,
        value: e[0]
    }
      , s = o6(t && t.length === e.length ? t : rL(e), r)
      , l = sA(s, e, {
        ease: Array.isArray(i) ? i : l6(e, i)
    });
    return {
        calculatedDuration: r,
        next: u => (a.value = l(u),
        a.done = u >= r,
        a)
    }
}
const u6 = r => r !== null;
function oA(r, {repeat: e, repeatType: t="loop"}, n, i=1) {
    const a = r.filter(u6)
      , l = i < 0 || e && t !== "loop" && e % 2 === 1 ? 0 : a.length - 1;
    return !l || n === void 0 ? a[l] : n
}
const c6 = {
    decay: ME,
    inertia: ME,
    tween: kv,
    keyframes: kv,
    spring: Zu
};
function aL(r) {
    typeof r.type == "string" && (r.type = c6[r.type])
}
class lA {
    constructor() {
        this.updateFinished()
    }
    get finished() {
        return this._finished
    }
    updateFinished() {
        this._finished = new Promise(e => {
            this.resolve = e
        }
        )
    }
    notifyFinished() {
        this.resolve()
    }
    then(e, t) {
        return this.finished.then(e, t)
    }
}
const f6 = r => r / 100;
class uA extends lA {
    constructor(e) {
        super(),
        this.state = "idle",
        this.startTime = null,
        this.isStopped = !1,
        this.currentTime = 0,
        this.holdTime = null,
        this.playbackSpeed = 1,
        this.stop = () => {
            var n, i;
            const {motionValue: t} = this.options;
            t && t.updatedAt !== ks.now() && this.tick(ks.now()),
            this.isStopped = !0,
            this.state !== "idle" && (this.teardown(),
            (i = (n = this.options).onStop) == null || i.call(n))
        }
        ,
        this.options = e,
        this.initAnimation(),
        this.play(),
        e.autoplay === !1 && this.pause()
    }
    initAnimation() {
        const {options: e} = this;
        aL(e);
        const {type: t=kv, repeat: n=0, repeatDelay: i=0, repeatType: a, velocity: s=0} = e;
        let {keyframes: l} = e;
        const u = t || kv;
        u !== kv && typeof l[0] != "number" && (this.mixKeyframes = t_(f6, tL(l[0], l[1])),
        l = [0, 100]);
        const f = u({
            ...e,
            keyframes: l
        });
        a === "mirror" && (this.mirroredGenerator = u({
            ...e,
            keyframes: [...l].reverse(),
            velocity: -s
        })),
        f.calculatedDuration === null && (f.calculatedDuration = aA(f));
        const {calculatedDuration: d} = f;
        this.calculatedDuration = d,
        this.resolvedDuration = d + i,
        this.totalDuration = this.resolvedDuration * (n + 1) - i,
        this.generator = f
    }
    updateTime(e) {
        const t = Math.round(e - this.startTime) * this.playbackSpeed;
        this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = t
    }
    tick(e, t=!1) {
        const {generator: n, totalDuration: i, mixKeyframes: a, mirroredGenerator: s, resolvedDuration: l, calculatedDuration: u} = this;
        if (this.startTime === null)
            return n.next(0);
        const {delay: f=0, keyframes: d, repeat: g, repeatType: v, repeatDelay: y, type: S, onUpdate: T, finalKeyframe: M} = this.options;
        this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - i / this.speed, this.startTime)),
        t ? this.currentTime = e : this.updateTime(e);
        const b = this.currentTime - f * (this.playbackSpeed >= 0 ? 1 : -1)
          , A = this.playbackSpeed >= 0 ? b < 0 : b > i;
        this.currentTime = Math.max(b, 0),
        this.state === "finished" && this.holdTime === null && (this.currentTime = i);
        let C = this.currentTime
          , R = n;
        if (g) {
            const I = Math.min(this.currentTime, i) / l;
            let N = Math.floor(I)
              , P = I % 1;
            !P && I >= 1 && (P = 1),
            P === 1 && N--,
            N = Math.min(N, g + 1),
            !!(N % 2) && (v === "reverse" ? (P = 1 - P,
            y && (P -= y / l)) : v === "mirror" && (R = s)),
            C = ec(0, 1, P) * l
        }
        const O = A ? {
            done: !1,
            value: d[0]
        } : R.next(C);
        a && (O.value = a(O.value));
        let {done: L} = O;
        !A && u !== null && (L = this.playbackSpeed >= 0 ? this.currentTime >= i : this.currentTime <= 0);
        const z = this.holdTime === null && (this.state === "finished" || this.state === "running" && L);
        return z && S !== ME && (O.value = oA(d, this.options, M, this.speed)),
        T && T(O.value),
        z && this.finish(),
        O
    }
    then(e, t) {
        return this.finished.then(e, t)
    }
    get duration() {
        return Yu(this.calculatedDuration)
    }
    get time() {
        return Yu(this.currentTime)
    }
    set time(e) {
        var t;
        e = Wu(e),
        this.currentTime = e,
        this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.playbackSpeed),
        (t = this.driver) == null || t.start(!1)
    }
    get speed() {
        return this.playbackSpeed
    }
    set speed(e) {
        this.updateTime(ks.now());
        const t = this.playbackSpeed !== e;
        this.playbackSpeed = e,
        t && (this.time = Yu(this.currentTime))
    }
    play() {
        var i, a;
        if (this.isStopped)
            return;
        const {driver: e=KF, startTime: t} = this.options;
        this.driver || (this.driver = e(s => this.tick(s))),
        (a = (i = this.options).onPlay) == null || a.call(i);
        const n = this.driver.now();
        this.state === "finished" ? (this.updateFinished(),
        this.startTime = n) : this.holdTime !== null ? this.startTime = n - this.holdTime : this.startTime || (this.startTime = t ?? n),
        this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration),
        this.holdTime = null,
        this.state = "running",
        this.driver.start()
    }
    pause() {
        this.state = "paused",
        this.updateTime(ks.now()),
        this.holdTime = this.currentTime
    }
    complete() {
        this.state !== "running" && this.play(),
        this.state = "finished",
        this.holdTime = null
    }
    finish() {
        var e, t;
        this.notifyFinished(),
        this.teardown(),
        this.state = "finished",
        (t = (e = this.options).onComplete) == null || t.call(e)
    }
    cancel() {
        var e, t;
        this.holdTime = null,
        this.startTime = 0,
        this.tick(0),
        this.teardown(),
        (t = (e = this.options).onCancel) == null || t.call(e)
    }
    teardown() {
        this.state = "idle",
        this.stopDriver(),
        this.startTime = this.holdTime = null
    }
    stopDriver() {
        this.driver && (this.driver.stop(),
        this.driver = void 0)
    }
    sample(e) {
        return this.startTime = 0,
        this.tick(e, !0)
    }
    attachTimeline(e) {
        var t;
        return this.options.allowFlatten && (this.options.type = "keyframes",
        this.options.ease = "linear",
        this.initAnimation()),
        (t = this.driver) == null || t.stop(),
        e.observe(this)
    }
}
function h6(r) {
    for (let e = 1; e < r.length; e++)
        r[e] ?? (r[e] = r[e - 1])
}
const Vd = r => r * 180 / Math.PI
  , TE = r => {
    const e = Vd(Math.atan2(r[1], r[0]));
    return EE(e)
}
  , d6 = {
    x: 4,
    y: 5,
    translateX: 4,
    translateY: 5,
    scaleX: 0,
    scaleY: 3,
    scale: r => (Math.abs(r[0]) + Math.abs(r[3])) / 2,
    rotate: TE,
    rotateZ: TE,
    skewX: r => Vd(Math.atan(r[1])),
    skewY: r => Vd(Math.atan(r[2])),
    skew: r => (Math.abs(r[1]) + Math.abs(r[2])) / 2
}
  , EE = r => (r = r % 360,
r < 0 && (r += 360),
r)
  , f3 = TE
  , h3 = r => Math.sqrt(r[0] * r[0] + r[1] * r[1])
  , d3 = r => Math.sqrt(r[4] * r[4] + r[5] * r[5])
  , p6 = {
    x: 12,
    y: 13,
    z: 14,
    translateX: 12,
    translateY: 13,
    translateZ: 14,
    scaleX: h3,
    scaleY: d3,
    scale: r => (h3(r) + d3(r)) / 2,
    rotateX: r => EE(Vd(Math.atan2(r[6], r[5]))),
    rotateY: r => EE(Vd(Math.atan2(-r[2], r[0]))),
    rotateZ: f3,
    rotate: f3,
    skewX: r => Vd(Math.atan(r[4])),
    skewY: r => Vd(Math.atan(r[1])),
    skew: r => (Math.abs(r[1]) + Math.abs(r[4])) / 2
};
function wE(r) {
    return r.includes("scale") ? 1 : 0
}
function AE(r, e) {
    if (!r || r === "none")
        return wE(e);
    const t = r.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
    let n, i;
    if (t)
        n = p6,
        i = t;
    else {
        const l = r.match(/^matrix\(([-\d.e\s,]+)\)$/u);
        n = d6,
        i = l
    }
    if (!i)
        return wE(e);
    const a = n[e]
      , s = i[1].split(",").map(g6);
    return typeof a == "function" ? a(s) : s[a]
}
const m6 = (r, e) => {
    const {transform: t="none"} = getComputedStyle(r);
    return AE(t, e)
}
;
function g6(r) {
    return parseFloat(r.trim())
}
const Hg = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
  , Vg = new Set(Hg)
  , p3 = r => r === Fg || r === _n
  , v6 = new Set(["x", "y", "z"])
  , y6 = Hg.filter(r => !v6.has(r));
function _6(r) {
    const e = [];
    return y6.forEach(t => {
        const n = r.getValue(t);
        n !== void 0 && (e.push([t, n.get()]),
        n.set(t.startsWith("scale") ? 1 : 0))
    }
    ),
    e
}
const Zd = {
    width: ({x: r}, {paddingLeft: e="0", paddingRight: t="0"}) => r.max - r.min - parseFloat(e) - parseFloat(t),
    height: ({y: r}, {paddingTop: e="0", paddingBottom: t="0"}) => r.max - r.min - parseFloat(e) - parseFloat(t),
    top: (r, {top: e}) => parseFloat(e),
    left: (r, {left: e}) => parseFloat(e),
    bottom: ({y: r}, {top: e}) => parseFloat(e) + (r.max - r.min),
    right: ({x: r}, {left: e}) => parseFloat(e) + (r.max - r.min),
    x: (r, {transform: e}) => AE(e, "x"),
    y: (r, {transform: e}) => AE(e, "y")
};
Zd.translateX = Zd.x;
Zd.translateY = Zd.y;
const Kd = new Set;
let CE = !1
  , RE = !1
  , DE = !1;
function sL() {
    if (RE) {
        const r = Array.from(Kd).filter(n => n.needsMeasurement)
          , e = new Set(r.map(n => n.element))
          , t = new Map;
        e.forEach(n => {
            const i = _6(n);
            i.length && (t.set(n, i),
            n.render())
        }
        ),
        r.forEach(n => n.measureInitialState()),
        e.forEach(n => {
            n.render();
            const i = t.get(n);
            i && i.forEach( ([a,s]) => {
                var l;
                (l = n.getValue(a)) == null || l.set(s)
            }
            )
        }
        ),
        r.forEach(n => n.measureEndState()),
        r.forEach(n => {
            n.suspendedScrollY !== void 0 && window.scrollTo(0, n.suspendedScrollY)
        }
        )
    }
    RE = !1,
    CE = !1,
    Kd.forEach(r => r.complete(DE)),
    Kd.clear()
}
function oL() {
    Kd.forEach(r => {
        r.readKeyframes(),
        r.needsMeasurement && (RE = !0)
    }
    )
}
function x6() {
    DE = !0,
    oL(),
    sL(),
    DE = !1
}
class cA {
    constructor(e, t, n, i, a, s=!1) {
        this.state = "pending",
        this.isAsync = !1,
        this.needsMeasurement = !1,
        this.unresolvedKeyframes = [...e],
        this.onComplete = t,
        this.name = n,
        this.motionValue = i,
        this.element = a,
        this.isAsync = s
    }
    scheduleResolve() {
        this.state = "scheduled",
        this.isAsync ? (Kd.add(this),
        CE || (CE = !0,
        wi.read(oL),
        wi.resolveKeyframes(sL))) : (this.readKeyframes(),
        this.complete())
    }
    readKeyframes() {
        const {unresolvedKeyframes: e, name: t, element: n, motionValue: i} = this;
        if (e[0] === null) {
            const a = i == null ? void 0 : i.get()
              , s = e[e.length - 1];
            if (a !== void 0)
                e[0] = a;
            else if (n && t) {
                const l = n.readValue(t, s);
                l != null && (e[0] = l)
            }
            e[0] === void 0 && (e[0] = s),
            i && a === void 0 && i.set(e[0])
        }
        h6(e)
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete(e=!1) {
        this.state = "complete",
        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, e),
        Kd.delete(this)
    }
    cancel() {
        this.state === "scheduled" && (Kd.delete(this),
        this.state = "pending")
    }
    resume() {
        this.state === "pending" && this.scheduleResolve()
    }
}
const S6 = r => r.startsWith("--");
function b6(r, e, t) {
    S6(e) ? r.style.setProperty(e, t) : r.style[e] = t
}
const lL = Zw( () => window.ScrollTimeline !== void 0)
  , M6 = {};
function T6(r, e) {
    const t = Zw(r);
    return () => M6[e] ?? t()
}
const uL = T6( () => {
    try {
        document.createElement("div").animate({
            opacity: 0
        }, {
            easing: "linear(0, 1)"
        })
    } catch {
        return !1
    }
    return !0
}
, "linearEasing")
  , Rv = ([r,e,t,n]) => `cubic-bezier(${r}, ${e}, ${t}, ${n})`
  , m3 = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: Rv([0, .65, .55, 1]),
    circOut: Rv([.55, 0, 1, .45]),
    backIn: Rv([.31, .01, .66, -.59]),
    backOut: Rv([.33, 1.53, .69, .99])
};
function cL(r, e) {
    if (r)
        return typeof r == "function" ? uL() ? nL(r, e) : "ease-out" : WN(r) ? Rv(r) : Array.isArray(r) ? r.map(t => cL(t, e) || m3.easeOut) : m3[r]
}
function E6(r, e, t, {delay: n=0, duration: i=300, repeat: a=0, repeatType: s="loop", ease: l="easeOut", times: u}={}, f=void 0) {
    const d = {
        [e]: t
    };
    u && (d.offset = u);
    const g = cL(l, i);
    Array.isArray(g) && (d.easing = g);
    const v = {
        delay: n,
        duration: i,
        easing: Array.isArray(g) ? "linear" : g,
        fill: "both",
        iterations: a + 1,
        direction: s === "reverse" ? "alternate" : "normal"
    };
    return f && (v.pseudoElement = f),
    r.animate(d, v)
}
function fL(r) {
    return typeof r == "function" && "applyToOptions"in r
}
function w6({type: r, ...e}) {
    return fL(r) && uL() ? r.applyToOptions(e) : (e.duration ?? (e.duration = 300),
    e.ease ?? (e.ease = "easeOut"),
    e)
}
class A6 extends lA {
    constructor(e) {
        if (super(),
        this.finishedTime = null,
        this.isStopped = !1,
        !e)
            return;
        const {element: t, name: n, keyframes: i, pseudoElement: a, allowFlatten: s=!1, finalKeyframe: l, onComplete: u} = e;
        this.isPseudoElement = !!a,
        this.allowFlatten = s,
        this.options = e,
        qw(typeof e.type != "string");
        const f = w6(e);
        this.animation = E6(t, n, i, f, a),
        f.autoplay === !1 && this.animation.pause(),
        this.animation.onfinish = () => {
            if (this.finishedTime = this.time,
            !a) {
                const d = oA(i, this.options, l, this.speed);
                this.updateMotionValue ? this.updateMotionValue(d) : b6(t, n, d),
                this.animation.cancel()
            }
            u == null || u(),
            this.notifyFinished()
        }
    }
    play() {
        this.isStopped || (this.animation.play(),
        this.state === "finished" && this.updateFinished())
    }
    pause() {
        this.animation.pause()
    }
    complete() {
        var e, t;
        (t = (e = this.animation).finish) == null || t.call(e)
    }
    cancel() {
        try {
            this.animation.cancel()
        } catch {}
    }
    stop() {
        if (this.isStopped)
            return;
        this.isStopped = !0;
        const {state: e} = this;
        e === "idle" || e === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(),
        this.isPseudoElement || this.cancel())
    }
    commitStyles() {
        var e, t;
        this.isPseudoElement || (t = (e = this.animation).commitStyles) == null || t.call(e)
    }
    get duration() {
        var t, n;
        const e = ((n = (t = this.animation.effect) == null ? void 0 : t.getComputedTiming) == null ? void 0 : n.call(t).duration) || 0;
        return Yu(Number(e))
    }
    get time() {
        return Yu(Number(this.animation.currentTime) || 0)
    }
    set time(e) {
        this.finishedTime = null,
        this.animation.currentTime = Wu(e)
    }
    get speed() {
        return this.animation.playbackRate
    }
    set speed(e) {
        e < 0 && (this.finishedTime = null),
        this.animation.playbackRate = e
    }
    get state() {
        return this.finishedTime !== null ? "finished" : this.animation.playState
    }
    get startTime() {
        return Number(this.animation.startTime)
    }
    set startTime(e) {
        this.animation.startTime = e
    }
    attachTimeline({timeline: e, observe: t}) {
        var n;
        return this.allowFlatten && ((n = this.animation.effect) == null || n.updateTiming({
            easing: "linear"
        })),
        this.animation.onfinish = null,
        e && lL() ? (this.animation.timeline = e,
        Gs) : t(this)
    }
}
const hL = {
    anticipate: kN,
    backInOut: VN,
    circInOut: XN
};
function C6(r) {
    return r in hL
}
function R6(r) {
    typeof r.ease == "string" && C6(r.ease) && (r.ease = hL[r.ease])
}
const g3 = 10;
class D6 extends A6 {
    constructor(e) {
        R6(e),
        aL(e),
        super(e),
        e.startTime && (this.startTime = e.startTime),
        this.options = e
    }
    updateMotionValue(e) {
        const {motionValue: t, onUpdate: n, onComplete: i, element: a, ...s} = this.options;
        if (!t)
            return;
        if (e !== void 0) {
            t.set(e);
            return
        }
        const l = new uA({
            ...s,
            autoplay: !1
        })
          , u = Wu(this.finishedTime ?? this.time);
        t.setWithVelocity(l.sample(u - g3).value, l.sample(u).value, g3),
        l.stop()
    }
}
const v3 = (r, e) => e === "zIndex" ? !1 : !!(typeof r == "number" || Array.isArray(r) || typeof r == "string" && (mh.test(r) || r === "0") && !r.startsWith("url("));
function U6(r) {
    const e = r[0];
    if (r.length === 1)
        return !0;
    for (let t = 0; t < r.length; t++)
        if (r[t] !== e)
            return !0
}
function O6(r, e, t, n) {
    const i = r[0];
    if (i === null)
        return !1;
    if (e === "display" || e === "visibility")
        return !0;
    const a = r[r.length - 1]
      , s = v3(i, e)
      , l = v3(a, e);
    return !s || !l ? !1 : U6(r) || (t === "spring" || fL(t)) && n
}
function qb(r) {
    return PN(r) && "offsetHeight"in r
}
const N6 = new Set(["opacity", "clipPath", "filter", "transform"])
  , L6 = Zw( () => Object.hasOwnProperty.call(Element.prototype, "animate"));
function P6(r) {
    var f;
    const {motionValue: e, name: t, repeatDelay: n, repeatType: i, damping: a, type: s} = r;
    if (!qb((f = e == null ? void 0 : e.owner) == null ? void 0 : f.current))
        return !1;
    const {onUpdate: l, transformTemplate: u} = e.owner.getProps();
    return L6() && t && N6.has(t) && (t !== "transform" || !u) && !l && !n && i !== "mirror" && a !== 0 && s !== "inertia"
}
const B6 = 40;
class z6 extends lA {
    constructor({autoplay: e=!0, delay: t=0, type: n="keyframes", repeat: i=0, repeatDelay: a=0, repeatType: s="loop", keyframes: l, name: u, motionValue: f, element: d, ...g}) {
        var S;
        super(),
        this.stop = () => {
            var T, M;
            this._animation && (this._animation.stop(),
            (T = this.stopTimeline) == null || T.call(this)),
            (M = this.keyframeResolver) == null || M.cancel()
        }
        ,
        this.createdAt = ks.now();
        const v = {
            autoplay: e,
            delay: t,
            type: n,
            repeat: i,
            repeatDelay: a,
            repeatType: s,
            name: u,
            motionValue: f,
            element: d,
            ...g
        }
          , y = (d == null ? void 0 : d.KeyframeResolver) || cA;
        this.keyframeResolver = new y(l, (T, M, b) => this.onKeyframesResolved(T, M, v, !b),u,f,d),
        (S = this.keyframeResolver) == null || S.scheduleResolve()
    }
    onKeyframesResolved(e, t, n, i) {
        this.keyframeResolver = void 0;
        const {name: a, type: s, velocity: l, delay: u, isHandoff: f, onUpdate: d} = n;
        this.resolvedAt = ks.now(),
        O6(e, a, s, l) || ((Qc.instantAnimations || !u) && (d == null || d(oA(e, n, t))),
        e[0] = e[e.length - 1],
        n.duration = 0,
        n.repeat = 0);
        const v = {
            startTime: i ? this.resolvedAt ? this.resolvedAt - this.createdAt > B6 ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
            finalKeyframe: t,
            ...n,
            keyframes: e
        }
          , y = !f && P6(v) ? new D6({
            ...v,
            element: v.motionValue.owner.current
        }) : new uA(v);
        y.finished.then( () => this.notifyFinished()).catch(Gs),
        this.pendingTimeline && (this.stopTimeline = y.attachTimeline(this.pendingTimeline),
        this.pendingTimeline = void 0),
        this._animation = y
    }
    get finished() {
        return this._animation ? this.animation.finished : this._finished
    }
    then(e, t) {
        return this.finished.finally(e).then( () => {}
        )
    }
    get animation() {
        var e;
        return this._animation || ((e = this.keyframeResolver) == null || e.resume(),
        x6()),
        this._animation
    }
    get duration() {
        return this.animation.duration
    }
    get time() {
        return this.animation.time
    }
    set time(e) {
        this.animation.time = e
    }
    get speed() {
        return this.animation.speed
    }
    get state() {
        return this.animation.state
    }
    set speed(e) {
        this.animation.speed = e
    }
    get startTime() {
        return this.animation.startTime
    }
    attachTimeline(e) {
        return this._animation ? this.stopTimeline = this.animation.attachTimeline(e) : this.pendingTimeline = e,
        () => this.stop()
    }
    play() {
        this.animation.play()
    }
    pause() {
        this.animation.pause()
    }
    complete() {
        this.animation.complete()
    }
    cancel() {
        var e;
        this._animation && this.animation.cancel(),
        (e = this.keyframeResolver) == null || e.cancel()
    }
}
const I6 = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function F6(r) {
    const e = I6.exec(r);
    if (!e)
        return [, ];
    const [,t,n,i] = e;
    return [`--${t ?? n}`, i]
}
function dL(r, e, t=1) {
    const [n,i] = F6(r);
    if (!n)
        return;
    const a = window.getComputedStyle(e).getPropertyValue(n);
    if (a) {
        const s = a.trim();
        return LN(s) ? parseFloat(s) : s
    }
    return tA(i) ? dL(i, e, t + 1) : i
}
function fA(r, e) {
    return (r == null ? void 0 : r[e]) ?? (r == null ? void 0 : r.default) ?? r
}
const pL = new Set(["width", "height", "top", "left", "right", "bottom", ...Hg])
  , H6 = {
    test: r => r === "auto",
    parse: r => r
}
  , mL = r => e => e.test(r)
  , gL = [Fg, _n, qu, $f, LF, NF, H6]
  , y3 = r => gL.find(mL(r));
function V6(r) {
    return typeof r == "number" ? r === 0 : r !== null ? r === "none" || r === "0" || BN(r) : !0
}
const k6 = new Set(["brightness", "contrast", "saturate", "opacity"]);
function G6(r) {
    const [e,t] = r.slice(0, -1).split("(");
    if (e === "drop-shadow")
        return r;
    const [n] = t.match(nA) || [];
    if (!n)
        return r;
    const i = t.replace(n, "");
    let a = k6.has(e) ? 1 : 0;
    return n !== t && (a *= 100),
    e + "(" + a + i + ")"
}
const X6 = /\b([a-z-]*)\(.*?\)/gu
  , UE = {
    ...mh,
    getAnimatableNone: r => {
        const e = r.match(X6);
        return e ? e.map(G6).join(" ") : r
    }
}
  , _3 = {
    ...Fg,
    transform: Math.round
}
  , j6 = {
    rotate: $f,
    rotateX: $f,
    rotateY: $f,
    rotateZ: $f,
    scale: Y1,
    scaleX: Y1,
    scaleY: Y1,
    scaleZ: Y1,
    skew: $f,
    skewX: $f,
    skewY: $f,
    distance: _n,
    translateX: _n,
    translateY: _n,
    translateZ: _n,
    x: _n,
    y: _n,
    z: _n,
    perspective: _n,
    transformPerspective: _n,
    opacity: Sy,
    originX: a3,
    originY: a3,
    originZ: _n
}
  , hA = {
    borderWidth: _n,
    borderTopWidth: _n,
    borderRightWidth: _n,
    borderBottomWidth: _n,
    borderLeftWidth: _n,
    borderRadius: _n,
    radius: _n,
    borderTopLeftRadius: _n,
    borderTopRightRadius: _n,
    borderBottomRightRadius: _n,
    borderBottomLeftRadius: _n,
    width: _n,
    maxWidth: _n,
    height: _n,
    maxHeight: _n,
    top: _n,
    right: _n,
    bottom: _n,
    left: _n,
    padding: _n,
    paddingTop: _n,
    paddingRight: _n,
    paddingBottom: _n,
    paddingLeft: _n,
    margin: _n,
    marginTop: _n,
    marginRight: _n,
    marginBottom: _n,
    marginLeft: _n,
    backgroundPositionX: _n,
    backgroundPositionY: _n,
    ...j6,
    zIndex: _3,
    fillOpacity: Sy,
    strokeOpacity: Sy,
    numOctaves: _3
}
  , W6 = {
    ...hA,
    color: La,
    backgroundColor: La,
    outlineColor: La,
    fill: La,
    stroke: La,
    borderColor: La,
    borderTopColor: La,
    borderRightColor: La,
    borderBottomColor: La,
    borderLeftColor: La,
    filter: UE,
    WebkitFilter: UE
}
  , vL = r => W6[r];
function yL(r, e) {
    let t = vL(r);
    return t !== UE && (t = mh),
    t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
}
const Y6 = new Set(["auto", "none", "0"]);
function q6(r, e, t) {
    let n = 0, i;
    for (; n < r.length && !i; ) {
        const a = r[n];
        typeof a == "string" && !Y6.has(a) && by(a).values.length && (i = r[n]),
        n++
    }
    if (i && t)
        for (const a of e)
            r[a] = yL(t, i)
}
class Z6 extends cA {
    constructor(e, t, n, i, a) {
        super(e, t, n, i, a, !0)
    }
    readKeyframes() {
        const {unresolvedKeyframes: e, element: t, name: n} = this;
        if (!t || !t.current)
            return;
        super.readKeyframes();
        for (let u = 0; u < e.length; u++) {
            let f = e[u];
            if (typeof f == "string" && (f = f.trim(),
            tA(f))) {
                const d = dL(f, t.current);
                d !== void 0 && (e[u] = d),
                u === e.length - 1 && (this.finalKeyframe = f)
            }
        }
        if (this.resolveNoneKeyframes(),
        !pL.has(n) || e.length !== 2)
            return;
        const [i,a] = e
          , s = y3(i)
          , l = y3(a);
        if (s !== l)
            if (p3(s) && p3(l))
                for (let u = 0; u < e.length; u++) {
                    const f = e[u];
                    typeof f == "string" && (e[u] = parseFloat(f))
                }
            else
                Zd[n] && (this.needsMeasurement = !0)
    }
    resolveNoneKeyframes() {
        const {unresolvedKeyframes: e, name: t} = this
          , n = [];
        for (let i = 0; i < e.length; i++)
            (e[i] === null || V6(e[i])) && n.push(i);
        n.length && q6(e, n, t)
    }
    measureInitialState() {
        const {element: e, unresolvedKeyframes: t, name: n} = this;
        if (!e || !e.current)
            return;
        n === "height" && (this.suspendedScrollY = window.pageYOffset),
        this.measuredOrigin = Zd[n](e.measureViewportBox(), window.getComputedStyle(e.current)),
        t[0] = this.measuredOrigin;
        const i = t[t.length - 1];
        i !== void 0 && e.getValue(n, i).jump(i, !1)
    }
    measureEndState() {
        var l;
        const {element: e, name: t, unresolvedKeyframes: n} = this;
        if (!e || !e.current)
            return;
        const i = e.getValue(t);
        i && i.jump(this.measuredOrigin, !1);
        const a = n.length - 1
          , s = n[a];
        n[a] = Zd[t](e.measureViewportBox(), window.getComputedStyle(e.current)),
        s !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = s),
        (l = this.removedTransforms) != null && l.length && this.removedTransforms.forEach( ([u,f]) => {
            e.getValue(u).set(f)
        }
        ),
        this.resolveNoneKeyframes()
    }
}
function dA(r, e, t) {
    if (r instanceof EventTarget)
        return [r];
    if (typeof r == "string") {
        const i = document.querySelectorAll(r);
        return i ? Array.from(i) : []
    }
    return Array.from(r)
}
const _L = (r, e) => e && typeof r == "number" ? e.transform(r) : r
  , x3 = 30
  , K6 = r => !isNaN(parseFloat(r))
  , Gv = {
    current: void 0
};
class Q6 {
    constructor(e, t={}) {
        this.canTrackVelocity = null,
        this.events = {},
        this.updateAndNotify = (n, i=!0) => {
            var s, l;
            const a = ks.now();
            if (this.updatedAt !== a && this.setPrevFrameValue(),
            this.prev = this.current,
            this.setCurrent(n),
            this.current !== this.prev && ((s = this.events.change) == null || s.notify(this.current),
            this.dependents))
                for (const u of this.dependents)
                    u.dirty();
            i && ((l = this.events.renderRequest) == null || l.notify(this.current))
        }
        ,
        this.hasAnimated = !1,
        this.setCurrent(e),
        this.owner = t.owner
    }
    setCurrent(e) {
        this.current = e,
        this.updatedAt = ks.now(),
        this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = K6(this.current))
    }
    setPrevFrameValue(e=this.current) {
        this.prevFrameValue = e,
        this.prevUpdatedAt = this.updatedAt
    }
    onChange(e) {
        return this.on("change", e)
    }
    on(e, t) {
        this.events[e] || (this.events[e] = new Kw);
        const n = this.events[e].add(t);
        return e === "change" ? () => {
            n(),
            wi.read( () => {
                this.events.change.getSize() || this.stop()
            }
            )
        }
        : n
    }
    clearListeners() {
        for (const e in this.events)
            this.events[e].clear()
    }
    attach(e, t) {
        this.passiveEffect = e,
        this.stopPassiveEffect = t
    }
    set(e, t=!0) {
        !t || !this.passiveEffect ? this.updateAndNotify(e, t) : this.passiveEffect(e, this.updateAndNotify)
    }
    setWithVelocity(e, t, n) {
        this.set(t),
        this.prev = void 0,
        this.prevFrameValue = e,
        this.prevUpdatedAt = this.updatedAt - n
    }
    jump(e, t=!0) {
        this.updateAndNotify(e),
        this.prev = e,
        this.prevUpdatedAt = this.prevFrameValue = void 0,
        t && this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
    dirty() {
        var e;
        (e = this.events.change) == null || e.notify(this.current)
    }
    addDependent(e) {
        this.dependents || (this.dependents = new Set),
        this.dependents.add(e)
    }
    removeDependent(e) {
        this.dependents && this.dependents.delete(e)
    }
    get() {
        return Gv.current && Gv.current.push(this),
        this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        const e = ks.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > x3)
            return 0;
        const t = Math.min(this.updatedAt - this.prevUpdatedAt, x3);
        return Qw(parseFloat(this.current) - parseFloat(this.prevFrameValue), t)
    }
    start(e) {
        return this.stop(),
        new Promise(t => {
            this.hasAnimated = !0,
            this.animation = e(t),
            this.events.animationStart && this.events.animationStart.notify()
        }
        ).then( () => {
            this.events.animationComplete && this.events.animationComplete.notify(),
            this.clearAnimation()
        }
        )
    }
    stop() {
        this.animation && (this.animation.stop(),
        this.events.animationCancel && this.events.animationCancel.notify()),
        this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        delete this.animation
    }
    destroy() {
        var e, t;
        (e = this.dependents) == null || e.clear(),
        (t = this.events.destroy) == null || t.notify(),
        this.clearListeners(),
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
}
function ql(r, e) {
    return new Q6(r,e)
}
const {schedule: pA} = YN(queueMicrotask, !1)
  , jl = {
    x: !1,
    y: !1
};
function xL() {
    return jl.x || jl.y
}
function J6(r) {
    return r === "x" || r === "y" ? jl[r] ? null : (jl[r] = !0,
    () => {
        jl[r] = !1
    }
    ) : jl.x || jl.y ? null : (jl.x = jl.y = !0,
    () => {
        jl.x = jl.y = !1
    }
    )
}
function SL(r, e) {
    const t = dA(r)
      , n = new AbortController
      , i = {
        passive: !0,
        ...e,
        signal: n.signal
    };
    return [t, i, () => n.abort()]
}
function S3(r) {
    return !(r.pointerType === "touch" || xL())
}
function $6(r, e, t={}) {
    const [n,i,a] = SL(r, t)
      , s = l => {
        if (!S3(l))
            return;
        const {target: u} = l
          , f = e(u, l);
        if (typeof f != "function" || !u)
            return;
        const d = g => {
            S3(g) && (f(g),
            u.removeEventListener("pointerleave", d))
        }
        ;
        u.addEventListener("pointerleave", d, i)
    }
    ;
    return n.forEach(l => {
        l.addEventListener("pointerenter", s, i)
    }
    ),
    a
}
const bL = (r, e) => e ? r === e ? !0 : bL(r, e.parentElement) : !1
  , mA = r => r.pointerType === "mouse" ? typeof r.button != "number" || r.button <= 0 : r.isPrimary !== !1
  , e8 = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);
function t8(r) {
    return e8.has(r.tagName) || r.tabIndex !== -1
}
const lS = new WeakSet;
function b3(r) {
    return e => {
        e.key === "Enter" && r(e)
    }
}
function N2(r, e) {
    r.dispatchEvent(new PointerEvent("pointer" + e,{
        isPrimary: !0,
        bubbles: !0
    }))
}
const n8 = (r, e) => {
    const t = r.currentTarget;
    if (!t)
        return;
    const n = b3( () => {
        if (lS.has(t))
            return;
        N2(t, "down");
        const i = b3( () => {
            N2(t, "up")
        }
        )
          , a = () => N2(t, "cancel");
        t.addEventListener("keyup", i, e),
        t.addEventListener("blur", a, e)
    }
    );
    t.addEventListener("keydown", n, e),
    t.addEventListener("blur", () => t.removeEventListener("keydown", n), e)
}
;
function M3(r) {
    return mA(r) && !xL()
}
function i8(r, e, t={}) {
    const [n,i,a] = SL(r, t)
      , s = l => {
        const u = l.currentTarget;
        if (!M3(l))
            return;
        lS.add(u);
        const f = e(u, l)
          , d = (y, S) => {
            window.removeEventListener("pointerup", g),
            window.removeEventListener("pointercancel", v),
            lS.has(u) && lS.delete(u),
            M3(y) && typeof f == "function" && f(y, {
                success: S
            })
        }
          , g = y => {
            d(y, u === window || u === document || t.useGlobalTarget || bL(u, y.target))
        }
          , v = y => {
            d(y, !1)
        }
        ;
        window.addEventListener("pointerup", g, i),
        window.addEventListener("pointercancel", v, i)
    }
    ;
    return n.forEach(l => {
        (t.useGlobalTarget ? window : l).addEventListener("pointerdown", s, i),
        qb(l) && (l.addEventListener("focus", f => n8(f, i)),
        !t8(l) && !l.hasAttribute("tabindex") && (l.tabIndex = 0))
    }
    ),
    a
}
function ML(r, e) {
    let t;
    const n = () => {
        const {currentTime: i} = e
          , s = (i === null ? 0 : i.value) / 100;
        t !== s && r(s),
        t = s
    }
    ;
    return wi.preUpdate(n, !0),
    () => Ql(n)
}
function gA(r) {
    return PN(r) && "ownerSVGElement"in r
}
function r8(r) {
    return gA(r) && r.tagName === "svg"
}
function a8(...r) {
    const e = !Array.isArray(r[0])
      , t = e ? 0 : -1
      , n = r[0 + t]
      , i = r[1 + t]
      , a = r[2 + t]
      , s = r[3 + t]
      , l = sA(i, a, s);
    return e ? l(n) : l
}
const Ia = r => !!(r && r.getVelocity)
  , s8 = [...gL, La, mh]
  , o8 = r => s8.find(mL(r))
  , Zb = de.createContext({
    transformPagePoint: r => r,
    isStatic: !1,
    reducedMotion: "never"
});
class l8 extends de.Component {
    getSnapshotBeforeUpdate(e) {
        const t = this.props.childRef.current;
        if (t && e.isPresent && !this.props.isPresent) {
            const n = t.offsetParent
              , i = qb(n) && n.offsetWidth || 0
              , a = this.props.sizeRef.current;
            a.height = t.offsetHeight || 0,
            a.width = t.offsetWidth || 0,
            a.top = t.offsetTop,
            a.left = t.offsetLeft,
            a.right = i - a.width - a.left
        }
        return null
    }
    componentDidUpdate() {}
    render() {
        return this.props.children
    }
}
function u8({children: r, isPresent: e, anchorX: t}) {
    const n = de.useId()
      , i = de.useRef(null)
      , a = de.useRef({
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        right: 0
    })
      , {nonce: s} = de.useContext(Zb);
    return de.useInsertionEffect( () => {
        const {width: l, height: u, top: f, left: d, right: g} = a.current;
        if (e || !i.current || !l || !u)
            return;
        const v = t === "left" ? `left: ${d}` : `right: ${g}`;
        i.current.dataset.motionPopId = n;
        const y = document.createElement("style");
        return s && (y.nonce = s),
        document.head.appendChild(y),
        y.sheet && y.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${l}px !important;
            height: ${u}px !important;
            ${v}px !important;
            top: ${f}px !important;
          }
        `),
        () => {
            document.head.contains(y) && document.head.removeChild(y)
        }
    }
    , [e]),
    ae.jsx(l8, {
        isPresent: e,
        childRef: i,
        sizeRef: a,
        children: de.cloneElement(r, {
            ref: i
        })
    })
}
const c8 = ({children: r, initial: e, isPresent: t, onExitComplete: n, custom: i, presenceAffectsLayout: a, mode: s, anchorX: l}) => {
    const u = Ig(f8)
      , f = de.useId();
    let d = !0
      , g = de.useMemo( () => (d = !1,
    {
        id: f,
        initial: e,
        isPresent: t,
        custom: i,
        onExitComplete: v => {
            u.set(v, !0);
            for (const y of u.values())
                if (!y)
                    return;
            n && n()
        }
        ,
        register: v => (u.set(v, !1),
        () => u.delete(v))
    }), [t, u, n]);
    return a && d && (g = {
        ...g
    }),
    de.useMemo( () => {
        u.forEach( (v, y) => u.set(y, !1))
    }
    , [t]),
    de.useEffect( () => {
        !t && !u.size && n && n()
    }
    , [t]),
    s === "popLayout" && (r = ae.jsx(u8, {
        isPresent: t,
        anchorX: l,
        children: r
    })),
    ae.jsx(Yb.Provider, {
        value: g,
        children: r
    })
}
;
function f8() {
    return new Map
}
function TL(r=!0) {
    const e = de.useContext(Yb);
    if (e === null)
        return [!0, null];
    const {isPresent: t, onExitComplete: n, register: i} = e
      , a = de.useId();
    de.useEffect( () => {
        if (r)
            return i(a)
    }
    , [r]);
    const s = de.useCallback( () => r && n && n(a), [a, n, r]);
    return !t && n ? [!1, s] : [!0]
}
const q1 = r => r.key || "";
function T3(r) {
    const e = [];
    return de.Children.forEach(r, t => {
        de.isValidElement(t) && e.push(t)
    }
    ),
    e
}
const h8 = ({children: r, custom: e, initial: t=!0, onExitComplete: n, presenceAffectsLayout: i=!0, mode: a="sync", propagate: s=!1, anchorX: l="left"}) => {
    const [u,f] = TL(s)
      , d = de.useMemo( () => T3(r), [r])
      , g = s && !u ? [] : d.map(q1)
      , v = de.useRef(!0)
      , y = de.useRef(d)
      , S = Ig( () => new Map)
      , [T,M] = de.useState(d)
      , [b,A] = de.useState(d);
    Wb( () => {
        v.current = !1,
        y.current = d;
        for (let O = 0; O < b.length; O++) {
            const L = q1(b[O]);
            g.includes(L) ? S.delete(L) : S.get(L) !== !0 && S.set(L, !1)
        }
    }
    , [b, g.length, g.join("-")]);
    const C = [];
    if (d !== T) {
        let O = [...d];
        for (let L = 0; L < b.length; L++) {
            const z = b[L]
              , I = q1(z);
            g.includes(I) || (O.splice(L, 0, z),
            C.push(z))
        }
        return a === "wait" && C.length && (O = C),
        A(T3(O)),
        M(d),
        null
    }
    const {forceRender: R} = de.useContext(Xw);
    return ae.jsx(ae.Fragment, {
        children: b.map(O => {
            const L = q1(O)
              , z = s && !u ? !1 : d === b || g.includes(L)
              , I = () => {
                if (S.has(L))
                    S.set(L, !0);
                else
                    return;
                let N = !0;
                S.forEach(P => {
                    P || (N = !1)
                }
                ),
                N && (R == null || R(),
                A(y.current),
                s && (f == null || f()),
                n && n())
            }
            ;
            return ae.jsx(c8, {
                isPresent: z,
                initial: !v.current || t ? void 0 : !1,
                custom: e,
                presenceAffectsLayout: i,
                mode: a,
                onExitComplete: z ? void 0 : I,
                anchorX: l,
                children: O
            }, L)
        }
        )
    })
}
  , EL = de.createContext({
    strict: !1
})
  , E3 = {
    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
}
  , mg = {};
for (const r in E3)
    mg[r] = {
        isEnabled: e => E3[r].some(t => !!e[t])
    };
function d8(r) {
    for (const e in r)
        mg[e] = {
            ...mg[e],
            ...r[e]
        }
}
const p8 = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);
function PS(r) {
    return r.startsWith("while") || r.startsWith("drag") && r !== "draggable" || r.startsWith("layout") || r.startsWith("onTap") || r.startsWith("onPan") || r.startsWith("onLayout") || p8.has(r)
}
let wL = r => !PS(r);
function m8(r) {
    r && (wL = e => e.startsWith("on") ? !PS(e) : r(e))
}
try {
    m8(require("@emotion/is-prop-valid").default)
} catch {}
function g8(r, e, t) {
    const n = {};
    for (const i in r)
        i === "values" && typeof r.values == "object" || (wL(i) || t === !0 && PS(i) || !e && !PS(i) || r.draggable && i.startsWith("onDrag")) && (n[i] = r[i]);
    return n
}
function v8(r) {
    if (typeof Proxy > "u")
        return r;
    const e = new Map
      , t = (...n) => r(...n);
    return new Proxy(t,{
        get: (n, i) => i === "create" ? r : (e.has(i) || e.set(i, r(i)),
        e.get(i))
    })
}
const Kb = de.createContext({});
function Qb(r) {
    return r !== null && typeof r == "object" && typeof r.start == "function"
}
function My(r) {
    return typeof r == "string" || Array.isArray(r)
}
const vA = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
  , yA = ["initial", ...vA];
function Jb(r) {
    return Qb(r.animate) || yA.some(e => My(r[e]))
}
function AL(r) {
    return !!(Jb(r) || r.variants)
}
function y8(r, e) {
    if (Jb(r)) {
        const {initial: t, animate: n} = r;
        return {
            initial: t === !1 || My(t) ? t : void 0,
            animate: My(n) ? n : void 0
        }
    }
    return r.inherit !== !1 ? e : {}
}
function _8(r) {
    const {initial: e, animate: t} = y8(r, de.useContext(Kb));
    return de.useMemo( () => ({
        initial: e,
        animate: t
    }), [w3(e), w3(t)])
}
function w3(r) {
    return Array.isArray(r) ? r.join(" ") : r
}
const x8 = Symbol.for("motionComponentSymbol");
function Zm(r) {
    return r && typeof r == "object" && Object.prototype.hasOwnProperty.call(r, "current")
}
function S8(r, e, t) {
    return de.useCallback(n => {
        n && r.onMount && r.onMount(n),
        e && (n ? e.mount(n) : e.unmount()),
        t && (typeof t == "function" ? t(n) : Zm(t) && (t.current = n))
    }
    , [e])
}
const _A = r => r.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase()
  , b8 = "framerAppearId"
  , CL = "data-" + _A(b8)
  , RL = de.createContext({});
function M8(r, e, t, n, i) {
    var T, M;
    const {visualElement: a} = de.useContext(Kb)
      , s = de.useContext(EL)
      , l = de.useContext(Yb)
      , u = de.useContext(Zb).reducedMotion
      , f = de.useRef(null);
    n = n || s.renderer,
    !f.current && n && (f.current = n(r, {
        visualState: e,
        parent: a,
        props: t,
        presenceContext: l,
        blockInitialAnimation: l ? l.initial === !1 : !1,
        reducedMotionConfig: u
    }));
    const d = f.current
      , g = de.useContext(RL);
    d && !d.projection && i && (d.type === "html" || d.type === "svg") && T8(f.current, t, i, g);
    const v = de.useRef(!1);
    de.useInsertionEffect( () => {
        d && v.current && d.update(t, l)
    }
    );
    const y = t[CL]
      , S = de.useRef(!!y && !((T = window.MotionHandoffIsComplete) != null && T.call(window, y)) && ((M = window.MotionHasOptimisedAnimation) == null ? void 0 : M.call(window, y)));
    return Wb( () => {
        d && (v.current = !0,
        window.MotionIsMounted = !0,
        d.updateFeatures(),
        pA.render(d.render),
        S.current && d.animationState && d.animationState.animateChanges())
    }
    ),
    de.useEffect( () => {
        d && (!S.current && d.animationState && d.animationState.animateChanges(),
        S.current && (queueMicrotask( () => {
            var b;
            (b = window.MotionHandoffMarkAsComplete) == null || b.call(window, y)
        }
        ),
        S.current = !1))
    }
    ),
    d
}
function T8(r, e, t, n) {
    const {layoutId: i, layout: a, drag: s, dragConstraints: l, layoutScroll: u, layoutRoot: f, layoutCrossfade: d} = e;
    r.projection = new t(r.latestValues,e["data-framer-portal-id"] ? void 0 : DL(r.parent)),
    r.projection.setOptions({
        layoutId: i,
        layout: a,
        alwaysMeasureLayout: !!s || l && Zm(l),
        visualElement: r,
        animationType: typeof a == "string" ? a : "both",
        initialPromotionConfig: n,
        crossfade: d,
        layoutScroll: u,
        layoutRoot: f
    })
}
function DL(r) {
    if (r)
        return r.options.allowProjection !== !1 ? r.projection : DL(r.parent)
}
function E8({preloadedFeatures: r, createVisualElement: e, useRender: t, useVisualState: n, Component: i}) {
    r && d8(r);
    function a(l, u) {
        let f;
        const d = {
            ...de.useContext(Zb),
            ...l,
            layoutId: w8(l)
        }
          , {isStatic: g} = d
          , v = _8(l)
          , y = n(l, g);
        if (!g && jw) {
            A8();
            const S = C8(d);
            f = S.MeasureLayout,
            v.visualElement = M8(i, y, d, e, S.ProjectionNode)
        }
        return ae.jsxs(Kb.Provider, {
            value: v,
            children: [f && v.visualElement ? ae.jsx(f, {
                visualElement: v.visualElement,
                ...d
            }) : null, t(i, l, S8(y, v.visualElement, u), y, g, v.visualElement)]
        })
    }
    a.displayName = `motion.${typeof i == "string" ? i : `create(${i.displayName ?? i.name ?? ""})`}`;
    const s = de.forwardRef(a);
    return s[x8] = i,
    s
}
function w8({layoutId: r}) {
    const e = de.useContext(Xw).id;
    return e && r !== void 0 ? e + "-" + r : r
}
function A8(r, e) {
    de.useContext(EL).strict
}
function C8(r) {
    const {drag: e, layout: t} = mg;
    if (!e && !t)
        return {};
    const n = {
        ...e,
        ...t
    };
    return {
        MeasureLayout: e != null && e.isEnabled(r) || t != null && t.isEnabled(r) ? n.MeasureLayout : void 0,
        ProjectionNode: n.ProjectionNode
    }
}
const Ty = {};
function R8(r) {
    for (const e in r)
        Ty[e] = r[e],
        eA(e) && (Ty[e].isCSSVariable = !0)
}
function UL(r, {layout: e, layoutId: t}) {
    return Vg.has(r) || r.startsWith("origin") || (e || t !== void 0) && (!!Ty[r] || r === "opacity")
}
const D8 = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
}
  , U8 = Hg.length;
function O8(r, e, t) {
    let n = ""
      , i = !0;
    for (let a = 0; a < U8; a++) {
        const s = Hg[a]
          , l = r[s];
        if (l === void 0)
            continue;
        let u = !0;
        if (typeof l == "number" ? u = l === (s.startsWith("scale") ? 1 : 0) : u = parseFloat(l) === 0,
        !u || t) {
            const f = _L(l, hA[s]);
            if (!u) {
                i = !1;
                const d = D8[s] || s;
                n += `${d}(${f}) `
            }
            t && (e[s] = f)
        }
    }
    return n = n.trim(),
    t ? n = t(e, i ? "" : n) : i && (n = "none"),
    n
}
function xA(r, e, t) {
    const {style: n, vars: i, transformOrigin: a} = r;
    let s = !1
      , l = !1;
    for (const u in e) {
        const f = e[u];
        if (Vg.has(u)) {
            s = !0;
            continue
        } else if (eA(u)) {
            i[u] = f;
            continue
        } else {
            const d = _L(f, hA[u]);
            u.startsWith("origin") ? (l = !0,
            a[u] = d) : n[u] = d
        }
    }
    if (e.transform || (s || t ? n.transform = O8(e, r.transform, t) : n.transform && (n.transform = "none")),
    l) {
        const {originX: u="50%", originY: f="50%", originZ: d=0} = a;
        n.transformOrigin = `${u} ${f} ${d}`
    }
}
const SA = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
});
function OL(r, e, t) {
    for (const n in e)
        !Ia(e[n]) && !UL(n, t) && (r[n] = e[n])
}
function N8({transformTemplate: r}, e) {
    return de.useMemo( () => {
        const t = SA();
        return xA(t, e, r),
        Object.assign({}, t.vars, t.style)
    }
    , [e])
}
function L8(r, e) {
    const t = r.style || {}
      , n = {};
    return OL(n, t, r),
    Object.assign(n, N8(r, e)),
    n
}
function P8(r, e) {
    const t = {}
      , n = L8(r, e);
    return r.drag && r.dragListener !== !1 && (t.draggable = !1,
    n.userSelect = n.WebkitUserSelect = n.WebkitTouchCallout = "none",
    n.touchAction = r.drag === !0 ? "none" : `pan-${r.drag === "x" ? "y" : "x"}`),
    r.tabIndex === void 0 && (r.onTap || r.onTapStart || r.whileTap) && (t.tabIndex = 0),
    t.style = n,
    t
}
const B8 = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
}
  , z8 = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
};
function I8(r, e, t=1, n=0, i=!0) {
    r.pathLength = 1;
    const a = i ? B8 : z8;
    r[a.offset] = _n.transform(-n);
    const s = _n.transform(e)
      , l = _n.transform(t);
    r[a.array] = `${s} ${l}`
}
function NL(r, {attrX: e, attrY: t, attrScale: n, pathLength: i, pathSpacing: a=1, pathOffset: s=0, ...l}, u, f, d) {
    if (xA(r, l, f),
    u) {
        r.style.viewBox && (r.attrs.viewBox = r.style.viewBox);
        return
    }
    r.attrs = r.style,
    r.style = {};
    const {attrs: g, style: v} = r;
    g.transform && (v.transform = g.transform,
    delete g.transform),
    (v.transform || g.transformOrigin) && (v.transformOrigin = g.transformOrigin ?? "50% 50%",
    delete g.transformOrigin),
    v.transform && (v.transformBox = (d == null ? void 0 : d.transformBox) ?? "fill-box",
    delete g.transformBox),
    e !== void 0 && (g.x = e),
    t !== void 0 && (g.y = t),
    n !== void 0 && (g.scale = n),
    i !== void 0 && I8(g, i, a, s, !1)
}
const LL = () => ({
    ...SA(),
    attrs: {}
})
  , PL = r => typeof r == "string" && r.toLowerCase() === "svg";
function F8(r, e, t, n) {
    const i = de.useMemo( () => {
        const a = LL();
        return NL(a, e, PL(n), r.transformTemplate, r.style),
        {
            ...a.attrs,
            style: {
                ...a.style
            }
        }
    }
    , [e]);
    if (r.style) {
        const a = {};
        OL(a, r.style, r),
        i.style = {
            ...a,
            ...i.style
        }
    }
    return i
}
const H8 = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
function bA(r) {
    return typeof r != "string" || r.includes("-") ? !1 : !!(H8.indexOf(r) > -1 || /[A-Z]/u.test(r))
}
function V8(r=!1) {
    return (t, n, i, {latestValues: a}, s) => {
        const u = (bA(t) ? F8 : P8)(n, a, s, t)
          , f = g8(n, typeof t == "string", r)
          , d = t !== de.Fragment ? {
            ...f,
            ...u,
            ref: i
        } : {}
          , {children: g} = n
          , v = de.useMemo( () => Ia(g) ? g.get() : g, [g]);
        return de.createElement(t, {
            ...d,
            children: v
        })
    }
}
function A3(r) {
    const e = [{}, {}];
    return r == null || r.values.forEach( (t, n) => {
        e[0][n] = t.get(),
        e[1][n] = t.getVelocity()
    }
    ),
    e
}
function MA(r, e, t, n) {
    if (typeof e == "function") {
        const [i,a] = A3(n);
        e = e(t !== void 0 ? t : r.custom, i, a)
    }
    if (typeof e == "string" && (e = r.variants && r.variants[e]),
    typeof e == "function") {
        const [i,a] = A3(n);
        e = e(t !== void 0 ? t : r.custom, i, a)
    }
    return e
}
function uS(r) {
    return Ia(r) ? r.get() : r
}
function k8({scrapeMotionValuesFromProps: r, createRenderState: e}, t, n, i) {
    return {
        latestValues: G8(t, n, i, r),
        renderState: e()
    }
}
const BL = r => (e, t) => {
    const n = de.useContext(Kb)
      , i = de.useContext(Yb)
      , a = () => k8(r, e, n, i);
    return t ? a() : Ig(a)
}
;
function G8(r, e, t, n) {
    const i = {}
      , a = n(r, {});
    for (const v in a)
        i[v] = uS(a[v]);
    let {initial: s, animate: l} = r;
    const u = Jb(r)
      , f = AL(r);
    e && f && !u && r.inherit !== !1 && (s === void 0 && (s = e.initial),
    l === void 0 && (l = e.animate));
    let d = t ? t.initial === !1 : !1;
    d = d || s === !1;
    const g = d ? l : s;
    if (g && typeof g != "boolean" && !Qb(g)) {
        const v = Array.isArray(g) ? g : [g];
        for (let y = 0; y < v.length; y++) {
            const S = MA(r, v[y]);
            if (S) {
                const {transitionEnd: T, transition: M, ...b} = S;
                for (const A in b) {
                    let C = b[A];
                    if (Array.isArray(C)) {
                        const R = d ? C.length - 1 : 0;
                        C = C[R]
                    }
                    C !== null && (i[A] = C)
                }
                for (const A in T)
                    i[A] = T[A]
            }
        }
    }
    return i
}
function TA(r, e, t) {
    var a;
    const {style: n} = r
      , i = {};
    for (const s in n)
        (Ia(n[s]) || e.style && Ia(e.style[s]) || UL(s, r) || ((a = t == null ? void 0 : t.getValue(s)) == null ? void 0 : a.liveStyle) !== void 0) && (i[s] = n[s]);
    return i
}
const X8 = {
    useVisualState: BL({
        scrapeMotionValuesFromProps: TA,
        createRenderState: SA
    })
};
function zL(r, e, t) {
    const n = TA(r, e, t);
    for (const i in r)
        if (Ia(r[i]) || Ia(e[i])) {
            const a = Hg.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
            n[a] = r[i]
        }
    return n
}
const j8 = {
    useVisualState: BL({
        scrapeMotionValuesFromProps: zL,
        createRenderState: LL
    })
};
function W8(r, e) {
    return function(n, {forwardMotionProps: i}={
        forwardMotionProps: !1
    }) {
        const s = {
            ...bA(n) ? j8 : X8,
            preloadedFeatures: r,
            useRender: V8(i),
            createVisualElement: e,
            Component: n
        };
        return E8(s)
    }
}
function Ey(r, e, t) {
    const n = r.getProps();
    return MA(n, e, t !== void 0 ? t : n.custom, r)
}
const OE = r => Array.isArray(r);
function Y8(r, e, t) {
    r.hasValue(e) ? r.getValue(e).set(t) : r.addValue(e, ql(t))
}
function q8(r) {
    return OE(r) ? r[r.length - 1] || 0 : r
}
function Z8(r, e) {
    const t = Ey(r, e);
    let {transitionEnd: n={}, transition: i={}, ...a} = t || {};
    a = {
        ...a,
        ...n
    };
    for (const s in a) {
        const l = q8(a[s]);
        Y8(r, s, l)
    }
}
function K8(r) {
    return !!(Ia(r) && r.add)
}
function NE(r, e) {
    const t = r.getValue("willChange");
    if (K8(t))
        return t.add(e);
    if (!t && Qc.WillChange) {
        const n = new Qc.WillChange("auto");
        r.addValue("willChange", n),
        n.add(e)
    }
}
function IL(r) {
    return r.props[CL]
}
const Q8 = r => r !== null;
function J8(r, {repeat: e, repeatType: t="loop"}, n) {
    const i = r.filter(Q8)
      , a = e && t !== "loop" && e % 2 === 1 ? 0 : i.length - 1;
    return i[a]
}
const $8 = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
}
  , eH = r => ({
    type: "spring",
    stiffness: 550,
    damping: r === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
})
  , tH = {
    type: "keyframes",
    duration: .8
}
  , nH = {
    type: "keyframes",
    ease: [.25, .1, .35, 1],
    duration: .3
}
  , iH = (r, {keyframes: e}) => e.length > 2 ? tH : Vg.has(r) ? r.startsWith("scale") ? eH(e[1]) : $8 : nH;
function rH({when: r, delay: e, delayChildren: t, staggerChildren: n, staggerDirection: i, repeat: a, repeatType: s, repeatDelay: l, from: u, elapsed: f, ...d}) {
    return !!Object.keys(d).length
}
const EA = (r, e, t, n={}, i, a) => s => {
    const l = fA(n, r) || {}
      , u = l.delay || n.delay || 0;
    let {elapsed: f=0} = n;
    f = f - Wu(u);
    const d = {
        keyframes: Array.isArray(t) ? t : [null, t],
        ease: "easeOut",
        velocity: e.getVelocity(),
        ...l,
        delay: -f,
        onUpdate: v => {
            e.set(v),
            l.onUpdate && l.onUpdate(v)
        }
        ,
        onComplete: () => {
            s(),
            l.onComplete && l.onComplete()
        }
        ,
        name: r,
        motionValue: e,
        element: a ? void 0 : i
    };
    rH(l) || Object.assign(d, iH(r, d)),
    d.duration && (d.duration = Wu(d.duration)),
    d.repeatDelay && (d.repeatDelay = Wu(d.repeatDelay)),
    d.from !== void 0 && (d.keyframes[0] = d.from);
    let g = !1;
    if ((d.type === !1 || d.duration === 0 && !d.repeatDelay) && (d.duration = 0,
    d.delay === 0 && (g = !0)),
    (Qc.instantAnimations || Qc.skipAnimations) && (g = !0,
    d.duration = 0,
    d.delay = 0),
    d.allowFlatten = !l.type && !l.ease,
    g && !a && e.get() !== void 0) {
        const v = J8(d.keyframes, l);
        if (v !== void 0) {
            wi.update( () => {
                d.onUpdate(v),
                d.onComplete()
            }
            );
            return
        }
    }
    return l.isSync ? new uA(d) : new z6(d)
}
;
function aH({protectedKeys: r, needsAnimating: e}, t) {
    const n = r.hasOwnProperty(t) && e[t] !== !0;
    return e[t] = !1,
    n
}
function FL(r, e, {delay: t=0, transitionOverride: n, type: i}={}) {
    let {transition: a=r.getDefaultTransition(), transitionEnd: s, ...l} = e;
    n && (a = n);
    const u = []
      , f = i && r.animationState && r.animationState.getState()[i];
    for (const d in l) {
        const g = r.getValue(d, r.latestValues[d] ?? null)
          , v = l[d];
        if (v === void 0 || f && aH(f, d))
            continue;
        const y = {
            delay: t,
            ...fA(a || {}, d)
        }
          , S = g.get();
        if (S !== void 0 && !g.isAnimating && !Array.isArray(v) && v === S && !y.velocity)
            continue;
        let T = !1;
        if (window.MotionHandoffAnimation) {
            const b = IL(r);
            if (b) {
                const A = window.MotionHandoffAnimation(b, d, wi);
                A !== null && (y.startTime = A,
                T = !0)
            }
        }
        NE(r, d),
        g.start(EA(d, g, v, r.shouldReduceMotion && pL.has(d) ? {
            type: !1
        } : y, r, T));
        const M = g.animation;
        M && u.push(M)
    }
    return s && Promise.all(u).then( () => {
        wi.update( () => {
            s && Z8(r, s)
        }
        )
    }
    ),
    u
}
function LE(r, e, t={}) {
    var u;
    const n = Ey(r, e, t.type === "exit" ? (u = r.presenceContext) == null ? void 0 : u.custom : void 0);
    let {transition: i=r.getDefaultTransition() || {}} = n || {};
    t.transitionOverride && (i = t.transitionOverride);
    const a = n ? () => Promise.all(FL(r, n, t)) : () => Promise.resolve()
      , s = r.variantChildren && r.variantChildren.size ? (f=0) => {
        const {delayChildren: d=0, staggerChildren: g, staggerDirection: v} = i;
        return sH(r, e, d + f, g, v, t)
    }
    : () => Promise.resolve()
      , {when: l} = i;
    if (l) {
        const [f,d] = l === "beforeChildren" ? [a, s] : [s, a];
        return f().then( () => d())
    } else
        return Promise.all([a(), s(t.delay)])
}
function sH(r, e, t=0, n=0, i=1, a) {
    const s = []
      , l = (r.variantChildren.size - 1) * n
      , u = i === 1 ? (f=0) => f * n : (f=0) => l - f * n;
    return Array.from(r.variantChildren).sort(oH).forEach( (f, d) => {
        f.notify("AnimationStart", e),
        s.push(LE(f, e, {
            ...a,
            delay: t + u(d)
        }).then( () => f.notify("AnimationComplete", e)))
    }
    ),
    Promise.all(s)
}
function oH(r, e) {
    return r.sortNodePosition(e)
}
function lH(r, e, t={}) {
    r.notify("AnimationStart", e);
    let n;
    if (Array.isArray(e)) {
        const i = e.map(a => LE(r, a, t));
        n = Promise.all(i)
    } else if (typeof e == "string")
        n = LE(r, e, t);
    else {
        const i = typeof e == "function" ? Ey(r, e, t.custom) : e;
        n = Promise.all(FL(r, i, t))
    }
    return n.then( () => {
        r.notify("AnimationComplete", e)
    }
    )
}
function HL(r, e) {
    if (!Array.isArray(e))
        return !1;
    const t = e.length;
    if (t !== r.length)
        return !1;
    for (let n = 0; n < t; n++)
        if (e[n] !== r[n])
            return !1;
    return !0
}
const uH = yA.length;
function VL(r) {
    if (!r)
        return;
    if (!r.isControllingVariants) {
        const t = r.parent ? VL(r.parent) || {} : {};
        return r.props.initial !== void 0 && (t.initial = r.props.initial),
        t
    }
    const e = {};
    for (let t = 0; t < uH; t++) {
        const n = yA[t]
          , i = r.props[n];
        (My(i) || i === !1) && (e[n] = i)
    }
    return e
}
const cH = [...vA].reverse()
  , fH = vA.length;
function hH(r) {
    return e => Promise.all(e.map( ({animation: t, options: n}) => lH(r, t, n)))
}
function dH(r) {
    let e = hH(r)
      , t = C3()
      , n = !0;
    const i = u => (f, d) => {
        var v;
        const g = Ey(r, d, u === "exit" ? (v = r.presenceContext) == null ? void 0 : v.custom : void 0);
        if (g) {
            const {transition: y, transitionEnd: S, ...T} = g;
            f = {
                ...f,
                ...T,
                ...S
            }
        }
        return f
    }
    ;
    function a(u) {
        e = u(r)
    }
    function s(u) {
        const {props: f} = r
          , d = VL(r.parent) || {}
          , g = []
          , v = new Set;
        let y = {}
          , S = 1 / 0;
        for (let M = 0; M < fH; M++) {
            const b = cH[M]
              , A = t[b]
              , C = f[b] !== void 0 ? f[b] : d[b]
              , R = My(C)
              , O = b === u ? A.isActive : null;
            O === !1 && (S = M);
            let L = C === d[b] && C !== f[b] && R;
            if (L && n && r.manuallyAnimateOnMount && (L = !1),
            A.protectedKeys = {
                ...y
            },
            !A.isActive && O === null || !C && !A.prevProp || Qb(C) || typeof C == "boolean")
                continue;
            const z = pH(A.prevProp, C);
            let I = z || b === u && A.isActive && !L && R || M > S && R
              , N = !1;
            const P = Array.isArray(C) ? C : [C];
            let Y = P.reduce(i(b), {});
            O === !1 && (Y = {});
            const {prevResolvedValues: V={}} = A
              , K = {
                ...V,
                ...Y
            }
              , Z = q => {
                I = !0,
                v.has(q) && (N = !0,
                v.delete(q)),
                A.needsAnimating[q] = !0;
                const Q = r.getValue(q);
                Q && (Q.liveStyle = !1)
            }
            ;
            for (const q in K) {
                const Q = Y[q]
                  , se = V[q];
                if (y.hasOwnProperty(q))
                    continue;
                let B = !1;
                OE(Q) && OE(se) ? B = !HL(Q, se) : B = Q !== se,
                B ? Q != null ? Z(q) : v.add(q) : Q !== void 0 && v.has(q) ? Z(q) : A.protectedKeys[q] = !0
            }
            A.prevProp = C,
            A.prevResolvedValues = Y,
            A.isActive && (y = {
                ...y,
                ...Y
            }),
            n && r.blockInitialAnimation && (I = !1),
            I && (!(L && z) || N) && g.push(...P.map(q => ({
                animation: q,
                options: {
                    type: b
                }
            })))
        }
        if (v.size) {
            const M = {};
            if (typeof f.initial != "boolean") {
                const b = Ey(r, Array.isArray(f.initial) ? f.initial[0] : f.initial);
                b && b.transition && (M.transition = b.transition)
            }
            v.forEach(b => {
                const A = r.getBaseTarget(b)
                  , C = r.getValue(b);
                C && (C.liveStyle = !0),
                M[b] = A ?? null
            }
            ),
            g.push({
                animation: M
            })
        }
        let T = !!g.length;
        return n && (f.initial === !1 || f.initial === f.animate) && !r.manuallyAnimateOnMount && (T = !1),
        n = !1,
        T ? e(g) : Promise.resolve()
    }
    function l(u, f) {
        var g;
        if (t[u].isActive === f)
            return Promise.resolve();
        (g = r.variantChildren) == null || g.forEach(v => {
            var y;
            return (y = v.animationState) == null ? void 0 : y.setActive(u, f)
        }
        ),
        t[u].isActive = f;
        const d = s(u);
        for (const v in t)
            t[v].protectedKeys = {};
        return d
    }
    return {
        animateChanges: s,
        setActive: l,
        setAnimateFunction: a,
        getState: () => t,
        reset: () => {
            t = C3(),
            n = !0
        }
    }
}
function pH(r, e) {
    return typeof e == "string" ? e !== r : Array.isArray(e) ? !HL(e, r) : !1
}
function md(r=!1) {
    return {
        isActive: r,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}
function C3() {
    return {
        animate: md(!0),
        whileInView: md(),
        whileHover: md(),
        whileTap: md(),
        whileDrag: md(),
        whileFocus: md(),
        exit: md()
    }
}
class bh {
    constructor(e) {
        this.isMounted = !1,
        this.node = e
    }
    update() {}
}
class mH extends bh {
    constructor(e) {
        super(e),
        e.animationState || (e.animationState = dH(e))
    }
    updateAnimationControlsSubscription() {
        const {animate: e} = this.node.getProps();
        Qb(e) && (this.unmountControls = e.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {animate: e} = this.node.getProps()
          , {animate: t} = this.node.prevProps || {};
        e !== t && this.updateAnimationControlsSubscription()
    }
    unmount() {
        var e;
        this.node.animationState.reset(),
        (e = this.unmountControls) == null || e.call(this)
    }
}
let gH = 0;
class vH extends bh {
    constructor() {
        super(...arguments),
        this.id = gH++
    }
    update() {
        if (!this.node.presenceContext)
            return;
        const {isPresent: e, onExitComplete: t} = this.node.presenceContext
          , {isPresent: n} = this.node.prevPresenceContext || {};
        if (!this.node.animationState || e === n)
            return;
        const i = this.node.animationState.setActive("exit", !e);
        t && !e && i.then( () => {
            t(this.id)
        }
        )
    }
    mount() {
        const {register: e, onExitComplete: t} = this.node.presenceContext || {};
        t && t(this.id),
        e && (this.unmount = e(this.id))
    }
    unmount() {}
}
const yH = {
    animation: {
        Feature: mH
    },
    exit: {
        Feature: vH
    }
};
function wy(r, e, t, n={
    passive: !0
}) {
    return r.addEventListener(e, t, n),
    () => r.removeEventListener(e, t)
}
function r_(r) {
    return {
        point: {
            x: r.pageX,
            y: r.pageY
        }
    }
}
const _H = r => e => mA(e) && r(e, r_(e));
function Xv(r, e, t, n) {
    return wy(r, e, _H(t), n)
}
function kL({top: r, left: e, right: t, bottom: n}) {
    return {
        x: {
            min: e,
            max: t
        },
        y: {
            min: r,
            max: n
        }
    }
}
function xH({x: r, y: e}) {
    return {
        top: e.min,
        right: r.max,
        bottom: e.max,
        left: r.min
    }
}
function SH(r, e) {
    if (!e)
        return r;
    const t = e({
        x: r.left,
        y: r.top
    })
      , n = e({
        x: r.right,
        y: r.bottom
    });
    return {
        top: t.y,
        left: t.x,
        bottom: n.y,
        right: n.x
    }
}
const GL = 1e-4
  , bH = 1 - GL
  , MH = 1 + GL
  , XL = .01
  , TH = 0 - XL
  , EH = 0 + XL;
function gs(r) {
    return r.max - r.min
}
function wH(r, e, t) {
    return Math.abs(r - e) <= t
}
function R3(r, e, t, n=.5) {
    r.origin = n,
    r.originPoint = Ji(e.min, e.max, r.origin),
    r.scale = gs(t) / gs(e),
    r.translate = Ji(t.min, t.max, r.origin) - r.originPoint,
    (r.scale >= bH && r.scale <= MH || isNaN(r.scale)) && (r.scale = 1),
    (r.translate >= TH && r.translate <= EH || isNaN(r.translate)) && (r.translate = 0)
}
function jv(r, e, t, n) {
    R3(r.x, e.x, t.x, n ? n.originX : void 0),
    R3(r.y, e.y, t.y, n ? n.originY : void 0)
}
function D3(r, e, t) {
    r.min = t.min + e.min,
    r.max = r.min + gs(e)
}
function AH(r, e, t) {
    D3(r.x, e.x, t.x),
    D3(r.y, e.y, t.y)
}
function U3(r, e, t) {
    r.min = e.min - t.min,
    r.max = r.min + gs(e)
}
function Wv(r, e, t) {
    U3(r.x, e.x, t.x),
    U3(r.y, e.y, t.y)
}
const O3 = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
})
  , Km = () => ({
    x: O3(),
    y: O3()
})
  , N3 = () => ({
    min: 0,
    max: 0
})
  , mr = () => ({
    x: N3(),
    y: N3()
});
function Ko(r) {
    return [r("x"), r("y")]
}
function L2(r) {
    return r === void 0 || r === 1
}
function PE({scale: r, scaleX: e, scaleY: t}) {
    return !L2(r) || !L2(e) || !L2(t)
}
function Nd(r) {
    return PE(r) || jL(r) || r.z || r.rotate || r.rotateX || r.rotateY || r.skewX || r.skewY
}
function jL(r) {
    return L3(r.x) || L3(r.y)
}
function L3(r) {
    return r && r !== "0%"
}
function BS(r, e, t) {
    const n = r - t
      , i = e * n;
    return t + i
}
function P3(r, e, t, n, i) {
    return i !== void 0 && (r = BS(r, i, n)),
    BS(r, t, n) + e
}
function BE(r, e=0, t=1, n, i) {
    r.min = P3(r.min, e, t, n, i),
    r.max = P3(r.max, e, t, n, i)
}
function WL(r, {x: e, y: t}) {
    BE(r.x, e.translate, e.scale, e.originPoint),
    BE(r.y, t.translate, t.scale, t.originPoint)
}
const B3 = .999999999999
  , z3 = 1.0000000000001;
function CH(r, e, t, n=!1) {
    const i = t.length;
    if (!i)
        return;
    e.x = e.y = 1;
    let a, s;
    for (let l = 0; l < i; l++) {
        a = t[l],
        s = a.projectionDelta;
        const {visualElement: u} = a.options;
        u && u.props.style && u.props.style.display === "contents" || (n && a.options.layoutScroll && a.scroll && a !== a.root && Jm(r, {
            x: -a.scroll.offset.x,
            y: -a.scroll.offset.y
        }),
        s && (e.x *= s.x.scale,
        e.y *= s.y.scale,
        WL(r, s)),
        n && Nd(a.latestValues) && Jm(r, a.latestValues))
    }
    e.x < z3 && e.x > B3 && (e.x = 1),
    e.y < z3 && e.y > B3 && (e.y = 1)
}
function Qm(r, e) {
    r.min = r.min + e,
    r.max = r.max + e
}
function I3(r, e, t, n, i=.5) {
    const a = Ji(r.min, r.max, i);
    BE(r, e, t, a, n)
}
function Jm(r, e) {
    I3(r.x, e.x, e.scaleX, e.scale, e.originX),
    I3(r.y, e.y, e.scaleY, e.scale, e.originY)
}
function YL(r, e) {
    return kL(SH(r.getBoundingClientRect(), e))
}
function RH(r, e, t) {
    const n = YL(r, t)
      , {scroll: i} = e;
    return i && (Qm(n.x, i.offset.x),
    Qm(n.y, i.offset.y)),
    n
}
const qL = ({current: r}) => r ? r.ownerDocument.defaultView : null
  , F3 = (r, e) => Math.abs(r - e);
function DH(r, e) {
    const t = F3(r.x, e.x)
      , n = F3(r.y, e.y);
    return Math.sqrt(t ** 2 + n ** 2)
}
class ZL {
    constructor(e, t, {transformPagePoint: n, contextWindow: i, dragSnapToOrigin: a=!1}={}) {
        if (this.startEvent = null,
        this.lastMoveEvent = null,
        this.lastMoveEventInfo = null,
        this.handlers = {},
        this.contextWindow = window,
        this.updatePoint = () => {
            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const g = B2(this.lastMoveEventInfo, this.history)
              , v = this.startEvent !== null
              , y = DH(g.offset, {
                x: 0,
                y: 0
            }) >= 3;
            if (!v && !y)
                return;
            const {point: S} = g
              , {timestamp: T} = Qr;
            this.history.push({
                ...S,
                timestamp: T
            });
            const {onStart: M, onMove: b} = this.handlers;
            v || (M && M(this.lastMoveEvent, g),
            this.startEvent = this.lastMoveEvent),
            b && b(this.lastMoveEvent, g)
        }
        ,
        this.handlePointerMove = (g, v) => {
            this.lastMoveEvent = g,
            this.lastMoveEventInfo = P2(v, this.transformPagePoint),
            wi.update(this.updatePoint, !0)
        }
        ,
        this.handlePointerUp = (g, v) => {
            this.end();
            const {onEnd: y, onSessionEnd: S, resumeAnimation: T} = this.handlers;
            if (this.dragSnapToOrigin && T && T(),
            !(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const M = B2(g.type === "pointercancel" ? this.lastMoveEventInfo : P2(v, this.transformPagePoint), this.history);
            this.startEvent && y && y(g, M),
            S && S(g, M)
        }
        ,
        !mA(e))
            return;
        this.dragSnapToOrigin = a,
        this.handlers = t,
        this.transformPagePoint = n,
        this.contextWindow = i || window;
        const s = r_(e)
          , l = P2(s, this.transformPagePoint)
          , {point: u} = l
          , {timestamp: f} = Qr;
        this.history = [{
            ...u,
            timestamp: f
        }];
        const {onSessionStart: d} = t;
        d && d(e, B2(l, this.history)),
        this.removeListeners = t_(Xv(this.contextWindow, "pointermove", this.handlePointerMove), Xv(this.contextWindow, "pointerup", this.handlePointerUp), Xv(this.contextWindow, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(e) {
        this.handlers = e
    }
    end() {
        this.removeListeners && this.removeListeners(),
        Ql(this.updatePoint)
    }
}
function P2(r, e) {
    return e ? {
        point: e(r.point)
    } : r
}
function H3(r, e) {
    return {
        x: r.x - e.x,
        y: r.y - e.y
    }
}
function B2({point: r}, e) {
    return {
        point: r,
        delta: H3(r, KL(e)),
        offset: H3(r, UH(e)),
        velocity: OH(e, .1)
    }
}
function UH(r) {
    return r[0]
}
function KL(r) {
    return r[r.length - 1]
}
function OH(r, e) {
    if (r.length < 2)
        return {
            x: 0,
            y: 0
        };
    let t = r.length - 1
      , n = null;
    const i = KL(r);
    for (; t >= 0 && (n = r[t],
    !(i.timestamp - n.timestamp > Wu(e))); )
        t--;
    if (!n)
        return {
            x: 0,
            y: 0
        };
    const a = Yu(i.timestamp - n.timestamp);
    if (a === 0)
        return {
            x: 0,
            y: 0
        };
    const s = {
        x: (i.x - n.x) / a,
        y: (i.y - n.y) / a
    };
    return s.x === 1 / 0 && (s.x = 0),
    s.y === 1 / 0 && (s.y = 0),
    s
}
function NH(r, {min: e, max: t}, n) {
    return e !== void 0 && r < e ? r = n ? Ji(e, r, n.min) : Math.max(r, e) : t !== void 0 && r > t && (r = n ? Ji(t, r, n.max) : Math.min(r, t)),
    r
}
function V3(r, e, t) {
    return {
        min: e !== void 0 ? r.min + e : void 0,
        max: t !== void 0 ? r.max + t - (r.max - r.min) : void 0
    }
}
function LH(r, {top: e, left: t, bottom: n, right: i}) {
    return {
        x: V3(r.x, t, i),
        y: V3(r.y, e, n)
    }
}
function k3(r, e) {
    let t = e.min - r.min
      , n = e.max - r.max;
    return e.max - e.min < r.max - r.min && ([t,n] = [n, t]),
    {
        min: t,
        max: n
    }
}
function PH(r, e) {
    return {
        x: k3(r.x, e.x),
        y: k3(r.y, e.y)
    }
}
function BH(r, e) {
    let t = .5;
    const n = gs(r)
      , i = gs(e);
    return i > n ? t = pg(e.min, e.max - n, r.min) : n > i && (t = pg(r.min, r.max - i, e.min)),
    ec(0, 1, t)
}
function zH(r, e) {
    const t = {};
    return e.min !== void 0 && (t.min = e.min - r.min),
    e.max !== void 0 && (t.max = e.max - r.min),
    t
}
const zE = .35;
function IH(r=zE) {
    return r === !1 ? r = 0 : r === !0 && (r = zE),
    {
        x: G3(r, "left", "right"),
        y: G3(r, "top", "bottom")
    }
}
function G3(r, e, t) {
    return {
        min: X3(r, e),
        max: X3(r, t)
    }
}
function X3(r, e) {
    return typeof r == "number" ? r : r[e] || 0
}
const FH = new WeakMap;
class HH {
    constructor(e) {
        this.openDragLock = null,
        this.isDragging = !1,
        this.currentDirection = null,
        this.originPoint = {
            x: 0,
            y: 0
        },
        this.constraints = !1,
        this.hasMutatedConstraints = !1,
        this.elastic = mr(),
        this.visualElement = e
    }
    start(e, {snapToCursor: t=!1}={}) {
        const {presenceContext: n} = this.visualElement;
        if (n && n.isPresent === !1)
            return;
        const i = d => {
            const {dragSnapToOrigin: g} = this.getProps();
            g ? this.pauseAnimation() : this.stopAnimation(),
            t && this.snapToCursor(r_(d).point)
        }
          , a = (d, g) => {
            const {drag: v, dragPropagation: y, onDragStart: S} = this.getProps();
            if (v && !y && (this.openDragLock && this.openDragLock(),
            this.openDragLock = J6(v),
            !this.openDragLock))
                return;
            this.isDragging = !0,
            this.currentDirection = null,
            this.resolveConstraints(),
            this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
            this.visualElement.projection.target = void 0),
            Ko(M => {
                let b = this.getAxisMotionValue(M).get() || 0;
                if (qu.test(b)) {
                    const {projection: A} = this.visualElement;
                    if (A && A.layout) {
                        const C = A.layout.layoutBox[M];
                        C && (b = gs(C) * (parseFloat(b) / 100))
                    }
                }
                this.originPoint[M] = b
            }
            ),
            S && wi.postRender( () => S(d, g)),
            NE(this.visualElement, "transform");
            const {animationState: T} = this.visualElement;
            T && T.setActive("whileDrag", !0)
        }
          , s = (d, g) => {
            const {dragPropagation: v, dragDirectionLock: y, onDirectionLock: S, onDrag: T} = this.getProps();
            if (!v && !this.openDragLock)
                return;
            const {offset: M} = g;
            if (y && this.currentDirection === null) {
                this.currentDirection = VH(M),
                this.currentDirection !== null && S && S(this.currentDirection);
                return
            }
            this.updateAxis("x", g.point, M),
            this.updateAxis("y", g.point, M),
            this.visualElement.render(),
            T && T(d, g)
        }
          , l = (d, g) => this.stop(d, g)
          , u = () => Ko(d => {
            var g;
            return this.getAnimationState(d) === "paused" && ((g = this.getAxisMotionValue(d).animation) == null ? void 0 : g.play())
        }
        )
          , {dragSnapToOrigin: f} = this.getProps();
        this.panSession = new ZL(e,{
            onSessionStart: i,
            onStart: a,
            onMove: s,
            onSessionEnd: l,
            resumeAnimation: u
        },{
            transformPagePoint: this.visualElement.getTransformPagePoint(),
            dragSnapToOrigin: f,
            contextWindow: qL(this.visualElement)
        })
    }
    stop(e, t) {
        const n = this.isDragging;
        if (this.cancel(),
        !n)
            return;
        const {velocity: i} = t;
        this.startAnimation(i);
        const {onDragEnd: a} = this.getProps();
        a && wi.postRender( () => a(e, t))
    }
    cancel() {
        this.isDragging = !1;
        const {projection: e, animationState: t} = this.visualElement;
        e && (e.isAnimationBlocked = !1),
        this.panSession && this.panSession.end(),
        this.panSession = void 0;
        const {dragPropagation: n} = this.getProps();
        !n && this.openDragLock && (this.openDragLock(),
        this.openDragLock = null),
        t && t.setActive("whileDrag", !1)
    }
    updateAxis(e, t, n) {
        const {drag: i} = this.getProps();
        if (!n || !Z1(e, i, this.currentDirection))
            return;
        const a = this.getAxisMotionValue(e);
        let s = this.originPoint[e] + n[e];
        this.constraints && this.constraints[e] && (s = NH(s, this.constraints[e], this.elastic[e])),
        a.set(s)
    }
    resolveConstraints() {
        var a;
        const {dragConstraints: e, dragElastic: t} = this.getProps()
          , n = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (a = this.visualElement.projection) == null ? void 0 : a.layout
          , i = this.constraints;
        e && Zm(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && n ? this.constraints = LH(n.layoutBox, e) : this.constraints = !1,
        this.elastic = IH(t),
        i !== this.constraints && n && this.constraints && !this.hasMutatedConstraints && Ko(s => {
            this.constraints !== !1 && this.getAxisMotionValue(s) && (this.constraints[s] = zH(n.layoutBox[s], this.constraints[s]))
        }
        )
    }
    resolveRefConstraints() {
        const {dragConstraints: e, onMeasureDragConstraints: t} = this.getProps();
        if (!e || !Zm(e))
            return !1;
        const n = e.current
          , {projection: i} = this.visualElement;
        if (!i || !i.layout)
            return !1;
        const a = RH(n, i.root, this.visualElement.getTransformPagePoint());
        let s = PH(i.layout.layoutBox, a);
        if (t) {
            const l = t(xH(s));
            this.hasMutatedConstraints = !!l,
            l && (s = kL(l))
        }
        return s
    }
    startAnimation(e) {
        const {drag: t, dragMomentum: n, dragElastic: i, dragTransition: a, dragSnapToOrigin: s, onDragTransitionEnd: l} = this.getProps()
          , u = this.constraints || {}
          , f = Ko(d => {
            if (!Z1(d, t, this.currentDirection))
                return;
            let g = u && u[d] || {};
            s && (g = {
                min: 0,
                max: 0
            });
            const v = i ? 200 : 1e6
              , y = i ? 40 : 1e7
              , S = {
                type: "inertia",
                velocity: n ? e[d] : 0,
                bounceStiffness: v,
                bounceDamping: y,
                timeConstant: 750,
                restDelta: 1,
                restSpeed: 10,
                ...a,
                ...g
            };
            return this.startAxisValueAnimation(d, S)
        }
        );
        return Promise.all(f).then(l)
    }
    startAxisValueAnimation(e, t) {
        const n = this.getAxisMotionValue(e);
        return NE(this.visualElement, e),
        n.start(EA(e, n, 0, t, this.visualElement, !1))
    }
    stopAnimation() {
        Ko(e => this.getAxisMotionValue(e).stop())
    }
    pauseAnimation() {
        Ko(e => {
            var t;
            return (t = this.getAxisMotionValue(e).animation) == null ? void 0 : t.pause()
        }
        )
    }
    getAnimationState(e) {
        var t;
        return (t = this.getAxisMotionValue(e).animation) == null ? void 0 : t.state
    }
    getAxisMotionValue(e) {
        const t = `_drag${e.toUpperCase()}`
          , n = this.visualElement.getProps()
          , i = n[t];
        return i || this.visualElement.getValue(e, (n.initial ? n.initial[e] : void 0) || 0)
    }
    snapToCursor(e) {
        Ko(t => {
            const {drag: n} = this.getProps();
            if (!Z1(t, n, this.currentDirection))
                return;
            const {projection: i} = this.visualElement
              , a = this.getAxisMotionValue(t);
            if (i && i.layout) {
                const {min: s, max: l} = i.layout.layoutBox[t];
                a.set(e[t] - Ji(s, l, .5))
            }
        }
        )
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current)
            return;
        const {drag: e, dragConstraints: t} = this.getProps()
          , {projection: n} = this.visualElement;
        if (!Zm(t) || !n || !this.constraints)
            return;
        this.stopAnimation();
        const i = {
            x: 0,
            y: 0
        };
        Ko(s => {
            const l = this.getAxisMotionValue(s);
            if (l && this.constraints !== !1) {
                const u = l.get();
                i[s] = BH({
                    min: u,
                    max: u
                }, this.constraints[s])
            }
        }
        );
        const {transformTemplate: a} = this.visualElement.getProps();
        this.visualElement.current.style.transform = a ? a({}, "") : "none",
        n.root && n.root.updateScroll(),
        n.updateLayout(),
        this.resolveConstraints(),
        Ko(s => {
            if (!Z1(s, e, null))
                return;
            const l = this.getAxisMotionValue(s)
              , {min: u, max: f} = this.constraints[s];
            l.set(Ji(u, f, i[s]))
        }
        )
    }
    addListeners() {
        if (!this.visualElement.current)
            return;
        FH.set(this.visualElement, this);
        const e = this.visualElement.current
          , t = Xv(e, "pointerdown", u => {
            const {drag: f, dragListener: d=!0} = this.getProps();
            f && d && this.start(u)
        }
        )
          , n = () => {
            const {dragConstraints: u} = this.getProps();
            Zm(u) && u.current && (this.constraints = this.resolveRefConstraints())
        }
          , {projection: i} = this.visualElement
          , a = i.addEventListener("measure", n);
        i && !i.layout && (i.root && i.root.updateScroll(),
        i.updateLayout()),
        wi.read(n);
        const s = wy(window, "resize", () => this.scalePositionWithinConstraints())
          , l = i.addEventListener("didUpdate", ({delta: u, hasLayoutChanged: f}) => {
            this.isDragging && f && (Ko(d => {
                const g = this.getAxisMotionValue(d);
                g && (this.originPoint[d] += u[d].translate,
                g.set(g.get() + u[d].translate))
            }
            ),
            this.visualElement.render())
        }
        );
        return () => {
            s(),
            t(),
            a(),
            l && l()
        }
    }
    getProps() {
        const e = this.visualElement.getProps()
          , {drag: t=!1, dragDirectionLock: n=!1, dragPropagation: i=!1, dragConstraints: a=!1, dragElastic: s=zE, dragMomentum: l=!0} = e;
        return {
            ...e,
            drag: t,
            dragDirectionLock: n,
            dragPropagation: i,
            dragConstraints: a,
            dragElastic: s,
            dragMomentum: l
        }
    }
}
function Z1(r, e, t) {
    return (e === !0 || e === r) && (t === null || t === r)
}
function VH(r, e=10) {
    let t = null;
    return Math.abs(r.y) > e ? t = "y" : Math.abs(r.x) > e && (t = "x"),
    t
}
class kH extends bh {
    constructor(e) {
        super(e),
        this.removeGroupControls = Gs,
        this.removeListeners = Gs,
        this.controls = new HH(e)
    }
    mount() {
        const {dragControls: e} = this.node.getProps();
        e && (this.removeGroupControls = e.subscribe(this.controls)),
        this.removeListeners = this.controls.addListeners() || Gs
    }
    unmount() {
        this.removeGroupControls(),
        this.removeListeners()
    }
}
const j3 = r => (e, t) => {
    r && wi.postRender( () => r(e, t))
}
;
class GH extends bh {
    constructor() {
        super(...arguments),
        this.removePointerDownListener = Gs
    }
    onPointerDown(e) {
        this.session = new ZL(e,this.createPanHandlers(),{
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: qL(this.node)
        })
    }
    createPanHandlers() {
        const {onPanSessionStart: e, onPanStart: t, onPan: n, onPanEnd: i} = this.node.getProps();
        return {
            onSessionStart: j3(e),
            onStart: j3(t),
            onMove: n,
            onEnd: (a, s) => {
                delete this.session,
                i && wi.postRender( () => i(a, s))
            }
        }
    }
    mount() {
        this.removePointerDownListener = Xv(this.node.current, "pointerdown", e => this.onPointerDown(e))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(),
        this.session && this.session.end()
    }
}
const cS = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1
};
function W3(r, e) {
    return e.max === e.min ? 0 : r / (e.max - e.min) * 100
}
const ov = {
    correct: (r, e) => {
        if (!e.target)
            return r;
        if (typeof r == "string")
            if (_n.test(r))
                r = parseFloat(r);
            else
                return r;
        const t = W3(r, e.target.x)
          , n = W3(r, e.target.y);
        return `${t}% ${n}%`
    }
}
  , XH = {
    correct: (r, {treeScale: e, projectionDelta: t}) => {
        const n = r
          , i = mh.parse(r);
        if (i.length > 5)
            return n;
        const a = mh.createTransformer(r)
          , s = typeof i[0] != "number" ? 1 : 0
          , l = t.x.scale * e.x
          , u = t.y.scale * e.y;
        i[0 + s] /= l,
        i[1 + s] /= u;
        const f = Ji(l, u, .5);
        return typeof i[2 + s] == "number" && (i[2 + s] /= f),
        typeof i[3 + s] == "number" && (i[3 + s] /= f),
        a(i)
    }
};
class jH extends de.Component {
    componentDidMount() {
        const {visualElement: e, layoutGroup: t, switchLayoutGroup: n, layoutId: i} = this.props
          , {projection: a} = e;
        R8(WH),
        a && (t.group && t.group.add(a),
        n && n.register && i && n.register(a),
        a.root.didUpdate(),
        a.addEventListener("animationComplete", () => {
            this.safeToRemove()
        }
        ),
        a.setOptions({
            ...a.options,
            onExitComplete: () => this.safeToRemove()
        })),
        cS.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(e) {
        const {layoutDependency: t, visualElement: n, drag: i, isPresent: a} = this.props
          , {projection: s} = n;
        return s && (s.isPresent = a,
        i || e.layoutDependency !== t || t === void 0 || e.isPresent !== a ? s.willUpdate() : this.safeToRemove(),
        e.isPresent !== a && (a ? s.promote() : s.relegate() || wi.postRender( () => {
            const l = s.getStack();
            (!l || !l.members.length) && this.safeToRemove()
        }
        ))),
        null
    }
    componentDidUpdate() {
        const {projection: e} = this.props.visualElement;
        e && (e.root.didUpdate(),
        pA.postRender( () => {
            !e.currentAnimation && e.isLead() && this.safeToRemove()
        }
        ))
    }
    componentWillUnmount() {
        const {visualElement: e, layoutGroup: t, switchLayoutGroup: n} = this.props
          , {projection: i} = e;
        i && (i.scheduleCheckAfterUnmount(),
        t && t.group && t.group.remove(i),
        n && n.deregister && n.deregister(i))
    }
    safeToRemove() {
        const {safeToRemove: e} = this.props;
        e && e()
    }
    render() {
        return null
    }
}
function QL(r) {
    const [e,t] = TL()
      , n = de.useContext(Xw);
    return ae.jsx(jH, {
        ...r,
        layoutGroup: n,
        switchLayoutGroup: de.useContext(RL),
        isPresent: e,
        safeToRemove: t
    })
}
const WH = {
    borderRadius: {
        ...ov,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
    },
    borderTopLeftRadius: ov,
    borderTopRightRadius: ov,
    borderBottomLeftRadius: ov,
    borderBottomRightRadius: ov,
    boxShadow: XH
};
function YH(r, e, t) {
    const n = Ia(r) ? r : ql(r);
    return n.start(EA("", n, e, t)),
    n.animation
}
const qH = (r, e) => r.depth - e.depth;
class ZH {
    constructor() {
        this.children = [],
        this.isDirty = !1
    }
    add(e) {
        Ww(this.children, e),
        this.isDirty = !0
    }
    remove(e) {
        Yw(this.children, e),
        this.isDirty = !0
    }
    forEach(e) {
        this.isDirty && this.children.sort(qH),
        this.isDirty = !1,
        this.children.forEach(e)
    }
}
function KH(r, e) {
    const t = ks.now()
      , n = ({timestamp: i}) => {
        const a = i - t;
        a >= e && (Ql(n),
        r(a - e))
    }
    ;
    return wi.setup(n, !0),
    () => Ql(n)
}
const JL = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
  , QH = JL.length
  , Y3 = r => typeof r == "string" ? parseFloat(r) : r
  , q3 = r => typeof r == "number" || _n.test(r);
function JH(r, e, t, n, i, a) {
    i ? (r.opacity = Ji(0, t.opacity ?? 1, $H(n)),
    r.opacityExit = Ji(e.opacity ?? 1, 0, eV(n))) : a && (r.opacity = Ji(e.opacity ?? 1, t.opacity ?? 1, n));
    for (let s = 0; s < QH; s++) {
        const l = `border${JL[s]}Radius`;
        let u = Z3(e, l)
          , f = Z3(t, l);
        if (u === void 0 && f === void 0)
            continue;
        u || (u = 0),
        f || (f = 0),
        u === 0 || f === 0 || q3(u) === q3(f) ? (r[l] = Math.max(Ji(Y3(u), Y3(f), n), 0),
        (qu.test(f) || qu.test(u)) && (r[l] += "%")) : r[l] = f
    }
    (e.rotate || t.rotate) && (r.rotate = Ji(e.rotate || 0, t.rotate || 0, n))
}
function Z3(r, e) {
    return r[e] !== void 0 ? r[e] : r.borderRadius
}
const $H = $L(0, .5, GN)
  , eV = $L(.5, .95, Gs);
function $L(r, e, t) {
    return n => n < r ? 0 : n > e ? 1 : t(pg(r, e, n))
}
function K3(r, e) {
    r.min = e.min,
    r.max = e.max
}
function qo(r, e) {
    K3(r.x, e.x),
    K3(r.y, e.y)
}
function Q3(r, e) {
    r.translate = e.translate,
    r.scale = e.scale,
    r.originPoint = e.originPoint,
    r.origin = e.origin
}
function J3(r, e, t, n, i) {
    return r -= e,
    r = BS(r, 1 / t, n),
    i !== void 0 && (r = BS(r, 1 / i, n)),
    r
}
function tV(r, e=0, t=1, n=.5, i, a=r, s=r) {
    if (qu.test(e) && (e = parseFloat(e),
    e = Ji(s.min, s.max, e / 100) - s.min),
    typeof e != "number")
        return;
    let l = Ji(a.min, a.max, n);
    r === a && (l -= e),
    r.min = J3(r.min, e, t, l, i),
    r.max = J3(r.max, e, t, l, i)
}
function $3(r, e, [t,n,i], a, s) {
    tV(r, e[t], e[n], e[i], e.scale, a, s)
}
const nV = ["x", "scaleX", "originX"]
  , iV = ["y", "scaleY", "originY"];
function eD(r, e, t, n) {
    $3(r.x, e, nV, t ? t.x : void 0, n ? n.x : void 0),
    $3(r.y, e, iV, t ? t.y : void 0, n ? n.y : void 0)
}
function tD(r) {
    return r.translate === 0 && r.scale === 1
}
function e4(r) {
    return tD(r.x) && tD(r.y)
}
function nD(r, e) {
    return r.min === e.min && r.max === e.max
}
function rV(r, e) {
    return nD(r.x, e.x) && nD(r.y, e.y)
}
function iD(r, e) {
    return Math.round(r.min) === Math.round(e.min) && Math.round(r.max) === Math.round(e.max)
}
function t4(r, e) {
    return iD(r.x, e.x) && iD(r.y, e.y)
}
function rD(r) {
    return gs(r.x) / gs(r.y)
}
function aD(r, e) {
    return r.translate === e.translate && r.scale === e.scale && r.originPoint === e.originPoint
}
class aV {
    constructor() {
        this.members = []
    }
    add(e) {
        Ww(this.members, e),
        e.scheduleRender()
    }
    remove(e) {
        if (Yw(this.members, e),
        e === this.prevLead && (this.prevLead = void 0),
        e === this.lead) {
            const t = this.members[this.members.length - 1];
            t && this.promote(t)
        }
    }
    relegate(e) {
        const t = this.members.findIndex(i => e === i);
        if (t === 0)
            return !1;
        let n;
        for (let i = t; i >= 0; i--) {
            const a = this.members[i];
            if (a.isPresent !== !1) {
                n = a;
                break
            }
        }
        return n ? (this.promote(n),
        !0) : !1
    }
    promote(e, t) {
        const n = this.lead;
        if (e !== n && (this.prevLead = n,
        this.lead = e,
        e.show(),
        n)) {
            n.instance && n.scheduleRender(),
            e.scheduleRender(),
            e.resumeFrom = n,
            t && (e.resumeFrom.preserveOpacity = !0),
            n.snapshot && (e.snapshot = n.snapshot,
            e.snapshot.latestValues = n.animationValues || n.latestValues),
            e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
            const {crossfade: i} = e.options;
            i === !1 && n.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(e => {
            const {options: t, resumingFrom: n} = e;
            t.onExitComplete && t.onExitComplete(),
            n && n.options.onExitComplete && n.options.onExitComplete()
        }
        )
    }
    scheduleRender() {
        this.members.forEach(e => {
            e.instance && e.scheduleRender(!1)
        }
        )
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}
function sV(r, e, t) {
    let n = "";
    const i = r.x.translate / e.x
      , a = r.y.translate / e.y
      , s = (t == null ? void 0 : t.z) || 0;
    if ((i || a || s) && (n = `translate3d(${i}px, ${a}px, ${s}px) `),
    (e.x !== 1 || e.y !== 1) && (n += `scale(${1 / e.x}, ${1 / e.y}) `),
    t) {
        const {transformPerspective: f, rotate: d, rotateX: g, rotateY: v, skewX: y, skewY: S} = t;
        f && (n = `perspective(${f}px) ${n}`),
        d && (n += `rotate(${d}deg) `),
        g && (n += `rotateX(${g}deg) `),
        v && (n += `rotateY(${v}deg) `),
        y && (n += `skewX(${y}deg) `),
        S && (n += `skewY(${S}deg) `)
    }
    const l = r.x.scale * e.x
      , u = r.y.scale * e.y;
    return (l !== 1 || u !== 1) && (n += `scale(${l}, ${u})`),
    n || "none"
}
const z2 = ["", "X", "Y", "Z"]
  , oV = {
    visibility: "hidden"
}
  , lV = 1e3;
let uV = 0;
function I2(r, e, t, n) {
    const {latestValues: i} = e;
    i[r] && (t[r] = i[r],
    e.setStaticValue(r, 0),
    n && (n[r] = 0))
}
function n4(r) {
    if (r.hasCheckedOptimisedAppear = !0,
    r.root === r)
        return;
    const {visualElement: e} = r.options;
    if (!e)
        return;
    const t = IL(e);
    if (window.MotionHasOptimisedAnimation(t, "transform")) {
        const {layout: i, layoutId: a} = r.options;
        window.MotionCancelOptimisedAnimation(t, "transform", wi, !(i || a))
    }
    const {parent: n} = r;
    n && !n.hasCheckedOptimisedAppear && n4(n)
}
function i4({attachResizeListener: r, defaultParent: e, measureScroll: t, checkIsScrollRoot: n, resetTransform: i}) {
    return class {
        constructor(s={}, l=e == null ? void 0 : e()) {
            this.id = uV++,
            this.animationId = 0,
            this.children = new Set,
            this.options = {},
            this.isTreeAnimating = !1,
            this.isAnimationBlocked = !1,
            this.isLayoutDirty = !1,
            this.isProjectionDirty = !1,
            this.isSharedProjectionDirty = !1,
            this.isTransformDirty = !1,
            this.updateManuallyBlocked = !1,
            this.updateBlockedByResize = !1,
            this.isUpdating = !1,
            this.isSVG = !1,
            this.needsReset = !1,
            this.shouldResetTransform = !1,
            this.hasCheckedOptimisedAppear = !1,
            this.treeScale = {
                x: 1,
                y: 1
            },
            this.eventHandlers = new Map,
            this.hasTreeAnimated = !1,
            this.updateScheduled = !1,
            this.scheduleUpdate = () => this.update(),
            this.projectionUpdateScheduled = !1,
            this.checkUpdateFailed = () => {
                this.isUpdating && (this.isUpdating = !1,
                this.clearAllSnapshots())
            }
            ,
            this.updateProjection = () => {
                this.projectionUpdateScheduled = !1,
                this.nodes.forEach(hV),
                this.nodes.forEach(vV),
                this.nodes.forEach(yV),
                this.nodes.forEach(dV)
            }
            ,
            this.resolvedRelativeTargetAt = 0,
            this.hasProjected = !1,
            this.isVisible = !0,
            this.animationProgress = 0,
            this.sharedNodes = new Map,
            this.latestValues = s,
            this.root = l ? l.root || l : this,
            this.path = l ? [...l.path, l] : [],
            this.parent = l,
            this.depth = l ? l.depth + 1 : 0;
            for (let u = 0; u < this.path.length; u++)
                this.path[u].shouldResetTransform = !0;
            this.root === this && (this.nodes = new ZH)
        }
        addEventListener(s, l) {
            return this.eventHandlers.has(s) || this.eventHandlers.set(s, new Kw),
            this.eventHandlers.get(s).add(l)
        }
        notifyListeners(s, ...l) {
            const u = this.eventHandlers.get(s);
            u && u.notify(...l)
        }
        hasListeners(s) {
            return this.eventHandlers.has(s)
        }
        mount(s) {
            if (this.instance)
                return;
            this.isSVG = gA(s) && !r8(s),
            this.instance = s;
            const {layoutId: l, layout: u, visualElement: f} = this.options;
            if (f && !f.current && f.mount(s),
            this.root.nodes.add(this),
            this.parent && this.parent.children.add(this),
            this.root.hasTreeAnimated && (u || l) && (this.isLayoutDirty = !0),
            r) {
                let d;
                const g = () => this.root.updateBlockedByResize = !1;
                r(s, () => {
                    this.root.updateBlockedByResize = !0,
                    d && d(),
                    d = KH(g, 250),
                    cS.hasAnimatedSinceResize && (cS.hasAnimatedSinceResize = !1,
                    this.nodes.forEach(oD))
                }
                )
            }
            l && this.root.registerSharedNode(l, this),
            this.options.animate !== !1 && f && (l || u) && this.addEventListener("didUpdate", ({delta: d, hasLayoutChanged: g, hasRelativeLayoutChanged: v, layout: y}) => {
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0,
                    this.relativeTarget = void 0;
                    return
                }
                const S = this.options.transition || f.getDefaultTransition() || MV
                  , {onLayoutAnimationStart: T, onLayoutAnimationComplete: M} = f.getProps()
                  , b = !this.targetLayout || !t4(this.targetLayout, y)
                  , A = !g && v;
                if (this.options.layoutRoot || this.resumeFrom || A || g && (b || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                    this.resumingFrom.resumingFrom = void 0);
                    const C = {
                        ...fA(S, "layout"),
                        onPlay: T,
                        onComplete: M
                    };
                    (f.shouldReduceMotion || this.options.layoutRoot) && (C.delay = 0,
                    C.type = !1),
                    this.startAnimation(C),
                    this.setAnimationOrigin(d, A)
                } else
                    g || oD(this),
                    this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = y
            }
            )
        }
        unmount() {
            this.options.layoutId && this.willUpdate(),
            this.root.nodes.remove(this);
            const s = this.getStack();
            s && s.remove(this),
            this.parent && this.parent.children.delete(this),
            this.instance = void 0,
            this.eventHandlers.clear(),
            Ql(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0,
            this.nodes && this.nodes.forEach(_V),
            this.animationId++)
        }
        getTransformTemplate() {
            const {visualElement: s} = this.options;
            return s && s.getProps().transformTemplate
        }
        willUpdate(s=!0) {
            if (this.root.hasTreeAnimated = !0,
            this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && n4(this),
            !this.root.isUpdating && this.root.startUpdate(),
            this.isLayoutDirty)
                return;
            this.isLayoutDirty = !0;
            for (let d = 0; d < this.path.length; d++) {
                const g = this.path[d];
                g.shouldResetTransform = !0,
                g.updateScroll("snapshot"),
                g.options.layoutRoot && g.willUpdate(!1)
            }
            const {layoutId: l, layout: u} = this.options;
            if (l === void 0 && !u)
                return;
            const f = this.getTransformTemplate();
            this.prevTransformTemplateValue = f ? f(this.latestValues, "") : void 0,
            this.updateSnapshot(),
            s && this.notifyListeners("willUpdate")
        }
        update() {
            if (this.updateScheduled = !1,
            this.isUpdateBlocked()) {
                this.unblockUpdate(),
                this.clearAllSnapshots(),
                this.nodes.forEach(sD);
                return
            }
            this.isUpdating || this.nodes.forEach(mV),
            this.isUpdating = !1,
            this.nodes.forEach(gV),
            this.nodes.forEach(cV),
            this.nodes.forEach(fV),
            this.clearAllSnapshots();
            const l = ks.now();
            Qr.delta = ec(0, 1e3 / 60, l - Qr.timestamp),
            Qr.timestamp = l,
            Qr.isProcessing = !0,
            R2.update.process(Qr),
            R2.preRender.process(Qr),
            R2.render.process(Qr),
            Qr.isProcessing = !1
        }
        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0,
            pA.read(this.scheduleUpdate))
        }
        clearAllSnapshots() {
            this.nodes.forEach(pV),
            this.sharedNodes.forEach(xV)
        }
        scheduleUpdateProjection() {
            this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0,
            wi.preRender(this.updateProjection, !1, !0))
        }
        scheduleCheckAfterUnmount() {
            wi.postRender( () => {
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            }
            )
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure(),
            this.snapshot && !gs(this.snapshot.measuredBox.x) && !gs(this.snapshot.measuredBox.y) && (this.snapshot = void 0))
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(),
            !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
                return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let u = 0; u < this.path.length; u++)
                    this.path[u].updateScroll();
            const s = this.layout;
            this.layout = this.measure(!1),
            this.layoutCorrected = mr(),
            this.isLayoutDirty = !1,
            this.projectionDelta = void 0,
            this.notifyListeners("measure", this.layout.layoutBox);
            const {visualElement: l} = this.options;
            l && l.notify("LayoutMeasure", this.layout.layoutBox, s ? s.layoutBox : void 0)
        }
        updateScroll(s="measure") {
            let l = !!(this.options.layoutScroll && this.instance);
            if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s && (l = !1),
            l && this.instance) {
                const u = n(this.instance);
                this.scroll = {
                    animationId: this.root.animationId,
                    phase: s,
                    isRoot: u,
                    offset: t(this.instance),
                    wasRoot: this.scroll ? this.scroll.isRoot : u
                }
            }
        }
        resetTransform() {
            if (!i)
                return;
            const s = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout
              , l = this.projectionDelta && !e4(this.projectionDelta)
              , u = this.getTransformTemplate()
              , f = u ? u(this.latestValues, "") : void 0
              , d = f !== this.prevTransformTemplateValue;
            s && this.instance && (l || Nd(this.latestValues) || d) && (i(this.instance, f),
            this.shouldResetTransform = !1,
            this.scheduleRender())
        }
        measure(s=!0) {
            const l = this.measurePageBox();
            let u = this.removeElementScroll(l);
            return s && (u = this.removeTransform(u)),
            TV(u),
            {
                animationId: this.root.animationId,
                measuredBox: l,
                layoutBox: u,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            var f;
            const {visualElement: s} = this.options;
            if (!s)
                return mr();
            const l = s.measureViewportBox();
            if (!(((f = this.scroll) == null ? void 0 : f.wasRoot) || this.path.some(EV))) {
                const {scroll: d} = this.root;
                d && (Qm(l.x, d.offset.x),
                Qm(l.y, d.offset.y))
            }
            return l
        }
        removeElementScroll(s) {
            var u;
            const l = mr();
            if (qo(l, s),
            (u = this.scroll) != null && u.wasRoot)
                return l;
            for (let f = 0; f < this.path.length; f++) {
                const d = this.path[f]
                  , {scroll: g, options: v} = d;
                d !== this.root && g && v.layoutScroll && (g.wasRoot && qo(l, s),
                Qm(l.x, g.offset.x),
                Qm(l.y, g.offset.y))
            }
            return l
        }
        applyTransform(s, l=!1) {
            const u = mr();
            qo(u, s);
            for (let f = 0; f < this.path.length; f++) {
                const d = this.path[f];
                !l && d.options.layoutScroll && d.scroll && d !== d.root && Jm(u, {
                    x: -d.scroll.offset.x,
                    y: -d.scroll.offset.y
                }),
                Nd(d.latestValues) && Jm(u, d.latestValues)
            }
            return Nd(this.latestValues) && Jm(u, this.latestValues),
            u
        }
        removeTransform(s) {
            const l = mr();
            qo(l, s);
            for (let u = 0; u < this.path.length; u++) {
                const f = this.path[u];
                if (!f.instance || !Nd(f.latestValues))
                    continue;
                PE(f.latestValues) && f.updateSnapshot();
                const d = mr()
                  , g = f.measurePageBox();
                qo(d, g),
                eD(l, f.latestValues, f.snapshot ? f.snapshot.layoutBox : void 0, d)
            }
            return Nd(this.latestValues) && eD(l, this.latestValues),
            l
        }
        setTargetDelta(s) {
            this.targetDelta = s,
            this.root.scheduleUpdateProjection(),
            this.isProjectionDirty = !0
        }
        setOptions(s) {
            this.options = {
                ...this.options,
                ...s,
                crossfade: s.crossfade !== void 0 ? s.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0,
            this.layout = void 0,
            this.snapshot = void 0,
            this.prevTransformTemplateValue = void 0,
            this.targetDelta = void 0,
            this.target = void 0,
            this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Qr.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(s=!1) {
            var v;
            const l = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty),
            this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty),
            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
            const u = !!this.resumingFrom || this !== l;
            if (!(s || u && this.isSharedProjectionDirty || this.isProjectionDirty || (v = this.parent) != null && v.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
                return;
            const {layout: d, layoutId: g} = this.options;
            if (!(!this.layout || !(d || g))) {
                if (this.resolvedRelativeTargetAt = Qr.timestamp,
                !this.targetDelta && !this.relativeTarget) {
                    const y = this.getClosestProjectingParent();
                    y && y.layout && this.animationProgress !== 1 ? (this.relativeParent = y,
                    this.forceRelativeParentToResolveTarget(),
                    this.relativeTarget = mr(),
                    this.relativeTargetOrigin = mr(),
                    Wv(this.relativeTargetOrigin, this.layout.layoutBox, y.layout.layoutBox),
                    qo(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = mr(),
                this.targetWithTransforms = mr()),
                this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(),
                AH(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : qo(this.target, this.layout.layoutBox),
                WL(this.target, this.targetDelta)) : qo(this.target, this.layout.layoutBox),
                this.attemptToResolveRelativeTarget)) {
                    this.attemptToResolveRelativeTarget = !1;
                    const y = this.getClosestProjectingParent();
                    y && !!y.resumingFrom == !!this.resumingFrom && !y.options.layoutScroll && y.target && this.animationProgress !== 1 ? (this.relativeParent = y,
                    this.forceRelativeParentToResolveTarget(),
                    this.relativeTarget = mr(),
                    this.relativeTargetOrigin = mr(),
                    Wv(this.relativeTargetOrigin, this.target, y.target),
                    qo(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || PE(this.parent.latestValues) || jL(this.parent.latestValues)))
                return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var S;
            const s = this.getLead()
              , l = !!this.resumingFrom || this !== s;
            let u = !0;
            if ((this.isProjectionDirty || (S = this.parent) != null && S.isProjectionDirty) && (u = !1),
            l && (this.isSharedProjectionDirty || this.isTransformDirty) && (u = !1),
            this.resolvedRelativeTargetAt === Qr.timestamp && (u = !1),
            u)
                return;
            const {layout: f, layoutId: d} = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
            this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
            !this.layout || !(f || d))
                return;
            qo(this.layoutCorrected, this.layout.layoutBox);
            const g = this.treeScale.x
              , v = this.treeScale.y;
            CH(this.layoutCorrected, this.treeScale, this.path, l),
            s.layout && !s.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (s.target = s.layout.layoutBox,
            s.targetWithTransforms = mr());
            const {target: y} = s;
            if (!y) {
                this.prevProjectionDelta && (this.createProjectionDeltas(),
                this.scheduleRender());
                return
            }
            !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Q3(this.prevProjectionDelta.x, this.projectionDelta.x),
            Q3(this.prevProjectionDelta.y, this.projectionDelta.y)),
            jv(this.projectionDelta, this.layoutCorrected, y, this.latestValues),
            (this.treeScale.x !== g || this.treeScale.y !== v || !aD(this.projectionDelta.x, this.prevProjectionDelta.x) || !aD(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0,
            this.scheduleRender(),
            this.notifyListeners("projectionUpdate", y))
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(s=!0) {
            var l;
            if ((l = this.options.visualElement) == null || l.scheduleRender(),
            s) {
                const u = this.getStack();
                u && u.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        createProjectionDeltas() {
            this.prevProjectionDelta = Km(),
            this.projectionDelta = Km(),
            this.projectionDeltaWithTransform = Km()
        }
        setAnimationOrigin(s, l=!1) {
            const u = this.snapshot
              , f = u ? u.latestValues : {}
              , d = {
                ...this.latestValues
            }
              , g = Km();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0),
            this.attemptToResolveRelativeTarget = !l;
            const v = mr()
              , y = u ? u.source : void 0
              , S = this.layout ? this.layout.source : void 0
              , T = y !== S
              , M = this.getStack()
              , b = !M || M.members.length <= 1
              , A = !!(T && !b && this.options.crossfade === !0 && !this.path.some(bV));
            this.animationProgress = 0;
            let C;
            this.mixTargetDelta = R => {
                const O = R / 1e3;
                lD(g.x, s.x, O),
                lD(g.y, s.y, O),
                this.setTargetDelta(g),
                this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Wv(v, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                SV(this.relativeTarget, this.relativeTargetOrigin, v, O),
                C && rV(this.relativeTarget, C) && (this.isProjectionDirty = !1),
                C || (C = mr()),
                qo(C, this.relativeTarget)),
                T && (this.animationValues = d,
                JH(d, f, this.latestValues, O, A, b)),
                this.root.scheduleUpdateProjection(),
                this.scheduleRender(),
                this.animationProgress = O
            }
            ,
            this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(s) {
            var l, u, f;
            this.notifyListeners("animationStart"),
            (l = this.currentAnimation) == null || l.stop(),
            (f = (u = this.resumingFrom) == null ? void 0 : u.currentAnimation) == null || f.stop(),
            this.pendingAnimation && (Ql(this.pendingAnimation),
            this.pendingAnimation = void 0),
            this.pendingAnimation = wi.update( () => {
                cS.hasAnimatedSinceResize = !0,
                this.motionValue || (this.motionValue = ql(0)),
                this.currentAnimation = YH(this.motionValue, [0, 1e3], {
                    ...s,
                    isSync: !0,
                    onUpdate: d => {
                        this.mixTargetDelta(d),
                        s.onUpdate && s.onUpdate(d)
                    }
                    ,
                    onStop: () => {}
                    ,
                    onComplete: () => {
                        s.onComplete && s.onComplete(),
                        this.completeAnimation()
                    }
                }),
                this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                this.pendingAnimation = void 0
            }
            )
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
            this.resumingFrom.preserveOpacity = void 0);
            const s = this.getStack();
            s && s.exitAnimationComplete(),
            this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
            this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(lV),
            this.currentAnimation.stop()),
            this.completeAnimation()
        }
        applyTransformsToTarget() {
            const s = this.getLead();
            let {targetWithTransforms: l, target: u, layout: f, latestValues: d} = s;
            if (!(!l || !u || !f)) {
                if (this !== s && this.layout && f && r4(this.options.animationType, this.layout.layoutBox, f.layoutBox)) {
                    u = this.target || mr();
                    const g = gs(this.layout.layoutBox.x);
                    u.x.min = s.target.x.min,
                    u.x.max = u.x.min + g;
                    const v = gs(this.layout.layoutBox.y);
                    u.y.min = s.target.y.min,
                    u.y.max = u.y.min + v
                }
                qo(l, u),
                Jm(l, d),
                jv(this.projectionDeltaWithTransform, this.layoutCorrected, l, d)
            }
        }
        registerSharedNode(s, l) {
            this.sharedNodes.has(s) || this.sharedNodes.set(s, new aV),
            this.sharedNodes.get(s).add(l);
            const f = l.options.initialPromotionConfig;
            l.promote({
                transition: f ? f.transition : void 0,
                preserveFollowOpacity: f && f.shouldPreserveFollowOpacity ? f.shouldPreserveFollowOpacity(l) : void 0
            })
        }
        isLead() {
            const s = this.getStack();
            return s ? s.lead === this : !0
        }
        getLead() {
            var l;
            const {layoutId: s} = this.options;
            return s ? ((l = this.getStack()) == null ? void 0 : l.lead) || this : this
        }
        getPrevLead() {
            var l;
            const {layoutId: s} = this.options;
            return s ? (l = this.getStack()) == null ? void 0 : l.prevLead : void 0
        }
        getStack() {
            const {layoutId: s} = this.options;
            if (s)
                return this.root.sharedNodes.get(s)
        }
        promote({needsReset: s, transition: l, preserveFollowOpacity: u}={}) {
            const f = this.getStack();
            f && f.promote(this, u),
            s && (this.projectionDelta = void 0,
            this.needsReset = !0),
            l && this.setOptions({
                transition: l
            })
        }
        relegate() {
            const s = this.getStack();
            return s ? s.relegate(this) : !1
        }
        resetSkewAndRotation() {
            const {visualElement: s} = this.options;
            if (!s)
                return;
            let l = !1;
            const {latestValues: u} = s;
            if ((u.z || u.rotate || u.rotateX || u.rotateY || u.rotateZ || u.skewX || u.skewY) && (l = !0),
            !l)
                return;
            const f = {};
            u.z && I2("z", s, f, this.animationValues);
            for (let d = 0; d < z2.length; d++)
                I2(`rotate${z2[d]}`, s, f, this.animationValues),
                I2(`skew${z2[d]}`, s, f, this.animationValues);
            s.render();
            for (const d in f)
                s.setStaticValue(d, f[d]),
                this.animationValues && (this.animationValues[d] = f[d]);
            s.scheduleRender()
        }
        getProjectionStyles(s) {
            if (!this.instance || this.isSVG)
                return;
            if (!this.isVisible)
                return oV;
            const l = {
                visibility: ""
            }
              , u = this.getTransformTemplate();
            if (this.needsReset)
                return this.needsReset = !1,
                l.opacity = "",
                l.pointerEvents = uS(s == null ? void 0 : s.pointerEvents) || "",
                l.transform = u ? u(this.latestValues, "") : "none",
                l;
            const f = this.getLead();
            if (!this.projectionDelta || !this.layout || !f.target) {
                const y = {};
                return this.options.layoutId && (y.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1,
                y.pointerEvents = uS(s == null ? void 0 : s.pointerEvents) || ""),
                this.hasProjected && !Nd(this.latestValues) && (y.transform = u ? u({}, "") : "none",
                this.hasProjected = !1),
                y
            }
            const d = f.animationValues || f.latestValues;
            this.applyTransformsToTarget(),
            l.transform = sV(this.projectionDeltaWithTransform, this.treeScale, d),
            u && (l.transform = u(d, l.transform));
            const {x: g, y: v} = this.projectionDelta;
            l.transformOrigin = `${g.origin * 100}% ${v.origin * 100}% 0`,
            f.animationValues ? l.opacity = f === this ? d.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : d.opacityExit : l.opacity = f === this ? d.opacity !== void 0 ? d.opacity : "" : d.opacityExit !== void 0 ? d.opacityExit : 0;
            for (const y in Ty) {
                if (d[y] === void 0)
                    continue;
                const {correct: S, applyTo: T, isCSSVariable: M} = Ty[y]
                  , b = l.transform === "none" ? d[y] : S(d[y], f);
                if (T) {
                    const A = T.length;
                    for (let C = 0; C < A; C++)
                        l[T[C]] = b
                } else
                    M ? this.options.visualElement.renderState.vars[y] = b : l[y] = b
            }
            return this.options.layoutId && (l.pointerEvents = f === this ? uS(s == null ? void 0 : s.pointerEvents) || "" : "none"),
            l
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(s => {
                var l;
                return (l = s.currentAnimation) == null ? void 0 : l.stop()
            }
            ),
            this.root.nodes.forEach(sD),
            this.root.sharedNodes.clear()
        }
    }
}
function cV(r) {
    r.updateLayout()
}
function fV(r) {
    var t;
    const e = ((t = r.resumeFrom) == null ? void 0 : t.snapshot) || r.snapshot;
    if (r.isLead() && r.layout && e && r.hasListeners("didUpdate")) {
        const {layoutBox: n, measuredBox: i} = r.layout
          , {animationType: a} = r.options
          , s = e.source !== r.layout.source;
        a === "size" ? Ko(g => {
            const v = s ? e.measuredBox[g] : e.layoutBox[g]
              , y = gs(v);
            v.min = n[g].min,
            v.max = v.min + y
        }
        ) : r4(a, e.layoutBox, n) && Ko(g => {
            const v = s ? e.measuredBox[g] : e.layoutBox[g]
              , y = gs(n[g]);
            v.max = v.min + y,
            r.relativeTarget && !r.currentAnimation && (r.isProjectionDirty = !0,
            r.relativeTarget[g].max = r.relativeTarget[g].min + y)
        }
        );
        const l = Km();
        jv(l, n, e.layoutBox);
        const u = Km();
        s ? jv(u, r.applyTransform(i, !0), e.measuredBox) : jv(u, n, e.layoutBox);
        const f = !e4(l);
        let d = !1;
        if (!r.resumeFrom) {
            const g = r.getClosestProjectingParent();
            if (g && !g.resumeFrom) {
                const {snapshot: v, layout: y} = g;
                if (v && y) {
                    const S = mr();
                    Wv(S, e.layoutBox, v.layoutBox);
                    const T = mr();
                    Wv(T, n, y.layoutBox),
                    t4(S, T) || (d = !0),
                    g.options.layoutRoot && (r.relativeTarget = T,
                    r.relativeTargetOrigin = S,
                    r.relativeParent = g)
                }
            }
        }
        r.notifyListeners("didUpdate", {
            layout: n,
            snapshot: e,
            delta: u,
            layoutDelta: l,
            hasLayoutChanged: f,
            hasRelativeLayoutChanged: d
        })
    } else if (r.isLead()) {
        const {onExitComplete: n} = r.options;
        n && n()
    }
    r.options.transition = void 0
}
function hV(r) {
    r.parent && (r.isProjecting() || (r.isProjectionDirty = r.parent.isProjectionDirty),
    r.isSharedProjectionDirty || (r.isSharedProjectionDirty = !!(r.isProjectionDirty || r.parent.isProjectionDirty || r.parent.isSharedProjectionDirty)),
    r.isTransformDirty || (r.isTransformDirty = r.parent.isTransformDirty))
}
function dV(r) {
    r.isProjectionDirty = r.isSharedProjectionDirty = r.isTransformDirty = !1
}
function pV(r) {
    r.clearSnapshot()
}
function sD(r) {
    r.clearMeasurements()
}
function mV(r) {
    r.isLayoutDirty = !1
}
function gV(r) {
    const {visualElement: e} = r.options;
    e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    r.resetTransform()
}
function oD(r) {
    r.finishAnimation(),
    r.targetDelta = r.relativeTarget = r.target = void 0,
    r.isProjectionDirty = !0
}
function vV(r) {
    r.resolveTargetDelta()
}
function yV(r) {
    r.calcProjection()
}
function _V(r) {
    r.resetSkewAndRotation()
}
function xV(r) {
    r.removeLeadSnapshot()
}
function lD(r, e, t) {
    r.translate = Ji(e.translate, 0, t),
    r.scale = Ji(e.scale, 1, t),
    r.origin = e.origin,
    r.originPoint = e.originPoint
}
function uD(r, e, t, n) {
    r.min = Ji(e.min, t.min, n),
    r.max = Ji(e.max, t.max, n)
}
function SV(r, e, t, n) {
    uD(r.x, e.x, t.x, n),
    uD(r.y, e.y, t.y, n)
}
function bV(r) {
    return r.animationValues && r.animationValues.opacityExit !== void 0
}
const MV = {
    duration: .45,
    ease: [.4, 0, .1, 1]
}
  , cD = r => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(r)
  , fD = cD("applewebkit/") && !cD("chrome/") ? Math.round : Gs;
function hD(r) {
    r.min = fD(r.min),
    r.max = fD(r.max)
}
function TV(r) {
    hD(r.x),
    hD(r.y)
}
function r4(r, e, t) {
    return r === "position" || r === "preserve-aspect" && !wH(rD(e), rD(t), .2)
}
function EV(r) {
    var e;
    return r !== r.root && ((e = r.scroll) == null ? void 0 : e.wasRoot)
}
const wV = i4({
    attachResizeListener: (r, e) => wy(r, "resize", e),
    measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => !0
})
  , F2 = {
    current: void 0
}
  , a4 = i4({
    measureScroll: r => ({
        x: r.scrollLeft,
        y: r.scrollTop
    }),
    defaultParent: () => {
        if (!F2.current) {
            const r = new wV({});
            r.mount(window),
            r.setOptions({
                layoutScroll: !0
            }),
            F2.current = r
        }
        return F2.current
    }
    ,
    resetTransform: (r, e) => {
        r.style.transform = e !== void 0 ? e : "none"
    }
    ,
    checkIsScrollRoot: r => window.getComputedStyle(r).position === "fixed"
})
  , AV = {
    pan: {
        Feature: GH
    },
    drag: {
        Feature: kH,
        ProjectionNode: a4,
        MeasureLayout: QL
    }
};
function dD(r, e, t) {
    const {props: n} = r;
    r.animationState && n.whileHover && r.animationState.setActive("whileHover", t === "Start");
    const i = "onHover" + t
      , a = n[i];
    a && wi.postRender( () => a(e, r_(e)))
}
class CV extends bh {
    mount() {
        const {current: e} = this.node;
        e && (this.unmount = $6(e, (t, n) => (dD(this.node, n, "Start"),
        i => dD(this.node, i, "End"))))
    }
    unmount() {}
}
class RV extends bh {
    constructor() {
        super(...arguments),
        this.isActive = !1
    }
    onFocus() {
        let e = !1;
        try {
            e = this.node.current.matches(":focus-visible")
        } catch {
            e = !0
        }
        !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0),
        this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1),
        this.isActive = !1)
    }
    mount() {
        this.unmount = t_(wy(this.node.current, "focus", () => this.onFocus()), wy(this.node.current, "blur", () => this.onBlur()))
    }
    unmount() {}
}
function pD(r, e, t) {
    const {props: n} = r;
    if (r.current instanceof HTMLButtonElement && r.current.disabled)
        return;
    r.animationState && n.whileTap && r.animationState.setActive("whileTap", t === "Start");
    const i = "onTap" + (t === "End" ? "" : t)
      , a = n[i];
    a && wi.postRender( () => a(e, r_(e)))
}
class DV extends bh {
    mount() {
        const {current: e} = this.node;
        e && (this.unmount = i8(e, (t, n) => (pD(this.node, n, "Start"),
        (i, {success: a}) => pD(this.node, i, a ? "End" : "Cancel")), {
            useGlobalTarget: this.node.props.globalTapTarget
        }))
    }
    unmount() {}
}
const IE = new WeakMap
  , H2 = new WeakMap
  , UV = r => {
    const e = IE.get(r.target);
    e && e(r)
}
  , OV = r => {
    r.forEach(UV)
}
;
function NV({root: r, ...e}) {
    const t = r || document;
    H2.has(t) || H2.set(t, {});
    const n = H2.get(t)
      , i = JSON.stringify(e);
    return n[i] || (n[i] = new IntersectionObserver(OV,{
        root: r,
        ...e
    })),
    n[i]
}
function LV(r, e, t) {
    const n = NV(e);
    return IE.set(r, t),
    n.observe(r),
    () => {
        IE.delete(r),
        n.unobserve(r)
    }
}
const PV = {
    some: 0,
    all: 1
};
class BV extends bh {
    constructor() {
        super(...arguments),
        this.hasEnteredView = !1,
        this.isInView = !1
    }
    startObserver() {
        this.unmount();
        const {viewport: e={}} = this.node.getProps()
          , {root: t, margin: n, amount: i="some", once: a} = e
          , s = {
            root: t ? t.current : void 0,
            rootMargin: n,
            threshold: typeof i == "number" ? i : PV[i]
        }
          , l = u => {
            const {isIntersecting: f} = u;
            if (this.isInView === f || (this.isInView = f,
            a && !f && this.hasEnteredView))
                return;
            f && (this.hasEnteredView = !0),
            this.node.animationState && this.node.animationState.setActive("whileInView", f);
            const {onViewportEnter: d, onViewportLeave: g} = this.node.getProps()
              , v = f ? d : g;
            v && v(u)
        }
        ;
        return LV(this.node.current, s, l)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u")
            return;
        const {props: e, prevProps: t} = this.node;
        ["amount", "margin", "root"].some(zV(e, t)) && this.startObserver()
    }
    unmount() {}
}
function zV({viewport: r={}}, {viewport: e={}}={}) {
    return t => r[t] !== e[t]
}
const IV = {
    inView: {
        Feature: BV
    },
    tap: {
        Feature: DV
    },
    focus: {
        Feature: RV
    },
    hover: {
        Feature: CV
    }
}
  , FV = {
    layout: {
        ProjectionNode: a4,
        MeasureLayout: QL
    }
}
  , FE = {
    current: null
}
  , s4 = {
    current: !1
};
function HV() {
    if (s4.current = !0,
    !!jw)
        if (window.matchMedia) {
            const r = window.matchMedia("(prefers-reduced-motion)")
              , e = () => FE.current = r.matches;
            r.addListener(e),
            e()
        } else
            FE.current = !1
}
const VV = new WeakMap;
function kV(r, e, t) {
    for (const n in e) {
        const i = e[n]
          , a = t[n];
        if (Ia(i))
            r.addValue(n, i);
        else if (Ia(a))
            r.addValue(n, ql(i, {
                owner: r
            }));
        else if (a !== i)
            if (r.hasValue(n)) {
                const s = r.getValue(n);
                s.liveStyle === !0 ? s.jump(i) : s.hasAnimated || s.set(i)
            } else {
                const s = r.getStaticValue(n);
                r.addValue(n, ql(s !== void 0 ? s : i, {
                    owner: r
                }))
            }
    }
    for (const n in t)
        e[n] === void 0 && r.removeValue(n);
    return e
}
const mD = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"];
class GV {
    scrapeMotionValuesFromProps(e, t, n) {
        return {}
    }
    constructor({parent: e, props: t, presenceContext: n, reducedMotionConfig: i, blockInitialAnimation: a, visualState: s}, l={}) {
        this.current = null,
        this.children = new Set,
        this.isVariantNode = !1,
        this.isControllingVariants = !1,
        this.shouldReduceMotion = null,
        this.values = new Map,
        this.KeyframeResolver = cA,
        this.features = {},
        this.valueSubscriptions = new Map,
        this.prevMotionValues = {},
        this.events = {},
        this.propEventSubscriptions = {},
        this.notifyUpdate = () => this.notify("Update", this.latestValues),
        this.render = () => {
            this.current && (this.triggerBuild(),
            this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }
        ,
        this.renderScheduledAt = 0,
        this.scheduleRender = () => {
            const v = ks.now();
            this.renderScheduledAt < v && (this.renderScheduledAt = v,
            wi.render(this.render, !1, !0))
        }
        ;
        const {latestValues: u, renderState: f} = s;
        this.latestValues = u,
        this.baseTarget = {
            ...u
        },
        this.initialValues = t.initial ? {
            ...u
        } : {},
        this.renderState = f,
        this.parent = e,
        this.props = t,
        this.presenceContext = n,
        this.depth = e ? e.depth + 1 : 0,
        this.reducedMotionConfig = i,
        this.options = l,
        this.blockInitialAnimation = !!a,
        this.isControllingVariants = Jb(t),
        this.isVariantNode = AL(t),
        this.isVariantNode && (this.variantChildren = new Set),
        this.manuallyAnimateOnMount = !!(e && e.current);
        const {willChange: d, ...g} = this.scrapeMotionValuesFromProps(t, {}, this);
        for (const v in g) {
            const y = g[v];
            u[v] !== void 0 && Ia(y) && y.set(u[v], !1)
        }
    }
    mount(e) {
        this.current = e,
        VV.set(e, this),
        this.projection && !this.projection.instance && this.projection.mount(e),
        this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
        this.values.forEach( (t, n) => this.bindToMotionValue(n, t)),
        s4.current || HV(),
        this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : FE.current,
        this.parent && this.parent.children.add(this),
        this.update(this.props, this.presenceContext)
    }
    unmount() {
        this.projection && this.projection.unmount(),
        Ql(this.notifyUpdate),
        Ql(this.render),
        this.valueSubscriptions.forEach(e => e()),
        this.valueSubscriptions.clear(),
        this.removeFromVariantTree && this.removeFromVariantTree(),
        this.parent && this.parent.children.delete(this);
        for (const e in this.events)
            this.events[e].clear();
        for (const e in this.features) {
            const t = this.features[e];
            t && (t.unmount(),
            t.isMounted = !1)
        }
        this.current = null
    }
    bindToMotionValue(e, t) {
        this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
        const n = Vg.has(e);
        n && this.onBindTransform && this.onBindTransform();
        const i = t.on("change", l => {
            this.latestValues[e] = l,
            this.props.onUpdate && wi.preRender(this.notifyUpdate),
            n && this.projection && (this.projection.isTransformDirty = !0)
        }
        )
          , a = t.on("renderRequest", this.scheduleRender);
        let s;
        window.MotionCheckAppearSync && (s = window.MotionCheckAppearSync(this, e, t)),
        this.valueSubscriptions.set(e, () => {
            i(),
            a(),
            s && s(),
            t.owner && t.stop()
        }
        )
    }
    sortNodePosition(e) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current)
    }
    updateFeatures() {
        let e = "animation";
        for (e in mg) {
            const t = mg[e];
            if (!t)
                continue;
            const {isEnabled: n, Feature: i} = t;
            if (!this.features[e] && i && n(this.props) && (this.features[e] = new i(this)),
            this.features[e]) {
                const a = this.features[e];
                a.isMounted ? a.update() : (a.mount(),
                a.isMounted = !0)
            }
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : mr()
    }
    getStaticValue(e) {
        return this.latestValues[e]
    }
    setStaticValue(e, t) {
        this.latestValues[e] = t
    }
    update(e, t) {
        (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
        this.prevProps = this.props,
        this.props = e,
        this.prevPresenceContext = this.presenceContext,
        this.presenceContext = t;
        for (let n = 0; n < mD.length; n++) {
            const i = mD[n];
            this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](),
            delete this.propEventSubscriptions[i]);
            const a = "on" + i
              , s = e[a];
            s && (this.propEventSubscriptions[i] = this.on(i, s))
        }
        this.prevMotionValues = kV(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues),
        this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
        return this.props
    }
    getVariant(e) {
        return this.props.variants ? this.props.variants[e] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    addVariantChild(e) {
        const t = this.getClosestVariantNode();
        if (t)
            return t.variantChildren && t.variantChildren.add(e),
            () => t.variantChildren.delete(e)
    }
    addValue(e, t) {
        const n = this.values.get(e);
        t !== n && (n && this.removeValue(e),
        this.bindToMotionValue(e, t),
        this.values.set(e, t),
        this.latestValues[e] = t.get())
    }
    removeValue(e) {
        this.values.delete(e);
        const t = this.valueSubscriptions.get(e);
        t && (t(),
        this.valueSubscriptions.delete(e)),
        delete this.latestValues[e],
        this.removeValueFromRenderState(e, this.renderState)
    }
    hasValue(e) {
        return this.values.has(e)
    }
    getValue(e, t) {
        if (this.props.values && this.props.values[e])
            return this.props.values[e];
        let n = this.values.get(e);
        return n === void 0 && t !== void 0 && (n = ql(t === null ? void 0 : t, {
            owner: this
        }),
        this.addValue(e, n)),
        n
    }
    readValue(e, t) {
        let n = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : this.getBaseTargetFromProps(this.props, e) ?? this.readValueFromInstance(this.current, e, this.options);
        return n != null && (typeof n == "string" && (LN(n) || BN(n)) ? n = parseFloat(n) : !o8(n) && mh.test(t) && (n = yL(e, t)),
        this.setBaseTarget(e, Ia(n) ? n.get() : n)),
        Ia(n) ? n.get() : n
    }
    setBaseTarget(e, t) {
        this.baseTarget[e] = t
    }
    getBaseTarget(e) {
        var a;
        const {initial: t} = this.props;
        let n;
        if (typeof t == "string" || typeof t == "object") {
            const s = MA(this.props, t, (a = this.presenceContext) == null ? void 0 : a.custom);
            s && (n = s[e])
        }
        if (t && n !== void 0)
            return n;
        const i = this.getBaseTargetFromProps(this.props, e);
        return i !== void 0 && !Ia(i) ? i : this.initialValues[e] !== void 0 && n === void 0 ? void 0 : this.baseTarget[e]
    }
    on(e, t) {
        return this.events[e] || (this.events[e] = new Kw),
        this.events[e].add(t)
    }
    notify(e, ...t) {
        this.events[e] && this.events[e].notify(...t)
    }
}
class o4 extends GV {
    constructor() {
        super(...arguments),
        this.KeyframeResolver = Z6
    }
    sortInstanceNodePosition(e, t) {
        return e.compareDocumentPosition(t) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(e, t) {
        return e.style ? e.style[t] : void 0
    }
    removeValueFromRenderState(e, {vars: t, style: n}) {
        delete t[e],
        delete n[e]
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(),
        delete this.childSubscription);
        const {children: e} = this.props;
        Ia(e) && (this.childSubscription = e.on("change", t => {
            this.current && (this.current.textContent = `${t}`)
        }
        ))
    }
}
function l4(r, {style: e, vars: t}, n, i) {
    Object.assign(r.style, e, i && i.getProjectionStyles(n));
    for (const a in t)
        r.style.setProperty(a, t[a])
}
function XV(r) {
    return window.getComputedStyle(r)
}
class jV extends o4 {
    constructor() {
        super(...arguments),
        this.type = "html",
        this.renderInstance = l4
    }
    readValueFromInstance(e, t) {
        var n;
        if (Vg.has(t))
            return (n = this.projection) != null && n.isProjecting ? wE(t) : m6(e, t);
        {
            const i = XV(e)
              , a = (eA(t) ? i.getPropertyValue(t) : i[t]) || 0;
            return typeof a == "string" ? a.trim() : a
        }
    }
    measureInstanceViewportBox(e, {transformPagePoint: t}) {
        return YL(e, t)
    }
    build(e, t, n) {
        xA(e, t, n.transformTemplate)
    }
    scrapeMotionValuesFromProps(e, t, n) {
        return TA(e, t, n)
    }
}
const u4 = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
function WV(r, e, t, n) {
    l4(r, e, void 0, n);
    for (const i in e.attrs)
        r.setAttribute(u4.has(i) ? i : _A(i), e.attrs[i])
}
class YV extends o4 {
    constructor() {
        super(...arguments),
        this.type = "svg",
        this.isSVGTag = !1,
        this.measureInstanceViewportBox = mr
    }
    getBaseTargetFromProps(e, t) {
        return e[t]
    }
    readValueFromInstance(e, t) {
        if (Vg.has(t)) {
            const n = vL(t);
            return n && n.default || 0
        }
        return t = u4.has(t) ? t : _A(t),
        e.getAttribute(t)
    }
    scrapeMotionValuesFromProps(e, t, n) {
        return zL(e, t, n)
    }
    build(e, t, n) {
        NL(e, t, this.isSVGTag, n.transformTemplate, n.style)
    }
    renderInstance(e, t, n, i) {
        WV(e, t, n, i)
    }
    mount(e) {
        this.isSVGTag = PL(e.tagName),
        super.mount(e)
    }
}
const qV = (r, e) => bA(r) ? new YV(e) : new jV(e,{
    allowProjection: r !== de.Fragment
})
  , ZV = W8({
    ...yH,
    ...IV,
    ...AV,
    ...FV
}, qV)
  , Jo = v8(ZV)
  , fS = new WeakMap;
let eh;
function KV(r, e) {
    if (e) {
        const {inlineSize: t, blockSize: n} = e[0];
        return {
            width: t,
            height: n
        }
    } else
        return gA(r) && "getBBox"in r ? r.getBBox() : {
            width: r.offsetWidth,
            height: r.offsetHeight
        }
}
function QV({target: r, contentRect: e, borderBoxSize: t}) {
    var n;
    (n = fS.get(r)) == null || n.forEach(i => {
        i({
            target: r,
            contentSize: e,
            get size() {
                return KV(r, t)
            }
        })
    }
    )
}
function JV(r) {
    r.forEach(QV)
}
function $V() {
    typeof ResizeObserver > "u" || (eh = new ResizeObserver(JV))
}
function ek(r, e) {
    eh || $V();
    const t = dA(r);
    return t.forEach(n => {
        let i = fS.get(n);
        i || (i = new Set,
        fS.set(n, i)),
        i.add(e),
        eh == null || eh.observe(n)
    }
    ),
    () => {
        t.forEach(n => {
            const i = fS.get(n);
            i == null || i.delete(e),
            i != null && i.size || eh == null || eh.unobserve(n)
        }
        )
    }
}
const hS = new Set;
let Yv;
function tk() {
    Yv = () => {
        const r = {
            width: window.innerWidth,
            height: window.innerHeight
        }
          , e = {
            target: window,
            size: r,
            contentSize: r
        };
        hS.forEach(t => t(e))
    }
    ,
    window.addEventListener("resize", Yv)
}
function nk(r) {
    return hS.add(r),
    Yv || tk(),
    () => {
        hS.delete(r),
        !hS.size && Yv && (Yv = void 0)
    }
}
function ik(r, e) {
    return typeof r == "function" ? nk(r) : ek(r, e)
}
const rk = 50
  , gD = () => ({
    current: 0,
    offset: [],
    progress: 0,
    scrollLength: 0,
    targetOffset: 0,
    targetLength: 0,
    containerLength: 0,
    velocity: 0
})
  , ak = () => ({
    time: 0,
    x: gD(),
    y: gD()
})
  , sk = {
    x: {
        length: "Width",
        position: "Left"
    },
    y: {
        length: "Height",
        position: "Top"
    }
};
function vD(r, e, t, n) {
    const i = t[e]
      , {length: a, position: s} = sk[e]
      , l = i.current
      , u = t.time;
    i.current = r[`scroll${s}`],
    i.scrollLength = r[`scroll${a}`] - r[`client${a}`],
    i.offset.length = 0,
    i.offset[0] = 0,
    i.offset[1] = i.scrollLength,
    i.progress = pg(0, i.scrollLength, i.current);
    const f = n - u;
    i.velocity = f > rk ? 0 : Qw(i.current - l, f)
}
function ok(r, e, t) {
    vD(r, "x", e, t),
    vD(r, "y", e, t),
    e.time = t
}
function lk(r, e) {
    const t = {
        x: 0,
        y: 0
    };
    let n = r;
    for (; n && n !== e; )
        if (qb(n))
            t.x += n.offsetLeft,
            t.y += n.offsetTop,
            n = n.offsetParent;
        else if (n.tagName === "svg") {
            const i = n.getBoundingClientRect();
            n = n.parentElement;
            const a = n.getBoundingClientRect();
            t.x += i.left - a.left,
            t.y += i.top - a.top
        } else if (n instanceof SVGGraphicsElement) {
            const {x: i, y: a} = n.getBBox();
            t.x += i,
            t.y += a;
            let s = null
              , l = n.parentNode;
            for (; !s; )
                l.tagName === "svg" && (s = l),
                l = n.parentNode;
            n = s
        } else
            break;
    return t
}
const HE = {
    start: 0,
    center: .5,
    end: 1
};
function yD(r, e, t=0) {
    let n = 0;
    if (r in HE && (r = HE[r]),
    typeof r == "string") {
        const i = parseFloat(r);
        r.endsWith("px") ? n = i : r.endsWith("%") ? r = i / 100 : r.endsWith("vw") ? n = i / 100 * document.documentElement.clientWidth : r.endsWith("vh") ? n = i / 100 * document.documentElement.clientHeight : r = i
    }
    return typeof r == "number" && (n = e * r),
    t + n
}
const uk = [0, 0];
function ck(r, e, t, n) {
    let i = Array.isArray(r) ? r : uk
      , a = 0
      , s = 0;
    return typeof r == "number" ? i = [r, r] : typeof r == "string" && (r = r.trim(),
    r.includes(" ") ? i = r.split(" ") : i = [r, HE[r] ? r : "0"]),
    a = yD(i[0], t, n),
    s = yD(i[1], e),
    a - s
}
const fk = {
    All: [[0, 0], [1, 1]]
}
  , hk = {
    x: 0,
    y: 0
};
function dk(r) {
    return "getBBox"in r && r.tagName !== "svg" ? r.getBBox() : {
        width: r.clientWidth,
        height: r.clientHeight
    }
}
function pk(r, e, t) {
    const {offset: n=fk.All} = t
      , {target: i=r, axis: a="y"} = t
      , s = a === "y" ? "height" : "width"
      , l = i !== r ? lk(i, r) : hk
      , u = i === r ? {
        width: r.scrollWidth,
        height: r.scrollHeight
    } : dk(i)
      , f = {
        width: r.clientWidth,
        height: r.clientHeight
    };
    e[a].offset.length = 0;
    let d = !e[a].interpolate;
    const g = n.length;
    for (let v = 0; v < g; v++) {
        const y = ck(n[v], f[s], u[s], l[a]);
        !d && y !== e[a].interpolatorOffsets[v] && (d = !0),
        e[a].offset[v] = y
    }
    d && (e[a].interpolate = sA(e[a].offset, rL(n), {
        clamp: !1
    }),
    e[a].interpolatorOffsets = [...e[a].offset]),
    e[a].progress = ec(0, 1, e[a].interpolate(e[a].current))
}
function mk(r, e=r, t) {
    if (t.x.targetOffset = 0,
    t.y.targetOffset = 0,
    e !== r) {
        let n = e;
        for (; n && n !== r; )
            t.x.targetOffset += n.offsetLeft,
            t.y.targetOffset += n.offsetTop,
            n = n.offsetParent
    }
    t.x.targetLength = e === r ? e.scrollWidth : e.clientWidth,
    t.y.targetLength = e === r ? e.scrollHeight : e.clientHeight,
    t.x.containerLength = r.clientWidth,
    t.y.containerLength = r.clientHeight
}
function gk(r, e, t, n={}) {
    return {
        measure: i => {
            mk(r, n.target, t),
            ok(r, t, i),
            (n.offset || n.target) && pk(r, t, n)
        }
        ,
        notify: () => e(t)
    }
}
const lv = new WeakMap
  , _D = new WeakMap
  , V2 = new WeakMap
  , xD = r => r === document.scrollingElement ? window : r;
function c4(r, {container: e=document.scrollingElement, ...t}={}) {
    if (!e)
        return Gs;
    let n = V2.get(e);
    n || (n = new Set,
    V2.set(e, n));
    const i = ak()
      , a = gk(e, r, i, t);
    if (n.add(a),
    !lv.has(e)) {
        const l = () => {
            for (const g of n)
                g.measure(Qr.timestamp);
            wi.preUpdate(u)
        }
          , u = () => {
            for (const g of n)
                g.notify()
        }
          , f = () => wi.read(l);
        lv.set(e, f);
        const d = xD(e);
        window.addEventListener("resize", f, {
            passive: !0
        }),
        e !== document.documentElement && _D.set(e, ik(e, f)),
        d.addEventListener("scroll", f, {
            passive: !0
        }),
        f()
    }
    const s = lv.get(e);
    return wi.read(s, !1, !0),
    () => {
        var f;
        Ql(s);
        const l = V2.get(e);
        if (!l || (l.delete(a),
        l.size))
            return;
        const u = lv.get(e);
        lv.delete(e),
        u && (xD(e).removeEventListener("scroll", u),
        (f = _D.get(e)) == null || f(),
        window.removeEventListener("resize", u))
    }
}
const SD = new Map;
function vk(r) {
    const e = {
        value: 0
    }
      , t = c4(n => {
        e.value = n[r.axis].progress * 100
    }
    , r);
    return {
        currentTime: e,
        cancel: t
    }
}
function f4({source: r, container: e, ...t}) {
    const {axis: n} = t;
    r && (e = r);
    const i = SD.get(e) ?? new Map;
    SD.set(e, i);
    const a = t.target ?? "self"
      , s = i.get(a) ?? {}
      , l = n + (t.offset ?? []).join(",");
    return s[l] || (s[l] = !t.target && lL() ? new ScrollTimeline({
        source: e,
        axis: n
    }) : vk({
        container: e,
        ...t
    })),
    s[l]
}
function yk(r, e) {
    const t = f4(e);
    return r.attachTimeline({
        timeline: e.target ? void 0 : t,
        observe: n => (n.pause(),
        ML(i => {
            n.time = n.duration * i
        }
        , t))
    })
}
function _k(r) {
    return r.length === 2
}
function xk(r, e) {
    return _k(r) ? c4(t => {
        r(t[e.axis].progress, t)
    }
    , e) : ML(r, f4(e))
}
function Sk(r, {axis: e="y", container: t=document.scrollingElement, ...n}={}) {
    if (!t)
        return Gs;
    const i = {
        axis: e,
        container: t,
        ...n
    };
    return typeof r == "function" ? xk(r, i) : yk(r, i)
}
function bD(r, e) {
    pF(!!(!e || e.current))
}
const bk = () => ({
    scrollX: ql(0),
    scrollY: ql(0),
    scrollXProgress: ql(0),
    scrollYProgress: ql(0)
});
function Mk({container: r, target: e, layoutEffect: t=!0, ...n}={}) {
    const i = Ig(bk);
    return (t ? Wb : de.useEffect)( () => (bD("target", e),
    bD("container", r),
    Sk( (s, {x: l, y: u}) => {
        i.scrollX.set(l.current),
        i.scrollXProgress.set(l.progress),
        i.scrollY.set(u.current),
        i.scrollYProgress.set(u.progress)
    }
    , {
        ...n,
        container: (r == null ? void 0 : r.current) || void 0,
        target: (e == null ? void 0 : e.current) || void 0
    })), [r, e, JSON.stringify(n.offset)]),
    i
}
function Tk(r) {
    const e = Ig( () => ql(r))
      , {isStatic: t} = de.useContext(Zb);
    if (t) {
        const [,n] = de.useState(r);
        de.useEffect( () => e.on("change", n), [])
    }
    return e
}
function h4(r, e) {
    const t = Tk(e())
      , n = () => t.set(e());
    return n(),
    Wb( () => {
        const i = () => wi.preRender(n, !1, !0)
          , a = r.map(s => s.on("change", i));
        return () => {
            a.forEach(s => s()),
            Ql(n)
        }
    }
    ),
    t
}
function Ek(r) {
    Gv.current = [],
    r();
    const e = h4(Gv.current, r);
    return Gv.current = void 0,
    e
}
function wk(r, e, t, n) {
    if (typeof r == "function")
        return Ek(r);
    const i = typeof e == "function" ? e : a8(e, t, n);
    return Array.isArray(r) ? MD(r, i) : MD([r], ([a]) => i(a))
}
function MD(r, e) {
    const t = Ig( () => []);
    return h4(r, () => {
        t.length = 0;
        const n = r.length;
        for (let i = 0; i < n; i++)
            t[i] = r[i].get();
        return e(t)
    }
    )
}
const Ak = {
    some: 0,
    all: 1
};
function Ck(r, e, {root: t, margin: n, amount: i="some"}={}) {
    const a = dA(r)
      , s = new WeakMap
      , l = f => {
        f.forEach(d => {
            const g = s.get(d.target);
            if (d.isIntersecting !== !!g)
                if (d.isIntersecting) {
                    const v = e(d.target, d);
                    typeof v == "function" ? s.set(d.target, v) : u.unobserve(d.target)
                } else
                    typeof g == "function" && (g(d),
                    s.delete(d.target))
        }
        )
    }
      , u = new IntersectionObserver(l,{
        root: t,
        rootMargin: n,
        threshold: typeof i == "number" ? i : Ak[i]
    });
    return a.forEach(f => u.observe(f)),
    () => u.disconnect()
}
function TD(r, {root: e, margin: t, amount: n, once: i=!1, initial: a=!1}={}) {
    const [s,l] = de.useState(a);
    return de.useEffect( () => {
        if (!r.current || i && s)
            return;
        const u = () => (l(!0),
        i ? void 0 : () => l(!1))
          , f = {
            root: e && e.current || void 0,
            margin: t,
            amount: n
        };
        return Ck(r.current, u, f)
    }
    , [e, r, t, i, n]),
    s
}
var uv = {}, ED;
function Rk() {
    if (ED)
        return uv;
    ED = 1,
    Object.defineProperty(uv, "__esModule", {
        value: !0
    }),
    uv.parse = s,
    uv.serialize = f;
    const r = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/
      , e = /^[\u0021-\u003A\u003C-\u007E]*$/
      , t = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i
      , n = /^[\u0020-\u003A\u003D-\u007E]*$/
      , i = Object.prototype.toString
      , a = ( () => {
        const v = function() {};
        return v.prototype = Object.create(null),
        v
    }
    )();
    function s(v, y) {
        const S = new a
          , T = v.length;
        if (T < 2)
            return S;
        const M = (y == null ? void 0 : y.decode) || d;
        let b = 0;
        do {
            const A = v.indexOf("=", b);
            if (A === -1)
                break;
            const C = v.indexOf(";", b)
              , R = C === -1 ? T : C;
            if (A > R) {
                b = v.lastIndexOf(";", A - 1) + 1;
                continue
            }
            const O = l(v, b, A)
              , L = u(v, A, O)
              , z = v.slice(O, L);
            if (S[z] === void 0) {
                let I = l(v, A + 1, R)
                  , N = u(v, R, I);
                const P = M(v.slice(I, N));
                S[z] = P
            }
            b = R + 1
        } while (b < T);
        return S
    }
    function l(v, y, S) {
        do {
            const T = v.charCodeAt(y);
            if (T !== 32 && T !== 9)
                return y
        } while (++y < S);
        return S
    }
    function u(v, y, S) {
        for (; y > S; ) {
            const T = v.charCodeAt(--y);
            if (T !== 32 && T !== 9)
                return y + 1
        }
        return S
    }
    function f(v, y, S) {
        const T = (S == null ? void 0 : S.encode) || encodeURIComponent;
        if (!r.test(v))
            throw new TypeError(`argument name is invalid: ${v}`);
        const M = T(y);
        if (!e.test(M))
            throw new TypeError(`argument val is invalid: ${y}`);
        let b = v + "=" + M;
        if (!S)
            return b;
        if (S.maxAge !== void 0) {
            if (!Number.isInteger(S.maxAge))
                throw new TypeError(`option maxAge is invalid: ${S.maxAge}`);
            b += "; Max-Age=" + S.maxAge
        }
        if (S.domain) {
            if (!t.test(S.domain))
                throw new TypeError(`option domain is invalid: ${S.domain}`);
            b += "; Domain=" + S.domain
        }
        if (S.path) {
            if (!n.test(S.path))
                throw new TypeError(`option path is invalid: ${S.path}`);
            b += "; Path=" + S.path
        }
        if (S.expires) {
            if (!g(S.expires) || !Number.isFinite(S.expires.valueOf()))
                throw new TypeError(`option expires is invalid: ${S.expires}`);
            b += "; Expires=" + S.expires.toUTCString()
        }
        if (S.httpOnly && (b += "; HttpOnly"),
        S.secure && (b += "; Secure"),
        S.partitioned && (b += "; Partitioned"),
        S.priority)
            switch (typeof S.priority == "string" ? S.priority.toLowerCase() : void 0) {
            case "low":
                b += "; Priority=Low";
                break;
            case "medium":
                b += "; Priority=Medium";
                break;
            case "high":
                b += "; Priority=High";
                break;
            default:
                throw new TypeError(`option priority is invalid: ${S.priority}`)
            }
        if (S.sameSite)
            switch (typeof S.sameSite == "string" ? S.sameSite.toLowerCase() : S.sameSite) {
            case !0:
            case "strict":
                b += "; SameSite=Strict";
                break;
            case "lax":
                b += "; SameSite=Lax";
                break;
            case "none":
                b += "; SameSite=None";
                break;
            default:
                throw new TypeError(`option sameSite is invalid: ${S.sameSite}`)
            }
        return b
    }
    function d(v) {
        if (v.indexOf("%") === -1)
            return v;
        try {
            return decodeURIComponent(v)
        } catch {
            return v
        }
    }
    function g(v) {
        return i.call(v) === "[object Date]"
    }
    return uv
}
Rk();
var wD = "popstate";
function Dk(r={}) {
    function e(n, i) {
        let {pathname: a, search: s, hash: l} = n.location;
        return VE("", {
            pathname: a,
            search: s,
            hash: l
        }, i.state && i.state.usr || null, i.state && i.state.key || "default")
    }
    function t(n, i) {
        return typeof i == "string" ? i : Ay(i)
    }
    return Ok(e, t, null, r)
}
function nr(r, e) {
    if (r === !1 || r === null || typeof r > "u")
        throw new Error(e)
}
function tc(r, e) {
    if (!r) {
        typeof console < "u" && console.warn(e);
        try {
            throw new Error(e)
        } catch {}
    }
}
function Uk() {
    return Math.random().toString(36).substring(2, 10)
}
function AD(r, e) {
    return {
        usr: r.state,
        key: r.key,
        idx: e
    }
}
function VE(r, e, t=null, n) {
    return {
        pathname: typeof r == "string" ? r : r.pathname,
        search: "",
        hash: "",
        ...typeof e == "string" ? kg(e) : e,
        state: t,
        key: e && e.key || n || Uk()
    }
}
function Ay({pathname: r="/", search: e="", hash: t=""}) {
    return e && e !== "?" && (r += e.charAt(0) === "?" ? e : "?" + e),
    t && t !== "#" && (r += t.charAt(0) === "#" ? t : "#" + t),
    r
}
function kg(r) {
    let e = {};
    if (r) {
        let t = r.indexOf("#");
        t >= 0 && (e.hash = r.substring(t),
        r = r.substring(0, t));
        let n = r.indexOf("?");
        n >= 0 && (e.search = r.substring(n),
        r = r.substring(0, n)),
        r && (e.pathname = r)
    }
    return e
}
function Ok(r, e, t, n={}) {
    let {window: i=document.defaultView, v5Compat: a=!1} = n
      , s = i.history
      , l = "POP"
      , u = null
      , f = d();
    f == null && (f = 0,
    s.replaceState({
        ...s.state,
        idx: f
    }, ""));
    function d() {
        return (s.state || {
            idx: null
        }).idx
    }
    function g() {
        l = "POP";
        let M = d()
          , b = M == null ? null : M - f;
        f = M,
        u && u({
            action: l,
            location: T.location,
            delta: b
        })
    }
    function v(M, b) {
        l = "PUSH";
        let A = VE(T.location, M, b);
        f = d() + 1;
        let C = AD(A, f)
          , R = T.createHref(A);
        try {
            s.pushState(C, "", R)
        } catch (O) {
            if (O instanceof DOMException && O.name === "DataCloneError")
                throw O;
            i.location.assign(R)
        }
        a && u && u({
            action: l,
            location: T.location,
            delta: 1
        })
    }
    function y(M, b) {
        l = "REPLACE";
        let A = VE(T.location, M, b);
        f = d();
        let C = AD(A, f)
          , R = T.createHref(A);
        s.replaceState(C, "", R),
        a && u && u({
            action: l,
            location: T.location,
            delta: 0
        })
    }
    function S(M) {
        return Nk(M)
    }
    let T = {
        get action() {
            return l
        },
        get location() {
            return r(i, s)
        },
        listen(M) {
            if (u)
                throw new Error("A history only accepts one active listener");
            return i.addEventListener(wD, g),
            u = M,
            () => {
                i.removeEventListener(wD, g),
                u = null
            }
        },
        createHref(M) {
            return e(i, M)
        },
        createURL: S,
        encodeLocation(M) {
            let b = S(M);
            return {
                pathname: b.pathname,
                search: b.search,
                hash: b.hash
            }
        },
        push: v,
        replace: y,
        go(M) {
            return s.go(M)
        }
    };
    return T
}
function Nk(r, e=!1) {
    let t = "http://localhost";
    typeof window < "u" && (t = window.location.origin !== "null" ? window.location.origin : window.location.href),
    nr(t, "No window.location.(origin|href) available to create URL");
    let n = typeof r == "string" ? r : Ay(r);
    return n = n.replace(/ $/, "%20"),
    !e && n.startsWith("//") && (n = t + n),
    new URL(n,t)
}
function d4(r, e, t="/") {
    return Lk(r, e, t, !1)
}
function Lk(r, e, t, n) {
    let i = typeof e == "string" ? kg(e) : e
      , a = Jc(i.pathname || "/", t);
    if (a == null)
        return null;
    let s = p4(r);
    Pk(s);
    let l = null;
    for (let u = 0; l == null && u < s.length; ++u) {
        let f = Wk(a);
        l = Xk(s[u], f, n)
    }
    return l
}
function p4(r, e=[], t=[], n="") {
    let i = (a, s, l) => {
        let u = {
            relativePath: l === void 0 ? a.path || "" : l,
            caseSensitive: a.caseSensitive === !0,
            childrenIndex: s,
            route: a
        };
        u.relativePath.startsWith("/") && (nr(u.relativePath.startsWith(n), `Absolute route path "${u.relativePath}" nested under path "${n}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),
        u.relativePath = u.relativePath.slice(n.length));
        let f = qc([n, u.relativePath])
          , d = t.concat(u);
        a.children && a.children.length > 0 && (nr(a.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${f}".`),
        p4(a.children, e, d, f)),
        !(a.path == null && !a.index) && e.push({
            path: f,
            score: kk(f, a.index),
            routesMeta: d
        })
    }
    ;
    return r.forEach( (a, s) => {
        var l;
        if (a.path === "" || !((l = a.path) != null && l.includes("?")))
            i(a, s);
        else
            for (let u of m4(a.path))
                i(a, s, u)
    }
    ),
    e
}
function m4(r) {
    let e = r.split("/");
    if (e.length === 0)
        return [];
    let[t,...n] = e
      , i = t.endsWith("?")
      , a = t.replace(/\?$/, "");
    if (n.length === 0)
        return i ? [a, ""] : [a];
    let s = m4(n.join("/"))
      , l = [];
    return l.push(...s.map(u => u === "" ? a : [a, u].join("/"))),
    i && l.push(...s),
    l.map(u => r.startsWith("/") && u === "" ? "/" : u)
}
function Pk(r) {
    r.sort( (e, t) => e.score !== t.score ? t.score - e.score : Gk(e.routesMeta.map(n => n.childrenIndex), t.routesMeta.map(n => n.childrenIndex)))
}
var Bk = /^:[\w-]+$/
  , zk = 3
  , Ik = 2
  , Fk = 1
  , Hk = 10
  , Vk = -2
  , CD = r => r === "*";
function kk(r, e) {
    let t = r.split("/")
      , n = t.length;
    return t.some(CD) && (n += Vk),
    e && (n += Ik),
    t.filter(i => !CD(i)).reduce( (i, a) => i + (Bk.test(a) ? zk : a === "" ? Fk : Hk), n)
}
function Gk(r, e) {
    return r.length === e.length && r.slice(0, -1).every( (n, i) => n === e[i]) ? r[r.length - 1] - e[e.length - 1] : 0
}
function Xk(r, e, t=!1) {
    let {routesMeta: n} = r
      , i = {}
      , a = "/"
      , s = [];
    for (let l = 0; l < n.length; ++l) {
        let u = n[l]
          , f = l === n.length - 1
          , d = a === "/" ? e : e.slice(a.length) || "/"
          , g = zS({
            path: u.relativePath,
            caseSensitive: u.caseSensitive,
            end: f
        }, d)
          , v = u.route;
        if (!g && f && t && !n[n.length - 1].route.index && (g = zS({
            path: u.relativePath,
            caseSensitive: u.caseSensitive,
            end: !1
        }, d)),
        !g)
            return null;
        Object.assign(i, g.params),
        s.push({
            params: i,
            pathname: qc([a, g.pathname]),
            pathnameBase: Kk(qc([a, g.pathnameBase])),
            route: v
        }),
        g.pathnameBase !== "/" && (a = qc([a, g.pathnameBase]))
    }
    return s
}
function zS(r, e) {
    typeof r == "string" && (r = {
        path: r,
        caseSensitive: !1,
        end: !0
    });
    let[t,n] = jk(r.path, r.caseSensitive, r.end)
      , i = e.match(t);
    if (!i)
        return null;
    let a = i[0]
      , s = a.replace(/(.)\/+$/, "$1")
      , l = i.slice(1);
    return {
        params: n.reduce( (f, {paramName: d, isOptional: g}, v) => {
            if (d === "*") {
                let S = l[v] || "";
                s = a.slice(0, a.length - S.length).replace(/(.)\/+$/, "$1")
            }
            const y = l[v];
            return g && !y ? f[d] = void 0 : f[d] = (y || "").replace(/%2F/g, "/"),
            f
        }
        , {}),
        pathname: a,
        pathnameBase: s,
        pattern: r
    }
}
function jk(r, e=!1, t=!0) {
    tc(r === "*" || !r.endsWith("*") || r.endsWith("/*"), `Route path "${r}" will be treated as if it were "${r.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${r.replace(/\*$/, "/*")}".`);
    let n = []
      , i = "^" + r.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (s, l, u) => (n.push({
        paramName: l,
        isOptional: u != null
    }),
    u ? "/?([^\\/]+)?" : "/([^\\/]+)"));
    return r.endsWith("*") ? (n.push({
        paramName: "*"
    }),
    i += r === "*" || r === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : t ? i += "\\/*$" : r !== "" && r !== "/" && (i += "(?:(?=\\/|$))"),
    [new RegExp(i,e ? void 0 : "i"), n]
}
function Wk(r) {
    try {
        return r.split("/").map(e => decodeURIComponent(e).replace(/\//g, "%2F")).join("/")
    } catch (e) {
        return tc(!1, `The URL path "${r}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`),
        r
    }
}
function Jc(r, e) {
    if (e === "/")
        return r;
    if (!r.toLowerCase().startsWith(e.toLowerCase()))
        return null;
    let t = e.endsWith("/") ? e.length - 1 : e.length
      , n = r.charAt(t);
    return n && n !== "/" ? null : r.slice(t) || "/"
}
function Yk(r, e="/") {
    let {pathname: t, search: n="", hash: i=""} = typeof r == "string" ? kg(r) : r;
    return {
        pathname: t ? t.startsWith("/") ? t : qk(t, e) : e,
        search: Qk(n),
        hash: Jk(i)
    }
}
function qk(r, e) {
    let t = e.replace(/\/+$/, "").split("/");
    return r.split("/").forEach(i => {
        i === ".." ? t.length > 1 && t.pop() : i !== "." && t.push(i)
    }
    ),
    t.length > 1 ? t.join("/") : "/"
}
function k2(r, e, t, n) {
    return `Cannot include a '${r}' character in a manually specified \`to.${e}\` field [${JSON.stringify(n)}].  Please separate it out to the \`to.${t}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`
}
function Zk(r) {
    return r.filter( (e, t) => t === 0 || e.route.path && e.route.path.length > 0)
}
function g4(r) {
    let e = Zk(r);
    return e.map( (t, n) => n === e.length - 1 ? t.pathname : t.pathnameBase)
}
function v4(r, e, t, n=!1) {
    let i;
    typeof r == "string" ? i = kg(r) : (i = {
        ...r
    },
    nr(!i.pathname || !i.pathname.includes("?"), k2("?", "pathname", "search", i)),
    nr(!i.pathname || !i.pathname.includes("#"), k2("#", "pathname", "hash", i)),
    nr(!i.search || !i.search.includes("#"), k2("#", "search", "hash", i)));
    let a = r === "" || i.pathname === "", s = a ? "/" : i.pathname, l;
    if (s == null)
        l = t;
    else {
        let g = e.length - 1;
        if (!n && s.startsWith("..")) {
            let v = s.split("/");
            for (; v[0] === ".."; )
                v.shift(),
                g -= 1;
            i.pathname = v.join("/")
        }
        l = g >= 0 ? e[g] : "/"
    }
    let u = Yk(i, l)
      , f = s && s !== "/" && s.endsWith("/")
      , d = (a || s === ".") && t.endsWith("/");
    return !u.pathname.endsWith("/") && (f || d) && (u.pathname += "/"),
    u
}
var qc = r => r.join("/").replace(/\/\/+/g, "/")
  , Kk = r => r.replace(/\/+$/, "").replace(/^\/*/, "/")
  , Qk = r => !r || r === "?" ? "" : r.startsWith("?") ? r : "?" + r
  , Jk = r => !r || r === "#" ? "" : r.startsWith("#") ? r : "#" + r;
function $k(r) {
    return r != null && typeof r.status == "number" && typeof r.statusText == "string" && typeof r.internal == "boolean" && "data"in r
}
var y4 = ["POST", "PUT", "PATCH", "DELETE"];
new Set(y4);
var eG = ["GET", ...y4];
new Set(eG);
var Gg = de.createContext(null);
Gg.displayName = "DataRouter";
var $b = de.createContext(null);
$b.displayName = "DataRouterState";
var _4 = de.createContext({
    isTransitioning: !1
});
_4.displayName = "ViewTransition";
var tG = de.createContext(new Map);
tG.displayName = "Fetchers";
var nG = de.createContext(null);
nG.displayName = "Await";
var ac = de.createContext(null);
ac.displayName = "Navigation";
var a_ = de.createContext(null);
a_.displayName = "Location";
var nf = de.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
});
nf.displayName = "Route";
var wA = de.createContext(null);
wA.displayName = "RouteError";
function iG(r, {relative: e}={}) {
    nr(s_(), "useHref() may be used only in the context of a <Router> component.");
    let {basename: t, navigator: n} = de.useContext(ac)
      , {hash: i, pathname: a, search: s} = o_(r, {
        relative: e
    })
      , l = a;
    return t !== "/" && (l = a === "/" ? t : qc([t, a])),
    n.createHref({
        pathname: l,
        search: s,
        hash: i
    })
}
function s_() {
    return de.useContext(a_) != null
}
function Mh() {
    return nr(s_(), "useLocation() may be used only in the context of a <Router> component."),
    de.useContext(a_).location
}
var x4 = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function S4(r) {
    de.useContext(ac).static || de.useLayoutEffect(r)
}
function b4() {
    let {isDataRoute: r} = de.useContext(nf);
    return r ? gG() : rG()
}
function rG() {
    nr(s_(), "useNavigate() may be used only in the context of a <Router> component.");
    let r = de.useContext(Gg)
      , {basename: e, navigator: t} = de.useContext(ac)
      , {matches: n} = de.useContext(nf)
      , {pathname: i} = Mh()
      , a = JSON.stringify(g4(n))
      , s = de.useRef(!1);
    return S4( () => {
        s.current = !0
    }
    ),
    de.useCallback( (u, f={}) => {
        if (tc(s.current, x4),
        !s.current)
            return;
        if (typeof u == "number") {
            t.go(u);
            return
        }
        let d = v4(u, JSON.parse(a), i, f.relative === "path");
        r == null && e !== "/" && (d.pathname = d.pathname === "/" ? e : qc([e, d.pathname])),
        (f.replace ? t.replace : t.push)(d, f.state, f)
    }
    , [e, t, a, i, r])
}
de.createContext(null);
function o_(r, {relative: e}={}) {
    let {matches: t} = de.useContext(nf)
      , {pathname: n} = Mh()
      , i = JSON.stringify(g4(t));
    return de.useMemo( () => v4(r, JSON.parse(i), n, e === "path"), [r, i, n, e])
}
function aG(r, e) {
    return M4(r, e)
}
function M4(r, e, t, n) {
    var b;
    nr(s_(), "useRoutes() may be used only in the context of a <Router> component.");
    let {navigator: i} = de.useContext(ac)
      , {matches: a} = de.useContext(nf)
      , s = a[a.length - 1]
      , l = s ? s.params : {}
      , u = s ? s.pathname : "/"
      , f = s ? s.pathnameBase : "/"
      , d = s && s.route;
    {
        let A = d && d.path || "";
        T4(u, !d || A.endsWith("*") || A.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${u}" (under <Route path="${A}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${A}"> to <Route path="${A === "/" ? "*" : `${A}/*`}">.`)
    }
    let g = Mh(), v;
    if (e) {
        let A = typeof e == "string" ? kg(e) : e;
        nr(f === "/" || ((b = A.pathname) == null ? void 0 : b.startsWith(f)), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${f}" but pathname "${A.pathname}" was given in the \`location\` prop.`),
        v = A
    } else
        v = g;
    let y = v.pathname || "/"
      , S = y;
    if (f !== "/") {
        let A = f.replace(/^\//, "").split("/");
        S = "/" + y.replace(/^\//, "").split("/").slice(A.length).join("/")
    }
    let T = d4(r, {
        pathname: S
    });
    tc(d || T != null, `No routes matched location "${v.pathname}${v.search}${v.hash}" `),
    tc(T == null || T[T.length - 1].route.element !== void 0 || T[T.length - 1].route.Component !== void 0 || T[T.length - 1].route.lazy !== void 0, `Matched leaf route at location "${v.pathname}${v.search}${v.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);
    let M = cG(T && T.map(A => Object.assign({}, A, {
        params: Object.assign({}, l, A.params),
        pathname: qc([f, i.encodeLocation ? i.encodeLocation(A.pathname).pathname : A.pathname]),
        pathnameBase: A.pathnameBase === "/" ? f : qc([f, i.encodeLocation ? i.encodeLocation(A.pathnameBase).pathname : A.pathnameBase])
    })), a, t, n);
    return e && M ? de.createElement(a_.Provider, {
        value: {
            location: {
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default",
                ...v
            },
            navigationType: "POP"
        }
    }, M) : M
}
function sG() {
    let r = mG()
      , e = $k(r) ? `${r.status} ${r.statusText}` : r instanceof Error ? r.message : JSON.stringify(r)
      , t = r instanceof Error ? r.stack : null
      , n = "rgba(200,200,200, 0.5)"
      , i = {
        padding: "0.5rem",
        backgroundColor: n
    }
      , a = {
        padding: "2px 4px",
        backgroundColor: n
    }
      , s = null;
    return console.error("Error handled by React Router default ErrorBoundary:", r),
    s = de.createElement(de.Fragment, null, de.createElement("p", null, " Hey developer "), de.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", de.createElement("code", {
        style: a
    }, "ErrorBoundary"), " or", " ", de.createElement("code", {
        style: a
    }, "errorElement"), " prop on your route.")),
    de.createElement(de.Fragment, null, de.createElement("h2", null, "Unexpected Application Error!"), de.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, e), t ? de.createElement("pre", {
        style: i
    }, t) : null, s)
}
var oG = de.createElement(sG, null)
  , lG = class extends de.Component {
    constructor(r) {
        super(r),
        this.state = {
            location: r.location,
            revalidation: r.revalidation,
            error: r.error
        }
    }
    static getDerivedStateFromError(r) {
        return {
            error: r
        }
    }
    static getDerivedStateFromProps(r, e) {
        return e.location !== r.location || e.revalidation !== "idle" && r.revalidation === "idle" ? {
            error: r.error,
            location: r.location,
            revalidation: r.revalidation
        } : {
            error: r.error !== void 0 ? r.error : e.error,
            location: e.location,
            revalidation: r.revalidation || e.revalidation
        }
    }
    componentDidCatch(r, e) {
        console.error("React Router caught the following error during render", r, e)
    }
    render() {
        return this.state.error !== void 0 ? de.createElement(nf.Provider, {
            value: this.props.routeContext
        }, de.createElement(wA.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
;
function uG({routeContext: r, match: e, children: t}) {
    let n = de.useContext(Gg);
    return n && n.static && n.staticContext && (e.route.errorElement || e.route.ErrorBoundary) && (n.staticContext._deepestRenderedBoundaryId = e.route.id),
    de.createElement(nf.Provider, {
        value: r
    }, t)
}
function cG(r, e=[], t=null, n=null) {
    if (r == null) {
        if (!t)
            return null;
        if (t.errors)
            r = t.matches;
        else if (e.length === 0 && !t.initialized && t.matches.length > 0)
            r = t.matches;
        else
            return null
    }
    let i = r
      , a = t == null ? void 0 : t.errors;
    if (a != null) {
        let u = i.findIndex(f => f.route.id && (a == null ? void 0 : a[f.route.id]) !== void 0);
        nr(u >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(a).join(",")}`),
        i = i.slice(0, Math.min(i.length, u + 1))
    }
    let s = !1
      , l = -1;
    if (t)
        for (let u = 0; u < i.length; u++) {
            let f = i[u];
            if ((f.route.HydrateFallback || f.route.hydrateFallbackElement) && (l = u),
            f.route.id) {
                let {loaderData: d, errors: g} = t
                  , v = f.route.loader && !d.hasOwnProperty(f.route.id) && (!g || g[f.route.id] === void 0);
                if (f.route.lazy || v) {
                    s = !0,
                    l >= 0 ? i = i.slice(0, l + 1) : i = [i[0]];
                    break
                }
            }
        }
    return i.reduceRight( (u, f, d) => {
        let g, v = !1, y = null, S = null;
        t && (g = a && f.route.id ? a[f.route.id] : void 0,
        y = f.route.errorElement || oG,
        s && (l < 0 && d === 0 ? (T4("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"),
        v = !0,
        S = null) : l === d && (v = !0,
        S = f.route.hydrateFallbackElement || null)));
        let T = e.concat(i.slice(0, d + 1))
          , M = () => {
            let b;
            return g ? b = y : v ? b = S : f.route.Component ? b = de.createElement(f.route.Component, null) : f.route.element ? b = f.route.element : b = u,
            de.createElement(uG, {
                match: f,
                routeContext: {
                    outlet: u,
                    matches: T,
                    isDataRoute: t != null
                },
                children: b
            })
        }
        ;
        return t && (f.route.ErrorBoundary || f.route.errorElement || d === 0) ? de.createElement(lG, {
            location: t.location,
            revalidation: t.revalidation,
            component: y,
            error: g,
            children: M(),
            routeContext: {
                outlet: null,
                matches: T,
                isDataRoute: !0
            }
        }) : M()
    }
    , null)
}
function AA(r) {
    return `${r} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function fG(r) {
    let e = de.useContext(Gg);
    return nr(e, AA(r)),
    e
}
function hG(r) {
    let e = de.useContext($b);
    return nr(e, AA(r)),
    e
}
function dG(r) {
    let e = de.useContext(nf);
    return nr(e, AA(r)),
    e
}
function CA(r) {
    let e = dG(r)
      , t = e.matches[e.matches.length - 1];
    return nr(t.route.id, `${r} can only be used on routes that contain a unique "id"`),
    t.route.id
}
function pG() {
    return CA("useRouteId")
}
function mG() {
    var n;
    let r = de.useContext(wA)
      , e = hG("useRouteError")
      , t = CA("useRouteError");
    return r !== void 0 ? r : (n = e.errors) == null ? void 0 : n[t]
}
function gG() {
    let {router: r} = fG("useNavigate")
      , e = CA("useNavigate")
      , t = de.useRef(!1);
    return S4( () => {
        t.current = !0
    }
    ),
    de.useCallback(async (i, a={}) => {
        tc(t.current, x4),
        t.current && (typeof i == "number" ? r.navigate(i) : await r.navigate(i, {
            fromRouteId: e,
            ...a
        }))
    }
    , [r, e])
}
var RD = {};
function T4(r, e, t) {
    !e && !RD[r] && (RD[r] = !0,
    tc(!1, t))
}
de.memo(vG);
function vG({routes: r, future: e, state: t}) {
    return M4(r, void 0, t, e)
}
function jm(r) {
    nr(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")
}
function yG({basename: r="/", children: e=null, location: t, navigationType: n="POP", navigator: i, static: a=!1}) {
    nr(!s_(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
    let s = r.replace(/^\/*/, "/")
      , l = de.useMemo( () => ({
        basename: s,
        navigator: i,
        static: a,
        future: {}
    }), [s, i, a]);
    typeof t == "string" && (t = kg(t));
    let {pathname: u="/", search: f="", hash: d="", state: g=null, key: v="default"} = t
      , y = de.useMemo( () => {
        let S = Jc(u, s);
        return S == null ? null : {
            location: {
                pathname: S,
                search: f,
                hash: d,
                state: g,
                key: v
            },
            navigationType: n
        }
    }
    , [s, u, f, d, g, v, n]);
    return tc(y != null, `<Router basename="${s}"> is not able to match the URL "${u}${f}${d}" because it does not start with the basename, so the <Router> won't render anything.`),
    y == null ? null : de.createElement(ac.Provider, {
        value: l
    }, de.createElement(a_.Provider, {
        children: e,
        value: y
    }))
}
function _G({children: r, location: e}) {
    return aG(kE(r), e)
}
function kE(r, e=[]) {
    let t = [];
    return de.Children.forEach(r, (n, i) => {
        if (!de.isValidElement(n))
            return;
        let a = [...e, i];
        if (n.type === de.Fragment) {
            t.push.apply(t, kE(n.props.children, a));
            return
        }
        nr(n.type === jm, `[${typeof n.type == "string" ? n.type : n.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),
        nr(!n.props.index || !n.props.children, "An index route cannot have child routes.");
        let s = {
            id: n.props.id || a.join("-"),
            caseSensitive: n.props.caseSensitive,
            element: n.props.element,
            Component: n.props.Component,
            index: n.props.index,
            path: n.props.path,
            loader: n.props.loader,
            action: n.props.action,
            hydrateFallbackElement: n.props.hydrateFallbackElement,
            HydrateFallback: n.props.HydrateFallback,
            errorElement: n.props.errorElement,
            ErrorBoundary: n.props.ErrorBoundary,
            hasErrorBoundary: n.props.hasErrorBoundary === !0 || n.props.ErrorBoundary != null || n.props.errorElement != null,
            shouldRevalidate: n.props.shouldRevalidate,
            handle: n.props.handle,
            lazy: n.props.lazy
        };
        n.props.children && (s.children = kE(n.props.children, a)),
        t.push(s)
    }
    ),
    t
}
var dS = "get"
  , pS = "application/x-www-form-urlencoded";
function eM(r) {
    return r != null && typeof r.tagName == "string"
}
function xG(r) {
    return eM(r) && r.tagName.toLowerCase() === "button"
}
function SG(r) {
    return eM(r) && r.tagName.toLowerCase() === "form"
}
function bG(r) {
    return eM(r) && r.tagName.toLowerCase() === "input"
}
function MG(r) {
    return !!(r.metaKey || r.altKey || r.ctrlKey || r.shiftKey)
}
function TG(r, e) {
    return r.button === 0 && (!e || e === "_self") && !MG(r)
}
var K1 = null;
function EG() {
    if (K1 === null)
        try {
            new FormData(document.createElement("form"),0),
            K1 = !1
        } catch {
            K1 = !0
        }
    return K1
}
var wG = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function G2(r) {
    return r != null && !wG.has(r) ? (tc(!1, `"${r}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${pS}"`),
    null) : r
}
function AG(r, e) {
    let t, n, i, a, s;
    if (SG(r)) {
        let l = r.getAttribute("action");
        n = l ? Jc(l, e) : null,
        t = r.getAttribute("method") || dS,
        i = G2(r.getAttribute("enctype")) || pS,
        a = new FormData(r)
    } else if (xG(r) || bG(r) && (r.type === "submit" || r.type === "image")) {
        let l = r.form;
        if (l == null)
            throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
        let u = r.getAttribute("formaction") || l.getAttribute("action");
        if (n = u ? Jc(u, e) : null,
        t = r.getAttribute("formmethod") || l.getAttribute("method") || dS,
        i = G2(r.getAttribute("formenctype")) || G2(l.getAttribute("enctype")) || pS,
        a = new FormData(l,r),
        !EG()) {
            let {name: f, type: d, value: g} = r;
            if (d === "image") {
                let v = f ? `${f}.` : "";
                a.append(`${v}x`, "0"),
                a.append(`${v}y`, "0")
            } else
                f && a.append(f, g)
        }
    } else {
        if (eM(r))
            throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
        t = dS,
        n = null,
        i = pS,
        s = r
    }
    return a && i === "text/plain" && (s = a,
    a = void 0),
    {
        action: n,
        method: t.toLowerCase(),
        encType: i,
        formData: a,
        body: s
    }
}
function RA(r, e) {
    if (r === !1 || r === null || typeof r > "u")
        throw new Error(e)
}
async function CG(r, e) {
    if (r.id in e)
        return e[r.id];
    try {
        let t = await import(r.module);
        return e[r.id] = t,
        t
    } catch (t) {
        return console.error(`Error loading route module \`${r.module}\`, reloading page...`),
        console.error(t),
        window.__reactRouterContext && window.__reactRouterContext.isSpaMode,
        window.location.reload(),
        new Promise( () => {}
        )
    }
}
function RG(r) {
    return r == null ? !1 : r.href == null ? r.rel === "preload" && typeof r.imageSrcSet == "string" && typeof r.imageSizes == "string" : typeof r.rel == "string" && typeof r.href == "string"
}
async function DG(r, e, t) {
    let n = await Promise.all(r.map(async i => {
        let a = e.routes[i.route.id];
        if (a) {
            let s = await CG(a, t);
            return s.links ? s.links() : []
        }
        return []
    }
    ));
    return LG(n.flat(1).filter(RG).filter(i => i.rel === "stylesheet" || i.rel === "preload").map(i => i.rel === "stylesheet" ? {
        ...i,
        rel: "prefetch",
        as: "style"
    } : {
        ...i,
        rel: "prefetch"
    }))
}
function DD(r, e, t, n, i, a) {
    let s = (u, f) => t[f] ? u.route.id !== t[f].route.id : !0
      , l = (u, f) => {
        var d;
        return t[f].pathname !== u.pathname || ((d = t[f].route.path) == null ? void 0 : d.endsWith("*")) && t[f].params["*"] !== u.params["*"]
    }
    ;
    return a === "assets" ? e.filter( (u, f) => s(u, f) || l(u, f)) : a === "data" ? e.filter( (u, f) => {
        var g;
        let d = n.routes[u.route.id];
        if (!d || !d.hasLoader)
            return !1;
        if (s(u, f) || l(u, f))
            return !0;
        if (u.route.shouldRevalidate) {
            let v = u.route.shouldRevalidate({
                currentUrl: new URL(i.pathname + i.search + i.hash,window.origin),
                currentParams: ((g = t[0]) == null ? void 0 : g.params) || {},
                nextUrl: new URL(r,window.origin),
                nextParams: u.params,
                defaultShouldRevalidate: !0
            });
            if (typeof v == "boolean")
                return v
        }
        return !0
    }
    ) : []
}
function UG(r, e, {includeHydrateFallback: t}={}) {
    return OG(r.map(n => {
        let i = e.routes[n.route.id];
        if (!i)
            return [];
        let a = [i.module];
        return i.clientActionModule && (a = a.concat(i.clientActionModule)),
        i.clientLoaderModule && (a = a.concat(i.clientLoaderModule)),
        t && i.hydrateFallbackModule && (a = a.concat(i.hydrateFallbackModule)),
        i.imports && (a = a.concat(i.imports)),
        a
    }
    ).flat(1))
}
function OG(r) {
    return [...new Set(r)]
}
function NG(r) {
    let e = {}
      , t = Object.keys(r).sort();
    for (let n of t)
        e[n] = r[n];
    return e
}
function LG(r, e) {
    let t = new Set;
    return new Set(e),
    r.reduce( (n, i) => {
        let a = JSON.stringify(NG(i));
        return t.has(a) || (t.add(a),
        n.push({
            key: a,
            link: i
        })),
        n
    }
    , [])
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
var PG = new Set([100, 101, 204, 205]);
function BG(r, e) {
    let t = typeof r == "string" ? new URL(r,typeof window > "u" ? "server://singlefetch/" : window.location.origin) : r;
    return t.pathname === "/" ? t.pathname = "_root.data" : e && Jc(t.pathname, e) === "/" ? t.pathname = `${e.replace(/\/$/, "")}/_root.data` : t.pathname = `${t.pathname.replace(/\/$/, "")}.data`,
    t
}
function E4() {
    let r = de.useContext(Gg);
    return RA(r, "You must render this element inside a <DataRouterContext.Provider> element"),
    r
}
function zG() {
    let r = de.useContext($b);
    return RA(r, "You must render this element inside a <DataRouterStateContext.Provider> element"),
    r
}
var DA = de.createContext(void 0);
DA.displayName = "FrameworkContext";
function w4() {
    let r = de.useContext(DA);
    return RA(r, "You must render this element inside a <HydratedRouter> element"),
    r
}
function IG(r, e) {
    let t = de.useContext(DA)
      , [n,i] = de.useState(!1)
      , [a,s] = de.useState(!1)
      , {onFocus: l, onBlur: u, onMouseEnter: f, onMouseLeave: d, onTouchStart: g} = e
      , v = de.useRef(null);
    de.useEffect( () => {
        if (r === "render" && s(!0),
        r === "viewport") {
            let T = b => {
                b.forEach(A => {
                    s(A.isIntersecting)
                }
                )
            }
              , M = new IntersectionObserver(T,{
                threshold: .5
            });
            return v.current && M.observe(v.current),
            () => {
                M.disconnect()
            }
        }
    }
    , [r]),
    de.useEffect( () => {
        if (n) {
            let T = setTimeout( () => {
                s(!0)
            }
            , 100);
            return () => {
                clearTimeout(T)
            }
        }
    }
    , [n]);
    let y = () => {
        i(!0)
    }
      , S = () => {
        i(!1),
        s(!1)
    }
    ;
    return t ? r !== "intent" ? [a, v, {}] : [a, v, {
        onFocus: cv(l, y),
        onBlur: cv(u, S),
        onMouseEnter: cv(f, y),
        onMouseLeave: cv(d, S),
        onTouchStart: cv(g, y)
    }] : [!1, v, {}]
}
function cv(r, e) {
    return t => {
        r && r(t),
        t.defaultPrevented || e(t)
    }
}
function FG({page: r, ...e}) {
    let {router: t} = E4()
      , n = de.useMemo( () => d4(t.routes, r, t.basename), [t.routes, r, t.basename]);
    return n ? de.createElement(VG, {
        page: r,
        matches: n,
        ...e
    }) : null
}
function HG(r) {
    let {manifest: e, routeModules: t} = w4()
      , [n,i] = de.useState([]);
    return de.useEffect( () => {
        let a = !1;
        return DG(r, e, t).then(s => {
            a || i(s)
        }
        ),
        () => {
            a = !0
        }
    }
    , [r, e, t]),
    n
}
function VG({page: r, matches: e, ...t}) {
    let n = Mh()
      , {manifest: i, routeModules: a} = w4()
      , {basename: s} = E4()
      , {loaderData: l, matches: u} = zG()
      , f = de.useMemo( () => DD(r, e, u, i, n, "data"), [r, e, u, i, n])
      , d = de.useMemo( () => DD(r, e, u, i, n, "assets"), [r, e, u, i, n])
      , g = de.useMemo( () => {
        if (r === n.pathname + n.search + n.hash)
            return [];
        let S = new Set
          , T = !1;
        if (e.forEach(b => {
            var C;
            let A = i.routes[b.route.id];
            !A || !A.hasLoader || (!f.some(R => R.route.id === b.route.id) && b.route.id in l && ((C = a[b.route.id]) != null && C.shouldRevalidate) || A.hasClientLoader ? T = !0 : S.add(b.route.id))
        }
        ),
        S.size === 0)
            return [];
        let M = BG(r, s);
        return T && S.size > 0 && M.searchParams.set("_routes", e.filter(b => S.has(b.route.id)).map(b => b.route.id).join(",")),
        [M.pathname + M.search]
    }
    , [s, l, n, i, f, e, r, a])
      , v = de.useMemo( () => UG(d, i), [d, i])
      , y = HG(d);
    return de.createElement(de.Fragment, null, g.map(S => de.createElement("link", {
        key: S,
        rel: "prefetch",
        as: "fetch",
        href: S,
        ...t
    })), v.map(S => de.createElement("link", {
        key: S,
        rel: "modulepreload",
        href: S,
        ...t
    })), y.map( ({key: S, link: T}) => de.createElement("link", {
        key: S,
        ...T
    })))
}
function kG(...r) {
    return e => {
        r.forEach(t => {
            typeof t == "function" ? t(e) : t != null && (t.current = e)
        }
        )
    }
}
var A4 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
    A4 && (window.__reactRouterVersion = "7.6.2")
} catch {}
function GG({basename: r, children: e, window: t}) {
    let n = de.useRef();
    n.current == null && (n.current = Dk({
        window: t,
        v5Compat: !0
    }));
    let i = n.current
      , [a,s] = de.useState({
        action: i.action,
        location: i.location
    })
      , l = de.useCallback(u => {
        de.startTransition( () => s(u))
    }
    , [s]);
    return de.useLayoutEffect( () => i.listen(l), [i, l]),
    de.createElement(yG, {
        basename: r,
        children: e,
        location: a.location,
        navigationType: a.action,
        navigator: i
    })
}
var C4 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , qv = de.forwardRef(function({onClick: e, discover: t="render", prefetch: n="none", relative: i, reloadDocument: a, replace: s, state: l, target: u, to: f, preventScrollReset: d, viewTransition: g, ...v}, y) {
    let {basename: S} = de.useContext(ac), T = typeof f == "string" && C4.test(f), M, b = !1;
    if (typeof f == "string" && T && (M = f,
    A4))
        try {
            let N = new URL(window.location.href)
              , P = f.startsWith("//") ? new URL(N.protocol + f) : new URL(f)
              , Y = Jc(P.pathname, S);
            P.origin === N.origin && Y != null ? f = Y + P.search + P.hash : b = !0
        } catch {
            tc(!1, `<Link to="${f}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)
        }
    let A = iG(f, {
        relative: i
    })
      , [C,R,O] = IG(n, v)
      , L = YG(f, {
        replace: s,
        state: l,
        target: u,
        preventScrollReset: d,
        relative: i,
        viewTransition: g
    });
    function z(N) {
        e && e(N),
        N.defaultPrevented || L(N)
    }
    let I = de.createElement("a", {
        ...v,
        ...O,
        href: M || A,
        onClick: b || a ? e : z,
        ref: kG(y, R),
        target: u,
        "data-discover": !T && t === "render" ? "true" : void 0
    });
    return C && !T ? de.createElement(de.Fragment, null, I, de.createElement(FG, {
        page: A
    })) : I
});
qv.displayName = "Link";
var XG = de.forwardRef(function({"aria-current": e="page", caseSensitive: t=!1, className: n="", end: i=!1, style: a, to: s, viewTransition: l, children: u, ...f}, d) {
    let g = o_(s, {
        relative: f.relative
    })
      , v = Mh()
      , y = de.useContext($b)
      , {navigator: S, basename: T} = de.useContext(ac)
      , M = y != null && JG(g) && l === !0
      , b = S.encodeLocation ? S.encodeLocation(g).pathname : g.pathname
      , A = v.pathname
      , C = y && y.navigation && y.navigation.location ? y.navigation.location.pathname : null;
    t || (A = A.toLowerCase(),
    C = C ? C.toLowerCase() : null,
    b = b.toLowerCase()),
    C && T && (C = Jc(C, T) || C);
    const R = b !== "/" && b.endsWith("/") ? b.length - 1 : b.length;
    let O = A === b || !i && A.startsWith(b) && A.charAt(R) === "/", L = C != null && (C === b || !i && C.startsWith(b) && C.charAt(b.length) === "/"), z = {
        isActive: O,
        isPending: L,
        isTransitioning: M
    }, I = O ? e : void 0, N;
    typeof n == "function" ? N = n(z) : N = [n, O ? "active" : null, L ? "pending" : null, M ? "transitioning" : null].filter(Boolean).join(" ");
    let P = typeof a == "function" ? a(z) : a;
    return de.createElement(qv, {
        ...f,
        "aria-current": I,
        className: N,
        ref: d,
        style: P,
        to: s,
        viewTransition: l
    }, typeof u == "function" ? u(z) : u)
});
XG.displayName = "NavLink";
var jG = de.forwardRef( ({discover: r="render", fetcherKey: e, navigate: t, reloadDocument: n, replace: i, state: a, method: s=dS, action: l, onSubmit: u, relative: f, preventScrollReset: d, viewTransition: g, ...v}, y) => {
    let S = KG()
      , T = QG(l, {
        relative: f
    })
      , M = s.toLowerCase() === "get" ? "get" : "post"
      , b = typeof l == "string" && C4.test(l)
      , A = C => {
        if (u && u(C),
        C.defaultPrevented)
            return;
        C.preventDefault();
        let R = C.nativeEvent.submitter
          , O = (R == null ? void 0 : R.getAttribute("formmethod")) || s;
        S(R || C.currentTarget, {
            fetcherKey: e,
            method: O,
            navigate: t,
            replace: i,
            state: a,
            relative: f,
            preventScrollReset: d,
            viewTransition: g
        })
    }
    ;
    return de.createElement("form", {
        ref: y,
        method: M,
        action: T,
        onSubmit: n ? u : A,
        ...v,
        "data-discover": !b && r === "render" ? "true" : void 0
    })
}
);
jG.displayName = "Form";
function WG(r) {
    return `${r} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function R4(r) {
    let e = de.useContext(Gg);
    return nr(e, WG(r)),
    e
}
function YG(r, {target: e, replace: t, state: n, preventScrollReset: i, relative: a, viewTransition: s}={}) {
    let l = b4()
      , u = Mh()
      , f = o_(r, {
        relative: a
    });
    return de.useCallback(d => {
        if (TG(d, e)) {
            d.preventDefault();
            let g = t !== void 0 ? t : Ay(u) === Ay(f);
            l(r, {
                replace: g,
                state: n,
                preventScrollReset: i,
                relative: a,
                viewTransition: s
            })
        }
    }
    , [u, l, f, t, n, e, r, i, a, s])
}
var qG = 0
  , ZG = () => `__${String(++qG)}__`;
function KG() {
    let {router: r} = R4("useSubmit")
      , {basename: e} = de.useContext(ac)
      , t = pG();
    return de.useCallback(async (n, i={}) => {
        let {action: a, method: s, encType: l, formData: u, body: f} = AG(n, e);
        if (i.navigate === !1) {
            let d = i.fetcherKey || ZG();
            await r.fetch(d, t, i.action || a, {
                preventScrollReset: i.preventScrollReset,
                formData: u,
                body: f,
                formMethod: i.method || s,
                formEncType: i.encType || l,
                flushSync: i.flushSync
            })
        } else
            await r.navigate(i.action || a, {
                preventScrollReset: i.preventScrollReset,
                formData: u,
                body: f,
                formMethod: i.method || s,
                formEncType: i.encType || l,
                replace: i.replace,
                state: i.state,
                fromRouteId: t,
                flushSync: i.flushSync,
                viewTransition: i.viewTransition
            })
    }
    , [r, e, t])
}
function QG(r, {relative: e}={}) {
    let {basename: t} = de.useContext(ac)
      , n = de.useContext(nf);
    nr(n, "useFormAction must be used inside a RouteContext");
    let[i] = n.matches.slice(-1)
      , a = {
        ...o_(r || ".", {
            relative: e
        })
    }
      , s = Mh();
    if (r == null) {
        a.search = s.search;
        let l = new URLSearchParams(a.search)
          , u = l.getAll("index");
        if (u.some(d => d === "")) {
            l.delete("index"),
            u.filter(g => g).forEach(g => l.append("index", g));
            let d = l.toString();
            a.search = d ? `?${d}` : ""
        }
    }
    return (!r || r === ".") && i.route.index && (a.search = a.search ? a.search.replace(/^\?/, "?index&") : "?index"),
    t !== "/" && (a.pathname = a.pathname === "/" ? t : qc([t, a.pathname])),
    Ay(a)
}
function JG(r, e={}) {
    let t = de.useContext(_4);
    nr(t != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
    let {basename: n} = R4("useViewTransitionState")
      , i = o_(r, {
        relative: e.relative
    });
    if (!t.isTransitioning)
        return !1;
    let a = Jc(t.currentLocation.pathname, n) || t.currentLocation.pathname
      , s = Jc(t.nextLocation.pathname, n) || t.nextLocation.pathname;
    return zS(i.pathname, s) != null || zS(i.pathname, a) != null
}
[...PG];
const $G = "/assets/logo-CWXt7ihH.png"
  , e7 = () => {
    const [r,e] = ln.useState(!1)
      , [t,n] = ln.useState(0)
      , i = ln.useRef(null)
      , a = ln.useRef(null)
      , s = () => {
        e(g => !g)
    }
      , l = () => {
        e(!1)
    }
    ;
    ln.useEffect( () => {
        if (a.current) {
            const g = new ResizeObserver(v => {
                for (let y of v)
                    n(y.contentRect.height)
            }
            );
            return g.observe(a.current),
            () => g.disconnect()
        }
    }
    , []),
    ln.useEffect( () => {
        const g = v => {
            i.current && !i.current.contains(v.target) && l()
        }
        ;
        return r && document.addEventListener("mousedown", g),
        () => {
            document.addEventListener("mousedown", g)
        }
    }
    , [r]);
    const u = [{
        label: "Home",
        path: "/",
        external: !1
    }, {
        label: "Meet the Team",
        path: "/team",
        external: !1
    }, {
        label: "Explore our Work",
        path: "/projects",
        external: !1
    }, {
        label: "Our Experiences",
        path: "/experience",
        external: !1
    }]
      , f = Jo.create(qv)
      , d = Mh();
    return ae.jsxs("header", {
        ref: a,
        className: `position-fixed top-0 w-full
     bg-white px-5 z-80 transition-all duration-300
      left-0 right-0 shadow-sm`,
        children: [ae.jsxs("div", {
            className: `w-full   
        flex items-center justify-between
        h-30 `,
            children: [ae.jsx(Jo.div, {
                initial: {
                    opacity: 0,
                    x: -100
                },
                animate: {
                    opacity: 1,
                    x: 0
                },
                transition: {
                    type: Zu,
                    stiffness: 100,
                    damping: 25,
                    delay: .3,
                    duration: 1.2
                },
                className: "flex align-baseline items-center",
                children: ae.jsx(qv, {
                    to: "/",
                    children: ae.jsx("img", {
                        src: $G,
                        alt: "Gen Z Logo",
                        className: "h-14 md:h-20 my-1"
                    })
                })
            }), ae.jsx("nav", {
                className: "md:flex hidden space-x-8",
                children: u.map( (g, v) => g.external ? ae.jsx(Jo.a, {
                    href: g.path,
                    target: "_blank",
                    rel: "noreferrer",
                    initial: {
                        opacity: 0,
                        y: -20
                    },
                    animate: {
                        opacity: 1,
                        y: 0
                    },
                    transition: {
                        type: Zu,
                        stiffness: 100,
                        damping: 20,
                        delay: .7 + v * .2
                    },
                    className: `ml-4 px-3 py-1 rounded-xl
                font-bold bg-[var(--nav-btn-bg)] text-white
                transition-all duration-500 text-lg xl:text-xl 
                text-center`,
                    children: g.label
                }, v) : ae.jsx(f, {
                    to: g.path,
                    initial: {
                        opacity: 0,
                        y: -20
                    },
                    animate: {
                        opacity: 1,
                        y: 0
                    },
                    transition: {
                        type: Zu,
                        stiffness: 100,
                        damping: 20,
                        delay: .7 + v * .2
                    },
                    className: `ml-4 px-3 py-1 rounded-xl
                text-[var(--nav-text)] font-bold
                hover:bg-[var(--nav-btn-bg)] hover:text-white
                transition-all duration-500 text-lg xl:text-xl text-center`,
                    children: ae.jsx("span", {
                        className: g.path === d.pathname ? "border-b-4 border-yellow-300 hover:border-0" : "",
                        children: g.label
                    })
                }, v))
            }), ae.jsx("div", {
                className: "md:hidden flex items-center",
                children: ae.jsx(Jo.button, {
                    onClick: s,
                    whileTap: {
                        scale: .7
                    },
                    className: "text-gray-500 mr-3",
                    children: r ? ae.jsx(NN, {
                        className: "h-6 w-6"
                    }) : ae.jsx(hF, {
                        className: "h-6 w-6"
                    })
                })
            })]
        }), ae.jsx(h8, {
            children: r && ae.jsxs(ae.Fragment, {
                children: [ae.jsx(Jo.div, {
                    className: "fixed inset-0",
                    initial: {
                        opacity: 0
                    },
                    animate: {
                        opacity: 1
                    },
                    exit: {
                        opacity: 0
                    },
                    onClick: l
                }), ae.jsx(Jo.div, {
                    ref: i,
                    initial: {
                        opacity: 0,
                        x: 30
                    },
                    animate: {
                        opacity: 1,
                        x: 0
                    },
                    exit: {
                        opacity: 0,
                        x: 30
                    },
                    transition: {
                        duration: .4
                    },
                    style: {
                        top: t
                    },
                    className: "fixed left-0 right-0 md:hidden bg-white  z-50 px-4 py-5 space-y-5",
                    children: ae.jsx("nav", {
                        className: "flex flex-col space-y-3",
                        children: u.map( (g, v) => g.external ? ae.jsx("a", {
                            href: g.path,
                            target: "_blank",
                            rel: "noreferrer",
                            className: "text-[var(--nav-text)] font-medium py-2",
                            onClick: l,
                            children: g.label
                        }, v) : ae.jsx(qv, {
                            to: g.path,
                            className: "text-[var(--nav-text)] font-medium py-2",
                            onClick: l,
                            children: g.label
                        }, v))
                    })
                })]
            })
        })]
    })
}
;
function kc(r) {
    if (r === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return r
}
function D4(r, e) {
    r.prototype = Object.create(e.prototype),
    r.prototype.constructor = r,
    r.__proto__ = e
}
/*!
 * GSAP 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
var Mo = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
        lineHeight: ""
    }
}, gg = {
    duration: .5,
    overwrite: !1,
    delay: 0
}, UA, ga, Gi, Ku = 1e8, Fa = 1 / Ku, GE = Math.PI * 2, t7 = GE / 4, n7 = 0, U4 = Math.sqrt, i7 = Math.cos, r7 = Math.sin, na = function(e) {
    return typeof e == "string"
}, ur = function(e) {
    return typeof e == "function"
}, $c = function(e) {
    return typeof e == "number"
}, OA = function(e) {
    return typeof e > "u"
}, nc = function(e) {
    return typeof e == "object"
}, Xs = function(e) {
    return e !== !1
}, NA = function() {
    return typeof window < "u"
}, Q1 = function(e) {
    return ur(e) || na(e)
}, O4 = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {}
, Ha = Array.isArray, XE = /(?:-?\.?\d|\.)+/gi, N4 = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, $m = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, X2 = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, L4 = /[+-]=-?[.\d]+/, P4 = /[^,'"\[\]\s]+/gi, a7 = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, Qi, Iu, jE, LA, wo = {}, IS = {}, B4, z4 = function(e) {
    return (IS = vg(e, wo)) && Zs
}, PA = function(e, t) {
    return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
}, Cy = function(e, t) {
    return !t && console.warn(e)
}, I4 = function(e, t) {
    return e && (wo[e] = t) && IS && (IS[e] = t) || wo
}, Ry = function() {
    return 0
}, s7 = {
    suppressEvents: !0,
    isStart: !0,
    kill: !1
}, mS = {
    suppressEvents: !0,
    kill: !1
}, o7 = {
    suppressEvents: !0
}, BA = {}, hh = [], WE = {}, F4, vo = {}, j2 = {}, UD = 30, gS = [], zA = "", IA = function(e) {
    var t = e[0], n, i;
    if (nc(t) || ur(t) || (e = [e]),
    !(n = (t._gsap || {}).harness)) {
        for (i = gS.length; i-- && !gS[i].targetTest(t); )
            ;
        n = gS[i]
    }
    for (i = e.length; i--; )
        e[i] && (e[i]._gsap || (e[i]._gsap = new uP(e[i],n))) || e.splice(i, 1);
    return e
}, Qd = function(e) {
    return e._gsap || IA(il(e))[0]._gsap
}, H4 = function(e, t, n) {
    return (n = e[t]) && ur(n) ? e[t]() : OA(n) && e.getAttribute && e.getAttribute(t) || n
}, js = function(e, t) {
    return (e = e.split(",")).forEach(t) || e
}, gr = function(e) {
    return Math.round(e * 1e5) / 1e5 || 0
}, Ar = function(e) {
    return Math.round(e * 1e7) / 1e7 || 0
}, sg = function(e, t) {
    var n = t.charAt(0)
      , i = parseFloat(t.substr(2));
    return e = parseFloat(e),
    n === "+" ? e + i : n === "-" ? e - i : n === "*" ? e * i : e / i
}, l7 = function(e, t) {
    for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n; )
        ;
    return i < n
}, FS = function() {
    var e = hh.length, t = hh.slice(0), n, i;
    for (WE = {},
    hh.length = 0,
    n = 0; n < e; n++)
        i = t[n],
        i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0)
}, FA = function(e) {
    return !!(e._initted || e._startAt || e.add)
}, V4 = function(e, t, n, i) {
    hh.length && !ga && FS(),
    e.render(t, n, !!(ga && t < 0 && FA(e))),
    hh.length && !ga && FS()
}, k4 = function(e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + "").match(P4).length < 2 ? t : na(e) ? e.trim() : e
}, G4 = function(e) {
    return e
}, Ao = function(e, t) {
    for (var n in t)
        n in e || (e[n] = t[n]);
    return e
}, u7 = function(e) {
    return function(t, n) {
        for (var i in n)
            i in t || i === "duration" && e || i === "ease" || (t[i] = n[i])
    }
}, vg = function(e, t) {
    for (var n in t)
        e[n] = t[n];
    return e
}, OD = function r(e, t) {
    for (var n in t)
        n !== "__proto__" && n !== "constructor" && n !== "prototype" && (e[n] = nc(t[n]) ? r(e[n] || (e[n] = {}), t[n]) : t[n]);
    return e
}, HS = function(e, t) {
    var n = {}, i;
    for (i in e)
        i in t || (n[i] = e[i]);
    return n
}, Zv = function(e) {
    var t = e.parent || Qi
      , n = e.keyframes ? u7(Ha(e.keyframes)) : Ao;
    if (Xs(e.inherit))
        for (; t; )
            n(e, t.vars.defaults),
            t = t.parent || t._dp;
    return e
}, c7 = function(e, t) {
    for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n]; )
        ;
    return n < 0
}, X4 = function(e, t, n, i, a) {
    var s = e[i], l;
    if (a)
        for (l = t[a]; s && s[a] > l; )
            s = s._prev;
    return s ? (t._next = s._next,
    s._next = t) : (t._next = e[n],
    e[n] = t),
    t._next ? t._next._prev = t : e[i] = t,
    t._prev = s,
    t.parent = t._dp = e,
    t
}, tM = function(e, t, n, i) {
    n === void 0 && (n = "_first"),
    i === void 0 && (i = "_last");
    var a = t._prev
      , s = t._next;
    a ? a._next = s : e[n] === t && (e[n] = s),
    s ? s._prev = a : e[i] === t && (e[i] = a),
    t._next = t._prev = t.parent = null
}, gh = function(e, t) {
    e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e),
    e._act = 0
}, Jd = function(e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0))
        for (var n = e; n; )
            n._dirty = 1,
            n = n.parent;
    return e
}, f7 = function(e) {
    for (var t = e.parent; t && t.parent; )
        t._dirty = 1,
        t.totalDuration(),
        t = t.parent;
    return e
}, YE = function(e, t, n, i) {
    return e._startAt && (ga ? e._startAt.revert(mS) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, i))
}, h7 = function r(e) {
    return !e || e._ts && r(e.parent)
}, ND = function(e) {
    return e._repeat ? yg(e._tTime, e = e.duration() + e._rDelay) * e : 0
}, yg = function(e, t) {
    var n = Math.floor(e = Ar(e / t));
    return e && n === e ? n - 1 : n
}, VS = function(e, t) {
    return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
}, nM = function(e) {
    return e._end = Ar(e._start + (e._tDur / Math.abs(e._ts || e._rts || Fa) || 0))
}, iM = function(e, t) {
    var n = e._dp;
    return n && n.smoothChildTiming && e._ts && (e._start = Ar(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)),
    nM(e),
    n._dirty || Jd(n, e)),
    e
}, j4 = function(e, t) {
    var n;
    if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = VS(e.rawTime(), t),
    (!t._dur || l_(0, t.totalDuration(), n) - t._tTime > Fa) && t.render(n, !0)),
    Jd(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
        if (e._dur < e.duration())
            for (n = e; n._dp; )
                n.rawTime() >= 0 && n.totalTime(n._tTime),
                n = n._dp;
        e._zTime = -1e-8
    }
}, Hu = function(e, t, n, i) {
    return t.parent && gh(t),
    t._start = Ar(($c(n) ? n : n || e !== Qi ? Qo(e, n, t) : e._time) + t._delay),
    t._end = Ar(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)),
    X4(e, t, "_first", "_last", e._sort ? "_start" : 0),
    qE(t) || (e._recent = t),
    i || j4(e, t),
    e._ts < 0 && iM(e, e._tTime),
    e
}, W4 = function(e, t) {
    return (wo.ScrollTrigger || PA("scrollTrigger", t)) && wo.ScrollTrigger.create(t, e)
}, Y4 = function(e, t, n, i, a) {
    if (VA(e, t, a),
    !e._initted)
        return 1;
    if (!n && e._pt && !ga && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && F4 !== _o.frame)
        return hh.push(e),
        e._lazy = [a, i],
        1
}, d7 = function r(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || r(t))
}, qE = function(e) {
    var t = e.data;
    return t === "isFromStart" || t === "isStart"
}, p7 = function(e, t, n, i) {
    var a = e.ratio, s = t < 0 || !t && (!e._start && d7(e) && !(!e._initted && qE(e)) || (e._ts < 0 || e._dp._ts < 0) && !qE(e)) ? 0 : 1, l = e._rDelay, u = 0, f, d, g;
    if (l && e._repeat && (u = l_(0, e._tDur, t),
    d = yg(u, l),
    e._yoyo && d & 1 && (s = 1 - s),
    d !== yg(e._tTime, l) && (a = 1 - s,
    e.vars.repeatRefresh && e._initted && e.invalidate())),
    s !== a || ga || i || e._zTime === Fa || !t && e._zTime) {
        if (!e._initted && Y4(e, t, i, n, u))
            return;
        for (g = e._zTime,
        e._zTime = t || (n ? Fa : 0),
        n || (n = t && !g),
        e.ratio = s,
        e._from && (s = 1 - s),
        e._time = 0,
        e._tTime = u,
        f = e._pt; f; )
            f.r(s, f.d),
            f = f._next;
        t < 0 && YE(e, t, n, !0),
        e._onUpdate && !n && So(e, "onUpdate"),
        u && e._repeat && !n && e.parent && So(e, "onRepeat"),
        (t >= e._tDur || t < 0) && e.ratio === s && (s && gh(e, 1),
        !n && !ga && (So(e, s ? "onComplete" : "onReverseComplete", !0),
        e._prom && e._prom()))
    } else
        e._zTime || (e._zTime = t)
}, m7 = function(e, t, n) {
    var i;
    if (n > t)
        for (i = e._first; i && i._start <= n; ) {
            if (i.data === "isPause" && i._start > t)
                return i;
            i = i._next
        }
    else
        for (i = e._last; i && i._start >= n; ) {
            if (i.data === "isPause" && i._start < t)
                return i;
            i = i._prev
        }
}, _g = function(e, t, n, i) {
    var a = e._repeat
      , s = Ar(t) || 0
      , l = e._tTime / e._tDur;
    return l && !i && (e._time *= s / e._dur),
    e._dur = s,
    e._tDur = a ? a < 0 ? 1e10 : Ar(s * (a + 1) + e._rDelay * a) : s,
    l > 0 && !i && iM(e, e._tTime = e._tDur * l),
    e.parent && nM(e),
    n || Jd(e.parent, e),
    e
}, LD = function(e) {
    return e instanceof ds ? Jd(e) : _g(e, e._dur)
}, g7 = {
    _start: 0,
    endTime: Ry,
    totalDuration: Ry
}, Qo = function r(e, t, n) {
    var i = e.labels, a = e._recent || g7, s = e.duration() >= Ku ? a.endTime(!1) : e._dur, l, u, f;
    return na(t) && (isNaN(t) || t in i) ? (u = t.charAt(0),
    f = t.substr(-1) === "%",
    l = t.indexOf("="),
    u === "<" || u === ">" ? (l >= 0 && (t = t.replace(/=/, "")),
    (u === "<" ? a._start : a.endTime(a._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (f ? (l < 0 ? a : n).totalDuration() / 100 : 1)) : l < 0 ? (t in i || (i[t] = s),
    i[t]) : (u = parseFloat(t.charAt(l - 1) + t.substr(l + 1)),
    f && n && (u = u / 100 * (Ha(n) ? n[0] : n).totalDuration()),
    l > 1 ? r(e, t.substr(0, l - 1), n) + u : s + u)) : t == null ? s : +t
}, Kv = function(e, t, n) {
    var i = $c(t[1]), a = (i ? 2 : 1) + (e < 2 ? 0 : 1), s = t[a], l, u;
    if (i && (s.duration = t[1]),
    s.parent = n,
    e) {
        for (l = s,
        u = n; u && !("immediateRender"in l); )
            l = u.vars.defaults || {},
            u = Xs(u.vars.inherit) && u.parent;
        s.immediateRender = Xs(l.immediateRender),
        e < 2 ? s.runBackwards = 1 : s.startAt = t[a - 1]
    }
    return new wr(t[0],s,t[a + 1])
}, Th = function(e, t) {
    return e || e === 0 ? t(e) : t
}, l_ = function(e, t, n) {
    return n < e ? e : n > t ? t : n
}, Ba = function(e, t) {
    return !na(e) || !(t = a7.exec(e)) ? "" : t[1]
}, v7 = function(e, t, n) {
    return Th(n, function(i) {
        return l_(e, t, i)
    })
}, ZE = [].slice, q4 = function(e, t) {
    return e && nc(e) && "length"in e && (!t && !e.length || e.length - 1 in e && nc(e[0])) && !e.nodeType && e !== Iu
}, y7 = function(e, t, n) {
    return n === void 0 && (n = []),
    e.forEach(function(i) {
        var a;
        return na(i) && !t || q4(i, 1) ? (a = n).push.apply(a, il(i)) : n.push(i)
    }) || n
}, il = function(e, t, n) {
    return Gi && !t && Gi.selector ? Gi.selector(e) : na(e) && !n && (jE || !xg()) ? ZE.call((t || LA).querySelectorAll(e), 0) : Ha(e) ? y7(e, n) : q4(e) ? ZE.call(e, 0) : e ? [e] : []
}, KE = function(e) {
    return e = il(e)[0] || Cy("Invalid scope") || {},
    function(t) {
        var n = e.current || e.nativeElement || e;
        return il(t, n.querySelectorAll ? n : n === e ? Cy("Invalid scope") || LA.createElement("div") : e)
    }
}, Z4 = function(e) {
    return e.sort(function() {
        return .5 - Math.random()
    })
}, K4 = function(e) {
    if (ur(e))
        return e;
    var t = nc(e) ? e : {
        each: e
    }
      , n = $d(t.ease)
      , i = t.from || 0
      , a = parseFloat(t.base) || 0
      , s = {}
      , l = i > 0 && i < 1
      , u = isNaN(i) || l
      , f = t.axis
      , d = i
      , g = i;
    return na(i) ? d = g = {
        center: .5,
        edges: .5,
        end: 1
    }[i] || 0 : !l && u && (d = i[0],
    g = i[1]),
    function(v, y, S) {
        var T = (S || t).length, M = s[T], b, A, C, R, O, L, z, I, N;
        if (!M) {
            if (N = t.grid === "auto" ? 0 : (t.grid || [1, Ku])[1],
            !N) {
                for (z = -1e8; z < (z = S[N++].getBoundingClientRect().left) && N < T; )
                    ;
                N < T && N--
            }
            for (M = s[T] = [],
            b = u ? Math.min(N, T) * d - .5 : i % N,
            A = N === Ku ? 0 : u ? T * g / N - .5 : i / N | 0,
            z = 0,
            I = Ku,
            L = 0; L < T; L++)
                C = L % N - b,
                R = A - (L / N | 0),
                M[L] = O = f ? Math.abs(f === "y" ? R : C) : U4(C * C + R * R),
                O > z && (z = O),
                O < I && (I = O);
            i === "random" && Z4(M),
            M.max = z - I,
            M.min = I,
            M.v = T = (parseFloat(t.amount) || parseFloat(t.each) * (N > T ? T - 1 : f ? f === "y" ? T / N : N : Math.max(N, T / N)) || 0) * (i === "edges" ? -1 : 1),
            M.b = T < 0 ? a - T : a,
            M.u = Ba(t.amount || t.each) || 0,
            n = n && T < 0 ? sP(n) : n
        }
        return T = (M[v] - M.min) / M.max || 0,
        Ar(M.b + (n ? n(T) : T) * M.v) + M.u
    }
}, QE = function(e) {
    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
    return function(n) {
        var i = Ar(Math.round(parseFloat(n) / e) * e * t);
        return (i - i % 1) / t + ($c(n) ? 0 : Ba(n))
    }
}, Q4 = function(e, t) {
    var n = Ha(e), i, a;
    return !n && nc(e) && (i = n = e.radius || Ku,
    e.values ? (e = il(e.values),
    (a = !$c(e[0])) && (i *= i)) : e = QE(e.increment)),
    Th(t, n ? ur(e) ? function(s) {
        return a = e(s),
        Math.abs(a - s) <= i ? a : s
    }
    : function(s) {
        for (var l = parseFloat(a ? s.x : s), u = parseFloat(a ? s.y : 0), f = Ku, d = 0, g = e.length, v, y; g--; )
            a ? (v = e[g].x - l,
            y = e[g].y - u,
            v = v * v + y * y) : v = Math.abs(e[g] - l),
            v < f && (f = v,
            d = g);
        return d = !i || f <= i ? e[d] : s,
        a || d === s || $c(s) ? d : d + Ba(s)
    }
    : QE(e))
}, J4 = function(e, t, n, i) {
    return Th(Ha(e) ? !t : n === !0 ? !!(n = 0) : !i, function() {
        return Ha(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + n * .99)) / n) * n * i) / i
    })
}, _7 = function() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    return function(i) {
        return t.reduce(function(a, s) {
            return s(a)
        }, i)
    }
}, x7 = function(e, t) {
    return function(n) {
        return e(parseFloat(n)) + (t || Ba(n))
    }
}, S7 = function(e, t, n) {
    return eP(e, t, 0, 1, n)
}, $4 = function(e, t, n) {
    return Th(n, function(i) {
        return e[~~t(i)]
    })
}, b7 = function r(e, t, n) {
    var i = t - e;
    return Ha(e) ? $4(e, r(0, e.length), t) : Th(n, function(a) {
        return (i + (a - e) % i) % i + e
    })
}, M7 = function r(e, t, n) {
    var i = t - e
      , a = i * 2;
    return Ha(e) ? $4(e, r(0, e.length - 1), t) : Th(n, function(s) {
        return s = (a + (s - e) % a) % a || 0,
        e + (s > i ? a - s : s)
    })
}, Dy = function(e) {
    for (var t = 0, n = "", i, a, s, l; ~(i = e.indexOf("random(", t)); )
        s = e.indexOf(")", i),
        l = e.charAt(i + 7) === "[",
        a = e.substr(i + 7, s - i - 7).match(l ? P4 : XE),
        n += e.substr(t, i - t) + J4(l ? a : +a[0], l ? 0 : +a[1], +a[2] || 1e-5),
        t = s + 1;
    return n + e.substr(t, e.length - t)
}, eP = function(e, t, n, i, a) {
    var s = t - e
      , l = i - n;
    return Th(a, function(u) {
        return n + ((u - e) / s * l || 0)
    })
}, T7 = function r(e, t, n, i) {
    var a = isNaN(e + t) ? 0 : function(y) {
        return (1 - y) * e + y * t
    }
    ;
    if (!a) {
        var s = na(e), l = {}, u, f, d, g, v;
        if (n === !0 && (i = 1) && (n = null),
        s)
            e = {
                p: e
            },
            t = {
                p: t
            };
        else if (Ha(e) && !Ha(t)) {
            for (d = [],
            g = e.length,
            v = g - 2,
            f = 1; f < g; f++)
                d.push(r(e[f - 1], e[f]));
            g--,
            a = function(S) {
                S *= g;
                var T = Math.min(v, ~~S);
                return d[T](S - T)
            }
            ,
            n = t
        } else
            i || (e = vg(Ha(e) ? [] : {}, e));
        if (!d) {
            for (u in t)
                HA.call(l, e, u, "get", t[u]);
            a = function(S) {
                return XA(S, l) || (s ? e.p : e)
            }
        }
    }
    return Th(n, a)
}, PD = function(e, t, n) {
    var i = e.labels, a = Ku, s, l, u;
    for (s in i)
        l = i[s] - t,
        l < 0 == !!n && l && a > (l = Math.abs(l)) && (u = s,
        a = l);
    return u
}, So = function(e, t, n) {
    var i = e.vars, a = i[t], s = Gi, l = e._ctx, u, f, d;
    if (a)
        return u = i[t + "Params"],
        f = i.callbackScope || e,
        n && hh.length && FS(),
        l && (Gi = l),
        d = u ? a.apply(f, u) : a.call(f),
        Gi = s,
        d
}, Dv = function(e) {
    return gh(e),
    e.scrollTrigger && e.scrollTrigger.kill(!!ga),
    e.progress() < 1 && So(e, "onInterrupt"),
    e
}, eg, tP = [], nP = function(e) {
    if (e)
        if (e = !e.name && e.default || e,
        NA() || e.headless) {
            var t = e.name
              , n = ur(e)
              , i = t && !n && e.init ? function() {
                this._props = []
            }
            : e
              , a = {
                init: Ry,
                render: XA,
                add: HA,
                kill: H7,
                modifier: F7,
                rawVars: 0
            }
              , s = {
                targetTest: 0,
                get: 0,
                getSetter: GA,
                aliases: {},
                register: 0
            };
            if (xg(),
            e !== i) {
                if (vo[t])
                    return;
                Ao(i, Ao(HS(e, a), s)),
                vg(i.prototype, vg(a, HS(e, s))),
                vo[i.prop = t] = i,
                e.targetTest && (gS.push(i),
                BA[t] = 1),
                t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
            }
            I4(t, i),
            e.register && e.register(Zs, i, Ws)
        } else
            tP.push(e)
}, Ri = 255, Uv = {
    aqua: [0, Ri, Ri],
    lime: [0, Ri, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, Ri],
    navy: [0, 0, 128],
    white: [Ri, Ri, Ri],
    olive: [128, 128, 0],
    yellow: [Ri, Ri, 0],
    orange: [Ri, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [Ri, 0, 0],
    pink: [Ri, 192, 203],
    cyan: [0, Ri, Ri],
    transparent: [Ri, Ri, Ri, 0]
}, W2 = function(e, t, n) {
    return e += e < 0 ? 1 : e > 1 ? -1 : 0,
    (e * 6 < 1 ? t + (n - t) * e * 6 : e < .5 ? n : e * 3 < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * Ri + .5 | 0
}, iP = function(e, t, n) {
    var i = e ? $c(e) ? [e >> 16, e >> 8 & Ri, e & Ri] : 0 : Uv.black, a, s, l, u, f, d, g, v, y, S;
    if (!i) {
        if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)),
        Uv[e])
            i = Uv[e];
        else if (e.charAt(0) === "#") {
            if (e.length < 6 && (a = e.charAt(1),
            s = e.charAt(2),
            l = e.charAt(3),
            e = "#" + a + a + s + s + l + l + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")),
            e.length === 9)
                return i = parseInt(e.substr(1, 6), 16),
                [i >> 16, i >> 8 & Ri, i & Ri, parseInt(e.substr(7), 16) / 255];
            e = parseInt(e.substr(1), 16),
            i = [e >> 16, e >> 8 & Ri, e & Ri]
        } else if (e.substr(0, 3) === "hsl") {
            if (i = S = e.match(XE),
            !t)
                u = +i[0] % 360 / 360,
                f = +i[1] / 100,
                d = +i[2] / 100,
                s = d <= .5 ? d * (f + 1) : d + f - d * f,
                a = d * 2 - s,
                i.length > 3 && (i[3] *= 1),
                i[0] = W2(u + 1 / 3, a, s),
                i[1] = W2(u, a, s),
                i[2] = W2(u - 1 / 3, a, s);
            else if (~e.indexOf("="))
                return i = e.match(N4),
                n && i.length < 4 && (i[3] = 1),
                i
        } else
            i = e.match(XE) || Uv.transparent;
        i = i.map(Number)
    }
    return t && !S && (a = i[0] / Ri,
    s = i[1] / Ri,
    l = i[2] / Ri,
    g = Math.max(a, s, l),
    v = Math.min(a, s, l),
    d = (g + v) / 2,
    g === v ? u = f = 0 : (y = g - v,
    f = d > .5 ? y / (2 - g - v) : y / (g + v),
    u = g === a ? (s - l) / y + (s < l ? 6 : 0) : g === s ? (l - a) / y + 2 : (a - s) / y + 4,
    u *= 60),
    i[0] = ~~(u + .5),
    i[1] = ~~(f * 100 + .5),
    i[2] = ~~(d * 100 + .5)),
    n && i.length < 4 && (i[3] = 1),
    i
}, rP = function(e) {
    var t = []
      , n = []
      , i = -1;
    return e.split(dh).forEach(function(a) {
        var s = a.match($m) || [];
        t.push.apply(t, s),
        n.push(i += s.length + 1)
    }),
    t.c = n,
    t
}, BD = function(e, t, n) {
    var i = "", a = (e + i).match(dh), s = t ? "hsla(" : "rgba(", l = 0, u, f, d, g;
    if (!a)
        return e;
    if (a = a.map(function(v) {
        return (v = iP(v, t, 1)) && s + (t ? v[0] + "," + v[1] + "%," + v[2] + "%," + v[3] : v.join(",")) + ")"
    }),
    n && (d = rP(e),
    u = n.c,
    u.join(i) !== d.c.join(i)))
        for (f = e.replace(dh, "1").split($m),
        g = f.length - 1; l < g; l++)
            i += f[l] + (~u.indexOf(l) ? a.shift() || s + "0,0,0,0)" : (d.length ? d : a.length ? a : n).shift());
    if (!f)
        for (f = e.split(dh),
        g = f.length - 1; l < g; l++)
            i += f[l] + a[l];
    return i + f[g]
}, dh = function() {
    var r = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
    for (e in Uv)
        r += "|" + e + "\\b";
    return new RegExp(r + ")","gi")
}(), E7 = /hsl[a]?\(/, aP = function(e) {
    var t = e.join(" "), n;
    if (dh.lastIndex = 0,
    dh.test(t))
        return n = E7.test(t),
        e[1] = BD(e[1], n),
        e[0] = BD(e[0], n, rP(e[1])),
        !0
}, Uy, _o = function() {
    var r = Date.now, e = 500, t = 33, n = r(), i = n, a = 1e3 / 240, s = a, l = [], u, f, d, g, v, y, S = function T(M) {
        var b = r() - i, A = M === !0, C, R, O, L;
        if ((b > e || b < 0) && (n += b - t),
        i += b,
        O = i - n,
        C = O - s,
        (C > 0 || A) && (L = ++g.frame,
        v = O - g.time * 1e3,
        g.time = O = O / 1e3,
        s += C + (C >= a ? 4 : a - C),
        R = 1),
        A || (u = f(T)),
        R)
            for (y = 0; y < l.length; y++)
                l[y](O, v, L, M)
    };
    return g = {
        time: 0,
        frame: 0,
        tick: function() {
            S(!0)
        },
        deltaRatio: function(M) {
            return v / (1e3 / (M || 60))
        },
        wake: function() {
            B4 && (!jE && NA() && (Iu = jE = window,
            LA = Iu.document || {},
            wo.gsap = Zs,
            (Iu.gsapVersions || (Iu.gsapVersions = [])).push(Zs.version),
            z4(IS || Iu.GreenSockGlobals || !Iu.gsap && Iu || {}),
            tP.forEach(nP)),
            d = typeof requestAnimationFrame < "u" && requestAnimationFrame,
            u && g.sleep(),
            f = d || function(M) {
                return setTimeout(M, s - g.time * 1e3 + 1 | 0)
            }
            ,
            Uy = 1,
            S(2))
        },
        sleep: function() {
            (d ? cancelAnimationFrame : clearTimeout)(u),
            Uy = 0,
            f = Ry
        },
        lagSmoothing: function(M, b) {
            e = M || 1 / 0,
            t = Math.min(b || 33, e)
        },
        fps: function(M) {
            a = 1e3 / (M || 240),
            s = g.time * 1e3 + a
        },
        add: function(M, b, A) {
            var C = b ? function(R, O, L, z) {
                M(R, O, L, z),
                g.remove(C)
            }
            : M;
            return g.remove(M),
            l[A ? "unshift" : "push"](C),
            xg(),
            C
        },
        remove: function(M, b) {
            ~(b = l.indexOf(M)) && l.splice(b, 1) && y >= b && y--
        },
        _listeners: l
    },
    g
}(), xg = function() {
    return !Uy && _o.wake()
}, Jn = {}, w7 = /^[\d.\-M][\d.\-,\s]/, A7 = /["']/g, C7 = function(e) {
    for (var t = {}, n = e.substr(1, e.length - 3).split(":"), i = n[0], a = 1, s = n.length, l, u, f; a < s; a++)
        u = n[a],
        l = a !== s - 1 ? u.lastIndexOf(",") : u.length,
        f = u.substr(0, l),
        t[i] = isNaN(f) ? f.replace(A7, "").trim() : +f,
        i = u.substr(l + 1).trim();
    return t
}, R7 = function(e) {
    var t = e.indexOf("(") + 1
      , n = e.indexOf(")")
      , i = e.indexOf("(", t);
    return e.substring(t, ~i && i < n ? e.indexOf(")", n + 1) : n)
}, D7 = function(e) {
    var t = (e + "").split("(")
      , n = Jn[t[0]];
    return n && t.length > 1 && n.config ? n.config.apply(null, ~e.indexOf("{") ? [C7(t[1])] : R7(e).split(",").map(k4)) : Jn._CE && w7.test(e) ? Jn._CE("", e) : n
}, sP = function(e) {
    return function(t) {
        return 1 - e(1 - t)
    }
}, oP = function r(e, t) {
    for (var n = e._first, i; n; )
        n instanceof ds ? r(n, t) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== t && (n.timeline ? r(n.timeline, t) : (i = n._ease,
        n._ease = n._yEase,
        n._yEase = i,
        n._yoyo = t)),
        n = n._next
}, $d = function(e, t) {
    return e && (ur(e) ? e : Jn[e] || D7(e)) || t
}, vp = function(e, t, n, i) {
    n === void 0 && (n = function(u) {
        return 1 - t(1 - u)
    }
    ),
    i === void 0 && (i = function(u) {
        return u < .5 ? t(u * 2) / 2 : 1 - t((1 - u) * 2) / 2
    }
    );
    var a = {
        easeIn: t,
        easeOut: n,
        easeInOut: i
    }, s;
    return js(e, function(l) {
        Jn[l] = wo[l] = a,
        Jn[s = l.toLowerCase()] = n;
        for (var u in a)
            Jn[s + (u === "easeIn" ? ".in" : u === "easeOut" ? ".out" : ".inOut")] = Jn[l + "." + u] = a[u]
    }),
    a
}, lP = function(e) {
    return function(t) {
        return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2
    }
}, Y2 = function r(e, t, n) {
    var i = t >= 1 ? t : 1
      , a = (n || (e ? .3 : .45)) / (t < 1 ? t : 1)
      , s = a / GE * (Math.asin(1 / i) || 0)
      , l = function(d) {
        return d === 1 ? 1 : i * Math.pow(2, -10 * d) * r7((d - s) * a) + 1
    }
      , u = e === "out" ? l : e === "in" ? function(f) {
        return 1 - l(1 - f)
    }
    : lP(l);
    return a = GE / a,
    u.config = function(f, d) {
        return r(e, f, d)
    }
    ,
    u
}, q2 = function r(e, t) {
    t === void 0 && (t = 1.70158);
    var n = function(s) {
        return s ? --s * s * ((t + 1) * s + t) + 1 : 0
    }
      , i = e === "out" ? n : e === "in" ? function(a) {
        return 1 - n(1 - a)
    }
    : lP(n);
    return i.config = function(a) {
        return r(e, a)
    }
    ,
    i
};
js("Linear,Quad,Cubic,Quart,Quint,Strong", function(r, e) {
    var t = e < 5 ? e + 1 : e;
    vp(r + ",Power" + (t - 1), e ? function(n) {
        return Math.pow(n, t)
    }
    : function(n) {
        return n
    }
    , function(n) {
        return 1 - Math.pow(1 - n, t)
    }, function(n) {
        return n < .5 ? Math.pow(n * 2, t) / 2 : 1 - Math.pow((1 - n) * 2, t) / 2
    })
});
Jn.Linear.easeNone = Jn.none = Jn.Linear.easeIn;
vp("Elastic", Y2("in"), Y2("out"), Y2());
(function(r, e) {
    var t = 1 / e
      , n = 2 * t
      , i = 2.5 * t
      , a = function(l) {
        return l < t ? r * l * l : l < n ? r * Math.pow(l - 1.5 / e, 2) + .75 : l < i ? r * (l -= 2.25 / e) * l + .9375 : r * Math.pow(l - 2.625 / e, 2) + .984375
    };
    vp("Bounce", function(s) {
        return 1 - a(1 - s)
    }, a)
}
)(7.5625, 2.75);
vp("Expo", function(r) {
    return Math.pow(2, 10 * (r - 1)) * r + r * r * r * r * r * r * (1 - r)
});
vp("Circ", function(r) {
    return -(U4(1 - r * r) - 1)
});
vp("Sine", function(r) {
    return r === 1 ? 1 : -i7(r * t7) + 1
});
vp("Back", q2("in"), q2("out"), q2());
Jn.SteppedEase = Jn.steps = wo.SteppedEase = {
    config: function(e, t) {
        e === void 0 && (e = 1);
        var n = 1 / e
          , i = e + (t ? 0 : 1)
          , a = t ? 1 : 0
          , s = 1 - Fa;
        return function(l) {
            return ((i * l_(0, s, l) | 0) + a) * n
        }
    }
};
gg.ease = Jn["quad.out"];
js("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(r) {
    return zA += r + "," + r + "Params,"
});
var uP = function(e, t) {
    this.id = n7++,
    e._gsap = this,
    this.target = e,
    this.harness = t,
    this.get = t ? t.get : H4,
    this.set = t ? t.getSetter : GA
}
  , Oy = function() {
    function r(t) {
        this.vars = t,
        this._delay = +t.delay || 0,
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0,
        this._yoyo = !!t.yoyo || !!t.yoyoEase),
        this._ts = 1,
        _g(this, +t.duration, 1, 1),
        this.data = t.data,
        Gi && (this._ctx = Gi,
        Gi.data.push(this)),
        Uy || _o.wake()
    }
    var e = r.prototype;
    return e.delay = function(n) {
        return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay),
        this._delay = n,
        this) : this._delay
    }
    ,
    e.duration = function(n) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur
    }
    ,
    e.totalDuration = function(n) {
        return arguments.length ? (this._dirty = 0,
        _g(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
    }
    ,
    e.totalTime = function(n, i) {
        if (xg(),
        !arguments.length)
            return this._tTime;
        var a = this._dp;
        if (a && a.smoothChildTiming && this._ts) {
            for (iM(this, n),
            !a._dp || a.parent || j4(a, this); a && a.parent; )
                a.parent._time !== a._start + (a._ts >= 0 ? a._tTime / a._ts : (a.totalDuration() - a._tTime) / -a._ts) && a.totalTime(a._tTime, !0),
                a = a.parent;
            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && Hu(this._dp, this, this._start - this._delay)
        }
        return (this._tTime !== n || !this._dur && !i || this._initted && Math.abs(this._zTime) === Fa || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n),
        V4(this, n, i)),
        this
    }
    ,
    e.time = function(n, i) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + ND(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), i) : this._time
    }
    ,
    e.totalProgress = function(n, i) {
        return arguments.length ? this.totalTime(this.totalDuration() * n, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0
    }
    ,
    e.progress = function(n, i) {
        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + ND(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
    }
    ,
    e.iteration = function(n, i) {
        var a = this.duration() + this._rDelay;
        return arguments.length ? this.totalTime(this._time + (n - 1) * a, i) : this._repeat ? yg(this._tTime, a) + 1 : 1
    }
    ,
    e.timeScale = function(n, i) {
        if (!arguments.length)
            return this._rts === -1e-8 ? 0 : this._rts;
        if (this._rts === n)
            return this;
        var a = this.parent && this._ts ? VS(this.parent._time, this) : this._tTime;
        return this._rts = +n || 0,
        this._ts = this._ps || n === -1e-8 ? 0 : this._rts,
        this.totalTime(l_(-Math.abs(this._delay), this.totalDuration(), a), i !== !1),
        nM(this),
        f7(this)
    }
    ,
    e.paused = function(n) {
        return arguments.length ? (this._ps !== n && (this._ps = n,
        n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
        this._ts = this._act = 0) : (xg(),
        this._ts = this._rts,
        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Fa && (this._tTime -= Fa)))),
        this) : this._ps
    }
    ,
    e.startTime = function(n) {
        if (arguments.length) {
            this._start = n;
            var i = this.parent || this._dp;
            return i && (i._sort || !this.parent) && Hu(i, this, n - this._delay),
            this
        }
        return this._start
    }
    ,
    e.endTime = function(n) {
        return this._start + (Xs(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
    }
    ,
    e.rawTime = function(n) {
        var i = this.parent || this._dp;
        return i ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? VS(i.rawTime(n), this) : this._tTime : this._tTime
    }
    ,
    e.revert = function(n) {
        n === void 0 && (n = o7);
        var i = ga;
        return ga = n,
        FA(this) && (this.timeline && this.timeline.revert(n),
        this.totalTime(-.01, n.suppressEvents)),
        this.data !== "nested" && n.kill !== !1 && this.kill(),
        ga = i,
        this
    }
    ,
    e.globalTime = function(n) {
        for (var i = this, a = arguments.length ? n : i.rawTime(); i; )
            a = i._start + a / (Math.abs(i._ts) || 1),
            i = i._dp;
        return !this.parent && this._sat ? this._sat.globalTime(n) : a
    }
    ,
    e.repeat = function(n) {
        return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n,
        LD(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
    }
    ,
    e.repeatDelay = function(n) {
        if (arguments.length) {
            var i = this._time;
            return this._rDelay = n,
            LD(this),
            i ? this.time(i) : this
        }
        return this._rDelay
    }
    ,
    e.yoyo = function(n) {
        return arguments.length ? (this._yoyo = n,
        this) : this._yoyo
    }
    ,
    e.seek = function(n, i) {
        return this.totalTime(Qo(this, n), Xs(i))
    }
    ,
    e.restart = function(n, i) {
        return this.play().totalTime(n ? -this._delay : 0, Xs(i)),
        this._dur || (this._zTime = -1e-8),
        this
    }
    ,
    e.play = function(n, i) {
        return n != null && this.seek(n, i),
        this.reversed(!1).paused(!1)
    }
    ,
    e.reverse = function(n, i) {
        return n != null && this.seek(n || this.totalDuration(), i),
        this.reversed(!0).paused(!1)
    }
    ,
    e.pause = function(n, i) {
        return n != null && this.seek(n, i),
        this.paused(!0)
    }
    ,
    e.resume = function() {
        return this.paused(!1)
    }
    ,
    e.reversed = function(n) {
        return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -1e-8 : 0)),
        this) : this._rts < 0
    }
    ,
    e.invalidate = function() {
        return this._initted = this._act = 0,
        this._zTime = -1e-8,
        this
    }
    ,
    e.isActive = function() {
        var n = this.parent || this._dp, i = this._start, a;
        return !!(!n || this._ts && this._initted && n.isActive() && (a = n.rawTime(!0)) >= i && a < this.endTime(!0) - Fa)
    }
    ,
    e.eventCallback = function(n, i, a) {
        var s = this.vars;
        return arguments.length > 1 ? (i ? (s[n] = i,
        a && (s[n + "Params"] = a),
        n === "onUpdate" && (this._onUpdate = i)) : delete s[n],
        this) : s[n]
    }
    ,
    e.then = function(n) {
        var i = this;
        return new Promise(function(a) {
            var s = ur(n) ? n : G4
              , l = function() {
                var f = i.then;
                i.then = null,
                ur(s) && (s = s(i)) && (s.then || s === i) && (i.then = f),
                a(s),
                i.then = f
            };
            i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? l() : i._prom = l
        }
        )
    }
    ,
    e.kill = function() {
        Dv(this)
    }
    ,
    r
}();
Ao(Oy.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -1e-8,
    _prom: 0,
    _ps: !1,
    _rts: 1
});
var ds = function(r) {
    D4(e, r);
    function e(n, i) {
        var a;
        return n === void 0 && (n = {}),
        a = r.call(this, n) || this,
        a.labels = {},
        a.smoothChildTiming = !!n.smoothChildTiming,
        a.autoRemoveChildren = !!n.autoRemoveChildren,
        a._sort = Xs(n.sortChildren),
        Qi && Hu(n.parent || Qi, kc(a), i),
        n.reversed && a.reverse(),
        n.paused && a.paused(!0),
        n.scrollTrigger && W4(kc(a), n.scrollTrigger),
        a
    }
    var t = e.prototype;
    return t.to = function(i, a, s) {
        return Kv(0, arguments, this),
        this
    }
    ,
    t.from = function(i, a, s) {
        return Kv(1, arguments, this),
        this
    }
    ,
    t.fromTo = function(i, a, s, l) {
        return Kv(2, arguments, this),
        this
    }
    ,
    t.set = function(i, a, s) {
        return a.duration = 0,
        a.parent = this,
        Zv(a).repeatDelay || (a.repeat = 0),
        a.immediateRender = !!a.immediateRender,
        new wr(i,a,Qo(this, s),1),
        this
    }
    ,
    t.call = function(i, a, s) {
        return Hu(this, wr.delayedCall(0, i, a), s)
    }
    ,
    t.staggerTo = function(i, a, s, l, u, f, d) {
        return s.duration = a,
        s.stagger = s.stagger || l,
        s.onComplete = f,
        s.onCompleteParams = d,
        s.parent = this,
        new wr(i,s,Qo(this, u)),
        this
    }
    ,
    t.staggerFrom = function(i, a, s, l, u, f, d) {
        return s.runBackwards = 1,
        Zv(s).immediateRender = Xs(s.immediateRender),
        this.staggerTo(i, a, s, l, u, f, d)
    }
    ,
    t.staggerFromTo = function(i, a, s, l, u, f, d, g) {
        return l.startAt = s,
        Zv(l).immediateRender = Xs(l.immediateRender),
        this.staggerTo(i, a, l, u, f, d, g)
    }
    ,
    t.render = function(i, a, s) {
        var l = this._time, u = this._dirty ? this.totalDuration() : this._tDur, f = this._dur, d = i <= 0 ? 0 : Ar(i), g = this._zTime < 0 != i < 0 && (this._initted || !f), v, y, S, T, M, b, A, C, R, O, L, z;
        if (this !== Qi && d > u && i >= 0 && (d = u),
        d !== this._tTime || s || g) {
            if (l !== this._time && f && (d += this._time - l,
            i += this._time - l),
            v = d,
            R = this._start,
            C = this._ts,
            b = !C,
            g && (f || (l = this._zTime),
            (i || !a) && (this._zTime = i)),
            this._repeat) {
                if (L = this._yoyo,
                M = f + this._rDelay,
                this._repeat < -1 && i < 0)
                    return this.totalTime(M * 100 + i, a, s);
                if (v = Ar(d % M),
                d === u ? (T = this._repeat,
                v = f) : (O = Ar(d / M),
                T = ~~O,
                T && T === O && (v = f,
                T--),
                v > f && (v = f)),
                O = yg(this._tTime, M),
                !l && this._tTime && O !== T && this._tTime - O * M - this._dur <= 0 && (O = T),
                L && T & 1 && (v = f - v,
                z = 1),
                T !== O && !this._lock) {
                    var I = L && O & 1
                      , N = I === (L && T & 1);
                    if (T < O && (I = !I),
                    l = I ? 0 : d % f ? f : d,
                    this._lock = 1,
                    this.render(l || (z ? 0 : Ar(T * M)), a, !f)._lock = 0,
                    this._tTime = d,
                    !a && this.parent && So(this, "onRepeat"),
                    this.vars.repeatRefresh && !z && (this.invalidate()._lock = 1),
                    l && l !== this._time || b !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                        return this;
                    if (f = this._dur,
                    u = this._tDur,
                    N && (this._lock = 2,
                    l = I ? f : -1e-4,
                    this.render(l, !0),
                    this.vars.repeatRefresh && !z && this.invalidate()),
                    this._lock = 0,
                    !this._ts && !b)
                        return this;
                    oP(this, z)
                }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (A = m7(this, Ar(l), Ar(v)),
            A && (d -= v - (v = A._start))),
            this._tTime = d,
            this._time = v,
            this._act = !C,
            this._initted || (this._onUpdate = this.vars.onUpdate,
            this._initted = 1,
            this._zTime = i,
            l = 0),
            !l && d && !a && !O && (So(this, "onStart"),
            this._tTime !== d))
                return this;
            if (v >= l && i >= 0)
                for (y = this._first; y; ) {
                    if (S = y._next,
                    (y._act || v >= y._start) && y._ts && A !== y) {
                        if (y.parent !== this)
                            return this.render(i, a, s);
                        if (y.render(y._ts > 0 ? (v - y._start) * y._ts : (y._dirty ? y.totalDuration() : y._tDur) + (v - y._start) * y._ts, a, s),
                        v !== this._time || !this._ts && !b) {
                            A = 0,
                            S && (d += this._zTime = -1e-8);
                            break
                        }
                    }
                    y = S
                }
            else {
                y = this._last;
                for (var P = i < 0 ? i : v; y; ) {
                    if (S = y._prev,
                    (y._act || P <= y._end) && y._ts && A !== y) {
                        if (y.parent !== this)
                            return this.render(i, a, s);
                        if (y.render(y._ts > 0 ? (P - y._start) * y._ts : (y._dirty ? y.totalDuration() : y._tDur) + (P - y._start) * y._ts, a, s || ga && FA(y)),
                        v !== this._time || !this._ts && !b) {
                            A = 0,
                            S && (d += this._zTime = P ? -1e-8 : Fa);
                            break
                        }
                    }
                    y = S
                }
            }
            if (A && !a && (this.pause(),
            A.render(v >= l ? 0 : -1e-8)._zTime = v >= l ? 1 : -1,
            this._ts))
                return this._start = R,
                nM(this),
                this.render(i, a, s);
            this._onUpdate && !a && So(this, "onUpdate", !0),
            (d === u && this._tTime >= this.totalDuration() || !d && l) && (R === this._start || Math.abs(C) !== Math.abs(this._ts)) && (this._lock || ((i || !f) && (d === u && this._ts > 0 || !d && this._ts < 0) && gh(this, 1),
            !a && !(i < 0 && !l) && (d || l || !u) && (So(this, d === u && i >= 0 ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(d < u && this.timeScale() > 0) && this._prom())))
        }
        return this
    }
    ,
    t.add = function(i, a) {
        var s = this;
        if ($c(a) || (a = Qo(this, a, i)),
        !(i instanceof Oy)) {
            if (Ha(i))
                return i.forEach(function(l) {
                    return s.add(l, a)
                }),
                this;
            if (na(i))
                return this.addLabel(i, a);
            if (ur(i))
                i = wr.delayedCall(0, i);
            else
                return this
        }
        return this !== i ? Hu(this, i, a) : this
    }
    ,
    t.getChildren = function(i, a, s, l) {
        i === void 0 && (i = !0),
        a === void 0 && (a = !0),
        s === void 0 && (s = !0),
        l === void 0 && (l = -1e8);
        for (var u = [], f = this._first; f; )
            f._start >= l && (f instanceof wr ? a && u.push(f) : (s && u.push(f),
            i && u.push.apply(u, f.getChildren(!0, a, s)))),
            f = f._next;
        return u
    }
    ,
    t.getById = function(i) {
        for (var a = this.getChildren(1, 1, 1), s = a.length; s--; )
            if (a[s].vars.id === i)
                return a[s]
    }
    ,
    t.remove = function(i) {
        return na(i) ? this.removeLabel(i) : ur(i) ? this.killTweensOf(i) : (i.parent === this && tM(this, i),
        i === this._recent && (this._recent = this._last),
        Jd(this))
    }
    ,
    t.totalTime = function(i, a) {
        return arguments.length ? (this._forcing = 1,
        !this._dp && this._ts && (this._start = Ar(_o.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))),
        r.prototype.totalTime.call(this, i, a),
        this._forcing = 0,
        this) : this._tTime
    }
    ,
    t.addLabel = function(i, a) {
        return this.labels[i] = Qo(this, a),
        this
    }
    ,
    t.removeLabel = function(i) {
        return delete this.labels[i],
        this
    }
    ,
    t.addPause = function(i, a, s) {
        var l = wr.delayedCall(0, a || Ry, s);
        return l.data = "isPause",
        this._hasPause = 1,
        Hu(this, l, Qo(this, i))
    }
    ,
    t.removePause = function(i) {
        var a = this._first;
        for (i = Qo(this, i); a; )
            a._start === i && a.data === "isPause" && gh(a),
            a = a._next
    }
    ,
    t.killTweensOf = function(i, a, s) {
        for (var l = this.getTweensOf(i, s), u = l.length; u--; )
            ah !== l[u] && l[u].kill(i, a);
        return this
    }
    ,
    t.getTweensOf = function(i, a) {
        for (var s = [], l = il(i), u = this._first, f = $c(a), d; u; )
            u instanceof wr ? l7(u._targets, l) && (f ? (!ah || u._initted && u._ts) && u.globalTime(0) <= a && u.globalTime(u.totalDuration()) > a : !a || u.isActive()) && s.push(u) : (d = u.getTweensOf(l, a)).length && s.push.apply(s, d),
            u = u._next;
        return s
    }
    ,
    t.tweenTo = function(i, a) {
        a = a || {};
        var s = this, l = Qo(s, i), u = a, f = u.startAt, d = u.onStart, g = u.onStartParams, v = u.immediateRender, y, S = wr.to(s, Ao({
            ease: a.ease || "none",
            lazy: !1,
            immediateRender: !1,
            time: l,
            overwrite: "auto",
            duration: a.duration || Math.abs((l - (f && "time"in f ? f.time : s._time)) / s.timeScale()) || Fa,
            onStart: function() {
                if (s.pause(),
                !y) {
                    var M = a.duration || Math.abs((l - (f && "time"in f ? f.time : s._time)) / s.timeScale());
                    S._dur !== M && _g(S, M, 0, 1).render(S._time, !0, !0),
                    y = 1
                }
                d && d.apply(S, g || [])
            }
        }, a));
        return v ? S.render(0) : S
    }
    ,
    t.tweenFromTo = function(i, a, s) {
        return this.tweenTo(a, Ao({
            startAt: {
                time: Qo(this, i)
            }
        }, s))
    }
    ,
    t.recent = function() {
        return this._recent
    }
    ,
    t.nextLabel = function(i) {
        return i === void 0 && (i = this._time),
        PD(this, Qo(this, i))
    }
    ,
    t.previousLabel = function(i) {
        return i === void 0 && (i = this._time),
        PD(this, Qo(this, i), 1)
    }
    ,
    t.currentLabel = function(i) {
        return arguments.length ? this.seek(i, !0) : this.previousLabel(this._time + Fa)
    }
    ,
    t.shiftChildren = function(i, a, s) {
        s === void 0 && (s = 0);
        for (var l = this._first, u = this.labels, f; l; )
            l._start >= s && (l._start += i,
            l._end += i),
            l = l._next;
        if (a)
            for (f in u)
                u[f] >= s && (u[f] += i);
        return Jd(this)
    }
    ,
    t.invalidate = function(i) {
        var a = this._first;
        for (this._lock = 0; a; )
            a.invalidate(i),
            a = a._next;
        return r.prototype.invalidate.call(this, i)
    }
    ,
    t.clear = function(i) {
        i === void 0 && (i = !0);
        for (var a = this._first, s; a; )
            s = a._next,
            this.remove(a),
            a = s;
        return this._dp && (this._time = this._tTime = this._pTime = 0),
        i && (this.labels = {}),
        Jd(this)
    }
    ,
    t.totalDuration = function(i) {
        var a = 0, s = this, l = s._last, u = Ku, f, d, g;
        if (arguments.length)
            return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -i : i));
        if (s._dirty) {
            for (g = s.parent; l; )
                f = l._prev,
                l._dirty && l.totalDuration(),
                d = l._start,
                d > u && s._sort && l._ts && !s._lock ? (s._lock = 1,
                Hu(s, l, d - l._delay, 1)._lock = 0) : u = d,
                d < 0 && l._ts && (a -= d,
                (!g && !s._dp || g && g.smoothChildTiming) && (s._start += d / s._ts,
                s._time -= d,
                s._tTime -= d),
                s.shiftChildren(-d, !1, -1 / 0),
                u = 0),
                l._end > a && l._ts && (a = l._end),
                l = f;
            _g(s, s === Qi && s._time > a ? s._time : a, 1, 1),
            s._dirty = 0
        }
        return s._tDur
    }
    ,
    e.updateRoot = function(i) {
        if (Qi._ts && (V4(Qi, VS(i, Qi)),
        F4 = _o.frame),
        _o.frame >= UD) {
            UD += Mo.autoSleep || 120;
            var a = Qi._first;
            if ((!a || !a._ts) && Mo.autoSleep && _o._listeners.length < 2) {
                for (; a && !a._ts; )
                    a = a._next;
                a || _o.sleep()
            }
        }
    }
    ,
    e
}(Oy);
Ao(ds.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
});
var U7 = function(e, t, n, i, a, s, l) {
    var u = new Ws(this._pt,e,t,0,1,mP,null,a), f = 0, d = 0, g, v, y, S, T, M, b, A;
    for (u.b = n,
    u.e = i,
    n += "",
    i += "",
    (b = ~i.indexOf("random(")) && (i = Dy(i)),
    s && (A = [n, i],
    s(A, e, t),
    n = A[0],
    i = A[1]),
    v = n.match(X2) || []; g = X2.exec(i); )
        S = g[0],
        T = i.substring(f, g.index),
        y ? y = (y + 1) % 5 : T.substr(-5) === "rgba(" && (y = 1),
        S !== v[d++] && (M = parseFloat(v[d - 1]) || 0,
        u._pt = {
            _next: u._pt,
            p: T || d === 1 ? T : ",",
            s: M,
            c: S.charAt(1) === "=" ? sg(M, S) - M : parseFloat(S) - M,
            m: y && y < 4 ? Math.round : 0
        },
        f = X2.lastIndex);
    return u.c = f < i.length ? i.substring(f, i.length) : "",
    u.fp = l,
    (L4.test(i) || b) && (u.e = 0),
    this._pt = u,
    u
}, HA = function(e, t, n, i, a, s, l, u, f, d) {
    ur(i) && (i = i(a || 0, e, s));
    var g = e[t], v = n !== "get" ? n : ur(g) ? f ? e[t.indexOf("set") || !ur(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](f) : e[t]() : g, y = ur(g) ? f ? B7 : dP : kA, S;
    if (na(i) && (~i.indexOf("random(") && (i = Dy(i)),
    i.charAt(1) === "=" && (S = sg(v, i) + (Ba(v) || 0),
    (S || S === 0) && (i = S))),
    !d || v !== i || JE)
        return !isNaN(v * i) && i !== "" ? (S = new Ws(this._pt,e,t,+v || 0,i - (v || 0),typeof g == "boolean" ? I7 : pP,0,y),
        f && (S.fp = f),
        l && S.modifier(l, this, e),
        this._pt = S) : (!g && !(t in e) && PA(t, i),
        U7.call(this, e, t, v, i, y, u || Mo.stringFilter, f))
}, O7 = function(e, t, n, i, a) {
    if (ur(e) && (e = Qv(e, a, t, n, i)),
    !nc(e) || e.style && e.nodeType || Ha(e) || O4(e))
        return na(e) ? Qv(e, a, t, n, i) : e;
    var s = {}, l;
    for (l in e)
        s[l] = Qv(e[l], a, t, n, i);
    return s
}, cP = function(e, t, n, i, a, s) {
    var l, u, f, d;
    if (vo[e] && (l = new vo[e]).init(a, l.rawVars ? t[e] : O7(t[e], i, a, s, n), n, i, s) !== !1 && (n._pt = u = new Ws(n._pt,a,e,0,1,l.render,l,0,l.priority),
    n !== eg))
        for (f = n._ptLookup[n._targets.indexOf(a)],
        d = l._props.length; d--; )
            f[l._props[d]] = u;
    return l
}, ah, JE, VA = function r(e, t, n) {
    var i = e.vars, a = i.ease, s = i.startAt, l = i.immediateRender, u = i.lazy, f = i.onUpdate, d = i.runBackwards, g = i.yoyoEase, v = i.keyframes, y = i.autoRevert, S = e._dur, T = e._startAt, M = e._targets, b = e.parent, A = b && b.data === "nested" ? b.vars.targets : M, C = e._overwrite === "auto" && !UA, R = e.timeline, O, L, z, I, N, P, Y, V, K, Z, oe, H, q;
    if (R && (!v || !a) && (a = "none"),
    e._ease = $d(a, gg.ease),
    e._yEase = g ? sP($d(g === !0 ? a : g, gg.ease)) : 0,
    g && e._yoyo && !e._repeat && (g = e._yEase,
    e._yEase = e._ease,
    e._ease = g),
    e._from = !R && !!i.runBackwards,
    !R || v && !i.stagger) {
        if (V = M[0] ? Qd(M[0]).harness : 0,
        H = V && i[V.prop],
        O = HS(i, BA),
        T && (T._zTime < 0 && T.progress(1),
        t < 0 && d && l && !y ? T.render(-1, !0) : T.revert(d && S ? mS : s7),
        T._lazy = 0),
        s) {
            if (gh(e._startAt = wr.set(M, Ao({
                data: "isStart",
                overwrite: !1,
                parent: b,
                immediateRender: !0,
                lazy: !T && Xs(u),
                startAt: null,
                delay: 0,
                onUpdate: f && function() {
                    return So(e, "onUpdate")
                }
                ,
                stagger: 0
            }, s))),
            e._startAt._dp = 0,
            e._startAt._sat = e,
            t < 0 && (ga || !l && !y) && e._startAt.revert(mS),
            l && S && t <= 0 && n <= 0) {
                t && (e._zTime = t);
                return
            }
        } else if (d && S && !T) {
            if (t && (l = !1),
            z = Ao({
                overwrite: !1,
                data: "isFromStart",
                lazy: l && !T && Xs(u),
                immediateRender: l,
                stagger: 0,
                parent: b
            }, O),
            H && (z[V.prop] = H),
            gh(e._startAt = wr.set(M, z)),
            e._startAt._dp = 0,
            e._startAt._sat = e,
            t < 0 && (ga ? e._startAt.revert(mS) : e._startAt.render(-1, !0)),
            e._zTime = t,
            !l)
                r(e._startAt, Fa, Fa);
            else if (!t)
                return
        }
        for (e._pt = e._ptCache = 0,
        u = S && Xs(u) || u && !S,
        L = 0; L < M.length; L++) {
            if (N = M[L],
            Y = N._gsap || IA(M)[L]._gsap,
            e._ptLookup[L] = Z = {},
            WE[Y.id] && hh.length && FS(),
            oe = A === M ? L : A.indexOf(N),
            V && (K = new V).init(N, H || O, e, oe, A) !== !1 && (e._pt = I = new Ws(e._pt,N,K.name,0,1,K.render,K,0,K.priority),
            K._props.forEach(function(Q) {
                Z[Q] = I
            }),
            K.priority && (P = 1)),
            !V || H)
                for (z in O)
                    vo[z] && (K = cP(z, O, e, oe, N, A)) ? K.priority && (P = 1) : Z[z] = I = HA.call(e, N, z, "get", O[z], oe, A, 0, i.stringFilter);
            e._op && e._op[L] && e.kill(N, e._op[L]),
            C && e._pt && (ah = e,
            Qi.killTweensOf(N, Z, e.globalTime(t)),
            q = !e.parent,
            ah = 0),
            e._pt && u && (WE[Y.id] = 1)
        }
        P && gP(e),
        e._onInit && e._onInit(e)
    }
    e._onUpdate = f,
    e._initted = (!e._op || e._pt) && !q,
    v && t <= 0 && R.render(Ku, !0, !0)
}, N7 = function(e, t, n, i, a, s, l, u) {
    var f = (e._pt && e._ptCache || (e._ptCache = {}))[t], d, g, v, y;
    if (!f)
        for (f = e._ptCache[t] = [],
        v = e._ptLookup,
        y = e._targets.length; y--; ) {
            if (d = v[y][t],
            d && d.d && d.d._pt)
                for (d = d.d._pt; d && d.p !== t && d.fp !== t; )
                    d = d._next;
            if (!d)
                return JE = 1,
                e.vars[t] = "+=0",
                VA(e, l),
                JE = 0,
                u ? Cy(t + " not eligible for reset") : 1;
            f.push(d)
        }
    for (y = f.length; y--; )
        g = f[y],
        d = g._pt || g,
        d.s = (i || i === 0) && !a ? i : d.s + (i || 0) + s * d.c,
        d.c = n - d.s,
        g.e && (g.e = gr(n) + Ba(g.e)),
        g.b && (g.b = d.s + Ba(g.b))
}, L7 = function(e, t) {
    var n = e[0] ? Qd(e[0]).harness : 0, i = n && n.aliases, a, s, l, u;
    if (!i)
        return t;
    a = vg({}, t);
    for (s in i)
        if (s in a)
            for (u = i[s].split(","),
            l = u.length; l--; )
                a[u[l]] = a[s];
    return a
}, P7 = function(e, t, n, i) {
    var a = t.ease || i || "power1.inOut", s, l;
    if (Ha(t))
        l = n[e] || (n[e] = []),
        t.forEach(function(u, f) {
            return l.push({
                t: f / (t.length - 1) * 100,
                v: u,
                e: a
            })
        });
    else
        for (s in t)
            l = n[s] || (n[s] = []),
            s === "ease" || l.push({
                t: parseFloat(e),
                v: t[s],
                e: a
            })
}, Qv = function(e, t, n, i, a) {
    return ur(e) ? e.call(t, n, i, a) : na(e) && ~e.indexOf("random(") ? Dy(e) : e
}, fP = zA + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", hP = {};
js(fP + ",id,stagger,delay,duration,paused,scrollTrigger", function(r) {
    return hP[r] = 1
});
var wr = function(r) {
    D4(e, r);
    function e(n, i, a, s) {
        var l;
        typeof i == "number" && (a.duration = i,
        i = a,
        a = null),
        l = r.call(this, s ? i : Zv(i)) || this;
        var u = l.vars, f = u.duration, d = u.delay, g = u.immediateRender, v = u.stagger, y = u.overwrite, S = u.keyframes, T = u.defaults, M = u.scrollTrigger, b = u.yoyoEase, A = i.parent || Qi, C = (Ha(n) || O4(n) ? $c(n[0]) : "length"in i) ? [n] : il(n), R, O, L, z, I, N, P, Y;
        if (l._targets = C.length ? IA(C) : Cy("GSAP target " + n + " not found. https://gsap.com", !Mo.nullTargetWarn) || [],
        l._ptLookup = [],
        l._overwrite = y,
        S || v || Q1(f) || Q1(d)) {
            if (i = l.vars,
            R = l.timeline = new ds({
                data: "nested",
                defaults: T || {},
                targets: A && A.data === "nested" ? A.vars.targets : C
            }),
            R.kill(),
            R.parent = R._dp = kc(l),
            R._start = 0,
            v || Q1(f) || Q1(d)) {
                if (z = C.length,
                P = v && K4(v),
                nc(v))
                    for (I in v)
                        ~fP.indexOf(I) && (Y || (Y = {}),
                        Y[I] = v[I]);
                for (O = 0; O < z; O++)
                    L = HS(i, hP),
                    L.stagger = 0,
                    b && (L.yoyoEase = b),
                    Y && vg(L, Y),
                    N = C[O],
                    L.duration = +Qv(f, kc(l), O, N, C),
                    L.delay = (+Qv(d, kc(l), O, N, C) || 0) - l._delay,
                    !v && z === 1 && L.delay && (l._delay = d = L.delay,
                    l._start += d,
                    L.delay = 0),
                    R.to(N, L, P ? P(O, N, C) : 0),
                    R._ease = Jn.none;
                R.duration() ? f = d = 0 : l.timeline = 0
            } else if (S) {
                Zv(Ao(R.vars.defaults, {
                    ease: "none"
                })),
                R._ease = $d(S.ease || i.ease || "none");
                var V = 0, K, Z, oe;
                if (Ha(S))
                    S.forEach(function(H) {
                        return R.to(C, H, ">")
                    }),
                    R.duration();
                else {
                    L = {};
                    for (I in S)
                        I === "ease" || I === "easeEach" || P7(I, S[I], L, S.easeEach);
                    for (I in L)
                        for (K = L[I].sort(function(H, q) {
                            return H.t - q.t
                        }),
                        V = 0,
                        O = 0; O < K.length; O++)
                            Z = K[O],
                            oe = {
                                ease: Z.e,
                                duration: (Z.t - (O ? K[O - 1].t : 0)) / 100 * f
                            },
                            oe[I] = Z.v,
                            R.to(C, oe, V),
                            V += oe.duration;
                    R.duration() < f && R.to({}, {
                        duration: f - R.duration()
                    })
                }
            }
            f || l.duration(f = R.duration())
        } else
            l.timeline = 0;
        return y === !0 && !UA && (ah = kc(l),
        Qi.killTweensOf(C),
        ah = 0),
        Hu(A, kc(l), a),
        i.reversed && l.reverse(),
        i.paused && l.paused(!0),
        (g || !f && !S && l._start === Ar(A._time) && Xs(g) && h7(kc(l)) && A.data !== "nested") && (l._tTime = -1e-8,
        l.render(Math.max(0, -d) || 0)),
        M && W4(kc(l), M),
        l
    }
    var t = e.prototype;
    return t.render = function(i, a, s) {
        var l = this._time, u = this._tDur, f = this._dur, d = i < 0, g = i > u - Fa && !d ? u : i < Fa ? 0 : i, v, y, S, T, M, b, A, C, R;
        if (!f)
            p7(this, i, a, s);
        else if (g !== this._tTime || !i || s || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== d || this._lazy) {
            if (v = g,
            C = this.timeline,
            this._repeat) {
                if (T = f + this._rDelay,
                this._repeat < -1 && d)
                    return this.totalTime(T * 100 + i, a, s);
                if (v = Ar(g % T),
                g === u ? (S = this._repeat,
                v = f) : (M = Ar(g / T),
                S = ~~M,
                S && S === M ? (v = f,
                S--) : v > f && (v = f)),
                b = this._yoyo && S & 1,
                b && (R = this._yEase,
                v = f - v),
                M = yg(this._tTime, T),
                v === l && !s && this._initted && S === M)
                    return this._tTime = g,
                    this;
                S !== M && (C && this._yEase && oP(C, b),
                this.vars.repeatRefresh && !b && !this._lock && v !== T && this._initted && (this._lock = s = 1,
                this.render(Ar(T * S), !0).invalidate()._lock = 0))
            }
            if (!this._initted) {
                if (Y4(this, d ? i : v, s, a, g))
                    return this._tTime = 0,
                    this;
                if (l !== this._time && !(s && this.vars.repeatRefresh && S !== M))
                    return this;
                if (f !== this._dur)
                    return this.render(i, a, s)
            }
            if (this._tTime = g,
            this._time = v,
            !this._act && this._ts && (this._act = 1,
            this._lazy = 0),
            this.ratio = A = (R || this._ease)(v / f),
            this._from && (this.ratio = A = 1 - A),
            !l && g && !a && !M && (So(this, "onStart"),
            this._tTime !== g))
                return this;
            for (y = this._pt; y; )
                y.r(A, y.d),
                y = y._next;
            C && C.render(i < 0 ? i : C._dur * C._ease(v / this._dur), a, s) || this._startAt && (this._zTime = i),
            this._onUpdate && !a && (d && YE(this, i, a, s),
            So(this, "onUpdate")),
            this._repeat && S !== M && this.vars.onRepeat && !a && this.parent && So(this, "onRepeat"),
            (g === this._tDur || !g) && this._tTime === g && (d && !this._onUpdate && YE(this, i, !0, !0),
            (i || !f) && (g === this._tDur && this._ts > 0 || !g && this._ts < 0) && gh(this, 1),
            !a && !(d && !l) && (g || l || b) && (So(this, g === u ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(g < u && this.timeScale() > 0) && this._prom()))
        }
        return this
    }
    ,
    t.targets = function() {
        return this._targets
    }
    ,
    t.invalidate = function(i) {
        return (!i || !this.vars.runBackwards) && (this._startAt = 0),
        this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
        this._ptLookup = [],
        this.timeline && this.timeline.invalidate(i),
        r.prototype.invalidate.call(this, i)
    }
    ,
    t.resetTo = function(i, a, s, l, u) {
        Uy || _o.wake(),
        this._ts || this.play();
        var f = Math.min(this._dur, (this._dp._time - this._start) * this._ts), d;
        return this._initted || VA(this, f),
        d = this._ease(f / this._dur),
        N7(this, i, a, s, l, d, f, u) ? this.resetTo(i, a, s, l, 1) : (iM(this, 0),
        this.parent || X4(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
        this.render(0))
    }
    ,
    t.kill = function(i, a) {
        if (a === void 0 && (a = "all"),
        !i && (!a || a === "all"))
            return this._lazy = this._pt = 0,
            this.parent ? Dv(this) : this.scrollTrigger && this.scrollTrigger.kill(!!ga),
            this;
        if (this.timeline) {
            var s = this.timeline.totalDuration();
            return this.timeline.killTweensOf(i, a, ah && ah.vars.overwrite !== !0)._first || Dv(this),
            this.parent && s !== this.timeline.totalDuration() && _g(this, this._dur * this.timeline._tDur / s, 0, 1),
            this
        }
        var l = this._targets, u = i ? il(i) : l, f = this._ptLookup, d = this._pt, g, v, y, S, T, M, b;
        if ((!a || a === "all") && c7(l, u))
            return a === "all" && (this._pt = 0),
            Dv(this);
        for (g = this._op = this._op || [],
        a !== "all" && (na(a) && (T = {},
        js(a, function(A) {
            return T[A] = 1
        }),
        a = T),
        a = L7(l, a)),
        b = l.length; b--; )
            if (~u.indexOf(l[b])) {
                v = f[b],
                a === "all" ? (g[b] = a,
                S = v,
                y = {}) : (y = g[b] = g[b] || {},
                S = a);
                for (T in S)
                    M = v && v[T],
                    M && ((!("kill"in M.d) || M.d.kill(T) === !0) && tM(this, M, "_pt"),
                    delete v[T]),
                    y !== "all" && (y[T] = 1)
            }
        return this._initted && !this._pt && d && Dv(this),
        this
    }
    ,
    e.to = function(i, a) {
        return new e(i,a,arguments[2])
    }
    ,
    e.from = function(i, a) {
        return Kv(1, arguments)
    }
    ,
    e.delayedCall = function(i, a, s, l) {
        return new e(a,0,{
            immediateRender: !1,
            lazy: !1,
            overwrite: !1,
            delay: i,
            onComplete: a,
            onReverseComplete: a,
            onCompleteParams: s,
            onReverseCompleteParams: s,
            callbackScope: l
        })
    }
    ,
    e.fromTo = function(i, a, s) {
        return Kv(2, arguments)
    }
    ,
    e.set = function(i, a) {
        return a.duration = 0,
        a.repeatDelay || (a.repeat = 0),
        new e(i,a)
    }
    ,
    e.killTweensOf = function(i, a, s) {
        return Qi.killTweensOf(i, a, s)
    }
    ,
    e
}(Oy);
Ao(wr.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
});
js("staggerTo,staggerFrom,staggerFromTo", function(r) {
    wr[r] = function() {
        var e = new ds
          , t = ZE.call(arguments, 0);
        return t.splice(r === "staggerFromTo" ? 5 : 4, 0, 0),
        e[r].apply(e, t)
    }
});
var kA = function(e, t, n) {
    return e[t] = n
}
  , dP = function(e, t, n) {
    return e[t](n)
}
  , B7 = function(e, t, n, i) {
    return e[t](i.fp, n)
}
  , z7 = function(e, t, n) {
    return e.setAttribute(t, n)
}
  , GA = function(e, t) {
    return ur(e[t]) ? dP : OA(e[t]) && e.setAttribute ? z7 : kA
}
  , pP = function(e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t)
}
  , I7 = function(e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t)
}
  , mP = function(e, t) {
    var n = t._pt
      , i = "";
    if (!e && t.b)
        i = t.b;
    else if (e === 1 && t.e)
        i = t.e;
    else {
        for (; n; )
            i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) + i,
            n = n._next;
        i += t.c
    }
    t.set(t.t, t.p, i, t)
}
  , XA = function(e, t) {
    for (var n = t._pt; n; )
        n.r(e, n.d),
        n = n._next
}
  , F7 = function(e, t, n, i) {
    for (var a = this._pt, s; a; )
        s = a._next,
        a.p === i && a.modifier(e, t, n),
        a = s
}
  , H7 = function(e) {
    for (var t = this._pt, n, i; t; )
        i = t._next,
        t.p === e && !t.op || t.op === e ? tM(this, t, "_pt") : t.dep || (n = 1),
        t = i;
    return !n
}
  , V7 = function(e, t, n, i) {
    i.mSet(e, t, i.m.call(i.tween, n, i.mt), i)
}
  , gP = function(e) {
    for (var t = e._pt, n, i, a, s; t; ) {
        for (n = t._next,
        i = a; i && i.pr > t.pr; )
            i = i._next;
        (t._prev = i ? i._prev : s) ? t._prev._next = t : a = t,
        (t._next = i) ? i._prev = t : s = t,
        t = n
    }
    e._pt = a
}
  , Ws = function() {
    function r(t, n, i, a, s, l, u, f, d) {
        this.t = n,
        this.s = a,
        this.c = s,
        this.p = i,
        this.r = l || pP,
        this.d = u || this,
        this.set = f || kA,
        this.pr = d || 0,
        this._next = t,
        t && (t._prev = this)
    }
    var e = r.prototype;
    return e.modifier = function(n, i, a) {
        this.mSet = this.mSet || this.set,
        this.set = V7,
        this.m = n,
        this.mt = a,
        this.tween = i
    }
    ,
    r
}();
js(zA + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(r) {
    return BA[r] = 1
});
wo.TweenMax = wo.TweenLite = wr;
wo.TimelineLite = wo.TimelineMax = ds;
Qi = new ds({
    sortChildren: !1,
    defaults: gg,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
});
Mo.stringFilter = aP;
var ep = []
  , vS = {}
  , k7 = []
  , zD = 0
  , G7 = 0
  , Z2 = function(e) {
    return (vS[e] || k7).map(function(t) {
        return t()
    })
}
  , $E = function() {
    var e = Date.now()
      , t = [];
    e - zD > 2 && (Z2("matchMediaInit"),
    ep.forEach(function(n) {
        var i = n.queries, a = n.conditions, s, l, u, f;
        for (l in i)
            s = Iu.matchMedia(i[l]).matches,
            s && (u = 1),
            s !== a[l] && (a[l] = s,
            f = 1);
        f && (n.revert(),
        u && t.push(n))
    }),
    Z2("matchMediaRevert"),
    t.forEach(function(n) {
        return n.onMatch(n, function(i) {
            return n.add(null, i)
        })
    }),
    zD = e,
    Z2("matchMedia"))
}
  , vP = function() {
    function r(t, n) {
        this.selector = n && KE(n),
        this.data = [],
        this._r = [],
        this.isReverted = !1,
        this.id = G7++,
        t && this.add(t)
    }
    var e = r.prototype;
    return e.add = function(n, i, a) {
        ur(n) && (a = i,
        i = n,
        n = ur);
        var s = this
          , l = function() {
            var f = Gi, d = s.selector, g;
            return f && f !== s && f.data.push(s),
            a && (s.selector = KE(a)),
            Gi = s,
            g = i.apply(s, arguments),
            ur(g) && s._r.push(g),
            Gi = f,
            s.selector = d,
            s.isReverted = !1,
            g
        };
        return s.last = l,
        n === ur ? l(s, function(u) {
            return s.add(null, u)
        }) : n ? s[n] = l : l
    }
    ,
    e.ignore = function(n) {
        var i = Gi;
        Gi = null,
        n(this),
        Gi = i
    }
    ,
    e.getTweens = function() {
        var n = [];
        return this.data.forEach(function(i) {
            return i instanceof r ? n.push.apply(n, i.getTweens()) : i instanceof wr && !(i.parent && i.parent.data === "nested") && n.push(i)
        }),
        n
    }
    ,
    e.clear = function() {
        this._r.length = this.data.length = 0
    }
    ,
    e.kill = function(n, i) {
        var a = this;
        if (n ? function() {
            for (var l = a.getTweens(), u = a.data.length, f; u--; )
                f = a.data[u],
                f.data === "isFlip" && (f.revert(),
                f.getChildren(!0, !0, !1).forEach(function(d) {
                    return l.splice(l.indexOf(d), 1)
                }));
            for (l.map(function(d) {
                return {
                    g: d._dur || d._delay || d._sat && !d._sat.vars.immediateRender ? d.globalTime(0) : -1 / 0,
                    t: d
                }
            }).sort(function(d, g) {
                return g.g - d.g || -1 / 0
            }).forEach(function(d) {
                return d.t.revert(n)
            }),
            u = a.data.length; u--; )
                f = a.data[u],
                f instanceof ds ? f.data !== "nested" && (f.scrollTrigger && f.scrollTrigger.revert(),
                f.kill()) : !(f instanceof wr) && f.revert && f.revert(n);
            a._r.forEach(function(d) {
                return d(n, a)
            }),
            a.isReverted = !0
        }() : this.data.forEach(function(l) {
            return l.kill && l.kill()
        }),
        this.clear(),
        i)
            for (var s = ep.length; s--; )
                ep[s].id === this.id && ep.splice(s, 1)
    }
    ,
    e.revert = function(n) {
        this.kill(n || {})
    }
    ,
    r
}()
  , X7 = function() {
    function r(t) {
        this.contexts = [],
        this.scope = t,
        Gi && Gi.data.push(this)
    }
    var e = r.prototype;
    return e.add = function(n, i, a) {
        nc(n) || (n = {
            matches: n
        });
        var s = new vP(0,a || this.scope), l = s.conditions = {}, u, f, d;
        Gi && !s.selector && (s.selector = Gi.selector),
        this.contexts.push(s),
        i = s.add("onMatch", i),
        s.queries = n;
        for (f in n)
            f === "all" ? d = 1 : (u = Iu.matchMedia(n[f]),
            u && (ep.indexOf(s) < 0 && ep.push(s),
            (l[f] = u.matches) && (d = 1),
            u.addListener ? u.addListener($E) : u.addEventListener("change", $E)));
        return d && i(s, function(g) {
            return s.add(null, g)
        }),
        this
    }
    ,
    e.revert = function(n) {
        this.kill(n || {})
    }
    ,
    e.kill = function(n) {
        this.contexts.forEach(function(i) {
            return i.kill(n, !0)
        })
    }
    ,
    r
}()
  , kS = {
    registerPlugin: function() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        t.forEach(function(i) {
            return nP(i)
        })
    },
    timeline: function(e) {
        return new ds(e)
    },
    getTweensOf: function(e, t) {
        return Qi.getTweensOf(e, t)
    },
    getProperty: function(e, t, n, i) {
        na(e) && (e = il(e)[0]);
        var a = Qd(e || {}).get
          , s = n ? G4 : k4;
        return n === "native" && (n = ""),
        e && (t ? s((vo[t] && vo[t].get || a)(e, t, n, i)) : function(l, u, f) {
            return s((vo[l] && vo[l].get || a)(e, l, u, f))
        }
        )
    },
    quickSetter: function(e, t, n) {
        if (e = il(e),
        e.length > 1) {
            var i = e.map(function(d) {
                return Zs.quickSetter(d, t, n)
            })
              , a = i.length;
            return function(d) {
                for (var g = a; g--; )
                    i[g](d)
            }
        }
        e = e[0] || {};
        var s = vo[t]
          , l = Qd(e)
          , u = l.harness && (l.harness.aliases || {})[t] || t
          , f = s ? function(d) {
            var g = new s;
            eg._pt = 0,
            g.init(e, n ? d + n : d, eg, 0, [e]),
            g.render(1, g),
            eg._pt && XA(1, eg)
        }
        : l.set(e, u);
        return s ? f : function(d) {
            return f(e, u, n ? d + n : d, l, 1)
        }
    },
    quickTo: function(e, t, n) {
        var i, a = Zs.to(e, Ao((i = {},
        i[t] = "+=0.1",
        i.paused = !0,
        i.stagger = 0,
        i), n || {})), s = function(u, f, d) {
            return a.resetTo(t, u, f, d)
        };
        return s.tween = a,
        s
    },
    isTweening: function(e) {
        return Qi.getTweensOf(e, !0).length > 0
    },
    defaults: function(e) {
        return e && e.ease && (e.ease = $d(e.ease, gg.ease)),
        OD(gg, e || {})
    },
    config: function(e) {
        return OD(Mo, e || {})
    },
    registerEffect: function(e) {
        var t = e.name
          , n = e.effect
          , i = e.plugins
          , a = e.defaults
          , s = e.extendTimeline;
        (i || "").split(",").forEach(function(l) {
            return l && !vo[l] && !wo[l] && Cy(t + " effect requires " + l + " plugin.")
        }),
        j2[t] = function(l, u, f) {
            return n(il(l), Ao(u || {}, a), f)
        }
        ,
        s && (ds.prototype[t] = function(l, u, f) {
            return this.add(j2[t](l, nc(u) ? u : (f = u) && {}, this), f)
        }
        )
    },
    registerEase: function(e, t) {
        Jn[e] = $d(t)
    },
    parseEase: function(e, t) {
        return arguments.length ? $d(e, t) : Jn
    },
    getById: function(e) {
        return Qi.getById(e)
    },
    exportRoot: function(e, t) {
        e === void 0 && (e = {});
        var n = new ds(e), i, a;
        for (n.smoothChildTiming = Xs(e.smoothChildTiming),
        Qi.remove(n),
        n._dp = 0,
        n._time = n._tTime = Qi._time,
        i = Qi._first; i; )
            a = i._next,
            (t || !(!i._dur && i instanceof wr && i.vars.onComplete === i._targets[0])) && Hu(n, i, i._start - i._delay),
            i = a;
        return Hu(Qi, n, 0),
        n
    },
    context: function(e, t) {
        return e ? new vP(e,t) : Gi
    },
    matchMedia: function(e) {
        return new X7(e)
    },
    matchMediaRefresh: function() {
        return ep.forEach(function(e) {
            var t = e.conditions, n, i;
            for (i in t)
                t[i] && (t[i] = !1,
                n = 1);
            n && e.revert()
        }) || $E()
    },
    addEventListener: function(e, t) {
        var n = vS[e] || (vS[e] = []);
        ~n.indexOf(t) || n.push(t)
    },
    removeEventListener: function(e, t) {
        var n = vS[e]
          , i = n && n.indexOf(t);
        i >= 0 && n.splice(i, 1)
    },
    utils: {
        wrap: b7,
        wrapYoyo: M7,
        distribute: K4,
        random: J4,
        snap: Q4,
        normalize: S7,
        getUnit: Ba,
        clamp: v7,
        splitColor: iP,
        toArray: il,
        selector: KE,
        mapRange: eP,
        pipe: _7,
        unitize: x7,
        interpolate: T7,
        shuffle: Z4
    },
    install: z4,
    effects: j2,
    ticker: _o,
    updateRoot: ds.updateRoot,
    plugins: vo,
    globalTimeline: Qi,
    core: {
        PropTween: Ws,
        globals: I4,
        Tween: wr,
        Timeline: ds,
        Animation: Oy,
        getCache: Qd,
        _removeLinkedListItem: tM,
        reverting: function() {
            return ga
        },
        context: function(e) {
            return e && Gi && (Gi.data.push(e),
            e._ctx = Gi),
            Gi
        },
        suppressOverwrites: function(e) {
            return UA = e
        }
    }
};
js("to,from,fromTo,delayedCall,set,killTweensOf", function(r) {
    return kS[r] = wr[r]
});
_o.add(ds.updateRoot);
eg = kS.to({}, {
    duration: 0
});
var j7 = function(e, t) {
    for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
        n = n._next;
    return n
}
  , W7 = function(e, t) {
    var n = e._targets, i, a, s;
    for (i in t)
        for (a = n.length; a--; )
            s = e._ptLookup[a][i],
            s && (s = s.d) && (s._pt && (s = j7(s, i)),
            s && s.modifier && s.modifier(t[i], e, n[a], i))
}
  , K2 = function(e, t) {
    return {
        name: e,
        headless: 1,
        rawVars: 1,
        init: function(i, a, s) {
            s._onInit = function(l) {
                var u, f;
                if (na(a) && (u = {},
                js(a, function(d) {
                    return u[d] = 1
                }),
                a = u),
                t) {
                    u = {};
                    for (f in a)
                        u[f] = t(a[f]);
                    a = u
                }
                W7(l, a)
            }
        }
    }
}
  , Zs = kS.registerPlugin({
    name: "attr",
    init: function(e, t, n, i, a) {
        var s, l, u;
        this.tween = n;
        for (s in t)
            u = e.getAttribute(s) || "",
            l = this.add(e, "setAttribute", (u || 0) + "", t[s], i, a, 0, 0, s),
            l.op = s,
            l.b = u,
            this._props.push(s)
    },
    render: function(e, t) {
        for (var n = t._pt; n; )
            ga ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d),
            n = n._next
    }
}, {
    name: "endArray",
    headless: 1,
    init: function(e, t) {
        for (var n = t.length; n--; )
            this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1)
    }
}, K2("roundProps", QE), K2("modifiers"), K2("snap", Q4)) || kS;
wr.version = ds.version = Zs.version = "3.13.0";
B4 = 1;
NA() && xg();
Jn.Power0;
Jn.Power1;
Jn.Power2;
Jn.Power3;
Jn.Power4;
Jn.Linear;
Jn.Quad;
Jn.Cubic;
Jn.Quart;
Jn.Quint;
Jn.Strong;
Jn.Elastic;
Jn.Back;
Jn.SteppedEase;
Jn.Bounce;
Jn.Sine;
Jn.Expo;
Jn.Circ;
/*!
 * CSSPlugin 3.13.0
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
var ID, sh, og, jA, kd, FD, WA, Y7 = function() {
    return typeof window < "u"
}, ef = {}, Ld = 180 / Math.PI, lg = Math.PI / 180, vm = Math.atan2, HD = 1e8, YA = /([A-Z])/g, q7 = /(left|right|width|margin|padding|x)/i, Z7 = /[\s,\(]\S/, ku = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
}, ew = function(e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
}, K7 = function(e, t) {
    return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
}, Q7 = function(e, t) {
    return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t)
}, J7 = function(e, t) {
    var n = t.s + t.c * e;
    t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t)
}, yP = function(e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t)
}, _P = function(e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t)
}, $7 = function(e, t, n) {
    return e.style[t] = n
}, e9 = function(e, t, n) {
    return e.style.setProperty(t, n)
}, t9 = function(e, t, n) {
    return e._gsap[t] = n
}, n9 = function(e, t, n) {
    return e._gsap.scaleX = e._gsap.scaleY = n
}, i9 = function(e, t, n, i, a) {
    var s = e._gsap;
    s.scaleX = s.scaleY = n,
    s.renderTransform(a, s)
}, r9 = function(e, t, n, i, a) {
    var s = e._gsap;
    s[t] = n,
    s.renderTransform(a, s)
}, $i = "transform", Ys = $i + "Origin", a9 = function r(e, t) {
    var n = this
      , i = this.target
      , a = i.style
      , s = i._gsap;
    if (e in ef && a) {
        if (this.tfm = this.tfm || {},
        e !== "transform")
            e = ku[e] || e,
            ~e.indexOf(",") ? e.split(",").forEach(function(l) {
                return n.tfm[l] = Gc(i, l)
            }) : this.tfm[e] = s.x ? s[e] : Gc(i, e),
            e === Ys && (this.tfm.zOrigin = s.zOrigin);
        else
            return ku.transform.split(",").forEach(function(l) {
                return r.call(n, l, t)
            });
        if (this.props.indexOf($i) >= 0)
            return;
        s.svg && (this.svgo = i.getAttribute("data-svg-origin"),
        this.props.push(Ys, t, "")),
        e = $i
    }
    (a || t) && this.props.push(e, t, a[e])
}, xP = function(e) {
    e.translate && (e.removeProperty("translate"),
    e.removeProperty("scale"),
    e.removeProperty("rotate"))
}, s9 = function() {
    var e = this.props, t = this.target, n = t.style, i = t._gsap, a, s;
    for (a = 0; a < e.length; a += 3)
        e[a + 1] ? e[a + 1] === 2 ? t[e[a]](e[a + 2]) : t[e[a]] = e[a + 2] : e[a + 2] ? n[e[a]] = e[a + 2] : n.removeProperty(e[a].substr(0, 2) === "--" ? e[a] : e[a].replace(YA, "-$1").toLowerCase());
    if (this.tfm) {
        for (s in this.tfm)
            i[s] = this.tfm[s];
        i.svg && (i.renderTransform(),
        t.setAttribute("data-svg-origin", this.svgo || "")),
        a = WA(),
        (!a || !a.isStart) && !n[$i] && (xP(n),
        i.zOrigin && n[Ys] && (n[Ys] += " " + i.zOrigin + "px",
        i.zOrigin = 0,
        i.renderTransform()),
        i.uncache = 1)
    }
}, SP = function(e, t) {
    var n = {
        target: e,
        props: [],
        revert: s9,
        save: a9
    };
    return e._gsap || Zs.core.getCache(e),
    t && e.style && e.nodeType && t.split(",").forEach(function(i) {
        return n.save(i)
    }),
    n
}, bP, tw = function(e, t) {
    var n = sh.createElementNS ? sh.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : sh.createElement(e);
    return n && n.style ? n : sh.createElement(e)
}, rl = function r(e, t, n) {
    var i = getComputedStyle(e);
    return i[t] || i.getPropertyValue(t.replace(YA, "-$1").toLowerCase()) || i.getPropertyValue(t) || !n && r(e, Sg(t) || t, 1) || ""
}, VD = "O,Moz,ms,Ms,Webkit".split(","), Sg = function(e, t, n) {
    var i = t || kd
      , a = i.style
      , s = 5;
    if (e in a && !n)
        return e;
    for (e = e.charAt(0).toUpperCase() + e.substr(1); s-- && !(VD[s] + e in a); )
        ;
    return s < 0 ? null : (s === 3 ? "ms" : s >= 0 ? VD[s] : "") + e
}, nw = function() {
    Y7() && window.document && (ID = window,
    sh = ID.document,
    og = sh.documentElement,
    kd = tw("div") || {
        style: {}
    },
    tw("div"),
    $i = Sg($i),
    Ys = $i + "Origin",
    kd.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
    bP = !!Sg("perspective"),
    WA = Zs.core.reverting,
    jA = 1)
}, kD = function(e) {
    var t = e.ownerSVGElement, n = tw("svg", t && t.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = e.cloneNode(!0), a;
    i.style.display = "block",
    n.appendChild(i),
    og.appendChild(n);
    try {
        a = i.getBBox()
    } catch {}
    return n.removeChild(i),
    og.removeChild(n),
    a
}, GD = function(e, t) {
    for (var n = t.length; n--; )
        if (e.hasAttribute(t[n]))
            return e.getAttribute(t[n])
}, MP = function(e) {
    var t, n;
    try {
        t = e.getBBox()
    } catch {
        t = kD(e),
        n = 1
    }
    return t && (t.width || t.height) || n || (t = kD(e)),
    t && !t.width && !t.x && !t.y ? {
        x: +GD(e, ["x", "cx", "x1"]) || 0,
        y: +GD(e, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
    } : t
}, TP = function(e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && MP(e))
}, lp = function(e, t) {
    if (t) {
        var n = e.style, i;
        t in ef && t !== Ys && (t = $i),
        n.removeProperty ? (i = t.substr(0, 2),
        (i === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t),
        n.removeProperty(i === "--" ? t : t.replace(YA, "-$1").toLowerCase())) : n.removeAttribute(t)
    }
}, oh = function(e, t, n, i, a, s) {
    var l = new Ws(e._pt,t,n,0,1,s ? _P : yP);
    return e._pt = l,
    l.b = i,
    l.e = a,
    e._props.push(n),
    l
}, XD = {
    deg: 1,
    rad: 1,
    turn: 1
}, o9 = {
    grid: 1,
    flex: 1
}, vh = function r(e, t, n, i) {
    var a = parseFloat(n) || 0, s = (n + "").trim().substr((a + "").length) || "px", l = kd.style, u = q7.test(t), f = e.tagName.toLowerCase() === "svg", d = (f ? "client" : "offset") + (u ? "Width" : "Height"), g = 100, v = i === "px", y = i === "%", S, T, M, b;
    if (i === s || !a || XD[i] || XD[s])
        return a;
    if (s !== "px" && !v && (a = r(e, t, n, "px")),
    b = e.getCTM && TP(e),
    (y || s === "%") && (ef[t] || ~t.indexOf("adius")))
        return S = b ? e.getBBox()[u ? "width" : "height"] : e[d],
        gr(y ? a / S * g : a / 100 * S);
    if (l[u ? "width" : "height"] = g + (v ? s : i),
    T = i !== "rem" && ~t.indexOf("adius") || i === "em" && e.appendChild && !f ? e : e.parentNode,
    b && (T = (e.ownerSVGElement || {}).parentNode),
    (!T || T === sh || !T.appendChild) && (T = sh.body),
    M = T._gsap,
    M && y && M.width && u && M.time === _o.time && !M.uncache)
        return gr(a / M.width * g);
    if (y && (t === "height" || t === "width")) {
        var A = e.style[t];
        e.style[t] = g + i,
        S = e[d],
        A ? e.style[t] = A : lp(e, t)
    } else
        (y || s === "%") && !o9[rl(T, "display")] && (l.position = rl(e, "position")),
        T === e && (l.position = "static"),
        T.appendChild(kd),
        S = kd[d],
        T.removeChild(kd),
        l.position = "absolute";
    return u && y && (M = Qd(T),
    M.time = _o.time,
    M.width = T[d]),
    gr(v ? S * a / g : S && a ? g / S * a : 0)
}, Gc = function(e, t, n, i) {
    var a;
    return jA || nw(),
    t in ku && t !== "transform" && (t = ku[t],
    ~t.indexOf(",") && (t = t.split(",")[0])),
    ef[t] && t !== "transform" ? (a = Ly(e, i),
    a = t !== "transformOrigin" ? a[t] : a.svg ? a.origin : XS(rl(e, Ys)) + " " + a.zOrigin + "px") : (a = e.style[t],
    (!a || a === "auto" || i || ~(a + "").indexOf("calc(")) && (a = GS[t] && GS[t](e, t, n) || rl(e, t) || H4(e, t) || (t === "opacity" ? 1 : 0))),
    n && !~(a + "").trim().indexOf(" ") ? vh(e, t, a, n) + n : a
}, l9 = function(e, t, n, i) {
    if (!n || n === "none") {
        var a = Sg(t, e, 1)
          , s = a && rl(e, a, 1);
        s && s !== n ? (t = a,
        n = s) : t === "borderColor" && (n = rl(e, "borderTopColor"))
    }
    var l = new Ws(this._pt,e.style,t,0,1,mP), u = 0, f = 0, d, g, v, y, S, T, M, b, A, C, R, O;
    if (l.b = n,
    l.e = i,
    n += "",
    i += "",
    i.substring(0, 6) === "var(--" && (i = rl(e, i.substring(4, i.indexOf(")")))),
    i === "auto" && (T = e.style[t],
    e.style[t] = i,
    i = rl(e, t) || i,
    T ? e.style[t] = T : lp(e, t)),
    d = [n, i],
    aP(d),
    n = d[0],
    i = d[1],
    v = n.match($m) || [],
    O = i.match($m) || [],
    O.length) {
        for (; g = $m.exec(i); )
            M = g[0],
            A = i.substring(u, g.index),
            S ? S = (S + 1) % 5 : (A.substr(-5) === "rgba(" || A.substr(-5) === "hsla(") && (S = 1),
            M !== (T = v[f++] || "") && (y = parseFloat(T) || 0,
            R = T.substr((y + "").length),
            M.charAt(1) === "=" && (M = sg(y, M) + R),
            b = parseFloat(M),
            C = M.substr((b + "").length),
            u = $m.lastIndex - C.length,
            C || (C = C || Mo.units[t] || R,
            u === i.length && (i += C,
            l.e += C)),
            R !== C && (y = vh(e, t, T, C) || 0),
            l._pt = {
                _next: l._pt,
                p: A || f === 1 ? A : ",",
                s: y,
                c: b - y,
                m: S && S < 4 || t === "zIndex" ? Math.round : 0
            });
        l.c = u < i.length ? i.substring(u, i.length) : ""
    } else
        l.r = t === "display" && i === "none" ? _P : yP;
    return L4.test(i) && (l.e = 0),
    this._pt = l,
    l
}, jD = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
}, u9 = function(e) {
    var t = e.split(" ")
      , n = t[0]
      , i = t[1] || "50%";
    return (n === "top" || n === "bottom" || i === "left" || i === "right") && (e = n,
    n = i,
    i = e),
    t[0] = jD[n] || n,
    t[1] = jD[i] || i,
    t.join(" ")
}, c9 = function(e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
        var n = t.t, i = n.style, a = t.u, s = n._gsap, l, u, f;
        if (a === "all" || a === !0)
            i.cssText = "",
            u = 1;
        else
            for (a = a.split(","),
            f = a.length; --f > -1; )
                l = a[f],
                ef[l] && (u = 1,
                l = l === "transformOrigin" ? Ys : $i),
                lp(n, l);
        u && (lp(n, $i),
        s && (s.svg && n.removeAttribute("transform"),
        i.scale = i.rotate = i.translate = "none",
        Ly(n, 1),
        s.uncache = 1,
        xP(i)))
    }
}, GS = {
    clearProps: function(e, t, n, i, a) {
        if (a.data !== "isFromStart") {
            var s = e._pt = new Ws(e._pt,t,n,0,0,c9);
            return s.u = i,
            s.pr = -10,
            s.tween = a,
            e._props.push(n),
            1
        }
    }
}, Ny = [1, 0, 0, 1, 0, 0], EP = {}, wP = function(e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e
}, WD = function(e) {
    var t = rl(e, $i);
    return wP(t) ? Ny : t.substr(7).match(N4).map(gr)
}, qA = function(e, t) {
    var n = e._gsap || Qd(e), i = e.style, a = WD(e), s, l, u, f;
    return n.svg && e.getAttribute("transform") ? (u = e.transform.baseVal.consolidate().matrix,
    a = [u.a, u.b, u.c, u.d, u.e, u.f],
    a.join(",") === "1,0,0,1,0,0" ? Ny : a) : (a === Ny && !e.offsetParent && e !== og && !n.svg && (u = i.display,
    i.display = "block",
    s = e.parentNode,
    (!s || !e.offsetParent && !e.getBoundingClientRect().width) && (f = 1,
    l = e.nextElementSibling,
    og.appendChild(e)),
    a = WD(e),
    u ? i.display = u : lp(e, "display"),
    f && (l ? s.insertBefore(e, l) : s ? s.appendChild(e) : og.removeChild(e))),
    t && a.length > 6 ? [a[0], a[1], a[4], a[5], a[12], a[13]] : a)
}, iw = function(e, t, n, i, a, s) {
    var l = e._gsap, u = a || qA(e, !0), f = l.xOrigin || 0, d = l.yOrigin || 0, g = l.xOffset || 0, v = l.yOffset || 0, y = u[0], S = u[1], T = u[2], M = u[3], b = u[4], A = u[5], C = t.split(" "), R = parseFloat(C[0]) || 0, O = parseFloat(C[1]) || 0, L, z, I, N;
    n ? u !== Ny && (z = y * M - S * T) && (I = R * (M / z) + O * (-T / z) + (T * A - M * b) / z,
    N = R * (-S / z) + O * (y / z) - (y * A - S * b) / z,
    R = I,
    O = N) : (L = MP(e),
    R = L.x + (~C[0].indexOf("%") ? R / 100 * L.width : R),
    O = L.y + (~(C[1] || C[0]).indexOf("%") ? O / 100 * L.height : O)),
    i || i !== !1 && l.smooth ? (b = R - f,
    A = O - d,
    l.xOffset = g + (b * y + A * T) - b,
    l.yOffset = v + (b * S + A * M) - A) : l.xOffset = l.yOffset = 0,
    l.xOrigin = R,
    l.yOrigin = O,
    l.smooth = !!i,
    l.origin = t,
    l.originIsAbsolute = !!n,
    e.style[Ys] = "0px 0px",
    s && (oh(s, l, "xOrigin", f, R),
    oh(s, l, "yOrigin", d, O),
    oh(s, l, "xOffset", g, l.xOffset),
    oh(s, l, "yOffset", v, l.yOffset)),
    e.setAttribute("data-svg-origin", R + " " + O)
}, Ly = function(e, t) {
    var n = e._gsap || new uP(e);
    if ("x"in n && !t && !n.uncache)
        return n;
    var i = e.style, a = n.scaleX < 0, s = "px", l = "deg", u = getComputedStyle(e), f = rl(e, Ys) || "0", d, g, v, y, S, T, M, b, A, C, R, O, L, z, I, N, P, Y, V, K, Z, oe, H, q, Q, se, B, W, te, fe, pe, _e;
    return d = g = v = T = M = b = A = C = R = 0,
    y = S = 1,
    n.svg = !!(e.getCTM && TP(e)),
    u.translate && ((u.translate !== "none" || u.scale !== "none" || u.rotate !== "none") && (i[$i] = (u.translate !== "none" ? "translate3d(" + (u.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (u.rotate !== "none" ? "rotate(" + u.rotate + ") " : "") + (u.scale !== "none" ? "scale(" + u.scale.split(" ").join(",") + ") " : "") + (u[$i] !== "none" ? u[$i] : "")),
    i.scale = i.rotate = i.translate = "none"),
    z = qA(e, n.svg),
    n.svg && (n.uncache ? (Q = e.getBBox(),
    f = n.xOrigin - Q.x + "px " + (n.yOrigin - Q.y) + "px",
    q = "") : q = !t && e.getAttribute("data-svg-origin"),
    iw(e, q || f, !!q || n.originIsAbsolute, n.smooth !== !1, z)),
    O = n.xOrigin || 0,
    L = n.yOrigin || 0,
    z !== Ny && (Y = z[0],
    V = z[1],
    K = z[2],
    Z = z[3],
    d = oe = z[4],
    g = H = z[5],
    z.length === 6 ? (y = Math.sqrt(Y * Y + V * V),
    S = Math.sqrt(Z * Z + K * K),
    T = Y || V ? vm(V, Y) * Ld : 0,
    A = K || Z ? vm(K, Z) * Ld + T : 0,
    A && (S *= Math.abs(Math.cos(A * lg))),
    n.svg && (d -= O - (O * Y + L * K),
    g -= L - (O * V + L * Z))) : (_e = z[6],
    fe = z[7],
    B = z[8],
    W = z[9],
    te = z[10],
    pe = z[11],
    d = z[12],
    g = z[13],
    v = z[14],
    I = vm(_e, te),
    M = I * Ld,
    I && (N = Math.cos(-I),
    P = Math.sin(-I),
    q = oe * N + B * P,
    Q = H * N + W * P,
    se = _e * N + te * P,
    B = oe * -P + B * N,
    W = H * -P + W * N,
    te = _e * -P + te * N,
    pe = fe * -P + pe * N,
    oe = q,
    H = Q,
    _e = se),
    I = vm(-K, te),
    b = I * Ld,
    I && (N = Math.cos(-I),
    P = Math.sin(-I),
    q = Y * N - B * P,
    Q = V * N - W * P,
    se = K * N - te * P,
    pe = Z * P + pe * N,
    Y = q,
    V = Q,
    K = se),
    I = vm(V, Y),
    T = I * Ld,
    I && (N = Math.cos(I),
    P = Math.sin(I),
    q = Y * N + V * P,
    Q = oe * N + H * P,
    V = V * N - Y * P,
    H = H * N - oe * P,
    Y = q,
    oe = Q),
    M && Math.abs(M) + Math.abs(T) > 359.9 && (M = T = 0,
    b = 180 - b),
    y = gr(Math.sqrt(Y * Y + V * V + K * K)),
    S = gr(Math.sqrt(H * H + _e * _e)),
    I = vm(oe, H),
    A = Math.abs(I) > 2e-4 ? I * Ld : 0,
    R = pe ? 1 / (pe < 0 ? -pe : pe) : 0),
    n.svg && (q = e.getAttribute("transform"),
    n.forceCSS = e.setAttribute("transform", "") || !wP(rl(e, $i)),
    q && e.setAttribute("transform", q))),
    Math.abs(A) > 90 && Math.abs(A) < 270 && (a ? (y *= -1,
    A += T <= 0 ? 180 : -180,
    T += T <= 0 ? 180 : -180) : (S *= -1,
    A += A <= 0 ? 180 : -180)),
    t = t || n.uncache,
    n.x = d - ((n.xPercent = d && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-d) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + s,
    n.y = g - ((n.yPercent = g && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-g) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + s,
    n.z = v + s,
    n.scaleX = gr(y),
    n.scaleY = gr(S),
    n.rotation = gr(T) + l,
    n.rotationX = gr(M) + l,
    n.rotationY = gr(b) + l,
    n.skewX = A + l,
    n.skewY = C + l,
    n.transformPerspective = R + s,
    (n.zOrigin = parseFloat(f.split(" ")[2]) || !t && n.zOrigin || 0) && (i[Ys] = XS(f)),
    n.xOffset = n.yOffset = 0,
    n.force3D = Mo.force3D,
    n.renderTransform = n.svg ? h9 : bP ? AP : f9,
    n.uncache = 0,
    n
}, XS = function(e) {
    return (e = e.split(" "))[0] + " " + e[1]
}, Q2 = function(e, t, n) {
    var i = Ba(t);
    return gr(parseFloat(t) + parseFloat(vh(e, "x", n + "px", i))) + i
}, f9 = function(e, t) {
    t.z = "0px",
    t.rotationY = t.rotationX = "0deg",
    t.force3D = 0,
    AP(e, t)
}, gd = "0deg", fv = "0px", vd = ") ", AP = function(e, t) {
    var n = t || this
      , i = n.xPercent
      , a = n.yPercent
      , s = n.x
      , l = n.y
      , u = n.z
      , f = n.rotation
      , d = n.rotationY
      , g = n.rotationX
      , v = n.skewX
      , y = n.skewY
      , S = n.scaleX
      , T = n.scaleY
      , M = n.transformPerspective
      , b = n.force3D
      , A = n.target
      , C = n.zOrigin
      , R = ""
      , O = b === "auto" && e && e !== 1 || b === !0;
    if (C && (g !== gd || d !== gd)) {
        var L = parseFloat(d) * lg, z = Math.sin(L), I = Math.cos(L), N;
        L = parseFloat(g) * lg,
        N = Math.cos(L),
        s = Q2(A, s, z * N * -C),
        l = Q2(A, l, -Math.sin(L) * -C),
        u = Q2(A, u, I * N * -C + C)
    }
    M !== fv && (R += "perspective(" + M + vd),
    (i || a) && (R += "translate(" + i + "%, " + a + "%) "),
    (O || s !== fv || l !== fv || u !== fv) && (R += u !== fv || O ? "translate3d(" + s + ", " + l + ", " + u + ") " : "translate(" + s + ", " + l + vd),
    f !== gd && (R += "rotate(" + f + vd),
    d !== gd && (R += "rotateY(" + d + vd),
    g !== gd && (R += "rotateX(" + g + vd),
    (v !== gd || y !== gd) && (R += "skew(" + v + ", " + y + vd),
    (S !== 1 || T !== 1) && (R += "scale(" + S + ", " + T + vd),
    A.style[$i] = R || "translate(0, 0)"
}, h9 = function(e, t) {
    var n = t || this, i = n.xPercent, a = n.yPercent, s = n.x, l = n.y, u = n.rotation, f = n.skewX, d = n.skewY, g = n.scaleX, v = n.scaleY, y = n.target, S = n.xOrigin, T = n.yOrigin, M = n.xOffset, b = n.yOffset, A = n.forceCSS, C = parseFloat(s), R = parseFloat(l), O, L, z, I, N;
    u = parseFloat(u),
    f = parseFloat(f),
    d = parseFloat(d),
    d && (d = parseFloat(d),
    f += d,
    u += d),
    u || f ? (u *= lg,
    f *= lg,
    O = Math.cos(u) * g,
    L = Math.sin(u) * g,
    z = Math.sin(u - f) * -v,
    I = Math.cos(u - f) * v,
    f && (d *= lg,
    N = Math.tan(f - d),
    N = Math.sqrt(1 + N * N),
    z *= N,
    I *= N,
    d && (N = Math.tan(d),
    N = Math.sqrt(1 + N * N),
    O *= N,
    L *= N)),
    O = gr(O),
    L = gr(L),
    z = gr(z),
    I = gr(I)) : (O = g,
    I = v,
    L = z = 0),
    (C && !~(s + "").indexOf("px") || R && !~(l + "").indexOf("px")) && (C = vh(y, "x", s, "px"),
    R = vh(y, "y", l, "px")),
    (S || T || M || b) && (C = gr(C + S - (S * O + T * z) + M),
    R = gr(R + T - (S * L + T * I) + b)),
    (i || a) && (N = y.getBBox(),
    C = gr(C + i / 100 * N.width),
    R = gr(R + a / 100 * N.height)),
    N = "matrix(" + O + "," + L + "," + z + "," + I + "," + C + "," + R + ")",
    y.setAttribute("transform", N),
    A && (y.style[$i] = N)
}, d9 = function(e, t, n, i, a) {
    var s = 360, l = na(a), u = parseFloat(a) * (l && ~a.indexOf("rad") ? Ld : 1), f = u - i, d = i + f + "deg", g, v;
    return l && (g = a.split("_")[1],
    g === "short" && (f %= s,
    f !== f % (s / 2) && (f += f < 0 ? s : -360)),
    g === "cw" && f < 0 ? f = (f + s * HD) % s - ~~(f / s) * s : g === "ccw" && f > 0 && (f = (f - s * HD) % s - ~~(f / s) * s)),
    e._pt = v = new Ws(e._pt,t,n,i,f,K7),
    v.e = d,
    v.u = "deg",
    e._props.push(n),
    v
}, YD = function(e, t) {
    for (var n in t)
        e[n] = t[n];
    return e
}, p9 = function(e, t, n) {
    var i = YD({}, n._gsap), a = "perspective,force3D,transformOrigin,svgOrigin", s = n.style, l, u, f, d, g, v, y, S;
    i.svg ? (f = n.getAttribute("transform"),
    n.setAttribute("transform", ""),
    s[$i] = t,
    l = Ly(n, 1),
    lp(n, $i),
    n.setAttribute("transform", f)) : (f = getComputedStyle(n)[$i],
    s[$i] = t,
    l = Ly(n, 1),
    s[$i] = f);
    for (u in ef)
        f = i[u],
        d = l[u],
        f !== d && a.indexOf(u) < 0 && (y = Ba(f),
        S = Ba(d),
        g = y !== S ? vh(n, u, f, S) : parseFloat(f),
        v = parseFloat(d),
        e._pt = new Ws(e._pt,l,u,g,v - g,ew),
        e._pt.u = S || 0,
        e._props.push(u));
    YD(l, i)
};
js("padding,margin,Width,Radius", function(r, e) {
    var t = "Top"
      , n = "Right"
      , i = "Bottom"
      , a = "Left"
      , s = (e < 3 ? [t, n, i, a] : [t + a, t + n, i + n, i + a]).map(function(l) {
        return e < 2 ? r + l : "border" + l + r
    });
    GS[e > 1 ? "border" + r : r] = function(l, u, f, d, g) {
        var v, y;
        if (arguments.length < 4)
            return v = s.map(function(S) {
                return Gc(l, S, f)
            }),
            y = v.join(" "),
            y.split(v[0]).length === 5 ? v[0] : y;
        v = (d + "").split(" "),
        y = {},
        s.forEach(function(S, T) {
            return y[S] = v[T] = v[T] || v[(T - 1) / 2 | 0]
        }),
        l.init(u, y, g)
    }
});
var CP = {
    name: "css",
    register: nw,
    targetTest: function(e) {
        return e.style && e.nodeType
    },
    init: function(e, t, n, i, a) {
        var s = this._props, l = e.style, u = n.vars.startAt, f, d, g, v, y, S, T, M, b, A, C, R, O, L, z, I;
        jA || nw(),
        this.styles = this.styles || SP(e),
        I = this.styles.props,
        this.tween = n;
        for (T in t)
            if (T !== "autoRound" && (d = t[T],
            !(vo[T] && cP(T, t, n, i, e, a)))) {
                if (y = typeof d,
                S = GS[T],
                y === "function" && (d = d.call(n, i, e, a),
                y = typeof d),
                y === "string" && ~d.indexOf("random(") && (d = Dy(d)),
                S)
                    S(this, e, T, d, n) && (z = 1);
                else if (T.substr(0, 2) === "--")
                    f = (getComputedStyle(e).getPropertyValue(T) + "").trim(),
                    d += "",
                    dh.lastIndex = 0,
                    dh.test(f) || (M = Ba(f),
                    b = Ba(d)),
                    b ? M !== b && (f = vh(e, T, f, b) + b) : M && (d += M),
                    this.add(l, "setProperty", f, d, i, a, 0, 0, T),
                    s.push(T),
                    I.push(T, 0, l[T]);
                else if (y !== "undefined") {
                    if (u && T in u ? (f = typeof u[T] == "function" ? u[T].call(n, i, e, a) : u[T],
                    na(f) && ~f.indexOf("random(") && (f = Dy(f)),
                    Ba(f + "") || f === "auto" || (f += Mo.units[T] || Ba(Gc(e, T)) || ""),
                    (f + "").charAt(1) === "=" && (f = Gc(e, T))) : f = Gc(e, T),
                    v = parseFloat(f),
                    A = y === "string" && d.charAt(1) === "=" && d.substr(0, 2),
                    A && (d = d.substr(2)),
                    g = parseFloat(d),
                    T in ku && (T === "autoAlpha" && (v === 1 && Gc(e, "visibility") === "hidden" && g && (v = 0),
                    I.push("visibility", 0, l.visibility),
                    oh(this, l, "visibility", v ? "inherit" : "hidden", g ? "inherit" : "hidden", !g)),
                    T !== "scale" && T !== "transform" && (T = ku[T],
                    ~T.indexOf(",") && (T = T.split(",")[0]))),
                    C = T in ef,
                    C) {
                        if (this.styles.save(T),
                        y === "string" && d.substring(0, 6) === "var(--" && (d = rl(e, d.substring(4, d.indexOf(")"))),
                        g = parseFloat(d)),
                        R || (O = e._gsap,
                        O.renderTransform && !t.parseTransform || Ly(e, t.parseTransform),
                        L = t.smoothOrigin !== !1 && O.smooth,
                        R = this._pt = new Ws(this._pt,l,$i,0,1,O.renderTransform,O,0,-1),
                        R.dep = 1),
                        T === "scale")
                            this._pt = new Ws(this._pt,O,"scaleY",O.scaleY,(A ? sg(O.scaleY, A + g) : g) - O.scaleY || 0,ew),
                            this._pt.u = 0,
                            s.push("scaleY", T),
                            T += "X";
                        else if (T === "transformOrigin") {
                            I.push(Ys, 0, l[Ys]),
                            d = u9(d),
                            O.svg ? iw(e, d, 0, L, 0, this) : (b = parseFloat(d.split(" ")[2]) || 0,
                            b !== O.zOrigin && oh(this, O, "zOrigin", O.zOrigin, b),
                            oh(this, l, T, XS(f), XS(d)));
                            continue
                        } else if (T === "svgOrigin") {
                            iw(e, d, 1, L, 0, this);
                            continue
                        } else if (T in EP) {
                            d9(this, O, T, v, A ? sg(v, A + d) : d);
                            continue
                        } else if (T === "smoothOrigin") {
                            oh(this, O, "smooth", O.smooth, d);
                            continue
                        } else if (T === "force3D") {
                            O[T] = d;
                            continue
                        } else if (T === "transform") {
                            p9(this, d, e);
                            continue
                        }
                    } else
                        T in l || (T = Sg(T) || T);
                    if (C || (g || g === 0) && (v || v === 0) && !Z7.test(d) && T in l)
                        M = (f + "").substr((v + "").length),
                        g || (g = 0),
                        b = Ba(d) || (T in Mo.units ? Mo.units[T] : M),
                        M !== b && (v = vh(e, T, f, b)),
                        this._pt = new Ws(this._pt,C ? O : l,T,v,(A ? sg(v, A + g) : g) - v,!C && (b === "px" || T === "zIndex") && t.autoRound !== !1 ? J7 : ew),
                        this._pt.u = b || 0,
                        M !== b && b !== "%" && (this._pt.b = f,
                        this._pt.r = Q7);
                    else if (T in l)
                        l9.call(this, e, T, f, A ? A + d : d);
                    else if (T in e)
                        this.add(e, T, f || e[T], A ? A + d : d, i, a);
                    else if (T !== "parseTransform") {
                        PA(T, d);
                        continue
                    }
                    C || (T in l ? I.push(T, 0, l[T]) : typeof e[T] == "function" ? I.push(T, 2, e[T]()) : I.push(T, 1, f || e[T])),
                    s.push(T)
                }
            }
        z && gP(this)
    },
    render: function(e, t) {
        if (t.tween._time || !WA())
            for (var n = t._pt; n; )
                n.r(e, n.d),
                n = n._next;
        else
            t.styles.revert()
    },
    get: Gc,
    aliases: ku,
    getSetter: function(e, t, n) {
        var i = ku[t];
        return i && i.indexOf(",") < 0 && (t = i),
        t in ef && t !== Ys && (e._gsap.x || Gc(e, "x")) ? n && FD === n ? t === "scale" ? n9 : t9 : (FD = n || {}) && (t === "scale" ? i9 : r9) : e.style && !OA(e.style[t]) ? $7 : ~t.indexOf("-") ? e9 : GA(e, t)
    },
    core: {
        _removeProperty: lp,
        _getMatrix: qA
    }
};
Zs.utils.checkPrefix = Sg;
Zs.core.getStyleSaver = SP;
(function(r, e, t, n) {
    var i = js(r + "," + e + "," + t, function(a) {
        ef[a] = 1
    });
    js(e, function(a) {
        Mo.units[a] = "deg",
        EP[a] = 1
    }),
    ku[i[13]] = r + "," + e,
    js(n, function(a) {
        var s = a.split(":");
        ku[s[1]] = i[s[0]]
    })
}
)("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
js("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(r) {
    Mo.units[r] = "px"
});
Zs.registerPlugin(CP);
var bg = Zs.registerPlugin(CP) || Zs;
bg.core.Tween;
const RP = ({children: r, onClick: e, bgColorVar: t="", textColorVar: n="--pb-text", extraStyling: i=""}) => ae.jsx("button", {
    className: ` appearance-none px-2 my-0 rounded-xl 
        bg-[var(${t}] 
        text-[var(${n}]
        text-md xl:text-lg 
        flex justify-center items-center 
        shadow ${i}`,
    type: "button",
    onClick: e,
    style: {
        backgroundColor: `var(${t})`,
        color: `var(${n})`
    },
    children: r
})
  , m9 = "/assets/GenZ2025(2)-C-GY567k.png";
var J2 = {
    exports: {}
}
  , Pc = {};
/**
 * @license React
 * react-reconciler-constants.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qD;
function g9() {
    return qD || (qD = 1,
    Pc.ConcurrentRoot = 1,
    Pc.ContinuousEventPriority = 8,
    Pc.DefaultEventPriority = 32,
    Pc.DiscreteEventPriority = 2,
    Pc.IdleEventPriority = 268435456,
    Pc.LegacyRoot = 0,
    Pc.NoEventPriority = 0),
    Pc
}
var ZD;
function v9() {
    return ZD || (ZD = 1,
    J2.exports = g9()),
    J2.exports
}
var yS = v9();
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const u_ = "180"
  , y9 = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
}
  , _9 = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
}
  , DP = 0
  , rw = 1
  , UP = 2
  , x9 = 3
  , OP = 0
  , rM = 1
  , Jv = 2
  , Wl = 3
  , tf = 0
  , vs = 1
  , tl = 2
  , Qu = 0
  , tp = 1
  , aw = 2
  , sw = 3
  , ow = 4
  , NP = 5
  , rh = 100
  , LP = 101
  , PP = 102
  , BP = 103
  , zP = 104
  , IP = 200
  , FP = 201
  , HP = 202
  , VP = 203
  , jS = 204
  , WS = 205
  , kP = 206
  , GP = 207
  , XP = 208
  , jP = 209
  , WP = 210
  , YP = 211
  , qP = 212
  , ZP = 213
  , KP = 214
  , YS = 0
  , qS = 1
  , ZS = 2
  , up = 3
  , KS = 4
  , QS = 5
  , JS = 6
  , $S = 7
  , c_ = 0
  , QP = 1
  , JP = 2
  , Ju = 0
  , $P = 1
  , eB = 2
  , tB = 3
  , ZA = 4
  , nB = 5
  , iB = 6
  , rB = 7
  , lw = "attached"
  , aB = "detached"
  , yh = 300
  , ic = 301
  , _h = 302
  , Mg = 303
  , Py = 304
  , Xg = 306
  , By = 1e3
  , Cr = 1001
  , zy = 1002
  , va = 1003
  , KA = 1004
  , S9 = 1004
  , tg = 1005
  , b9 = 1005
  , fi = 1006
  , $v = 1007
  , M9 = 1007
  , Gu = 1008
  , uw = 1008
  , ys = 1009
  , aM = 1010
  , sM = 1011
  , Tg = 1012
  , f_ = 1013
  , rc = 1014
  , tr = 1015
  , $r = 1016
  , oM = 1017
  , lM = 1018
  , Eg = 1020
  , QA = 35902
  , JA = 35899
  , $A = 1021
  , eC = 1022
  , vr = 1023
  , wg = 1026
  , Ag = 1027
  , h_ = 1028
  , d_ = 1029
  , tC = 1030
  , uM = 1031
  , T9 = 1032
  , cM = 1033
  , ey = 33776
  , ty = 33777
  , ny = 33778
  , iy = 33779
  , eb = 35840
  , tb = 35841
  , nb = 35842
  , ib = 35843
  , rb = 36196
  , ab = 37492
  , sb = 37496
  , ob = 37808
  , lb = 37809
  , ub = 37810
  , cb = 37811
  , fb = 37812
  , hb = 37813
  , db = 37814
  , pb = 37815
  , mb = 37816
  , gb = 37817
  , vb = 37818
  , yb = 37819
  , _b = 37820
  , xb = 37821
  , Sb = 36492
  , bb = 36494
  , Mb = 36495
  , Tb = 36283
  , Eb = 36284
  , wb = 36285
  , Ab = 36286
  , sB = 2200
  , oB = 2201
  , lB = 2202
  , Iy = 2300
  , Cb = 2301
  , _S = 2302
  , Gd = 2400
  , Xd = 2401
  , Fy = 2402
  , fM = 2500
  , nC = 2501
  , E9 = 0
  , w9 = 1
  , A9 = 2
  , uB = 3200
  , iC = 3201
  , C9 = 3202
  , R9 = 3203
  , Eh = 0
  , cB = 1
  , Xc = ""
  , pa = "srgb"
  , Jl = "srgb-linear"
  , Hy = "linear"
  , yi = "srgb"
  , D9 = 0
  , Pd = 7680
  , U9 = 7681
  , O9 = 7682
  , N9 = 7683
  , L9 = 34055
  , P9 = 34056
  , B9 = 5386
  , z9 = 512
  , I9 = 513
  , F9 = 514
  , H9 = 515
  , V9 = 516
  , k9 = 517
  , G9 = 518
  , cw = 519
  , fB = 512
  , hB = 513
  , dB = 514
  , rC = 515
  , pB = 516
  , mB = 517
  , gB = 518
  , vB = 519
  , Vy = 35044
  , X9 = 35048
  , j9 = 35040
  , W9 = 35045
  , Y9 = 35049
  , q9 = 35041
  , Z9 = 35046
  , K9 = 35050
  , Q9 = 35042
  , J9 = "100"
  , fw = "300 es"
  , bo = 2e3
  , Cg = 2001
  , $9 = {
    COMPUTE: "compute",
    RENDER: "render"
}
  , eX = {
    PERSPECTIVE: "perspective",
    LINEAR: "linear",
    FLAT: "flat"
}
  , tX = {
    NORMAL: "normal",
    CENTROID: "centroid",
    SAMPLE: "sample",
    FIRST: "first",
    EITHER: "either"
};
class sc {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const n = this._listeners;
        n[e] === void 0 && (n[e] = []),
        n[e].indexOf(t) === -1 && n[e].push(t)
    }
    hasEventListener(e, t) {
        const n = this._listeners;
        return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        const n = this._listeners;
        if (n === void 0)
            return;
        const i = n[e];
        if (i !== void 0) {
            const a = i.indexOf(t);
            a !== -1 && i.splice(a, 1)
        }
    }
    dispatchEvent(e) {
        const t = this._listeners;
        if (t === void 0)
            return;
        const n = t[e.type];
        if (n !== void 0) {
            e.target = this;
            const i = n.slice(0);
            for (let a = 0, s = i.length; a < s; a++)
                i[a].call(this, e);
            e.target = null
        }
    }
}
const Da = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let KD = 1234567;
const np = Math.PI / 180
  , Rg = 180 / Math.PI;
function To() {
    const r = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , n = Math.random() * 4294967295 | 0;
    return (Da[r & 255] + Da[r >> 8 & 255] + Da[r >> 16 & 255] + Da[r >> 24 & 255] + "-" + Da[e & 255] + Da[e >> 8 & 255] + "-" + Da[e >> 16 & 15 | 64] + Da[e >> 24 & 255] + "-" + Da[t & 63 | 128] + Da[t >> 8 & 255] + "-" + Da[t >> 16 & 255] + Da[t >> 24 & 255] + Da[n & 255] + Da[n >> 8 & 255] + Da[n >> 16 & 255] + Da[n >> 24 & 255]).toLowerCase()
}
function gn(r, e, t) {
    return Math.max(e, Math.min(t, r))
}
function aC(r, e) {
    return (r % e + e) % e
}
function nX(r, e, t, n, i) {
    return n + (r - e) * (i - n) / (t - e)
}
function iX(r, e, t) {
    return r !== e ? (t - r) / (e - r) : 0
}
function ry(r, e, t) {
    return (1 - t) * r + t * e
}
function rX(r, e, t, n) {
    return ry(r, e, 1 - Math.exp(-t * n))
}
function aX(r, e=1) {
    return e - Math.abs(aC(r, e * 2) - e)
}
function sX(r, e, t) {
    return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e),
    r * r * (3 - 2 * r))
}
function oX(r, e, t) {
    return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e),
    r * r * r * (r * (r * 6 - 15) + 10))
}
function lX(r, e) {
    return r + Math.floor(Math.random() * (e - r + 1))
}
function uX(r, e) {
    return r + Math.random() * (e - r)
}
function cX(r) {
    return r * (.5 - Math.random())
}
function fX(r) {
    r !== void 0 && (KD = r);
    let e = KD += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1),
    e ^= e + Math.imul(e ^ e >>> 7, e | 61),
    ((e ^ e >>> 14) >>> 0) / 4294967296
}
function hX(r) {
    return r * np
}
function dX(r) {
    return r * Rg
}
function pX(r) {
    return (r & r - 1) === 0 && r !== 0
}
function mX(r) {
    return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2))
}
function gX(r) {
    return Math.pow(2, Math.floor(Math.log(r) / Math.LN2))
}
function vX(r, e, t, n, i) {
    const a = Math.cos
      , s = Math.sin
      , l = a(t / 2)
      , u = s(t / 2)
      , f = a((e + n) / 2)
      , d = s((e + n) / 2)
      , g = a((e - n) / 2)
      , v = s((e - n) / 2)
      , y = a((n - e) / 2)
      , S = s((n - e) / 2);
    switch (i) {
    case "XYX":
        r.set(l * d, u * g, u * v, l * f);
        break;
    case "YZY":
        r.set(u * v, l * d, u * g, l * f);
        break;
    case "ZXZ":
        r.set(u * g, u * v, l * d, l * f);
        break;
    case "XZX":
        r.set(l * d, u * S, u * y, l * f);
        break;
    case "YXY":
        r.set(u * y, l * d, u * S, l * f);
        break;
    case "ZYZ":
        r.set(u * S, u * y, l * d, l * f);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
    }
}
function ps(r, e) {
    switch (e.constructor) {
    case Float32Array:
        return r;
    case Uint32Array:
        return r / 4294967295;
    case Uint16Array:
        return r / 65535;
    case Uint8Array:
        return r / 255;
    case Int32Array:
        return Math.max(r / 2147483647, -1);
    case Int16Array:
        return Math.max(r / 32767, -1);
    case Int8Array:
        return Math.max(r / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function On(r, e) {
    switch (e.constructor) {
    case Float32Array:
        return r;
    case Uint32Array:
        return Math.round(r * 4294967295);
    case Uint16Array:
        return Math.round(r * 65535);
    case Uint8Array:
        return Math.round(r * 255);
    case Int32Array:
        return Math.round(r * 2147483647);
    case Int16Array:
        return Math.round(r * 32767);
    case Int8Array:
        return Math.round(r * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
const yB = {
    DEG2RAD: np,
    RAD2DEG: Rg,
    generateUUID: To,
    clamp: gn,
    euclideanModulo: aC,
    mapLinear: nX,
    inverseLerp: iX,
    lerp: ry,
    damp: rX,
    pingpong: aX,
    smoothstep: sX,
    smootherstep: oX,
    randInt: lX,
    randFloat: uX,
    randFloatSpread: cX,
    seededRandom: fX,
    degToRad: hX,
    radToDeg: dX,
    isPowerOfTwo: pX,
    ceilPowerOfTwo: mX,
    floorPowerOfTwo: gX,
    setQuaternionFromProperEuler: vX,
    normalize: On,
    denormalize: ps
};
class xt {
    constructor(e=0, t=0) {
        xt.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , n = this.y
          , i = e.elements;
        return this.x = i[0] * t + i[3] * n + i[6],
        this.y = i[1] * t + i[4] * n + i[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = gn(this.x, e.x, t.x),
        this.y = gn(this.y, e.y, t.y),
        this
    }
    clampScalar(e, t) {
        return this.x = gn(this.x, e, t),
        this.y = gn(this.y, e, t),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(gn(n, e, t))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(gn(n, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , n = this.y - e.y;
        return t * t + n * n
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const n = Math.cos(t)
          , i = Math.sin(t)
          , a = this.x - e.x
          , s = this.y - e.y;
        return this.x = a * n - s * i + e.x,
        this.y = a * i + s * n + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class qs {
    constructor(e=0, t=0, n=0, i=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = n,
        this._w = i
    }
    static slerpFlat(e, t, n, i, a, s, l) {
        let u = n[i + 0]
          , f = n[i + 1]
          , d = n[i + 2]
          , g = n[i + 3];
        const v = a[s + 0]
          , y = a[s + 1]
          , S = a[s + 2]
          , T = a[s + 3];
        if (l === 0) {
            e[t + 0] = u,
            e[t + 1] = f,
            e[t + 2] = d,
            e[t + 3] = g;
            return
        }
        if (l === 1) {
            e[t + 0] = v,
            e[t + 1] = y,
            e[t + 2] = S,
            e[t + 3] = T;
            return
        }
        if (g !== T || u !== v || f !== y || d !== S) {
            let M = 1 - l;
            const b = u * v + f * y + d * S + g * T
              , A = b >= 0 ? 1 : -1
              , C = 1 - b * b;
            if (C > Number.EPSILON) {
                const O = Math.sqrt(C)
                  , L = Math.atan2(O, b * A);
                M = Math.sin(M * L) / O,
                l = Math.sin(l * L) / O
            }
            const R = l * A;
            if (u = u * M + v * R,
            f = f * M + y * R,
            d = d * M + S * R,
            g = g * M + T * R,
            M === 1 - l) {
                const O = 1 / Math.sqrt(u * u + f * f + d * d + g * g);
                u *= O,
                f *= O,
                d *= O,
                g *= O
            }
        }
        e[t] = u,
        e[t + 1] = f,
        e[t + 2] = d,
        e[t + 3] = g
    }
    static multiplyQuaternionsFlat(e, t, n, i, a, s) {
        const l = n[i]
          , u = n[i + 1]
          , f = n[i + 2]
          , d = n[i + 3]
          , g = a[s]
          , v = a[s + 1]
          , y = a[s + 2]
          , S = a[s + 3];
        return e[t] = l * S + d * g + u * y - f * v,
        e[t + 1] = u * S + d * v + f * g - l * y,
        e[t + 2] = f * S + d * y + l * v - u * g,
        e[t + 3] = d * S - l * g - u * v - f * y,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, n, i) {
        return this._x = e,
        this._y = t,
        this._z = n,
        this._w = i,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t=!0) {
        const n = e._x
          , i = e._y
          , a = e._z
          , s = e._order
          , l = Math.cos
          , u = Math.sin
          , f = l(n / 2)
          , d = l(i / 2)
          , g = l(a / 2)
          , v = u(n / 2)
          , y = u(i / 2)
          , S = u(a / 2);
        switch (s) {
        case "XYZ":
            this._x = v * d * g + f * y * S,
            this._y = f * y * g - v * d * S,
            this._z = f * d * S + v * y * g,
            this._w = f * d * g - v * y * S;
            break;
        case "YXZ":
            this._x = v * d * g + f * y * S,
            this._y = f * y * g - v * d * S,
            this._z = f * d * S - v * y * g,
            this._w = f * d * g + v * y * S;
            break;
        case "ZXY":
            this._x = v * d * g - f * y * S,
            this._y = f * y * g + v * d * S,
            this._z = f * d * S + v * y * g,
            this._w = f * d * g - v * y * S;
            break;
        case "ZYX":
            this._x = v * d * g - f * y * S,
            this._y = f * y * g + v * d * S,
            this._z = f * d * S - v * y * g,
            this._w = f * d * g + v * y * S;
            break;
        case "YZX":
            this._x = v * d * g + f * y * S,
            this._y = f * y * g + v * d * S,
            this._z = f * d * S - v * y * g,
            this._w = f * d * g - v * y * S;
            break;
        case "XZY":
            this._x = v * d * g - f * y * S,
            this._y = f * y * g - v * d * S,
            this._z = f * d * S + v * y * g,
            this._w = f * d * g + v * y * S;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
        }
        return t === !0 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const n = t / 2
          , i = Math.sin(n);
        return this._x = e.x * i,
        this._y = e.y * i,
        this._z = e.z * i,
        this._w = Math.cos(n),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , n = t[0]
          , i = t[4]
          , a = t[8]
          , s = t[1]
          , l = t[5]
          , u = t[9]
          , f = t[2]
          , d = t[6]
          , g = t[10]
          , v = n + l + g;
        if (v > 0) {
            const y = .5 / Math.sqrt(v + 1);
            this._w = .25 / y,
            this._x = (d - u) * y,
            this._y = (a - f) * y,
            this._z = (s - i) * y
        } else if (n > l && n > g) {
            const y = 2 * Math.sqrt(1 + n - l - g);
            this._w = (d - u) / y,
            this._x = .25 * y,
            this._y = (i + s) / y,
            this._z = (a + f) / y
        } else if (l > g) {
            const y = 2 * Math.sqrt(1 + l - n - g);
            this._w = (a - f) / y,
            this._x = (i + s) / y,
            this._y = .25 * y,
            this._z = (u + d) / y
        } else {
            const y = 2 * Math.sqrt(1 + g - n - l);
            this._w = (s - i) / y,
            this._x = (a + f) / y,
            this._y = (u + d) / y,
            this._z = .25 * y
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let n = e.dot(t) + 1;
        return n < 1e-8 ? (n = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = n) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = n),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(gn(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const n = this.angleTo(e);
        if (n === 0)
            return this;
        const i = Math.min(1, t / n);
        return this.slerp(e, i),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const n = e._x
          , i = e._y
          , a = e._z
          , s = e._w
          , l = t._x
          , u = t._y
          , f = t._z
          , d = t._w;
        return this._x = n * d + s * l + i * f - a * u,
        this._y = i * d + s * u + a * l - n * f,
        this._z = a * d + s * f + n * u - i * l,
        this._w = s * d - n * l - i * u - a * f,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const n = this._x
          , i = this._y
          , a = this._z
          , s = this._w;
        let l = s * e._w + n * e._x + i * e._y + a * e._z;
        if (l < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        l = -l) : this.copy(e),
        l >= 1)
            return this._w = s,
            this._x = n,
            this._y = i,
            this._z = a,
            this;
        const u = 1 - l * l;
        if (u <= Number.EPSILON) {
            const y = 1 - t;
            return this._w = y * s + t * this._w,
            this._x = y * n + t * this._x,
            this._y = y * i + t * this._y,
            this._z = y * a + t * this._z,
            this.normalize(),
            this
        }
        const f = Math.sqrt(u)
          , d = Math.atan2(f, l)
          , g = Math.sin((1 - t) * d) / f
          , v = Math.sin(t * d) / f;
        return this._w = s * g + this._w * v,
        this._x = n * g + this._x * v,
        this._y = i * g + this._y * v,
        this._z = a * g + this._z * v,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, n) {
        return this.copy(e).slerp(t, n)
    }
    random() {
        const e = 2 * Math.PI * Math.random()
          , t = 2 * Math.PI * Math.random()
          , n = Math.random()
          , i = Math.sqrt(1 - n)
          , a = Math.sqrt(n);
        return this.set(i * Math.sin(e), i * Math.cos(e), a * Math.sin(t), a * Math.cos(t))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this._onChangeCallback(),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class he {
    constructor(e=0, t=0, n=0) {
        he.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = n
    }
    set(e, t, n) {
        return n === void 0 && (n = this.z),
        this.x = e,
        this.y = t,
        this.z = n,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(QD.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(QD.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , a = e.elements;
        return this.x = a[0] * t + a[3] * n + a[6] * i,
        this.y = a[1] * t + a[4] * n + a[7] * i,
        this.z = a[2] * t + a[5] * n + a[8] * i,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , a = e.elements
          , s = 1 / (a[3] * t + a[7] * n + a[11] * i + a[15]);
        return this.x = (a[0] * t + a[4] * n + a[8] * i + a[12]) * s,
        this.y = (a[1] * t + a[5] * n + a[9] * i + a[13]) * s,
        this.z = (a[2] * t + a[6] * n + a[10] * i + a[14]) * s,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , a = e.x
          , s = e.y
          , l = e.z
          , u = e.w
          , f = 2 * (s * i - l * n)
          , d = 2 * (l * t - a * i)
          , g = 2 * (a * n - s * t);
        return this.x = t + u * f + s * g - l * d,
        this.y = n + u * d + l * f - a * g,
        this.z = i + u * g + a * d - s * f,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , a = e.elements;
        return this.x = a[0] * t + a[4] * n + a[8] * i,
        this.y = a[1] * t + a[5] * n + a[9] * i,
        this.z = a[2] * t + a[6] * n + a[10] * i,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = gn(this.x, e.x, t.x),
        this.y = gn(this.y, e.y, t.y),
        this.z = gn(this.z, e.z, t.z),
        this
    }
    clampScalar(e, t) {
        return this.x = gn(this.x, e, t),
        this.y = gn(this.y, e, t),
        this.z = gn(this.z, e, t),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(gn(n, e, t))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this.z = e.z + (t.z - e.z) * n,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const n = e.x
          , i = e.y
          , a = e.z
          , s = t.x
          , l = t.y
          , u = t.z;
        return this.x = i * u - a * l,
        this.y = a * s - n * u,
        this.z = n * l - i * s,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const n = e.dot(this) / t;
        return this.copy(e).multiplyScalar(n)
    }
    projectOnPlane(e) {
        return $2.copy(this).projectOnVector(e),
        this.sub($2)
    }
    reflect(e) {
        return this.sub($2.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(gn(n, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , n = this.y - e.y
          , i = this.z - e.z;
        return t * t + n * n + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, n) {
        const i = Math.sin(t) * e;
        return this.x = i * Math.sin(n),
        this.y = Math.cos(t) * e,
        this.z = i * Math.cos(n),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, n) {
        return this.x = e * Math.sin(t),
        this.y = n,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , n = this.setFromMatrixColumn(e, 1).length()
          , i = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = n,
        this.z = i,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = Math.random() * Math.PI * 2
          , t = Math.random() * 2 - 1
          , n = Math.sqrt(1 - t * t);
        return this.x = n * Math.cos(e),
        this.y = t,
        this.z = n * Math.sin(e),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const $2 = new he
  , QD = new qs;
class An {
    constructor(e, t, n, i, a, s, l, u, f) {
        An.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, n, i, a, s, l, u, f)
    }
    set(e, t, n, i, a, s, l, u, f) {
        const d = this.elements;
        return d[0] = e,
        d[1] = i,
        d[2] = l,
        d[3] = t,
        d[4] = a,
        d[5] = u,
        d[6] = n,
        d[7] = s,
        d[8] = f,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , n = e.elements;
        return t[0] = n[0],
        t[1] = n[1],
        t[2] = n[2],
        t[3] = n[3],
        t[4] = n[4],
        t[5] = n[5],
        t[6] = n[6],
        t[7] = n[7],
        t[8] = n[8],
        this
    }
    extractBasis(e, t, n) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        n.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const n = e.elements
          , i = t.elements
          , a = this.elements
          , s = n[0]
          , l = n[3]
          , u = n[6]
          , f = n[1]
          , d = n[4]
          , g = n[7]
          , v = n[2]
          , y = n[5]
          , S = n[8]
          , T = i[0]
          , M = i[3]
          , b = i[6]
          , A = i[1]
          , C = i[4]
          , R = i[7]
          , O = i[2]
          , L = i[5]
          , z = i[8];
        return a[0] = s * T + l * A + u * O,
        a[3] = s * M + l * C + u * L,
        a[6] = s * b + l * R + u * z,
        a[1] = f * T + d * A + g * O,
        a[4] = f * M + d * C + g * L,
        a[7] = f * b + d * R + g * z,
        a[2] = v * T + y * A + S * O,
        a[5] = v * M + y * C + S * L,
        a[8] = v * b + y * R + S * z,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , i = e[2]
          , a = e[3]
          , s = e[4]
          , l = e[5]
          , u = e[6]
          , f = e[7]
          , d = e[8];
        return t * s * d - t * l * f - n * a * d + n * l * u + i * a * f - i * s * u
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , i = e[2]
          , a = e[3]
          , s = e[4]
          , l = e[5]
          , u = e[6]
          , f = e[7]
          , d = e[8]
          , g = d * s - l * f
          , v = l * u - d * a
          , y = f * a - s * u
          , S = t * g + n * v + i * y;
        if (S === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const T = 1 / S;
        return e[0] = g * T,
        e[1] = (i * f - d * n) * T,
        e[2] = (l * n - i * s) * T,
        e[3] = v * T,
        e[4] = (d * t - i * u) * T,
        e[5] = (i * a - l * t) * T,
        e[6] = y * T,
        e[7] = (n * u - f * t) * T,
        e[8] = (s * t - n * a) * T,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, n, i, a, s, l) {
        const u = Math.cos(a)
          , f = Math.sin(a);
        return this.set(n * u, n * f, -n * (u * s + f * l) + s + e, -i * f, i * u, -i * (-f * s + u * l) + l + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(eT.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(eT.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(eT.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, -n, 0, n, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , n = e.elements;
        for (let i = 0; i < 9; i++)
            if (t[i] !== n[i])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let n = 0; n < 9; n++)
            this.elements[n] = e[n + t];
        return this
    }
    toArray(e=[], t=0) {
        const n = this.elements;
        return e[t] = n[0],
        e[t + 1] = n[1],
        e[t + 2] = n[2],
        e[t + 3] = n[3],
        e[t + 4] = n[4],
        e[t + 5] = n[5],
        e[t + 6] = n[6],
        e[t + 7] = n[7],
        e[t + 8] = n[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const eT = new An;
function _B(r) {
    for (let e = r.length - 1; e >= 0; --e)
        if (r[e] >= 65535)
            return !0;
    return !1
}
const yX = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
};
function ng(r, e) {
    return new yX[r](e)
}
function ky(r) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", r)
}
function xB() {
    const r = ky("canvas");
    return r.style.display = "block",
    r
}
const JD = {};
function Gy(r) {
    r in JD || (JD[r] = !0,
    console.warn(r))
}
function _X(r, e, t) {
    return new Promise(function(n, i) {
        function a() {
            switch (r.clientWaitSync(e, r.SYNC_FLUSH_COMMANDS_BIT, 0)) {
            case r.WAIT_FAILED:
                i();
                break;
            case r.TIMEOUT_EXPIRED:
                setTimeout(a, t);
                break;
            default:
                n()
            }
        }
        setTimeout(a, t)
    }
    )
}
const $D = new An().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322)
  , eU = new An().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
function xX() {
    const r = {
        enabled: !0,
        workingColorSpace: Jl,
        spaces: {},
        convert: function(i, a, s) {
            return this.enabled === !1 || a === s || !a || !s || (this.spaces[a].transfer === yi && (i.r = Zc(i.r),
            i.g = Zc(i.g),
            i.b = Zc(i.b)),
            this.spaces[a].primaries !== this.spaces[s].primaries && (i.applyMatrix3(this.spaces[a].toXYZ),
            i.applyMatrix3(this.spaces[s].fromXYZ)),
            this.spaces[s].transfer === yi && (i.r = ug(i.r),
            i.g = ug(i.g),
            i.b = ug(i.b))),
            i
        },
        workingToColorSpace: function(i, a) {
            return this.convert(i, this.workingColorSpace, a)
        },
        colorSpaceToWorking: function(i, a) {
            return this.convert(i, a, this.workingColorSpace)
        },
        getPrimaries: function(i) {
            return this.spaces[i].primaries
        },
        getTransfer: function(i) {
            return i === Xc ? Hy : this.spaces[i].transfer
        },
        getToneMappingMode: function(i) {
            return this.spaces[i].outputColorSpaceConfig.toneMappingMode || "standard"
        },
        getLuminanceCoefficients: function(i, a=this.workingColorSpace) {
            return i.fromArray(this.spaces[a].luminanceCoefficients)
        },
        define: function(i) {
            Object.assign(this.spaces, i)
        },
        _getMatrix: function(i, a, s) {
            return i.copy(this.spaces[a].toXYZ).multiply(this.spaces[s].fromXYZ)
        },
        _getDrawingBufferColorSpace: function(i) {
            return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace
        },
        _getUnpackColorSpace: function(i=this.workingColorSpace) {
            return this.spaces[i].workingColorSpaceConfig.unpackColorSpace
        },
        fromWorkingColorSpace: function(i, a) {
            return Gy("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),
            r.workingToColorSpace(i, a)
        },
        toWorkingColorSpace: function(i, a) {
            return Gy("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),
            r.colorSpaceToWorking(i, a)
        }
    }
      , e = [.64, .33, .3, .6, .15, .06]
      , t = [.2126, .7152, .0722]
      , n = [.3127, .329];
    return r.define({
        [Jl]: {
            primaries: e,
            whitePoint: n,
            transfer: Hy,
            toXYZ: $D,
            fromXYZ: eU,
            luminanceCoefficients: t,
            workingColorSpaceConfig: {
                unpackColorSpace: pa
            },
            outputColorSpaceConfig: {
                drawingBufferColorSpace: pa
            }
        },
        [pa]: {
            primaries: e,
            whitePoint: n,
            transfer: yi,
            toXYZ: $D,
            fromXYZ: eU,
            luminanceCoefficients: t,
            outputColorSpaceConfig: {
                drawingBufferColorSpace: pa
            }
        }
    }),
    r
}
const Kn = xX();
function Zc(r) {
    return r < .04045 ? r * .0773993808 : Math.pow(r * .9478672986 + .0521327014, 2.4)
}
function ug(r) {
    return r < .0031308 ? r * 12.92 : 1.055 * Math.pow(r, .41666) - .055
}
let ym;
class SB {
    static getDataURL(e, t="image/png") {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let n;
        if (e instanceof HTMLCanvasElement)
            n = e;
        else {
            ym === void 0 && (ym = ky("canvas")),
            ym.width = e.width,
            ym.height = e.height;
            const i = ym.getContext("2d");
            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height),
            n = ym
        }
        return n.toDataURL(t)
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = ky("canvas");
            t.width = e.width,
            t.height = e.height;
            const n = t.getContext("2d");
            n.drawImage(e, 0, 0, e.width, e.height);
            const i = n.getImageData(0, 0, e.width, e.height)
              , a = i.data;
            for (let s = 0; s < a.length; s++)
                a[s] = Zc(a[s] / 255) * 255;
            return n.putImageData(i, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let n = 0; n < t.length; n++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Zc(t[n] / 255) * 255) : t[n] = Zc(t[n]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
let SX = 0;
class lh {
    constructor(e=null) {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: SX++
        }),
        this.uuid = To(),
        this.data = e,
        this.dataReady = !0,
        this.version = 0
    }
    getSize(e) {
        const t = this.data;
        return typeof HTMLVideoElement < "u" && t instanceof HTMLVideoElement ? e.set(t.videoWidth, t.videoHeight, 0) : t instanceof VideoFrame ? e.set(t.displayHeight, t.displayWidth, 0) : t !== null ? e.set(t.width, t.height, t.depth || 0) : e.set(0, 0, 0),
        e
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const n = {
            uuid: this.uuid,
            url: ""
        }
          , i = this.data;
        if (i !== null) {
            let a;
            if (Array.isArray(i)) {
                a = [];
                for (let s = 0, l = i.length; s < l; s++)
                    i[s].isDataTexture ? a.push(tT(i[s].image)) : a.push(tT(i[s]))
            } else
                a = tT(i);
            n.url = a
        }
        return t || (e.images[this.uuid] = n),
        n
    }
}
function tT(r) {
    return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? SB.getDataURL(r) : r.data ? {
        data: Array.from(r.data),
        width: r.width,
        height: r.height,
        type: r.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let bX = 0;
const nT = new he;
class _i extends sc {
    constructor(e=_i.DEFAULT_IMAGE, t=_i.DEFAULT_MAPPING, n=Cr, i=Cr, a=fi, s=Gu, l=vr, u=ys, f=_i.DEFAULT_ANISOTROPY, d=Xc) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: bX++
        }),
        this.uuid = To(),
        this.name = "",
        this.source = new lh(e),
        this.mipmaps = [],
        this.mapping = t,
        this.channel = 0,
        this.wrapS = n,
        this.wrapT = i,
        this.magFilter = a,
        this.minFilter = s,
        this.anisotropy = f,
        this.format = l,
        this.internalFormat = null,
        this.type = u,
        this.offset = new xt(0,0),
        this.repeat = new xt(1,1),
        this.center = new xt(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new An,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.colorSpace = d,
        this.userData = {},
        this.updateRanges = [],
        this.version = 0,
        this.onUpdate = null,
        this.renderTarget = null,
        this.isRenderTargetTexture = !1,
        this.isArrayTexture = !!(e && e.depth && e.depth > 1),
        this.pmremVersion = 0
    }
    get width() {
        return this.source.getSize(nT).x
    }
    get height() {
        return this.source.getSize(nT).y
    }
    get depth() {
        return this.source.getSize(nT).z
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.renderTarget = e.renderTarget,
        this.isRenderTargetTexture = e.isRenderTargetTexture,
        this.isArrayTexture = e.isArrayTexture,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    setValues(e) {
        for (const t in e) {
            const n = e[t];
            if (n === void 0) {
                console.warn(`THREE.Texture.setValues(): parameter '${t}' has value of undefined.`);
                continue
            }
            const i = this[t];
            if (i === void 0) {
                console.warn(`THREE.Texture.setValues(): property '${t}' does not exist.`);
                continue
            }
            i && n && i.isVector2 && n.isVector2 || i && n && i.isVector3 && n.isVector3 || i && n && i.isMatrix3 && n.isMatrix3 ? i.copy(n) : this[t] = n
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const n = {
            metadata: {
                version: 4.7,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (n.userData = this.userData),
        t || (e.textures[this.uuid] = n),
        n
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== yh)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case By:
                e.x = e.x - Math.floor(e.x);
                break;
            case Cr:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case zy:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case By:
                e.y = e.y - Math.floor(e.y);
                break;
            case Cr:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case zy:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
    set needsPMREMUpdate(e) {
        e === !0 && this.pmremVersion++
    }
}
_i.DEFAULT_IMAGE = null;
_i.DEFAULT_MAPPING = yh;
_i.DEFAULT_ANISOTROPY = 1;
class Qn {
    constructor(e=0, t=0, n=0, i=1) {
        Qn.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = n,
        this.w = i
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, n, i) {
        return this.x = e,
        this.y = t,
        this.z = n,
        this.w = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , a = this.w
          , s = e.elements;
        return this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * a,
        this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * a,
        this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * a,
        this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * a,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this.w /= e.w,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, n, i, a;
        const u = e.elements
          , f = u[0]
          , d = u[4]
          , g = u[8]
          , v = u[1]
          , y = u[5]
          , S = u[9]
          , T = u[2]
          , M = u[6]
          , b = u[10];
        if (Math.abs(d - v) < .01 && Math.abs(g - T) < .01 && Math.abs(S - M) < .01) {
            if (Math.abs(d + v) < .1 && Math.abs(g + T) < .1 && Math.abs(S + M) < .1 && Math.abs(f + y + b - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const C = (f + 1) / 2
              , R = (y + 1) / 2
              , O = (b + 1) / 2
              , L = (d + v) / 4
              , z = (g + T) / 4
              , I = (S + M) / 4;
            return C > R && C > O ? C < .01 ? (n = 0,
            i = .707106781,
            a = .707106781) : (n = Math.sqrt(C),
            i = L / n,
            a = z / n) : R > O ? R < .01 ? (n = .707106781,
            i = 0,
            a = .707106781) : (i = Math.sqrt(R),
            n = L / i,
            a = I / i) : O < .01 ? (n = .707106781,
            i = .707106781,
            a = 0) : (a = Math.sqrt(O),
            n = z / a,
            i = I / a),
            this.set(n, i, a, t),
            this
        }
        let A = Math.sqrt((M - S) * (M - S) + (g - T) * (g - T) + (v - d) * (v - d));
        return Math.abs(A) < .001 && (A = 1),
        this.x = (M - S) / A,
        this.y = (g - T) / A,
        this.z = (v - d) / A,
        this.w = Math.acos((f + y + b - 1) / 2),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this.w = t[15],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = gn(this.x, e.x, t.x),
        this.y = gn(this.y, e.y, t.y),
        this.z = gn(this.z, e.z, t.z),
        this.w = gn(this.w, e.w, t.w),
        this
    }
    clampScalar(e, t) {
        return this.x = gn(this.x, e, t),
        this.y = gn(this.y, e, t),
        this.z = gn(this.z, e, t),
        this.w = gn(this.w, e, t),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(gn(n, e, t))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this.w = Math.trunc(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this.z = e.z + (t.z - e.z) * n,
        this.w = e.w + (t.w - e.w) * n,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class sC extends sc {
    constructor(e=1, t=1, n={}) {
        super(),
        n = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: fi,
            depthBuffer: !0,
            stencilBuffer: !1,
            resolveDepthBuffer: !0,
            resolveStencilBuffer: !0,
            depthTexture: null,
            samples: 0,
            count: 1,
            depth: 1,
            multiview: !1
        }, n),
        this.isRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = n.depth,
        this.scissor = new Qn(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new Qn(0,0,e,t);
        const i = {
            width: e,
            height: t,
            depth: n.depth
        }
          , a = new _i(i);
        this.textures = [];
        const s = n.count;
        for (let l = 0; l < s; l++)
            this.textures[l] = a.clone(),
            this.textures[l].isRenderTargetTexture = !0,
            this.textures[l].renderTarget = this;
        this._setTextureOptions(n),
        this.depthBuffer = n.depthBuffer,
        this.stencilBuffer = n.stencilBuffer,
        this.resolveDepthBuffer = n.resolveDepthBuffer,
        this.resolveStencilBuffer = n.resolveStencilBuffer,
        this._depthTexture = null,
        this.depthTexture = n.depthTexture,
        this.samples = n.samples,
        this.multiview = n.multiview
    }
    _setTextureOptions(e={}) {
        const t = {
            minFilter: fi,
            generateMipmaps: !1,
            flipY: !1,
            internalFormat: null
        };
        e.mapping !== void 0 && (t.mapping = e.mapping),
        e.wrapS !== void 0 && (t.wrapS = e.wrapS),
        e.wrapT !== void 0 && (t.wrapT = e.wrapT),
        e.wrapR !== void 0 && (t.wrapR = e.wrapR),
        e.magFilter !== void 0 && (t.magFilter = e.magFilter),
        e.minFilter !== void 0 && (t.minFilter = e.minFilter),
        e.format !== void 0 && (t.format = e.format),
        e.type !== void 0 && (t.type = e.type),
        e.anisotropy !== void 0 && (t.anisotropy = e.anisotropy),
        e.colorSpace !== void 0 && (t.colorSpace = e.colorSpace),
        e.flipY !== void 0 && (t.flipY = e.flipY),
        e.generateMipmaps !== void 0 && (t.generateMipmaps = e.generateMipmaps),
        e.internalFormat !== void 0 && (t.internalFormat = e.internalFormat);
        for (let n = 0; n < this.textures.length; n++)
            this.textures[n].setValues(t)
    }
    get texture() {
        return this.textures[0]
    }
    set texture(e) {
        this.textures[0] = e
    }
    set depthTexture(e) {
        this._depthTexture !== null && (this._depthTexture.renderTarget = null),
        e !== null && (e.renderTarget = this),
        this._depthTexture = e
    }
    get depthTexture() {
        return this._depthTexture
    }
    setSize(e, t, n=1) {
        if (this.width !== e || this.height !== t || this.depth !== n) {
            this.width = e,
            this.height = t,
            this.depth = n;
            for (let i = 0, a = this.textures.length; i < a; i++)
                this.textures[i].image.width = e,
                this.textures[i].image.height = t,
                this.textures[i].image.depth = n,
                this.textures[i].isArrayTexture = this.textures[i].image.depth > 1;
            this.dispose()
        }
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.textures.length = 0;
        for (let t = 0, n = e.textures.length; t < n; t++) {
            this.textures[t] = e.textures[t].clone(),
            this.textures[t].isRenderTargetTexture = !0,
            this.textures[t].renderTarget = this;
            const i = Object.assign({}, e.textures[t].image);
            this.textures[t].source = new lh(i)
        }
        return this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        this.resolveDepthBuffer = e.resolveDepthBuffer,
        this.resolveStencilBuffer = e.resolveStencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class sl extends sC {
    constructor(e=1, t=1, n={}) {
        super(e, t, n),
        this.isWebGLRenderTarget = !0
    }
}
class hM extends _i {
    constructor(e=null, t=1, n=1, i=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n,
            depth: i
        },
        this.magFilter = va,
        this.minFilter = va,
        this.wrapR = Cr,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1,
        this.layerUpdates = new Set
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class MX extends sl {
    constructor(e=1, t=1, n=1, i={}) {
        super(e, t, i),
        this.isWebGLArrayRenderTarget = !0,
        this.depth = n,
        this.texture = new hM(null,e,t,n),
        this._setTextureOptions(i),
        this.texture.isRenderTargetTexture = !0
    }
}
class dM extends _i {
    constructor(e=null, t=1, n=1, i=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n,
            depth: i
        },
        this.magFilter = va,
        this.minFilter = va,
        this.wrapR = Cr,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class TX extends sl {
    constructor(e=1, t=1, n=1, i={}) {
        super(e, t, i),
        this.isWebGL3DRenderTarget = !0,
        this.depth = n,
        this.texture = new dM(null,e,t,n),
        this._setTextureOptions(i),
        this.texture.isRenderTargetTexture = !0
    }
}
class ea {
    constructor(e=new he(1 / 0,1 / 0,1 / 0), t=new he(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t += 3)
            this.expandByPoint(Hl.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, n = e.count; t < n; t++)
            this.expandByPoint(Hl.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const n = Hl.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(n),
        this.max.copy(e).add(n),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const n = e.geometry;
        if (n !== void 0) {
            const a = n.getAttribute("position");
            if (t === !0 && a !== void 0 && e.isInstancedMesh !== !0)
                for (let s = 0, l = a.count; s < l; s++)
                    e.isMesh === !0 ? e.getVertexPosition(s, Hl) : Hl.fromBufferAttribute(a, s),
                    Hl.applyMatrix4(e.matrixWorld),
                    this.expandByPoint(Hl);
            else
                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                J1.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(),
                J1.copy(n.boundingBox)),
                J1.applyMatrix4(e.matrixWorld),
                this.union(J1)
        }
        const i = e.children;
        for (let a = 0, s = i.length; a < s; a++)
            this.expandByObject(i[a], t);
        return this
    }
    containsPoint(e) {
        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, Hl),
        Hl.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, n;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        n = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        n += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        n += e.normal.z * this.min.z),
        t <= -e.constant && n >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(hv),
        $1.subVectors(this.max, hv),
        _m.subVectors(e.a, hv),
        xm.subVectors(e.b, hv),
        Sm.subVectors(e.c, hv),
        Xf.subVectors(xm, _m),
        jf.subVectors(Sm, xm),
        yd.subVectors(_m, Sm);
        let t = [0, -Xf.z, Xf.y, 0, -jf.z, jf.y, 0, -yd.z, yd.y, Xf.z, 0, -Xf.x, jf.z, 0, -jf.x, yd.z, 0, -yd.x, -Xf.y, Xf.x, 0, -jf.y, jf.x, 0, -yd.y, yd.x, 0];
        return !iT(t, _m, xm, Sm, $1) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !iT(t, _m, xm, Sm, $1)) ? !1 : (ex.crossVectors(Xf, jf),
        t = [ex.x, ex.y, ex.z],
        iT(t, _m, xm, Sm, $1))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, Hl).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(Hl).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (Bc[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Bc[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Bc[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Bc[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Bc[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Bc[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Bc[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Bc[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Bc),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
    toJSON() {
        return {
            min: this.min.toArray(),
            max: this.max.toArray()
        }
    }
    fromJSON(e) {
        return this.min.fromArray(e.min),
        this.max.fromArray(e.max),
        this
    }
}
const Bc = [new he, new he, new he, new he, new he, new he, new he, new he]
  , Hl = new he
  , J1 = new ea
  , _m = new he
  , xm = new he
  , Sm = new he
  , Xf = new he
  , jf = new he
  , yd = new he
  , hv = new he
  , $1 = new he
  , ex = new he
  , _d = new he;
function iT(r, e, t, n, i) {
    for (let a = 0, s = r.length - 3; a <= s; a += 3) {
        _d.fromArray(r, a);
        const l = i.x * Math.abs(_d.x) + i.y * Math.abs(_d.y) + i.z * Math.abs(_d.z)
          , u = e.dot(_d)
          , f = t.dot(_d)
          , d = n.dot(_d);
        if (Math.max(-Math.max(u, f, d), Math.min(u, f, d)) > l)
            return !1
    }
    return !0
}
const EX = new ea
  , dv = new he
  , rT = new he;
class ta {
    constructor(e=new he, t=-1) {
        this.isSphere = !0,
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const n = this.center;
        t !== void 0 ? n.copy(t) : EX.setFromPoints(e).getCenter(n);
        let i = 0;
        for (let a = 0, s = e.length; a < s; a++)
            i = Math.max(i, n.distanceToSquared(e[a]));
        return this.radius = Math.sqrt(i),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const n = this.center.distanceToSquared(e);
        return t.copy(e),
        n > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        dv.subVectors(e, this.center);
        const t = dv.lengthSq();
        if (t > this.radius * this.radius) {
            const n = Math.sqrt(t)
              , i = (n - this.radius) * .5;
            this.center.addScaledVector(dv, i / n),
            this.radius += i
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (rT.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(dv.copy(e.center).add(rT)),
        this.expandByPoint(dv.copy(e.center).sub(rT))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        return {
            radius: this.radius,
            center: this.center.toArray()
        }
    }
    fromJSON(e) {
        return this.radius = e.radius,
        this.center.fromArray(e.center),
        this
    }
}
const zc = new he
  , aT = new he
  , tx = new he
  , Wf = new he
  , sT = new he
  , nx = new he
  , oT = new he;
class jg {
    constructor(e=new he, t=new he(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, zc)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const n = t.dot(this.direction);
        return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = zc.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (zc.copy(this.origin).addScaledVector(this.direction, t),
        zc.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, n, i) {
        aT.copy(e).add(t).multiplyScalar(.5),
        tx.copy(t).sub(e).normalize(),
        Wf.copy(this.origin).sub(aT);
        const a = e.distanceTo(t) * .5
          , s = -this.direction.dot(tx)
          , l = Wf.dot(this.direction)
          , u = -Wf.dot(tx)
          , f = Wf.lengthSq()
          , d = Math.abs(1 - s * s);
        let g, v, y, S;
        if (d > 0)
            if (g = s * u - l,
            v = s * l - u,
            S = a * d,
            g >= 0)
                if (v >= -S)
                    if (v <= S) {
                        const T = 1 / d;
                        g *= T,
                        v *= T,
                        y = g * (g + s * v + 2 * l) + v * (s * g + v + 2 * u) + f
                    } else
                        v = a,
                        g = Math.max(0, -(s * v + l)),
                        y = -g * g + v * (v + 2 * u) + f;
                else
                    v = -a,
                    g = Math.max(0, -(s * v + l)),
                    y = -g * g + v * (v + 2 * u) + f;
            else
                v <= -S ? (g = Math.max(0, -(-s * a + l)),
                v = g > 0 ? -a : Math.min(Math.max(-a, -u), a),
                y = -g * g + v * (v + 2 * u) + f) : v <= S ? (g = 0,
                v = Math.min(Math.max(-a, -u), a),
                y = v * (v + 2 * u) + f) : (g = Math.max(0, -(s * a + l)),
                v = g > 0 ? a : Math.min(Math.max(-a, -u), a),
                y = -g * g + v * (v + 2 * u) + f);
        else
            v = s > 0 ? -a : a,
            g = Math.max(0, -(s * v + l)),
            y = -g * g + v * (v + 2 * u) + f;
        return n && n.copy(this.origin).addScaledVector(this.direction, g),
        i && i.copy(aT).addScaledVector(tx, v),
        y
    }
    intersectSphere(e, t) {
        zc.subVectors(e.center, this.origin);
        const n = zc.dot(this.direction)
          , i = zc.dot(zc) - n * n
          , a = e.radius * e.radius;
        if (i > a)
            return null;
        const s = Math.sqrt(a - i)
          , l = n - s
          , u = n + s;
        return u < 0 ? null : l < 0 ? this.at(u, t) : this.at(l, t)
    }
    intersectsSphere(e) {
        return e.radius < 0 ? !1 : this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const n = -(this.origin.dot(e.normal) + e.constant) / t;
        return n >= 0 ? n : null
    }
    intersectPlane(e, t) {
        const n = this.distanceToPlane(e);
        return n === null ? null : this.at(n, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let n, i, a, s, l, u;
        const f = 1 / this.direction.x
          , d = 1 / this.direction.y
          , g = 1 / this.direction.z
          , v = this.origin;
        return f >= 0 ? (n = (e.min.x - v.x) * f,
        i = (e.max.x - v.x) * f) : (n = (e.max.x - v.x) * f,
        i = (e.min.x - v.x) * f),
        d >= 0 ? (a = (e.min.y - v.y) * d,
        s = (e.max.y - v.y) * d) : (a = (e.max.y - v.y) * d,
        s = (e.min.y - v.y) * d),
        n > s || a > i || ((a > n || isNaN(n)) && (n = a),
        (s < i || isNaN(i)) && (i = s),
        g >= 0 ? (l = (e.min.z - v.z) * g,
        u = (e.max.z - v.z) * g) : (l = (e.max.z - v.z) * g,
        u = (e.min.z - v.z) * g),
        n > u || l > i) || ((l > n || n !== n) && (n = l),
        (u < i || i !== i) && (i = u),
        i < 0) ? null : this.at(n >= 0 ? n : i, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, zc) !== null
    }
    intersectTriangle(e, t, n, i, a) {
        sT.subVectors(t, e),
        nx.subVectors(n, e),
        oT.crossVectors(sT, nx);
        let s = this.direction.dot(oT), l;
        if (s > 0) {
            if (i)
                return null;
            l = 1
        } else if (s < 0)
            l = -1,
            s = -s;
        else
            return null;
        Wf.subVectors(this.origin, e);
        const u = l * this.direction.dot(nx.crossVectors(Wf, nx));
        if (u < 0)
            return null;
        const f = l * this.direction.dot(sT.cross(Wf));
        if (f < 0 || u + f > s)
            return null;
        const d = -l * Wf.dot(oT);
        return d < 0 ? null : this.at(d / s, a)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class vn {
    constructor(e, t, n, i, a, s, l, u, f, d, g, v, y, S, T, M) {
        vn.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, n, i, a, s, l, u, f, d, g, v, y, S, T, M)
    }
    set(e, t, n, i, a, s, l, u, f, d, g, v, y, S, T, M) {
        const b = this.elements;
        return b[0] = e,
        b[4] = t,
        b[8] = n,
        b[12] = i,
        b[1] = a,
        b[5] = s,
        b[9] = l,
        b[13] = u,
        b[2] = f,
        b[6] = d,
        b[10] = g,
        b[14] = v,
        b[3] = y,
        b[7] = S,
        b[11] = T,
        b[15] = M,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new vn().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , n = e.elements;
        return t[0] = n[0],
        t[1] = n[1],
        t[2] = n[2],
        t[3] = n[3],
        t[4] = n[4],
        t[5] = n[5],
        t[6] = n[6],
        t[7] = n[7],
        t[8] = n[8],
        t[9] = n[9],
        t[10] = n[10],
        t[11] = n[11],
        t[12] = n[12],
        t[13] = n[13],
        t[14] = n[14],
        t[15] = n[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , n = e.elements;
        return t[12] = n[12],
        t[13] = n[13],
        t[14] = n[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, n) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        n.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, n) {
        return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , n = e.elements
          , i = 1 / bm.setFromMatrixColumn(e, 0).length()
          , a = 1 / bm.setFromMatrixColumn(e, 1).length()
          , s = 1 / bm.setFromMatrixColumn(e, 2).length();
        return t[0] = n[0] * i,
        t[1] = n[1] * i,
        t[2] = n[2] * i,
        t[3] = 0,
        t[4] = n[4] * a,
        t[5] = n[5] * a,
        t[6] = n[6] * a,
        t[7] = 0,
        t[8] = n[8] * s,
        t[9] = n[9] * s,
        t[10] = n[10] * s,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , n = e.x
          , i = e.y
          , a = e.z
          , s = Math.cos(n)
          , l = Math.sin(n)
          , u = Math.cos(i)
          , f = Math.sin(i)
          , d = Math.cos(a)
          , g = Math.sin(a);
        if (e.order === "XYZ") {
            const v = s * d
              , y = s * g
              , S = l * d
              , T = l * g;
            t[0] = u * d,
            t[4] = -u * g,
            t[8] = f,
            t[1] = y + S * f,
            t[5] = v - T * f,
            t[9] = -l * u,
            t[2] = T - v * f,
            t[6] = S + y * f,
            t[10] = s * u
        } else if (e.order === "YXZ") {
            const v = u * d
              , y = u * g
              , S = f * d
              , T = f * g;
            t[0] = v + T * l,
            t[4] = S * l - y,
            t[8] = s * f,
            t[1] = s * g,
            t[5] = s * d,
            t[9] = -l,
            t[2] = y * l - S,
            t[6] = T + v * l,
            t[10] = s * u
        } else if (e.order === "ZXY") {
            const v = u * d
              , y = u * g
              , S = f * d
              , T = f * g;
            t[0] = v - T * l,
            t[4] = -s * g,
            t[8] = S + y * l,
            t[1] = y + S * l,
            t[5] = s * d,
            t[9] = T - v * l,
            t[2] = -s * f,
            t[6] = l,
            t[10] = s * u
        } else if (e.order === "ZYX") {
            const v = s * d
              , y = s * g
              , S = l * d
              , T = l * g;
            t[0] = u * d,
            t[4] = S * f - y,
            t[8] = v * f + T,
            t[1] = u * g,
            t[5] = T * f + v,
            t[9] = y * f - S,
            t[2] = -f,
            t[6] = l * u,
            t[10] = s * u
        } else if (e.order === "YZX") {
            const v = s * u
              , y = s * f
              , S = l * u
              , T = l * f;
            t[0] = u * d,
            t[4] = T - v * g,
            t[8] = S * g + y,
            t[1] = g,
            t[5] = s * d,
            t[9] = -l * d,
            t[2] = -f * d,
            t[6] = y * g + S,
            t[10] = v - T * g
        } else if (e.order === "XZY") {
            const v = s * u
              , y = s * f
              , S = l * u
              , T = l * f;
            t[0] = u * d,
            t[4] = -g,
            t[8] = f * d,
            t[1] = v * g + T,
            t[5] = s * d,
            t[9] = y * g - S,
            t[2] = S * g - y,
            t[6] = l * d,
            t[10] = T * g + v
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(wX, e, AX)
    }
    lookAt(e, t, n) {
        const i = this.elements;
        return fo.subVectors(e, t),
        fo.lengthSq() === 0 && (fo.z = 1),
        fo.normalize(),
        Yf.crossVectors(n, fo),
        Yf.lengthSq() === 0 && (Math.abs(n.z) === 1 ? fo.x += 1e-4 : fo.z += 1e-4,
        fo.normalize(),
        Yf.crossVectors(n, fo)),
        Yf.normalize(),
        ix.crossVectors(fo, Yf),
        i[0] = Yf.x,
        i[4] = ix.x,
        i[8] = fo.x,
        i[1] = Yf.y,
        i[5] = ix.y,
        i[9] = fo.y,
        i[2] = Yf.z,
        i[6] = ix.z,
        i[10] = fo.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const n = e.elements
          , i = t.elements
          , a = this.elements
          , s = n[0]
          , l = n[4]
          , u = n[8]
          , f = n[12]
          , d = n[1]
          , g = n[5]
          , v = n[9]
          , y = n[13]
          , S = n[2]
          , T = n[6]
          , M = n[10]
          , b = n[14]
          , A = n[3]
          , C = n[7]
          , R = n[11]
          , O = n[15]
          , L = i[0]
          , z = i[4]
          , I = i[8]
          , N = i[12]
          , P = i[1]
          , Y = i[5]
          , V = i[9]
          , K = i[13]
          , Z = i[2]
          , oe = i[6]
          , H = i[10]
          , q = i[14]
          , Q = i[3]
          , se = i[7]
          , B = i[11]
          , W = i[15];
        return a[0] = s * L + l * P + u * Z + f * Q,
        a[4] = s * z + l * Y + u * oe + f * se,
        a[8] = s * I + l * V + u * H + f * B,
        a[12] = s * N + l * K + u * q + f * W,
        a[1] = d * L + g * P + v * Z + y * Q,
        a[5] = d * z + g * Y + v * oe + y * se,
        a[9] = d * I + g * V + v * H + y * B,
        a[13] = d * N + g * K + v * q + y * W,
        a[2] = S * L + T * P + M * Z + b * Q,
        a[6] = S * z + T * Y + M * oe + b * se,
        a[10] = S * I + T * V + M * H + b * B,
        a[14] = S * N + T * K + M * q + b * W,
        a[3] = A * L + C * P + R * Z + O * Q,
        a[7] = A * z + C * Y + R * oe + O * se,
        a[11] = A * I + C * V + R * H + O * B,
        a[15] = A * N + C * K + R * q + O * W,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , n = e[4]
          , i = e[8]
          , a = e[12]
          , s = e[1]
          , l = e[5]
          , u = e[9]
          , f = e[13]
          , d = e[2]
          , g = e[6]
          , v = e[10]
          , y = e[14]
          , S = e[3]
          , T = e[7]
          , M = e[11]
          , b = e[15];
        return S * (+a * u * g - i * f * g - a * l * v + n * f * v + i * l * y - n * u * y) + T * (+t * u * y - t * f * v + a * s * v - i * s * y + i * f * d - a * u * d) + M * (+t * f * g - t * l * y - a * s * g + n * s * y + a * l * d - n * f * d) + b * (-i * l * d - t * u * g + t * l * v + i * s * g - n * s * v + n * u * d)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, n) {
        const i = this.elements;
        return e.isVector3 ? (i[12] = e.x,
        i[13] = e.y,
        i[14] = e.z) : (i[12] = e,
        i[13] = t,
        i[14] = n),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , i = e[2]
          , a = e[3]
          , s = e[4]
          , l = e[5]
          , u = e[6]
          , f = e[7]
          , d = e[8]
          , g = e[9]
          , v = e[10]
          , y = e[11]
          , S = e[12]
          , T = e[13]
          , M = e[14]
          , b = e[15]
          , A = g * M * f - T * v * f + T * u * y - l * M * y - g * u * b + l * v * b
          , C = S * v * f - d * M * f - S * u * y + s * M * y + d * u * b - s * v * b
          , R = d * T * f - S * g * f + S * l * y - s * T * y - d * l * b + s * g * b
          , O = S * g * u - d * T * u - S * l * v + s * T * v + d * l * M - s * g * M
          , L = t * A + n * C + i * R + a * O;
        if (L === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const z = 1 / L;
        return e[0] = A * z,
        e[1] = (T * v * a - g * M * a - T * i * y + n * M * y + g * i * b - n * v * b) * z,
        e[2] = (l * M * a - T * u * a + T * i * f - n * M * f - l * i * b + n * u * b) * z,
        e[3] = (g * u * a - l * v * a - g * i * f + n * v * f + l * i * y - n * u * y) * z,
        e[4] = C * z,
        e[5] = (d * M * a - S * v * a + S * i * y - t * M * y - d * i * b + t * v * b) * z,
        e[6] = (S * u * a - s * M * a - S * i * f + t * M * f + s * i * b - t * u * b) * z,
        e[7] = (s * v * a - d * u * a + d * i * f - t * v * f - s * i * y + t * u * y) * z,
        e[8] = R * z,
        e[9] = (S * g * a - d * T * a - S * n * y + t * T * y + d * n * b - t * g * b) * z,
        e[10] = (s * T * a - S * l * a + S * n * f - t * T * f - s * n * b + t * l * b) * z,
        e[11] = (d * l * a - s * g * a - d * n * f + t * g * f + s * n * y - t * l * y) * z,
        e[12] = O * z,
        e[13] = (d * T * i - S * g * i + S * n * v - t * T * v - d * n * M + t * g * M) * z,
        e[14] = (S * l * i - s * T * i - S * n * u + t * T * u + s * n * M - t * l * M) * z,
        e[15] = (s * g * i - d * l * i + d * n * u - t * g * u - s * n * v + t * l * v) * z,
        this
    }
    scale(e) {
        const t = this.elements
          , n = e.x
          , i = e.y
          , a = e.z;
        return t[0] *= n,
        t[4] *= i,
        t[8] *= a,
        t[1] *= n,
        t[5] *= i,
        t[9] *= a,
        t[2] *= n,
        t[6] *= i,
        t[10] *= a,
        t[3] *= n,
        t[7] *= i,
        t[11] *= a,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, n, i))
    }
    makeTranslation(e, t, n) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const n = Math.cos(t)
          , i = Math.sin(t)
          , a = 1 - n
          , s = e.x
          , l = e.y
          , u = e.z
          , f = a * s
          , d = a * l;
        return this.set(f * s + n, f * l - i * u, f * u + i * l, 0, f * l + i * u, d * l + n, d * u - i * s, 0, f * u - i * l, d * u + i * s, a * u * u + n, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, n) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, n, i, a, s) {
        return this.set(1, n, a, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, n) {
        const i = this.elements
          , a = t._x
          , s = t._y
          , l = t._z
          , u = t._w
          , f = a + a
          , d = s + s
          , g = l + l
          , v = a * f
          , y = a * d
          , S = a * g
          , T = s * d
          , M = s * g
          , b = l * g
          , A = u * f
          , C = u * d
          , R = u * g
          , O = n.x
          , L = n.y
          , z = n.z;
        return i[0] = (1 - (T + b)) * O,
        i[1] = (y + R) * O,
        i[2] = (S - C) * O,
        i[3] = 0,
        i[4] = (y - R) * L,
        i[5] = (1 - (v + b)) * L,
        i[6] = (M + A) * L,
        i[7] = 0,
        i[8] = (S + C) * z,
        i[9] = (M - A) * z,
        i[10] = (1 - (v + T)) * z,
        i[11] = 0,
        i[12] = e.x,
        i[13] = e.y,
        i[14] = e.z,
        i[15] = 1,
        this
    }
    decompose(e, t, n) {
        const i = this.elements;
        let a = bm.set(i[0], i[1], i[2]).length();
        const s = bm.set(i[4], i[5], i[6]).length()
          , l = bm.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (a = -a),
        e.x = i[12],
        e.y = i[13],
        e.z = i[14],
        Vl.copy(this);
        const f = 1 / a
          , d = 1 / s
          , g = 1 / l;
        return Vl.elements[0] *= f,
        Vl.elements[1] *= f,
        Vl.elements[2] *= f,
        Vl.elements[4] *= d,
        Vl.elements[5] *= d,
        Vl.elements[6] *= d,
        Vl.elements[8] *= g,
        Vl.elements[9] *= g,
        Vl.elements[10] *= g,
        t.setFromRotationMatrix(Vl),
        n.x = a,
        n.y = s,
        n.z = l,
        this
    }
    makePerspective(e, t, n, i, a, s, l=bo, u=!1) {
        const f = this.elements
          , d = 2 * a / (t - e)
          , g = 2 * a / (n - i)
          , v = (t + e) / (t - e)
          , y = (n + i) / (n - i);
        let S, T;
        if (u)
            S = a / (s - a),
            T = s * a / (s - a);
        else if (l === bo)
            S = -(s + a) / (s - a),
            T = -2 * s * a / (s - a);
        else if (l === Cg)
            S = -s / (s - a),
            T = -s * a / (s - a);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
        return f[0] = d,
        f[4] = 0,
        f[8] = v,
        f[12] = 0,
        f[1] = 0,
        f[5] = g,
        f[9] = y,
        f[13] = 0,
        f[2] = 0,
        f[6] = 0,
        f[10] = S,
        f[14] = T,
        f[3] = 0,
        f[7] = 0,
        f[11] = -1,
        f[15] = 0,
        this
    }
    makeOrthographic(e, t, n, i, a, s, l=bo, u=!1) {
        const f = this.elements
          , d = 2 / (t - e)
          , g = 2 / (n - i)
          , v = -(t + e) / (t - e)
          , y = -(n + i) / (n - i);
        let S, T;
        if (u)
            S = 1 / (s - a),
            T = s / (s - a);
        else if (l === bo)
            S = -2 / (s - a),
            T = -(s + a) / (s - a);
        else if (l === Cg)
            S = -1 / (s - a),
            T = -a / (s - a);
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
        return f[0] = d,
        f[4] = 0,
        f[8] = 0,
        f[12] = v,
        f[1] = 0,
        f[5] = g,
        f[9] = 0,
        f[13] = y,
        f[2] = 0,
        f[6] = 0,
        f[10] = S,
        f[14] = T,
        f[3] = 0,
        f[7] = 0,
        f[11] = 0,
        f[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , n = e.elements;
        for (let i = 0; i < 16; i++)
            if (t[i] !== n[i])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let n = 0; n < 16; n++)
            this.elements[n] = e[n + t];
        return this
    }
    toArray(e=[], t=0) {
        const n = this.elements;
        return e[t] = n[0],
        e[t + 1] = n[1],
        e[t + 2] = n[2],
        e[t + 3] = n[3],
        e[t + 4] = n[4],
        e[t + 5] = n[5],
        e[t + 6] = n[6],
        e[t + 7] = n[7],
        e[t + 8] = n[8],
        e[t + 9] = n[9],
        e[t + 10] = n[10],
        e[t + 11] = n[11],
        e[t + 12] = n[12],
        e[t + 13] = n[13],
        e[t + 14] = n[14],
        e[t + 15] = n[15],
        e
    }
}
const bm = new he
  , Vl = new vn
  , wX = new he(0,0,0)
  , AX = new he(1,1,1)
  , Yf = new he
  , ix = new he
  , fo = new he
  , tU = new vn
  , nU = new qs;
class Co {
    constructor(e=0, t=0, n=0, i=Co.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = n,
        this._order = i
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, n, i=this._order) {
        return this._x = e,
        this._y = t,
        this._z = n,
        this._order = i,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, n=!0) {
        const i = e.elements
          , a = i[0]
          , s = i[4]
          , l = i[8]
          , u = i[1]
          , f = i[5]
          , d = i[9]
          , g = i[2]
          , v = i[6]
          , y = i[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(gn(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-d, y),
            this._z = Math.atan2(-s, a)) : (this._x = Math.atan2(v, f),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-gn(d, -1, 1)),
            Math.abs(d) < .9999999 ? (this._y = Math.atan2(l, y),
            this._z = Math.atan2(u, f)) : (this._y = Math.atan2(-g, a),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(gn(v, -1, 1)),
            Math.abs(v) < .9999999 ? (this._y = Math.atan2(-g, y),
            this._z = Math.atan2(-s, f)) : (this._y = 0,
            this._z = Math.atan2(u, a));
            break;
        case "ZYX":
            this._y = Math.asin(-gn(g, -1, 1)),
            Math.abs(g) < .9999999 ? (this._x = Math.atan2(v, y),
            this._z = Math.atan2(u, a)) : (this._x = 0,
            this._z = Math.atan2(-s, f));
            break;
        case "YZX":
            this._z = Math.asin(gn(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._x = Math.atan2(-d, f),
            this._y = Math.atan2(-g, a)) : (this._x = 0,
            this._y = Math.atan2(l, y));
            break;
        case "XZY":
            this._z = Math.asin(-gn(s, -1, 1)),
            Math.abs(s) < .9999999 ? (this._x = Math.atan2(v, f),
            this._y = Math.atan2(l, a)) : (this._x = Math.atan2(-d, y),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        n === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, n) {
        return tU.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(tU, t, n)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return nU.setFromEuler(this),
        this.setFromQuaternion(nU, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
Co.DEFAULT_ORDER = "XYZ";
class Dg {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let CX = 0;
const iU = new he
  , Mm = new qs
  , Ic = new vn
  , rx = new he
  , pv = new he
  , RX = new he
  , DX = new qs
  , rU = new he(1,0,0)
  , aU = new he(0,1,0)
  , sU = new he(0,0,1)
  , oU = {
    type: "added"
}
  , UX = {
    type: "removed"
}
  , Tm = {
    type: "childadded",
    child: null
}
  , lT = {
    type: "childremoved",
    child: null
};
class ii extends sc {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: CX++
        }),
        this.uuid = To(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = ii.DEFAULT_UP.clone();
        const e = new he
          , t = new Co
          , n = new qs
          , i = new he(1,1,1);
        function a() {
            n.setFromEuler(t, !1)
        }
        function s() {
            t.setFromQuaternion(n, void 0, !1)
        }
        t._onChange(a),
        n._onChange(s),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new vn
            },
            normalMatrix: {
                value: new An
            }
        }),
        this.matrix = new vn,
        this.matrixWorld = new vn,
        this.matrixAutoUpdate = ii.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = ii.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new Dg,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.customDepthMaterial = void 0,
        this.customDistanceMaterial = void 0,
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return Mm.setFromAxisAngle(e, t),
        this.quaternion.multiply(Mm),
        this
    }
    rotateOnWorldAxis(e, t) {
        return Mm.setFromAxisAngle(e, t),
        this.quaternion.premultiply(Mm),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(rU, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(aU, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(sU, e)
    }
    translateOnAxis(e, t) {
        return iU.copy(e).applyQuaternion(this.quaternion),
        this.position.add(iU.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(rU, e)
    }
    translateY(e) {
        return this.translateOnAxis(aU, e)
    }
    translateZ(e) {
        return this.translateOnAxis(sU, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(Ic.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, n) {
        e.isVector3 ? rx.copy(e) : rx.set(e, t, n);
        const i = this.parent;
        this.updateWorldMatrix(!0, !1),
        pv.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? Ic.lookAt(pv, rx, this.up) : Ic.lookAt(rx, pv, this.up),
        this.quaternion.setFromRotationMatrix(Ic),
        i && (Ic.extractRotation(i.matrixWorld),
        Mm.setFromRotationMatrix(Ic),
        this.quaternion.premultiply(Mm.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(oU),
        Tm.child = e,
        this.dispatchEvent(Tm),
        Tm.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++)
                this.remove(arguments[n]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(UX),
        lT.child = e,
        this.dispatchEvent(lT),
        lT.child = null),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        Ic.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        Ic.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(Ic),
        e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.updateWorldMatrix(!1, !0),
        e.dispatchEvent(oU),
        Tm.child = e,
        this.dispatchEvent(Tm),
        Tm.child = null,
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let n = 0, i = this.children.length; n < i; n++) {
            const s = this.children[n].getObjectByProperty(e, t);
            if (s !== void 0)
                return s
        }
    }
    getObjectsByProperty(e, t, n=[]) {
        this[e] === t && n.push(this);
        const i = this.children;
        for (let a = 0, s = i.length; a < s; a++)
            i[a].getObjectsByProperty(e, t, n);
        return n
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(pv, e, RX),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(pv, DX, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++)
            t[n].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++)
            t[n].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++)
            t[n].updateMatrixWorld(e)
    }
    updateWorldMatrix(e, t) {
        const n = this.parent;
        if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        t === !0) {
            const i = this.children;
            for (let a = 0, s = i.length; a < s; a++)
                i[a].updateWorldMatrix(!1, !0)
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , n = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        n.metadata = {
            version: 4.7,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const i = {};
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.castShadow === !0 && (i.castShadow = !0),
        this.receiveShadow === !0 && (i.receiveShadow = !0),
        this.visible === !1 && (i.visible = !1),
        this.frustumCulled === !1 && (i.frustumCulled = !1),
        this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        i.layers = this.layers.mask,
        i.matrix = this.matrix.toArray(),
        i.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
        this.isInstancedMesh && (i.type = "InstancedMesh",
        i.count = this.count,
        i.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh && (i.type = "BatchedMesh",
        i.perObjectFrustumCulled = this.perObjectFrustumCulled,
        i.sortObjects = this.sortObjects,
        i.drawRanges = this._drawRanges,
        i.reservedRanges = this._reservedRanges,
        i.geometryInfo = this._geometryInfo.map(l => ({
            ...l,
            boundingBox: l.boundingBox ? l.boundingBox.toJSON() : void 0,
            boundingSphere: l.boundingSphere ? l.boundingSphere.toJSON() : void 0
        })),
        i.instanceInfo = this._instanceInfo.map(l => ({
            ...l
        })),
        i.availableInstanceIds = this._availableInstanceIds.slice(),
        i.availableGeometryIds = this._availableGeometryIds.slice(),
        i.nextIndexStart = this._nextIndexStart,
        i.nextVertexStart = this._nextVertexStart,
        i.geometryCount = this._geometryCount,
        i.maxInstanceCount = this._maxInstanceCount,
        i.maxVertexCount = this._maxVertexCount,
        i.maxIndexCount = this._maxIndexCount,
        i.geometryInitialized = this._geometryInitialized,
        i.matricesTexture = this._matricesTexture.toJSON(e),
        i.indirectTexture = this._indirectTexture.toJSON(e),
        this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null && (i.boundingSphere = this.boundingSphere.toJSON()),
        this.boundingBox !== null && (i.boundingBox = this.boundingBox.toJSON()));
        function a(l, u) {
            return l[u.uuid] === void 0 && (l[u.uuid] = u.toJSON(e)),
            u.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = a(e.geometries, this.geometry);
            const l = this.geometry.parameters;
            if (l !== void 0 && l.shapes !== void 0) {
                const u = l.shapes;
                if (Array.isArray(u))
                    for (let f = 0, d = u.length; f < d; f++) {
                        const g = u[f];
                        a(e.shapes, g)
                    }
                else
                    a(e.shapes, u)
            }
        }
        if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
        i.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (a(e.skeletons, this.skeleton),
        i.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const l = [];
                for (let u = 0, f = this.material.length; u < f; u++)
                    l.push(a(e.materials, this.material[u]));
                i.material = l
            } else
                i.material = a(e.materials, this.material);
        if (this.children.length > 0) {
            i.children = [];
            for (let l = 0; l < this.children.length; l++)
                i.children.push(this.children[l].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            i.animations = [];
            for (let l = 0; l < this.animations.length; l++) {
                const u = this.animations[l];
                i.animations.push(a(e.animations, u))
            }
        }
        if (t) {
            const l = s(e.geometries)
              , u = s(e.materials)
              , f = s(e.textures)
              , d = s(e.images)
              , g = s(e.shapes)
              , v = s(e.skeletons)
              , y = s(e.animations)
              , S = s(e.nodes);
            l.length > 0 && (n.geometries = l),
            u.length > 0 && (n.materials = u),
            f.length > 0 && (n.textures = f),
            d.length > 0 && (n.images = d),
            g.length > 0 && (n.shapes = g),
            v.length > 0 && (n.skeletons = v),
            y.length > 0 && (n.animations = y),
            S.length > 0 && (n.nodes = S)
        }
        return n.object = i,
        n;
        function s(l) {
            const u = [];
            for (const f in l) {
                const d = l[f];
                delete d.metadata,
                u.push(d)
            }
            return u
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations.slice(),
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let n = 0; n < e.children.length; n++) {
                const i = e.children[n];
                this.add(i.clone())
            }
        return this
    }
}
ii.DEFAULT_UP = new he(0,1,0);
ii.DEFAULT_MATRIX_AUTO_UPDATE = !0;
ii.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const kl = new he
  , Fc = new he
  , uT = new he
  , Hc = new he
  , Em = new he
  , wm = new he
  , lU = new he
  , cT = new he
  , fT = new he
  , hT = new he
  , dT = new Qn
  , pT = new Qn
  , mT = new Qn;
class Vs {
    constructor(e=new he, t=new he, n=new he) {
        this.a = e,
        this.b = t,
        this.c = n
    }
    static getNormal(e, t, n, i) {
        i.subVectors(n, t),
        kl.subVectors(e, t),
        i.cross(kl);
        const a = i.lengthSq();
        return a > 0 ? i.multiplyScalar(1 / Math.sqrt(a)) : i.set(0, 0, 0)
    }
    static getBarycoord(e, t, n, i, a) {
        kl.subVectors(i, t),
        Fc.subVectors(n, t),
        uT.subVectors(e, t);
        const s = kl.dot(kl)
          , l = kl.dot(Fc)
          , u = kl.dot(uT)
          , f = Fc.dot(Fc)
          , d = Fc.dot(uT)
          , g = s * f - l * l;
        if (g === 0)
            return a.set(0, 0, 0),
            null;
        const v = 1 / g
          , y = (f * u - l * d) * v
          , S = (s * d - l * u) * v;
        return a.set(1 - y - S, S, y)
    }
    static containsPoint(e, t, n, i) {
        return this.getBarycoord(e, t, n, i, Hc) === null ? !1 : Hc.x >= 0 && Hc.y >= 0 && Hc.x + Hc.y <= 1
    }
    static getInterpolation(e, t, n, i, a, s, l, u) {
        return this.getBarycoord(e, t, n, i, Hc) === null ? (u.x = 0,
        u.y = 0,
        "z"in u && (u.z = 0),
        "w"in u && (u.w = 0),
        null) : (u.setScalar(0),
        u.addScaledVector(a, Hc.x),
        u.addScaledVector(s, Hc.y),
        u.addScaledVector(l, Hc.z),
        u)
    }
    static getInterpolatedAttribute(e, t, n, i, a, s) {
        return dT.setScalar(0),
        pT.setScalar(0),
        mT.setScalar(0),
        dT.fromBufferAttribute(e, t),
        pT.fromBufferAttribute(e, n),
        mT.fromBufferAttribute(e, i),
        s.setScalar(0),
        s.addScaledVector(dT, a.x),
        s.addScaledVector(pT, a.y),
        s.addScaledVector(mT, a.z),
        s
    }
    static isFrontFacing(e, t, n, i) {
        return kl.subVectors(n, t),
        Fc.subVectors(e, t),
        kl.cross(Fc).dot(i) < 0
    }
    set(e, t, n) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(n),
        this
    }
    setFromPointsAndIndices(e, t, n, i) {
        return this.a.copy(e[t]),
        this.b.copy(e[n]),
        this.c.copy(e[i]),
        this
    }
    setFromAttributeAndIndices(e, t, n, i) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, n),
        this.c.fromBufferAttribute(e, i),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return kl.subVectors(this.c, this.b),
        Fc.subVectors(this.a, this.b),
        kl.cross(Fc).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return Vs.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return Vs.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getInterpolation(e, t, n, i, a) {
        return Vs.getInterpolation(e, this.a, this.b, this.c, t, n, i, a)
    }
    containsPoint(e) {
        return Vs.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return Vs.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const n = this.a
          , i = this.b
          , a = this.c;
        let s, l;
        Em.subVectors(i, n),
        wm.subVectors(a, n),
        cT.subVectors(e, n);
        const u = Em.dot(cT)
          , f = wm.dot(cT);
        if (u <= 0 && f <= 0)
            return t.copy(n);
        fT.subVectors(e, i);
        const d = Em.dot(fT)
          , g = wm.dot(fT);
        if (d >= 0 && g <= d)
            return t.copy(i);
        const v = u * g - d * f;
        if (v <= 0 && u >= 0 && d <= 0)
            return s = u / (u - d),
            t.copy(n).addScaledVector(Em, s);
        hT.subVectors(e, a);
        const y = Em.dot(hT)
          , S = wm.dot(hT);
        if (S >= 0 && y <= S)
            return t.copy(a);
        const T = y * f - u * S;
        if (T <= 0 && f >= 0 && S <= 0)
            return l = f / (f - S),
            t.copy(n).addScaledVector(wm, l);
        const M = d * S - y * g;
        if (M <= 0 && g - d >= 0 && y - S >= 0)
            return lU.subVectors(a, i),
            l = (g - d) / (g - d + (y - S)),
            t.copy(i).addScaledVector(lU, l);
        const b = 1 / (M + T + v);
        return s = T * b,
        l = v * b,
        t.copy(n).addScaledVector(Em, s).addScaledVector(wm, l)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const bB = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , qf = {
    h: 0,
    s: 0,
    l: 0
}
  , ax = {
    h: 0,
    s: 0,
    l: 0
};
function gT(r, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? r + (e - r) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - t) : r
}
class kt {
    constructor(e, t, n) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        this.set(e, t, n)
    }
    set(e, t, n) {
        if (t === void 0 && n === void 0) {
            const i = e;
            i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i)
        } else
            this.setRGB(e, t, n);
        return this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=pa) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        Kn.colorSpaceToWorking(this, t),
        this
    }
    setRGB(e, t, n, i=Kn.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = n,
        Kn.colorSpaceToWorking(this, i),
        this
    }
    setHSL(e, t, n, i=Kn.workingColorSpace) {
        if (e = aC(e, 1),
        t = gn(t, 0, 1),
        n = gn(n, 0, 1),
        t === 0)
            this.r = this.g = this.b = n;
        else {
            const a = n <= .5 ? n * (1 + t) : n + t - n * t
              , s = 2 * n - a;
            this.r = gT(s, a, e + 1 / 3),
            this.g = gT(s, a, e),
            this.b = gT(s, a, e - 1 / 3)
        }
        return Kn.colorSpaceToWorking(this, i),
        this
    }
    setStyle(e, t=pa) {
        function n(a) {
            a !== void 0 && parseFloat(a) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let i;
        if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let a;
            const s = i[1]
              , l = i[2];
            switch (s) {
            case "rgb":
            case "rgba":
                if (a = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
                    return n(a[4]),
                    this.setRGB(Math.min(255, parseInt(a[1], 10)) / 255, Math.min(255, parseInt(a[2], 10)) / 255, Math.min(255, parseInt(a[3], 10)) / 255, t);
                if (a = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
                    return n(a[4]),
                    this.setRGB(Math.min(100, parseInt(a[1], 10)) / 100, Math.min(100, parseInt(a[2], 10)) / 100, Math.min(100, parseInt(a[3], 10)) / 100, t);
                break;
            case "hsl":
            case "hsla":
                if (a = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
                    return n(a[4]),
                    this.setHSL(parseFloat(a[1]) / 360, parseFloat(a[2]) / 100, parseFloat(a[3]) / 100, t);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const a = i[1]
              , s = a.length;
            if (s === 3)
                return this.setRGB(parseInt(a.charAt(0), 16) / 15, parseInt(a.charAt(1), 16) / 15, parseInt(a.charAt(2), 16) / 15, t);
            if (s === 6)
                return this.setHex(parseInt(a, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, t);
        return this
    }
    setColorName(e, t=pa) {
        const n = bB[e.toLowerCase()];
        return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = Zc(e.r),
        this.g = Zc(e.g),
        this.b = Zc(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = ug(e.r),
        this.g = ug(e.g),
        this.b = ug(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=pa) {
        return Kn.workingToColorSpace(Ua.copy(this), e),
        Math.round(gn(Ua.r * 255, 0, 255)) * 65536 + Math.round(gn(Ua.g * 255, 0, 255)) * 256 + Math.round(gn(Ua.b * 255, 0, 255))
    }
    getHexString(e=pa) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=Kn.workingColorSpace) {
        Kn.workingToColorSpace(Ua.copy(this), t);
        const n = Ua.r
          , i = Ua.g
          , a = Ua.b
          , s = Math.max(n, i, a)
          , l = Math.min(n, i, a);
        let u, f;
        const d = (l + s) / 2;
        if (l === s)
            u = 0,
            f = 0;
        else {
            const g = s - l;
            switch (f = d <= .5 ? g / (s + l) : g / (2 - s - l),
            s) {
            case n:
                u = (i - a) / g + (i < a ? 6 : 0);
                break;
            case i:
                u = (a - n) / g + 2;
                break;
            case a:
                u = (n - i) / g + 4;
                break
            }
            u /= 6
        }
        return e.h = u,
        e.s = f,
        e.l = d,
        e
    }
    getRGB(e, t=Kn.workingColorSpace) {
        return Kn.workingToColorSpace(Ua.copy(this), t),
        e.r = Ua.r,
        e.g = Ua.g,
        e.b = Ua.b,
        e
    }
    getStyle(e=pa) {
        Kn.workingToColorSpace(Ua.copy(this), e);
        const t = Ua.r
          , n = Ua.g
          , i = Ua.b;
        return e !== pa ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`
    }
    offsetHSL(e, t, n) {
        return this.getHSL(qf),
        this.setHSL(qf.h + e, qf.s + t, qf.l + n)
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, n) {
        return this.r = e.r + (t.r - e.r) * n,
        this.g = e.g + (t.g - e.g) * n,
        this.b = e.b + (t.b - e.b) * n,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(qf),
        e.getHSL(ax);
        const n = ry(qf.h, ax.h, t)
          , i = ry(qf.s, ax.s, t)
          , a = ry(qf.l, ax.l, t);
        return this.setHSL(n, i, a),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const t = this.r
          , n = this.g
          , i = this.b
          , a = e.elements;
        return this.r = a[0] * t + a[3] * n + a[6] * i,
        this.g = a[1] * t + a[4] * n + a[7] * i,
        this.b = a[2] * t + a[5] * n + a[8] * i,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const Ua = new kt;
kt.NAMES = bB;
let OX = 0;
class Va extends sc {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: OX++
        }),
        this.uuid = To(),
        this.name = "",
        this.type = "Material",
        this.blending = tp,
        this.side = tf,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = jS,
        this.blendDst = WS,
        this.blendEquation = rh,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.blendColor = new kt(0,0,0),
        this.blendAlpha = 0,
        this.depthFunc = up,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = cw,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = Pd,
        this.stencilZFail = Pd,
        this.stencilZPass = Pd,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.allowOverride = !0,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const n = e[t];
                if (n === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue
                }
                const i = this[t];
                if (i === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue
                }
                i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const n = {
            metadata: {
                version: 4.7,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        n.uuid = this.uuid,
        n.type = this.type,
        this.name !== "" && (n.name = this.name),
        this.color && this.color.isColor && (n.color = this.color.getHex()),
        this.roughness !== void 0 && (n.roughness = this.roughness),
        this.metalness !== void 0 && (n.metalness = this.metalness),
        this.sheen !== void 0 && (n.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
        this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (n.shininess = this.shininess),
        this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.sheenColorMap && this.sheenColorMap.isTexture && (n.sheenColorMap = this.sheenColorMap.toJSON(e).uuid),
        this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture && (n.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(e).uuid),
        this.dispersion !== void 0 && (n.dispersion = this.dispersion),
        this.iridescence !== void 0 && (n.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
        n.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
        n.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
        n.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
        n.normalMapType = this.normalMapType,
        n.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
        n.displacementScale = this.displacementScale,
        n.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (n.combine = this.combine)),
        this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()),
        this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (n.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (n.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (n.size = this.size),
        this.shadowSide !== null && (n.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation),
        this.blending !== tp && (n.blending = this.blending),
        this.side !== tf && (n.side = this.side),
        this.vertexColors === !0 && (n.vertexColors = !0),
        this.opacity < 1 && (n.opacity = this.opacity),
        this.transparent === !0 && (n.transparent = !0),
        this.blendSrc !== jS && (n.blendSrc = this.blendSrc),
        this.blendDst !== WS && (n.blendDst = this.blendDst),
        this.blendEquation !== rh && (n.blendEquation = this.blendEquation),
        this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
        this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
        this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
        this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
        this.depthFunc !== up && (n.depthFunc = this.depthFunc),
        this.depthTest === !1 && (n.depthTest = this.depthTest),
        this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
        this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
        this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask),
        this.stencilFunc !== cw && (n.stencilFunc = this.stencilFunc),
        this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
        this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== Pd && (n.stencilFail = this.stencilFail),
        this.stencilZFail !== Pd && (n.stencilZFail = this.stencilZFail),
        this.stencilZPass !== Pd && (n.stencilZPass = this.stencilZPass),
        this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
        this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation),
        this.polygonOffset === !0 && (n.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth),
        this.dashSize !== void 0 && (n.dashSize = this.dashSize),
        this.gapSize !== void 0 && (n.gapSize = this.gapSize),
        this.scale !== void 0 && (n.scale = this.scale),
        this.dithering === !0 && (n.dithering = !0),
        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (n.alphaHash = !0),
        this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (n.forceSinglePass = !0),
        this.wireframe === !0 && (n.wireframe = !0),
        this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (n.flatShading = !0),
        this.visible === !1 && (n.visible = !1),
        this.toneMapped === !1 && (n.toneMapped = !1),
        this.fog === !1 && (n.fog = !1),
        Object.keys(this.userData).length > 0 && (n.userData = this.userData);
        function i(a) {
            const s = [];
            for (const l in a) {
                const u = a[l];
                delete u.metadata,
                s.push(u)
            }
            return s
        }
        if (t) {
            const a = i(e.textures)
              , s = i(e.images);
            a.length > 0 && (n.textures = a),
            s.length > 0 && (n.images = s)
        }
        return n
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.blendColor.copy(e.blendColor),
        this.blendAlpha = e.blendAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let n = null;
        if (t !== null) {
            const i = t.length;
            n = new Array(i);
            for (let a = 0; a !== i; ++a)
                n[a] = t[a].clone()
        }
        return this.clippingPlanes = n,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaHash = e.alphaHash,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
class oc extends Va {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new kt(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Co,
        this.combine = c_,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const jc = NX();
function NX() {
    const r = new ArrayBuffer(4)
      , e = new Float32Array(r)
      , t = new Uint32Array(r)
      , n = new Uint32Array(512)
      , i = new Uint32Array(512);
    for (let u = 0; u < 256; ++u) {
        const f = u - 127;
        f < -27 ? (n[u] = 0,
        n[u | 256] = 32768,
        i[u] = 24,
        i[u | 256] = 24) : f < -14 ? (n[u] = 1024 >> -f - 14,
        n[u | 256] = 1024 >> -f - 14 | 32768,
        i[u] = -f - 1,
        i[u | 256] = -f - 1) : f <= 15 ? (n[u] = f + 15 << 10,
        n[u | 256] = f + 15 << 10 | 32768,
        i[u] = 13,
        i[u | 256] = 13) : f < 128 ? (n[u] = 31744,
        n[u | 256] = 64512,
        i[u] = 24,
        i[u | 256] = 24) : (n[u] = 31744,
        n[u | 256] = 64512,
        i[u] = 13,
        i[u | 256] = 13)
    }
    const a = new Uint32Array(2048)
      , s = new Uint32Array(64)
      , l = new Uint32Array(64);
    for (let u = 1; u < 1024; ++u) {
        let f = u << 13
          , d = 0;
        for (; (f & 8388608) === 0; )
            f <<= 1,
            d -= 8388608;
        f &= -8388609,
        d += 947912704,
        a[u] = f | d
    }
    for (let u = 1024; u < 2048; ++u)
        a[u] = 939524096 + (u - 1024 << 13);
    for (let u = 1; u < 31; ++u)
        s[u] = u << 23;
    s[31] = 1199570944,
    s[32] = 2147483648;
    for (let u = 33; u < 63; ++u)
        s[u] = 2147483648 + (u - 32 << 23);
    s[63] = 3347054592;
    for (let u = 1; u < 64; ++u)
        u !== 32 && (l[u] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: n,
        shiftTable: i,
        mantissaTable: a,
        exponentTable: s,
        offsetTable: l
    }
}
function Fs(r) {
    Math.abs(r) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    r = gn(r, -65504, 65504),
    jc.floatView[0] = r;
    const e = jc.uint32View[0]
      , t = e >> 23 & 511;
    return jc.baseTable[t] + ((e & 8388607) >> jc.shiftTable[t])
}
function Ov(r) {
    const e = r >> 10;
    return jc.uint32View[0] = jc.mantissaTable[jc.offsetTable[e] + (r & 1023)] + jc.exponentTable[e],
    jc.floatView[0]
}
class jd {
    static toHalfFloat(e) {
        return Fs(e)
    }
    static fromHalfFloat(e) {
        return Ov(e)
    }
}
const Tr = new he
  , sx = new xt;
let LX = 0;
class xi {
    constructor(e, t, n=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        Object.defineProperty(this, "id", {
            value: LX++
        }),
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = n,
        this.usage = Vy,
        this.updateRanges = [],
        this.gpuType = tr,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this.gpuType = e.gpuType,
        this
    }
    copyAt(e, t, n) {
        e *= this.itemSize,
        n *= t.itemSize;
        for (let i = 0, a = this.itemSize; i < a; i++)
            this.array[e + i] = t.array[n + i];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, n = this.count; t < n; t++)
                sx.fromBufferAttribute(this, t),
                sx.applyMatrix3(e),
                this.setXY(t, sx.x, sx.y);
        else if (this.itemSize === 3)
            for (let t = 0, n = this.count; t < n; t++)
                Tr.fromBufferAttribute(this, t),
                Tr.applyMatrix3(e),
                this.setXYZ(t, Tr.x, Tr.y, Tr.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, n = this.count; t < n; t++)
            Tr.fromBufferAttribute(this, t),
            Tr.applyMatrix4(e),
            this.setXYZ(t, Tr.x, Tr.y, Tr.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
            Tr.fromBufferAttribute(this, t),
            Tr.applyNormalMatrix(e),
            this.setXYZ(t, Tr.x, Tr.y, Tr.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
            Tr.fromBufferAttribute(this, t),
            Tr.transformDirection(e),
            this.setXYZ(t, Tr.x, Tr.y, Tr.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getComponent(e, t) {
        let n = this.array[e * this.itemSize + t];
        return this.normalized && (n = ps(n, this.array)),
        n
    }
    setComponent(e, t, n) {
        return this.normalized && (n = On(n, this.array)),
        this.array[e * this.itemSize + t] = n,
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = ps(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = On(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = ps(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = On(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = ps(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = On(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = ps(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = On(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, n) {
        return e *= this.itemSize,
        this.normalized && (t = On(t, this.array),
        n = On(n, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this
    }
    setXYZ(e, t, n, i) {
        return e *= this.itemSize,
        this.normalized && (t = On(t, this.array),
        n = On(n, this.array),
        i = On(i, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this.array[e + 2] = i,
        this
    }
    setXYZW(e, t, n, i, a) {
        return e *= this.itemSize,
        this.normalized && (t = On(t, this.array),
        n = On(n, this.array),
        i = On(i, this.array),
        a = On(a, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this.array[e + 2] = i,
        this.array[e + 3] = a,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== Vy && (e.usage = this.usage),
        e
    }
}
class PX extends xi {
    constructor(e, t, n) {
        super(new Int8Array(e), t, n)
    }
}
class BX extends xi {
    constructor(e, t, n) {
        super(new Uint8Array(e), t, n)
    }
}
class zX extends xi {
    constructor(e, t, n) {
        super(new Uint8ClampedArray(e), t, n)
    }
}
class IX extends xi {
    constructor(e, t, n) {
        super(new Int16Array(e), t, n)
    }
}
class oC extends xi {
    constructor(e, t, n) {
        super(new Uint16Array(e), t, n)
    }
}
class FX extends xi {
    constructor(e, t, n) {
        super(new Int32Array(e), t, n)
    }
}
class lC extends xi {
    constructor(e, t, n) {
        super(new Uint32Array(e), t, n)
    }
}
class HX extends xi {
    constructor(e, t, n) {
        super(new Uint16Array(e), t, n),
        this.isFloat16BufferAttribute = !0
    }
    getX(e) {
        let t = Ov(this.array[e * this.itemSize]);
        return this.normalized && (t = ps(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = On(t, this.array)),
        this.array[e * this.itemSize] = Fs(t),
        this
    }
    getY(e) {
        let t = Ov(this.array[e * this.itemSize + 1]);
        return this.normalized && (t = ps(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = On(t, this.array)),
        this.array[e * this.itemSize + 1] = Fs(t),
        this
    }
    getZ(e) {
        let t = Ov(this.array[e * this.itemSize + 2]);
        return this.normalized && (t = ps(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = On(t, this.array)),
        this.array[e * this.itemSize + 2] = Fs(t),
        this
    }
    getW(e) {
        let t = Ov(this.array[e * this.itemSize + 3]);
        return this.normalized && (t = ps(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = On(t, this.array)),
        this.array[e * this.itemSize + 3] = Fs(t),
        this
    }
    setXY(e, t, n) {
        return e *= this.itemSize,
        this.normalized && (t = On(t, this.array),
        n = On(n, this.array)),
        this.array[e + 0] = Fs(t),
        this.array[e + 1] = Fs(n),
        this
    }
    setXYZ(e, t, n, i) {
        return e *= this.itemSize,
        this.normalized && (t = On(t, this.array),
        n = On(n, this.array),
        i = On(i, this.array)),
        this.array[e + 0] = Fs(t),
        this.array[e + 1] = Fs(n),
        this.array[e + 2] = Fs(i),
        this
    }
    setXYZW(e, t, n, i, a) {
        return e *= this.itemSize,
        this.normalized && (t = On(t, this.array),
        n = On(n, this.array),
        i = On(i, this.array),
        a = On(a, this.array)),
        this.array[e + 0] = Fs(t),
        this.array[e + 1] = Fs(n),
        this.array[e + 2] = Fs(i),
        this.array[e + 3] = Fs(a),
        this
    }
}
class Qt extends xi {
    constructor(e, t, n) {
        super(new Float32Array(e), t, n)
    }
}
let VX = 0;
const Zo = new vn
  , vT = new ii
  , Am = new he
  , ho = new ea
  , mv = new ea
  , qr = new he;
class Nn extends sc {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: VX++
        }),
        this.uuid = To(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.indirect = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (_B(e) ? lC : oC)(e,1) : this.index = e,
        this
    }
    setIndirect(e) {
        return this.indirect = e,
        this
    }
    getIndirect() {
        return this.indirect
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, n=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: n
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const n = this.attributes.normal;
        if (n !== void 0) {
            const a = new An().getNormalMatrix(e);
            n.applyNormalMatrix(a),
            n.needsUpdate = !0
        }
        const i = this.attributes.tangent;
        return i !== void 0 && (i.transformDirection(e),
        i.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return Zo.makeRotationFromQuaternion(e),
        this.applyMatrix4(Zo),
        this
    }
    rotateX(e) {
        return Zo.makeRotationX(e),
        this.applyMatrix4(Zo),
        this
    }
    rotateY(e) {
        return Zo.makeRotationY(e),
        this.applyMatrix4(Zo),
        this
    }
    rotateZ(e) {
        return Zo.makeRotationZ(e),
        this.applyMatrix4(Zo),
        this
    }
    translate(e, t, n) {
        return Zo.makeTranslation(e, t, n),
        this.applyMatrix4(Zo),
        this
    }
    scale(e, t, n) {
        return Zo.makeScale(e, t, n),
        this.applyMatrix4(Zo),
        this
    }
    lookAt(e) {
        return vT.lookAt(e),
        vT.updateMatrix(),
        this.applyMatrix4(vT.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(Am).negate(),
        this.translate(Am.x, Am.y, Am.z),
        this
    }
    setFromPoints(e) {
        const t = this.getAttribute("position");
        if (t === void 0) {
            const n = [];
            for (let i = 0, a = e.length; i < a; i++) {
                const s = e[i];
                n.push(s.x, s.y, s.z || 0)
            }
            this.setAttribute("position", new Qt(n,3))
        } else {
            const n = Math.min(e.length, t.count);
            for (let i = 0; i < n; i++) {
                const a = e[i];
                t.setXYZ(i, a.x, a.y, a.z || 0)
            }
            e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),
            t.needsUpdate = !0
        }
        return this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new ea);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
            this.boundingBox.set(new he(-1 / 0,-1 / 0,-1 / 0), new he(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let n = 0, i = t.length; n < i; n++) {
                    const a = t[n];
                    ho.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (qr.addVectors(this.boundingBox.min, ho.min),
                    this.boundingBox.expandByPoint(qr),
                    qr.addVectors(this.boundingBox.max, ho.max),
                    this.boundingBox.expandByPoint(qr)) : (this.boundingBox.expandByPoint(ho.min),
                    this.boundingBox.expandByPoint(ho.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new ta);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
            this.boundingSphere.set(new he, 1 / 0);
            return
        }
        if (e) {
            const n = this.boundingSphere.center;
            if (ho.setFromBufferAttribute(e),
            t)
                for (let a = 0, s = t.length; a < s; a++) {
                    const l = t[a];
                    mv.setFromBufferAttribute(l),
                    this.morphTargetsRelative ? (qr.addVectors(ho.min, mv.min),
                    ho.expandByPoint(qr),
                    qr.addVectors(ho.max, mv.max),
                    ho.expandByPoint(qr)) : (ho.expandByPoint(mv.min),
                    ho.expandByPoint(mv.max))
                }
            ho.getCenter(n);
            let i = 0;
            for (let a = 0, s = e.count; a < s; a++)
                qr.fromBufferAttribute(e, a),
                i = Math.max(i, n.distanceToSquared(qr));
            if (t)
                for (let a = 0, s = t.length; a < s; a++) {
                    const l = t[a]
                      , u = this.morphTargetsRelative;
                    for (let f = 0, d = l.count; f < d; f++)
                        qr.fromBufferAttribute(l, f),
                        u && (Am.fromBufferAttribute(e, f),
                        qr.add(Am)),
                        i = Math.max(i, n.distanceToSquared(qr))
                }
            this.boundingSphere.radius = Math.sqrt(i),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const n = t.position
          , i = t.normal
          , a = t.uv;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new xi(new Float32Array(4 * n.count),4));
        const s = this.getAttribute("tangent")
          , l = []
          , u = [];
        for (let I = 0; I < n.count; I++)
            l[I] = new he,
            u[I] = new he;
        const f = new he
          , d = new he
          , g = new he
          , v = new xt
          , y = new xt
          , S = new xt
          , T = new he
          , M = new he;
        function b(I, N, P) {
            f.fromBufferAttribute(n, I),
            d.fromBufferAttribute(n, N),
            g.fromBufferAttribute(n, P),
            v.fromBufferAttribute(a, I),
            y.fromBufferAttribute(a, N),
            S.fromBufferAttribute(a, P),
            d.sub(f),
            g.sub(f),
            y.sub(v),
            S.sub(v);
            const Y = 1 / (y.x * S.y - S.x * y.y);
            isFinite(Y) && (T.copy(d).multiplyScalar(S.y).addScaledVector(g, -y.y).multiplyScalar(Y),
            M.copy(g).multiplyScalar(y.x).addScaledVector(d, -S.x).multiplyScalar(Y),
            l[I].add(T),
            l[N].add(T),
            l[P].add(T),
            u[I].add(M),
            u[N].add(M),
            u[P].add(M))
        }
        let A = this.groups;
        A.length === 0 && (A = [{
            start: 0,
            count: e.count
        }]);
        for (let I = 0, N = A.length; I < N; ++I) {
            const P = A[I]
              , Y = P.start
              , V = P.count;
            for (let K = Y, Z = Y + V; K < Z; K += 3)
                b(e.getX(K + 0), e.getX(K + 1), e.getX(K + 2))
        }
        const C = new he
          , R = new he
          , O = new he
          , L = new he;
        function z(I) {
            O.fromBufferAttribute(i, I),
            L.copy(O);
            const N = l[I];
            C.copy(N),
            C.sub(O.multiplyScalar(O.dot(N))).normalize(),
            R.crossVectors(L, N);
            const Y = R.dot(u[I]) < 0 ? -1 : 1;
            s.setXYZW(I, C.x, C.y, C.z, Y)
        }
        for (let I = 0, N = A.length; I < N; ++I) {
            const P = A[I]
              , Y = P.start
              , V = P.count;
            for (let K = Y, Z = Y + V; K < Z; K += 3)
                z(e.getX(K + 0)),
                z(e.getX(K + 1)),
                z(e.getX(K + 2))
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let n = this.getAttribute("normal");
            if (n === void 0)
                n = new xi(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", n);
            else
                for (let v = 0, y = n.count; v < y; v++)
                    n.setXYZ(v, 0, 0, 0);
            const i = new he
              , a = new he
              , s = new he
              , l = new he
              , u = new he
              , f = new he
              , d = new he
              , g = new he;
            if (e)
                for (let v = 0, y = e.count; v < y; v += 3) {
                    const S = e.getX(v + 0)
                      , T = e.getX(v + 1)
                      , M = e.getX(v + 2);
                    i.fromBufferAttribute(t, S),
                    a.fromBufferAttribute(t, T),
                    s.fromBufferAttribute(t, M),
                    d.subVectors(s, a),
                    g.subVectors(i, a),
                    d.cross(g),
                    l.fromBufferAttribute(n, S),
                    u.fromBufferAttribute(n, T),
                    f.fromBufferAttribute(n, M),
                    l.add(d),
                    u.add(d),
                    f.add(d),
                    n.setXYZ(S, l.x, l.y, l.z),
                    n.setXYZ(T, u.x, u.y, u.z),
                    n.setXYZ(M, f.x, f.y, f.z)
                }
            else
                for (let v = 0, y = t.count; v < y; v += 3)
                    i.fromBufferAttribute(t, v + 0),
                    a.fromBufferAttribute(t, v + 1),
                    s.fromBufferAttribute(t, v + 2),
                    d.subVectors(s, a),
                    g.subVectors(i, a),
                    d.cross(g),
                    n.setXYZ(v + 0, d.x, d.y, d.z),
                    n.setXYZ(v + 1, d.x, d.y, d.z),
                    n.setXYZ(v + 2, d.x, d.y, d.z);
            this.normalizeNormals(),
            n.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, n = e.count; t < n; t++)
            qr.fromBufferAttribute(e, t),
            qr.normalize(),
            e.setXYZ(t, qr.x, qr.y, qr.z)
    }
    toNonIndexed() {
        function e(l, u) {
            const f = l.array
              , d = l.itemSize
              , g = l.normalized
              , v = new f.constructor(u.length * d);
            let y = 0
              , S = 0;
            for (let T = 0, M = u.length; T < M; T++) {
                l.isInterleavedBufferAttribute ? y = u[T] * l.data.stride + l.offset : y = u[T] * d;
                for (let b = 0; b < d; b++)
                    v[S++] = f[y++]
            }
            return new xi(v,d,g)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new Nn
          , n = this.index.array
          , i = this.attributes;
        for (const l in i) {
            const u = i[l]
              , f = e(u, n);
            t.setAttribute(l, f)
        }
        const a = this.morphAttributes;
        for (const l in a) {
            const u = []
              , f = a[l];
            for (let d = 0, g = f.length; d < g; d++) {
                const v = f[d]
                  , y = e(v, n);
                u.push(y)
            }
            t.morphAttributes[l] = u
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const s = this.groups;
        for (let l = 0, u = s.length; l < u; l++) {
            const f = s[l];
            t.addGroup(f.start, f.count, f.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.7,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const u = this.parameters;
            for (const f in u)
                u[f] !== void 0 && (e[f] = u[f]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const n = this.attributes;
        for (const u in n) {
            const f = n[u];
            e.data.attributes[u] = f.toJSON(e.data)
        }
        const i = {};
        let a = !1;
        for (const u in this.morphAttributes) {
            const f = this.morphAttributes[u]
              , d = [];
            for (let g = 0, v = f.length; g < v; g++) {
                const y = f[g];
                d.push(y.toJSON(e.data))
            }
            d.length > 0 && (i[u] = d,
            a = !0)
        }
        a && (e.data.morphAttributes = i,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const s = this.groups;
        s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
        const l = this.boundingSphere;
        return l !== null && (e.data.boundingSphere = l.toJSON()),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const n = e.index;
        n !== null && this.setIndex(n.clone());
        const i = e.attributes;
        for (const f in i) {
            const d = i[f];
            this.setAttribute(f, d.clone(t))
        }
        const a = e.morphAttributes;
        for (const f in a) {
            const d = []
              , g = a[f];
            for (let v = 0, y = g.length; v < y; v++)
                d.push(g[v].clone(t));
            this.morphAttributes[f] = d
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const s = e.groups;
        for (let f = 0, d = s.length; f < d; f++) {
            const g = s[f];
            this.addGroup(g.start, g.count, g.materialIndex)
        }
        const l = e.boundingBox;
        l !== null && (this.boundingBox = l.clone());
        const u = e.boundingSphere;
        return u !== null && (this.boundingSphere = u.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const uU = new vn
  , xd = new jg
  , ox = new ta
  , cU = new he
  , lx = new he
  , ux = new he
  , cx = new he
  , yT = new he
  , fx = new he
  , fU = new he
  , hx = new he;
class Ni extends ii {
    constructor(e=new Nn, t=new oc) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.morphTargetDictionary = void 0,
        this.morphTargetInfluences = void 0,
        this.count = 1,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , n = Object.keys(t);
        if (n.length > 0) {
            const i = t[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let a = 0, s = i.length; a < s; a++) {
                    const l = i[a].name || String(a);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[l] = a
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const n = this.geometry
          , i = n.attributes.position
          , a = n.morphAttributes.position
          , s = n.morphTargetsRelative;
        t.fromBufferAttribute(i, e);
        const l = this.morphTargetInfluences;
        if (a && l) {
            fx.set(0, 0, 0);
            for (let u = 0, f = a.length; u < f; u++) {
                const d = l[u]
                  , g = a[u];
                d !== 0 && (yT.fromBufferAttribute(g, e),
                s ? fx.addScaledVector(yT, d) : fx.addScaledVector(yT.sub(t), d))
            }
            t.add(fx)
        }
        return t
    }
    raycast(e, t) {
        const n = this.geometry
          , i = this.material
          , a = this.matrixWorld;
        i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(),
        ox.copy(n.boundingSphere),
        ox.applyMatrix4(a),
        xd.copy(e.ray).recast(e.near),
        !(ox.containsPoint(xd.origin) === !1 && (xd.intersectSphere(ox, cU) === null || xd.origin.distanceToSquared(cU) > (e.far - e.near) ** 2)) && (uU.copy(a).invert(),
        xd.copy(e.ray).applyMatrix4(uU),
        !(n.boundingBox !== null && xd.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, xd)))
    }
    _computeIntersections(e, t, n) {
        let i;
        const a = this.geometry
          , s = this.material
          , l = a.index
          , u = a.attributes.position
          , f = a.attributes.uv
          , d = a.attributes.uv1
          , g = a.attributes.normal
          , v = a.groups
          , y = a.drawRange;
        if (l !== null)
            if (Array.isArray(s))
                for (let S = 0, T = v.length; S < T; S++) {
                    const M = v[S]
                      , b = s[M.materialIndex]
                      , A = Math.max(M.start, y.start)
                      , C = Math.min(l.count, Math.min(M.start + M.count, y.start + y.count));
                    for (let R = A, O = C; R < O; R += 3) {
                        const L = l.getX(R)
                          , z = l.getX(R + 1)
                          , I = l.getX(R + 2);
                        i = dx(this, b, e, n, f, d, g, L, z, I),
                        i && (i.faceIndex = Math.floor(R / 3),
                        i.face.materialIndex = M.materialIndex,
                        t.push(i))
                    }
                }
            else {
                const S = Math.max(0, y.start)
                  , T = Math.min(l.count, y.start + y.count);
                for (let M = S, b = T; M < b; M += 3) {
                    const A = l.getX(M)
                      , C = l.getX(M + 1)
                      , R = l.getX(M + 2);
                    i = dx(this, s, e, n, f, d, g, A, C, R),
                    i && (i.faceIndex = Math.floor(M / 3),
                    t.push(i))
                }
            }
        else if (u !== void 0)
            if (Array.isArray(s))
                for (let S = 0, T = v.length; S < T; S++) {
                    const M = v[S]
                      , b = s[M.materialIndex]
                      , A = Math.max(M.start, y.start)
                      , C = Math.min(u.count, Math.min(M.start + M.count, y.start + y.count));
                    for (let R = A, O = C; R < O; R += 3) {
                        const L = R
                          , z = R + 1
                          , I = R + 2;
                        i = dx(this, b, e, n, f, d, g, L, z, I),
                        i && (i.faceIndex = Math.floor(R / 3),
                        i.face.materialIndex = M.materialIndex,
                        t.push(i))
                    }
                }
            else {
                const S = Math.max(0, y.start)
                  , T = Math.min(u.count, y.start + y.count);
                for (let M = S, b = T; M < b; M += 3) {
                    const A = M
                      , C = M + 1
                      , R = M + 2;
                    i = dx(this, s, e, n, f, d, g, A, C, R),
                    i && (i.faceIndex = Math.floor(M / 3),
                    t.push(i))
                }
            }
    }
}
function kX(r, e, t, n, i, a, s, l) {
    let u;
    if (e.side === vs ? u = n.intersectTriangle(s, a, i, !0, l) : u = n.intersectTriangle(i, a, s, e.side === tf, l),
    u === null)
        return null;
    hx.copy(l),
    hx.applyMatrix4(r.matrixWorld);
    const f = t.ray.origin.distanceTo(hx);
    return f < t.near || f > t.far ? null : {
        distance: f,
        point: hx.clone(),
        object: r
    }
}
function dx(r, e, t, n, i, a, s, l, u, f) {
    r.getVertexPosition(l, lx),
    r.getVertexPosition(u, ux),
    r.getVertexPosition(f, cx);
    const d = kX(r, e, t, n, lx, ux, cx, fU);
    if (d) {
        const g = new he;
        Vs.getBarycoord(fU, lx, ux, cx, g),
        i && (d.uv = Vs.getInterpolatedAttribute(i, l, u, f, g, new xt)),
        a && (d.uv1 = Vs.getInterpolatedAttribute(a, l, u, f, g, new xt)),
        s && (d.normal = Vs.getInterpolatedAttribute(s, l, u, f, g, new he),
        d.normal.dot(n.direction) > 0 && d.normal.multiplyScalar(-1));
        const v = {
            a: l,
            b: u,
            c: f,
            normal: new he,
            materialIndex: 0
        };
        Vs.getNormal(lx, ux, cx, v.normal),
        d.face = v,
        d.barycoord = g
    }
    return d
}
class yp extends Nn {
    constructor(e=1, t=1, n=1, i=1, a=1, s=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: n,
            widthSegments: i,
            heightSegments: a,
            depthSegments: s
        };
        const l = this;
        i = Math.floor(i),
        a = Math.floor(a),
        s = Math.floor(s);
        const u = []
          , f = []
          , d = []
          , g = [];
        let v = 0
          , y = 0;
        S("z", "y", "x", -1, -1, n, t, e, s, a, 0),
        S("z", "y", "x", 1, -1, n, t, -e, s, a, 1),
        S("x", "z", "y", 1, 1, e, n, t, i, s, 2),
        S("x", "z", "y", 1, -1, e, n, -t, i, s, 3),
        S("x", "y", "z", 1, -1, e, t, n, i, a, 4),
        S("x", "y", "z", -1, -1, e, t, -n, i, a, 5),
        this.setIndex(u),
        this.setAttribute("position", new Qt(f,3)),
        this.setAttribute("normal", new Qt(d,3)),
        this.setAttribute("uv", new Qt(g,2));
        function S(T, M, b, A, C, R, O, L, z, I, N) {
            const P = R / z
              , Y = O / I
              , V = R / 2
              , K = O / 2
              , Z = L / 2
              , oe = z + 1
              , H = I + 1;
            let q = 0
              , Q = 0;
            const se = new he;
            for (let B = 0; B < H; B++) {
                const W = B * Y - K;
                for (let te = 0; te < oe; te++) {
                    const fe = te * P - V;
                    se[T] = fe * A,
                    se[M] = W * C,
                    se[b] = Z,
                    f.push(se.x, se.y, se.z),
                    se[T] = 0,
                    se[M] = 0,
                    se[b] = L > 0 ? 1 : -1,
                    d.push(se.x, se.y, se.z),
                    g.push(te / z),
                    g.push(1 - B / I),
                    q += 1
                }
            }
            for (let B = 0; B < I; B++)
                for (let W = 0; W < z; W++) {
                    const te = v + W + oe * B
                      , fe = v + W + oe * (B + 1)
                      , pe = v + (W + 1) + oe * (B + 1)
                      , _e = v + (W + 1) + oe * B;
                    u.push(te, fe, _e),
                    u.push(fe, pe, _e),
                    Q += 6
                }
            l.addGroup(y, Q, N),
            y += Q,
            v += q
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new yp(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function Ug(r) {
    const e = {};
    for (const t in r) {
        e[t] = {};
        for (const n in r[t]) {
            const i = r[t][n];
            i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
            e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i
        }
    }
    return e
}
function ls(r) {
    const e = {};
    for (let t = 0; t < r.length; t++) {
        const n = Ug(r[t]);
        for (const i in n)
            e[i] = n[i]
    }
    return e
}
function GX(r) {
    const e = [];
    for (let t = 0; t < r.length; t++)
        e.push(r[t].clone());
    return e
}
function MB(r) {
    const e = r.getRenderTarget();
    return e === null ? r.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Kn.workingColorSpace
}
const uC = {
    clone: Ug,
    merge: ls
};
var XX = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , jX = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Ks extends Va {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = XX,
        this.fragmentShader = jX,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            clipCullDistance: !1,
            multiDraw: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = Ug(e.uniforms),
        this.uniformsGroups = GX(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const i in this.uniforms) {
            const s = this.uniforms[i].value;
            s && s.isTexture ? t.uniforms[i] = {
                type: "t",
                value: s.toJSON(e).uuid
            } : s && s.isColor ? t.uniforms[i] = {
                type: "c",
                value: s.getHex()
            } : s && s.isVector2 ? t.uniforms[i] = {
                type: "v2",
                value: s.toArray()
            } : s && s.isVector3 ? t.uniforms[i] = {
                type: "v3",
                value: s.toArray()
            } : s && s.isVector4 ? t.uniforms[i] = {
                type: "v4",
                value: s.toArray()
            } : s && s.isMatrix3 ? t.uniforms[i] = {
                type: "m3",
                value: s.toArray()
            } : s && s.isMatrix4 ? t.uniforms[i] = {
                type: "m4",
                value: s.toArray()
            } : t.uniforms[i] = {
                value: s
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader,
        t.lights = this.lights,
        t.clipping = this.clipping;
        const n = {};
        for (const i in this.extensions)
            this.extensions[i] === !0 && (n[i] = !0);
        return Object.keys(n).length > 0 && (t.extensions = n),
        t
    }
}
class pM extends ii {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new vn,
        this.projectionMatrix = new vn,
        this.projectionMatrixInverse = new vn,
        this.coordinateSystem = bo,
        this._reversedDepth = !1
    }
    get reversedDepth() {
        return this._reversedDepth
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this.coordinateSystem = e.coordinateSystem,
        this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Zf = new he
  , hU = new xt
  , dU = new xt;
class Jr extends pM {
    constructor(e=50, t=1, n=.1, i=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = n,
        this.far = i,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = Rg * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(np * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return Rg * 2 * Math.atan(Math.tan(np * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(e, t, n) {
        Zf.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
        t.set(Zf.x, Zf.y).multiplyScalar(-e / Zf.z),
        Zf.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
        n.set(Zf.x, Zf.y).multiplyScalar(-e / Zf.z)
    }
    getViewSize(e, t) {
        return this.getViewBounds(e, hU, dU),
        t.subVectors(dU, hU)
    }
    setViewOffset(e, t, n, i, a, s) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = n,
        this.view.offsetY = i,
        this.view.width = a,
        this.view.height = s,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(np * .5 * this.fov) / this.zoom
          , n = 2 * t
          , i = this.aspect * n
          , a = -.5 * i;
        const s = this.view;
        if (this.view !== null && this.view.enabled) {
            const u = s.fullWidth
              , f = s.fullHeight;
            a += s.offsetX * i / u,
            t -= s.offsetY * n / f,
            i *= s.width / u,
            n *= s.height / f
        }
        const l = this.filmOffset;
        l !== 0 && (a += e * l / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(a, a + i, t, t - n, e, this.far, this.coordinateSystem, this.reversedDepth),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const Cm = -90
  , Rm = 1;
class TB extends ii {
    constructor(e, t, n) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = n,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const i = new Jr(Cm,Rm,e,t);
        i.layers = this.layers,
        this.add(i);
        const a = new Jr(Cm,Rm,e,t);
        a.layers = this.layers,
        this.add(a);
        const s = new Jr(Cm,Rm,e,t);
        s.layers = this.layers,
        this.add(s);
        const l = new Jr(Cm,Rm,e,t);
        l.layers = this.layers,
        this.add(l);
        const u = new Jr(Cm,Rm,e,t);
        u.layers = this.layers,
        this.add(u);
        const f = new Jr(Cm,Rm,e,t);
        f.layers = this.layers,
        this.add(f)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem
          , t = this.children.concat()
          , [n,i,a,s,l,u] = t;
        for (const f of t)
            this.remove(f);
        if (e === bo)
            n.up.set(0, 1, 0),
            n.lookAt(1, 0, 0),
            i.up.set(0, 1, 0),
            i.lookAt(-1, 0, 0),
            a.up.set(0, 0, -1),
            a.lookAt(0, 1, 0),
            s.up.set(0, 0, 1),
            s.lookAt(0, -1, 0),
            l.up.set(0, 1, 0),
            l.lookAt(0, 0, 1),
            u.up.set(0, 1, 0),
            u.lookAt(0, 0, -1);
        else if (e === Cg)
            n.up.set(0, -1, 0),
            n.lookAt(-1, 0, 0),
            i.up.set(0, -1, 0),
            i.lookAt(1, 0, 0),
            a.up.set(0, 0, 1),
            a.lookAt(0, 1, 0),
            s.up.set(0, 0, -1),
            s.lookAt(0, -1, 0),
            l.up.set(0, -1, 0),
            l.lookAt(0, 0, 1),
            u.up.set(0, -1, 0),
            u.lookAt(0, 0, -1);
        else
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const f of t)
            this.add(f),
            f.updateMatrixWorld()
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const {renderTarget: n, activeMipmapLevel: i} = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
        this.updateCoordinateSystem());
        const [a,s,l,u,f,d] = this.children
          , g = e.getRenderTarget()
          , v = e.getActiveCubeFace()
          , y = e.getActiveMipmapLevel()
          , S = e.xr.enabled;
        e.xr.enabled = !1;
        const T = n.texture.generateMipmaps;
        n.texture.generateMipmaps = !1,
        e.setRenderTarget(n, 0, i),
        e.render(t, a),
        e.setRenderTarget(n, 1, i),
        e.render(t, s),
        e.setRenderTarget(n, 2, i),
        e.render(t, l),
        e.setRenderTarget(n, 3, i),
        e.render(t, u),
        e.setRenderTarget(n, 4, i),
        e.render(t, f),
        n.texture.generateMipmaps = T,
        e.setRenderTarget(n, 5, i),
        e.render(t, d),
        e.setRenderTarget(g, v, y),
        e.xr.enabled = S,
        n.texture.needsPMREMUpdate = !0
    }
}
class p_ extends _i {
    constructor(e=[], t=ic, n, i, a, s, l, u, f, d) {
        super(e, t, n, i, a, s, l, u, f, d),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class cC extends sl {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const n = {
            width: e,
            height: e,
            depth: 1
        }
          , i = [n, n, n, n, n, n];
        this.texture = new p_(i),
        this._setTextureOptions(t),
        this.texture.isRenderTargetTexture = !0
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.colorSpace = t.colorSpace,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const n = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , i = new yp(5,5,5)
          , a = new Ks({
            name: "CubemapFromEquirect",
            uniforms: Ug(n.uniforms),
            vertexShader: n.vertexShader,
            fragmentShader: n.fragmentShader,
            side: vs,
            blending: Qu
        });
        a.uniforms.tEquirect.value = t;
        const s = new Ni(i,a)
          , l = t.minFilter;
        return t.minFilter === Gu && (t.minFilter = fi),
        new TB(1,10,this).update(e, s),
        t.minFilter = l,
        s.geometry.dispose(),
        s.material.dispose(),
        this
    }
    clear(e, t=!0, n=!0, i=!0) {
        const a = e.getRenderTarget();
        for (let s = 0; s < 6; s++)
            e.setRenderTarget(this, s),
            e.clear(t, n, i);
        e.setRenderTarget(a)
    }
}
class ig extends ii {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const WX = {
    type: "move"
};
class xS {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new ig,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new ig,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new he,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new he),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new ig,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new he,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new he),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const n of e.hand.values())
                    this._getHandJoint(t, n)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, n) {
        let i = null
          , a = null
          , s = null;
        const l = this._targetRay
          , u = this._grip
          , f = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (f && e.hand) {
                s = !0;
                for (const T of e.hand.values()) {
                    const M = t.getJointPose(T, n)
                      , b = this._getHandJoint(f, T);
                    M !== null && (b.matrix.fromArray(M.transform.matrix),
                    b.matrix.decompose(b.position, b.rotation, b.scale),
                    b.matrixWorldNeedsUpdate = !0,
                    b.jointRadius = M.radius),
                    b.visible = M !== null
                }
                const d = f.joints["index-finger-tip"]
                  , g = f.joints["thumb-tip"]
                  , v = d.position.distanceTo(g.position)
                  , y = .02
                  , S = .005;
                f.inputState.pinching && v > y + S ? (f.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !f.inputState.pinching && v <= y - S && (f.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                u !== null && e.gripSpace && (a = t.getPose(e.gripSpace, n),
                a !== null && (u.matrix.fromArray(a.transform.matrix),
                u.matrix.decompose(u.position, u.rotation, u.scale),
                u.matrixWorldNeedsUpdate = !0,
                a.linearVelocity ? (u.hasLinearVelocity = !0,
                u.linearVelocity.copy(a.linearVelocity)) : u.hasLinearVelocity = !1,
                a.angularVelocity ? (u.hasAngularVelocity = !0,
                u.angularVelocity.copy(a.angularVelocity)) : u.hasAngularVelocity = !1));
            l !== null && (i = t.getPose(e.targetRaySpace, n),
            i === null && a !== null && (i = a),
            i !== null && (l.matrix.fromArray(i.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            l.matrixWorldNeedsUpdate = !0,
            i.linearVelocity ? (l.hasLinearVelocity = !0,
            l.linearVelocity.copy(i.linearVelocity)) : l.hasLinearVelocity = !1,
            i.angularVelocity ? (l.hasAngularVelocity = !0,
            l.angularVelocity.copy(i.angularVelocity)) : l.hasAngularVelocity = !1,
            this.dispatchEvent(WX)))
        }
        return l !== null && (l.visible = i !== null),
        u !== null && (u.visible = a !== null),
        f !== null && (f.visible = s !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const n = new ig;
            n.matrixAutoUpdate = !1,
            n.visible = !1,
            e.joints[t.jointName] = n,
            e.add(n)
        }
        return e.joints[t.jointName]
    }
}
class mM {
    constructor(e, t=25e-5) {
        this.isFogExp2 = !0,
        this.name = "",
        this.color = new kt(e),
        this.density = t
    }
    clone() {
        return new mM(this.color,this.density)
    }
    toJSON() {
        return {
            type: "FogExp2",
            name: this.name,
            color: this.color.getHex(),
            density: this.density
        }
    }
}
class gM {
    constructor(e, t=1, n=1e3) {
        this.isFog = !0,
        this.name = "",
        this.color = new kt(e),
        this.near = t,
        this.far = n
    }
    clone() {
        return new gM(this.color,this.near,this.far)
    }
    toJSON() {
        return {
            type: "Fog",
            name: this.name,
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
}
let m_ = class extends ii {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.backgroundRotation = new Co,
        this.environmentIntensity = 1,
        this.environmentRotation = new Co,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        this.backgroundRotation.copy(e.backgroundRotation),
        this.environmentIntensity = e.environmentIntensity,
        this.environmentRotation.copy(e.environmentRotation),
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
        t.object.backgroundRotation = this.backgroundRotation.toArray(),
        this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity),
        t.object.environmentRotation = this.environmentRotation.toArray(),
        t
    }
}
;
class vM {
    constructor(e, t) {
        this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.usage = Vy,
        this.updateRanges = [],
        this.version = 0,
        this.uuid = To()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, n) {
        e *= this.stride,
        n *= t.stride;
        for (let i = 0, a = this.stride; i < a; i++)
            this.array[e + i] = t.array[n + i];
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = To()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
          , n = new this.constructor(t,this.stride);
        return n.setUsage(this.usage),
        n
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = To()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const as = new he;
class cp {
    constructor(e, t, n, i=!1) {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = n,
        this.normalized = i
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, n = this.data.count; t < n; t++)
            as.fromBufferAttribute(this, t),
            as.applyMatrix4(e),
            this.setXYZ(t, as.x, as.y, as.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
            as.fromBufferAttribute(this, t),
            as.applyNormalMatrix(e),
            this.setXYZ(t, as.x, as.y, as.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
            as.fromBufferAttribute(this, t),
            as.transformDirection(e),
            this.setXYZ(t, as.x, as.y, as.z);
        return this
    }
    getComponent(e, t) {
        let n = this.array[e * this.data.stride + this.offset + t];
        return this.normalized && (n = ps(n, this.array)),
        n
    }
    setComponent(e, t, n) {
        return this.normalized && (n = On(n, this.array)),
        this.data.array[e * this.data.stride + this.offset + t] = n,
        this
    }
    setX(e, t) {
        return this.normalized && (t = On(t, this.array)),
        this.data.array[e * this.data.stride + this.offset] = t,
        this
    }
    setY(e, t) {
        return this.normalized && (t = On(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 1] = t,
        this
    }
    setZ(e, t) {
        return this.normalized && (t = On(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 2] = t,
        this
    }
    setW(e, t) {
        return this.normalized && (t = On(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 3] = t,
        this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = ps(t, this.array)),
        t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = ps(t, this.array)),
        t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = ps(t, this.array)),
        t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = ps(t, this.array)),
        t
    }
    setXY(e, t, n) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = On(t, this.array),
        n = On(n, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this
    }
    setXYZ(e, t, n, i) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = On(t, this.array),
        n = On(n, this.array),
        i = On(i, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this.data.array[e + 2] = i,
        this
    }
    setXYZW(e, t, n, i, a) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = On(t, this.array),
        n = On(n, this.array),
        i = On(i, this.array),
        a = On(a, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this.data.array[e + 2] = i,
        this.data.array[e + 3] = a,
        this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let n = 0; n < this.count; n++) {
                const i = n * this.data.stride + this.offset;
                for (let a = 0; a < this.itemSize; a++)
                    t.push(this.data.array[i + a])
            }
            return new xi(new this.array.constructor(t),this.itemSize,this.normalized)
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new cp(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let n = 0; n < this.count; n++) {
                const i = n * this.data.stride + this.offset;
                for (let a = 0; a < this.itemSize; a++)
                    t.push(this.data.array[i + a])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
class fC extends Va {
    constructor(e) {
        super(),
        this.isSpriteMaterial = !0,
        this.type = "SpriteMaterial",
        this.color = new kt(16777215),
        this.map = null,
        this.alphaMap = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.rotation = e.rotation,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
let Dm;
const gv = new he
  , Um = new he
  , Om = new he
  , Nm = new xt
  , vv = new xt
  , EB = new vn
  , px = new he
  , yv = new he
  , mx = new he
  , pU = new xt
  , _T = new xt
  , mU = new xt;
class wB extends ii {
    constructor(e=new fC) {
        if (super(),
        this.isSprite = !0,
        this.type = "Sprite",
        Dm === void 0) {
            Dm = new Nn;
            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
              , n = new vM(t,5);
            Dm.setIndex([0, 1, 2, 0, 2, 3]),
            Dm.setAttribute("position", new cp(n,3,0,!1)),
            Dm.setAttribute("uv", new cp(n,2,3,!1))
        }
        this.geometry = Dm,
        this.material = e,
        this.center = new xt(.5,.5),
        this.count = 1
    }
    raycast(e, t) {
        e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
        Um.setFromMatrixScale(this.matrixWorld),
        EB.copy(e.camera.matrixWorld),
        this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
        Om.setFromMatrixPosition(this.modelViewMatrix),
        e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Um.multiplyScalar(-Om.z);
        const n = this.material.rotation;
        let i, a;
        n !== 0 && (a = Math.cos(n),
        i = Math.sin(n));
        const s = this.center;
        gx(px.set(-.5, -.5, 0), Om, s, Um, i, a),
        gx(yv.set(.5, -.5, 0), Om, s, Um, i, a),
        gx(mx.set(.5, .5, 0), Om, s, Um, i, a),
        pU.set(0, 0),
        _T.set(1, 0),
        mU.set(1, 1);
        let l = e.ray.intersectTriangle(px, yv, mx, !1, gv);
        if (l === null && (gx(yv.set(-.5, .5, 0), Om, s, Um, i, a),
        _T.set(0, 1),
        l = e.ray.intersectTriangle(px, mx, yv, !1, gv),
        l === null))
            return;
        const u = e.ray.origin.distanceTo(gv);
        u < e.near || u > e.far || t.push({
            distance: u,
            point: gv.clone(),
            uv: Vs.getInterpolation(gv, px, yv, mx, pU, _T, mU, new xt),
            face: null,
            object: this
        })
    }
    copy(e, t) {
        return super.copy(e, t),
        e.center !== void 0 && this.center.copy(e.center),
        this.material = e.material,
        this
    }
}
function gx(r, e, t, n, i, a) {
    Nm.subVectors(r, t).addScalar(.5).multiply(n),
    i !== void 0 ? (vv.x = a * Nm.x - i * Nm.y,
    vv.y = i * Nm.x + a * Nm.y) : vv.copy(Nm),
    r.copy(e),
    r.x += vv.x,
    r.y += vv.y,
    r.applyMatrix4(EB)
}
const vx = new he
  , gU = new he;
class AB extends ii {
    constructor() {
        super(),
        this.isLOD = !0,
        this._currentLevel = 0,
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        }),
        this.autoUpdate = !0
    }
    copy(e) {
        super.copy(e, !1);
        const t = e.levels;
        for (let n = 0, i = t.length; n < i; n++) {
            const a = t[n];
            this.addLevel(a.object.clone(), a.distance, a.hysteresis)
        }
        return this.autoUpdate = e.autoUpdate,
        this
    }
    addLevel(e, t=0, n=0) {
        t = Math.abs(t);
        const i = this.levels;
        let a;
        for (a = 0; a < i.length && !(t < i[a].distance); a++)
            ;
        return i.splice(a, 0, {
            distance: t,
            hysteresis: n,
            object: e
        }),
        this.add(e),
        this
    }
    removeLevel(e) {
        const t = this.levels;
        for (let n = 0; n < t.length; n++)
            if (t[n].distance === e) {
                const i = t.splice(n, 1);
                return this.remove(i[0].object),
                !0
            }
        return !1
    }
    getCurrentLevel() {
        return this._currentLevel
    }
    getObjectForDistance(e) {
        const t = this.levels;
        if (t.length > 0) {
            let n, i;
            for (n = 1,
            i = t.length; n < i; n++) {
                let a = t[n].distance;
                if (t[n].object.visible && (a -= a * t[n].hysteresis),
                e < a)
                    break
            }
            return t[n - 1].object
        }
        return null
    }
    raycast(e, t) {
        if (this.levels.length > 0) {
            vx.setFromMatrixPosition(this.matrixWorld);
            const i = e.ray.origin.distanceTo(vx);
            this.getObjectForDistance(i).raycast(e, t)
        }
    }
    update(e) {
        const t = this.levels;
        if (t.length > 1) {
            vx.setFromMatrixPosition(e.matrixWorld),
            gU.setFromMatrixPosition(this.matrixWorld);
            const n = vx.distanceTo(gU) / e.zoom;
            t[0].object.visible = !0;
            let i, a;
            for (i = 1,
            a = t.length; i < a; i++) {
                let s = t[i].distance;
                if (t[i].object.visible && (s -= s * t[i].hysteresis),
                n >= s)
                    t[i - 1].object.visible = !1,
                    t[i].object.visible = !0;
                else
                    break
            }
            for (this._currentLevel = i - 1; i < a; i++)
                t[i].object.visible = !1
        }
    }
    toJSON(e) {
        const t = super.toJSON(e);
        this.autoUpdate === !1 && (t.object.autoUpdate = !1),
        t.object.levels = [];
        const n = this.levels;
        for (let i = 0, a = n.length; i < a; i++) {
            const s = n[i];
            t.object.levels.push({
                object: s.object.uuid,
                distance: s.distance,
                hysteresis: s.hysteresis
            })
        }
        return t
    }
}
const vU = new he
  , yU = new Qn
  , _U = new Qn
  , YX = new he
  , xU = new vn
  , yx = new he
  , xT = new ta
  , SU = new vn
  , ST = new jg;
class CB extends Ni {
    constructor(e, t) {
        super(e, t),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = lw,
        this.bindMatrix = new vn,
        this.bindMatrixInverse = new vn,
        this.boundingBox = null,
        this.boundingSphere = null
    }
    computeBoundingBox() {
        const e = this.geometry;
        this.boundingBox === null && (this.boundingBox = new ea),
        this.boundingBox.makeEmpty();
        const t = e.getAttribute("position");
        for (let n = 0; n < t.count; n++)
            this.getVertexPosition(n, yx),
            this.boundingBox.expandByPoint(yx)
    }
    computeBoundingSphere() {
        const e = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new ta),
        this.boundingSphere.makeEmpty();
        const t = e.getAttribute("position");
        for (let n = 0; n < t.count; n++)
            this.getVertexPosition(n, yx),
            this.boundingSphere.expandByPoint(yx)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.bindMode = e.bindMode,
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        this.skeleton = e.skeleton,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    raycast(e, t) {
        const n = this.material
          , i = this.matrixWorld;
        n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        xT.copy(this.boundingSphere),
        xT.applyMatrix4(i),
        e.ray.intersectsSphere(xT) !== !1 && (SU.copy(i).invert(),
        ST.copy(e.ray).applyMatrix4(SU),
        !(this.boundingBox !== null && ST.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, ST)))
    }
    getVertexPosition(e, t) {
        return super.getVertexPosition(e, t),
        this.applyBoneTransform(e, t),
        t
    }
    bind(e, t) {
        this.skeleton = e,
        t === void 0 && (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        t = this.matrixWorld),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new Qn
          , t = this.geometry.attributes.skinWeight;
        for (let n = 0, i = t.count; n < i; n++) {
            e.fromBufferAttribute(t, n);
            const a = 1 / e.manhattanLength();
            a !== 1 / 0 ? e.multiplyScalar(a) : e.set(1, 0, 0, 0),
            t.setXYZW(n, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.bindMode === lw ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === aB ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    applyBoneTransform(e, t) {
        const n = this.skeleton
          , i = this.geometry;
        yU.fromBufferAttribute(i.attributes.skinIndex, e),
        _U.fromBufferAttribute(i.attributes.skinWeight, e),
        vU.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
        for (let a = 0; a < 4; a++) {
            const s = _U.getComponent(a);
            if (s !== 0) {
                const l = yU.getComponent(a);
                xU.multiplyMatrices(n.bones[l].matrixWorld, n.boneInverses[l]),
                t.addScaledVector(YX.copy(vU).applyMatrix4(xU), s)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
}
class hC extends ii {
    constructor() {
        super(),
        this.isBone = !0,
        this.type = "Bone"
    }
}
class Kl extends _i {
    constructor(e=null, t=1, n=1, i, a, s, l, u, f=va, d=va, g, v) {
        super(null, s, l, u, f, d, i, a, g, v),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
const bU = new vn
  , qX = new vn;
class yM {
    constructor(e=[], t=[]) {
        this.uuid = To(),
        this.bones = e.slice(0),
        this.boneInverses = t,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.init()
    }
    init() {
        const e = this.bones
          , t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16),
        t.length === 0)
            this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
            this.boneInverses = [];
            for (let n = 0, i = this.bones.length; n < i; n++)
                this.boneInverses.push(new vn)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = new vn;
            this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(n)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n && n.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(),
            n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld),
            n.matrix.decompose(n.position, n.quaternion, n.scale))
        }
    }
    update() {
        const e = this.bones
          , t = this.boneInverses
          , n = this.boneMatrices
          , i = this.boneTexture;
        for (let a = 0, s = e.length; a < s; a++) {
            const l = e[a] ? e[a].matrixWorld : qX;
            bU.multiplyMatrices(l, t[a]),
            bU.toArray(n, a * 16)
        }
        i !== null && (i.needsUpdate = !0)
    }
    clone() {
        return new yM(this.bones,this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = Math.ceil(e / 4) * 4,
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const n = new Kl(t,e,e,vr,tr);
        return n.needsUpdate = !0,
        this.boneMatrices = t,
        this.boneTexture = n,
        this
    }
    getBoneByName(e) {
        for (let t = 0, n = this.bones.length; t < n; t++) {
            const i = this.bones[t];
            if (i.name === e)
                return i
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(),
        this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let n = 0, i = e.bones.length; n < i; n++) {
            const a = e.bones[n];
            let s = t[a];
            s === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", a),
            s = new hC),
            this.bones.push(s),
            this.boneInverses.push(new vn().fromArray(e.boneInverses[n]))
        }
        return this.init(),
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.7,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones
          , n = this.boneInverses;
        for (let i = 0, a = t.length; i < a; i++) {
            const s = t[i];
            e.bones.push(s.uuid);
            const l = n[i];
            e.boneInverses.push(l.toArray())
        }
        return e
    }
}
class fp extends xi {
    constructor(e, t, n, i=1) {
        super(e, t, n),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = i
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e
    }
}
const Lm = new vn
  , MU = new vn
  , _x = []
  , TU = new ea
  , ZX = new vn
  , _v = new Ni
  , xv = new ta;
class RB extends Ni {
    constructor(e, t, n) {
        super(e, t),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new fp(new Float32Array(n * 16),16),
        this.instanceColor = null,
        this.morphTexture = null,
        this.count = n,
        this.boundingBox = null,
        this.boundingSphere = null;
        for (let i = 0; i < n; i++)
            this.setMatrixAt(i, ZX)
    }
    computeBoundingBox() {
        const e = this.geometry
          , t = this.count;
        this.boundingBox === null && (this.boundingBox = new ea),
        e.boundingBox === null && e.computeBoundingBox(),
        this.boundingBox.makeEmpty();
        for (let n = 0; n < t; n++)
            this.getMatrixAt(n, Lm),
            TU.copy(e.boundingBox).applyMatrix4(Lm),
            this.boundingBox.union(TU)
    }
    computeBoundingSphere() {
        const e = this.geometry
          , t = this.count;
        this.boundingSphere === null && (this.boundingSphere = new ta),
        e.boundingSphere === null && e.computeBoundingSphere(),
        this.boundingSphere.makeEmpty();
        for (let n = 0; n < t; n++)
            this.getMatrixAt(n, Lm),
            xv.copy(e.boundingSphere).applyMatrix4(Lm),
            this.boundingSphere.union(xv)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.instanceMatrix.copy(e.instanceMatrix),
        e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
        this.count = e.count,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    getMorphAt(e, t) {
        const n = t.morphTargetInfluences
          , i = this.morphTexture.source.data.data
          , a = n.length + 1
          , s = e * a + 1;
        for (let l = 0; l < n.length; l++)
            n[l] = i[s + l]
    }
    raycast(e, t) {
        const n = this.matrixWorld
          , i = this.count;
        if (_v.geometry = this.geometry,
        _v.material = this.material,
        _v.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        xv.copy(this.boundingSphere),
        xv.applyMatrix4(n),
        e.ray.intersectsSphere(xv) !== !1))
            for (let a = 0; a < i; a++) {
                this.getMatrixAt(a, Lm),
                MU.multiplyMatrices(n, Lm),
                _v.matrixWorld = MU,
                _v.raycast(e, _x);
                for (let s = 0, l = _x.length; s < l; s++) {
                    const u = _x[s];
                    u.instanceId = a,
                    u.object = this,
                    t.push(u)
                }
                _x.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new fp(new Float32Array(this.instanceMatrix.count * 3).fill(1),3)),
        t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    setMorphAt(e, t) {
        const n = t.morphTargetInfluences
          , i = n.length + 1;
        this.morphTexture === null && (this.morphTexture = new Kl(new Float32Array(i * this.count),i,this.count,h_,tr));
        const a = this.morphTexture.source.data.data;
        let s = 0;
        for (let f = 0; f < n.length; f++)
            s += n[f];
        const l = this.geometry.morphTargetsRelative ? 1 : 1 - s
          , u = i * e;
        a[u] = l,
        a.set(n, u + 1)
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        }),
        this.morphTexture !== null && (this.morphTexture.dispose(),
        this.morphTexture = null)
    }
}
const bT = new he
  , KX = new he
  , QX = new An;
class nh {
    constructor(e=new he(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, n, i) {
        return this.normal.set(e, t, n),
        this.constant = i,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, n) {
        const i = bT.subVectors(n, t).cross(KX.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(i, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const n = e.delta(bT)
          , i = this.normal.dot(n);
        if (i === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const a = -(e.start.dot(this.normal) + this.constant) / i;
        return a < 0 || a > 1 ? null : t.copy(e.start).addScaledVector(n, a)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , n = this.distanceToPoint(e.end);
        return t < 0 && n > 0 || n < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const n = t || QX.getNormalMatrix(e)
          , i = this.coplanarPoint(bT).applyMatrix4(e)
          , a = this.normal.applyMatrix3(n).normalize();
        return this.constant = -i.dot(a),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Sd = new ta
  , JX = new xt(.5,.5)
  , xx = new he;
class Wg {
    constructor(e=new nh, t=new nh, n=new nh, i=new nh, a=new nh, s=new nh) {
        this.planes = [e, t, n, i, a, s]
    }
    set(e, t, n, i, a, s) {
        const l = this.planes;
        return l[0].copy(e),
        l[1].copy(t),
        l[2].copy(n),
        l[3].copy(i),
        l[4].copy(a),
        l[5].copy(s),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            t[n].copy(e.planes[n]);
        return this
    }
    setFromProjectionMatrix(e, t=bo, n=!1) {
        const i = this.planes
          , a = e.elements
          , s = a[0]
          , l = a[1]
          , u = a[2]
          , f = a[3]
          , d = a[4]
          , g = a[5]
          , v = a[6]
          , y = a[7]
          , S = a[8]
          , T = a[9]
          , M = a[10]
          , b = a[11]
          , A = a[12]
          , C = a[13]
          , R = a[14]
          , O = a[15];
        if (i[0].setComponents(f - s, y - d, b - S, O - A).normalize(),
        i[1].setComponents(f + s, y + d, b + S, O + A).normalize(),
        i[2].setComponents(f + l, y + g, b + T, O + C).normalize(),
        i[3].setComponents(f - l, y - g, b - T, O - C).normalize(),
        n)
            i[4].setComponents(u, v, M, R).normalize(),
            i[5].setComponents(f - u, y - v, b - M, O - R).normalize();
        else if (i[4].setComponents(f - u, y - v, b - M, O - R).normalize(),
        t === bo)
            i[5].setComponents(f + u, y + v, b + M, O + R).normalize();
        else if (t === Cg)
            i[5].setComponents(u, v, M, R).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            Sd.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(),
            Sd.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(Sd)
    }
    intersectsSprite(e) {
        Sd.center.set(0, 0, 0);
        const t = JX.distanceTo(e.center);
        return Sd.radius = .7071067811865476 + t,
        Sd.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(Sd)
    }
    intersectsSphere(e) {
        const t = this.planes
          , n = e.center
          , i = -e.radius;
        for (let a = 0; a < 6; a++)
            if (t[a].distanceToPoint(n) < i)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) {
            const i = t[n];
            if (xx.x = i.normal.x > 0 ? e.max.x : e.min.x,
            xx.y = i.normal.y > 0 ? e.max.y : e.min.y,
            xx.z = i.normal.z > 0 ? e.max.z : e.min.z,
            i.distanceToPoint(xx) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Bu = new vn
  , zu = new Wg;
class _M {
    constructor() {
        this.coordinateSystem = bo
    }
    intersectsObject(e, t) {
        if (!t.isArrayCamera || t.cameras.length === 0)
            return !1;
        for (let n = 0; n < t.cameras.length; n++) {
            const i = t.cameras[n];
            if (Bu.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
            zu.setFromProjectionMatrix(Bu, i.coordinateSystem, i.reversedDepth),
            zu.intersectsObject(e))
                return !0
        }
        return !1
    }
    intersectsSprite(e, t) {
        if (!t || !t.cameras || t.cameras.length === 0)
            return !1;
        for (let n = 0; n < t.cameras.length; n++) {
            const i = t.cameras[n];
            if (Bu.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
            zu.setFromProjectionMatrix(Bu, i.coordinateSystem, i.reversedDepth),
            zu.intersectsSprite(e))
                return !0
        }
        return !1
    }
    intersectsSphere(e, t) {
        if (!t || !t.cameras || t.cameras.length === 0)
            return !1;
        for (let n = 0; n < t.cameras.length; n++) {
            const i = t.cameras[n];
            if (Bu.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
            zu.setFromProjectionMatrix(Bu, i.coordinateSystem, i.reversedDepth),
            zu.intersectsSphere(e))
                return !0
        }
        return !1
    }
    intersectsBox(e, t) {
        if (!t || !t.cameras || t.cameras.length === 0)
            return !1;
        for (let n = 0; n < t.cameras.length; n++) {
            const i = t.cameras[n];
            if (Bu.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
            zu.setFromProjectionMatrix(Bu, i.coordinateSystem, i.reversedDepth),
            zu.intersectsBox(e))
                return !0
        }
        return !1
    }
    containsPoint(e, t) {
        if (!t || !t.cameras || t.cameras.length === 0)
            return !1;
        for (let n = 0; n < t.cameras.length; n++) {
            const i = t.cameras[n];
            if (Bu.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
            zu.setFromProjectionMatrix(Bu, i.coordinateSystem, i.reversedDepth),
            zu.containsPoint(e))
                return !0
        }
        return !1
    }
    clone() {
        return new _M
    }
}
function MT(r, e) {
    return r - e
}
function $X(r, e) {
    return r.z - e.z
}
function ej(r, e) {
    return e.z - r.z
}
class tj {
    constructor() {
        this.index = 0,
        this.pool = [],
        this.list = []
    }
    push(e, t, n, i) {
        const a = this.pool
          , s = this.list;
        this.index >= a.length && a.push({
            start: -1,
            count: -1,
            z: -1,
            index: -1
        });
        const l = a[this.index];
        s.push(l),
        this.index++,
        l.start = e,
        l.count = t,
        l.z = n,
        l.index = i
    }
    reset() {
        this.list.length = 0,
        this.index = 0
    }
}
const Is = new vn
  , nj = new kt(1,1,1)
  , EU = new Wg
  , ij = new _M
  , Sx = new ea
  , bd = new ta
  , Sv = new he
  , wU = new he
  , rj = new he
  , TT = new tj
  , Oa = new Ni
  , bx = [];
function aj(r, e, t=0) {
    const n = e.itemSize;
    if (r.isInterleavedBufferAttribute || r.array.constructor !== e.array.constructor) {
        const i = r.count;
        for (let a = 0; a < i; a++)
            for (let s = 0; s < n; s++)
                e.setComponent(a + t, s, r.getComponent(a, s))
    } else
        e.array.set(r.array, t * n);
    e.needsUpdate = !0
}
function Md(r, e) {
    if (r.constructor !== e.constructor) {
        const t = Math.min(r.length, e.length);
        for (let n = 0; n < t; n++)
            e[n] = r[n]
    } else {
        const t = Math.min(r.length, e.length);
        e.set(new r.constructor(r.buffer,0,t))
    }
}
class DB extends Ni {
    constructor(e, t, n=t * 2, i) {
        super(new Nn, i),
        this.isBatchedMesh = !0,
        this.perObjectFrustumCulled = !0,
        this.sortObjects = !0,
        this.boundingBox = null,
        this.boundingSphere = null,
        this.customSort = null,
        this._instanceInfo = [],
        this._geometryInfo = [],
        this._availableInstanceIds = [],
        this._availableGeometryIds = [],
        this._nextIndexStart = 0,
        this._nextVertexStart = 0,
        this._geometryCount = 0,
        this._visibilityChanged = !0,
        this._geometryInitialized = !1,
        this._maxInstanceCount = e,
        this._maxVertexCount = t,
        this._maxIndexCount = n,
        this._multiDrawCounts = new Int32Array(e),
        this._multiDrawStarts = new Int32Array(e),
        this._multiDrawCount = 0,
        this._multiDrawInstances = null,
        this._matricesTexture = null,
        this._indirectTexture = null,
        this._colorsTexture = null,
        this._initMatricesTexture(),
        this._initIndirectTexture()
    }
    get maxInstanceCount() {
        return this._maxInstanceCount
    }
    get instanceCount() {
        return this._instanceInfo.length - this._availableInstanceIds.length
    }
    get unusedVertexCount() {
        return this._maxVertexCount - this._nextVertexStart
    }
    get unusedIndexCount() {
        return this._maxIndexCount - this._nextIndexStart
    }
    _initMatricesTexture() {
        let e = Math.sqrt(this._maxInstanceCount * 4);
        e = Math.ceil(e / 4) * 4,
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4)
          , n = new Kl(t,e,e,vr,tr);
        this._matricesTexture = n
    }
    _initIndirectTexture() {
        let e = Math.sqrt(this._maxInstanceCount);
        e = Math.ceil(e);
        const t = new Uint32Array(e * e)
          , n = new Kl(t,e,e,d_,rc);
        this._indirectTexture = n
    }
    _initColorsTexture() {
        let e = Math.sqrt(this._maxInstanceCount);
        e = Math.ceil(e);
        const t = new Float32Array(e * e * 4).fill(1)
          , n = new Kl(t,e,e,vr,tr);
        n.colorSpace = Kn.workingColorSpace,
        this._colorsTexture = n
    }
    _initializeGeometry(e) {
        const t = this.geometry
          , n = this._maxVertexCount
          , i = this._maxIndexCount;
        if (this._geometryInitialized === !1) {
            for (const a in e.attributes) {
                const s = e.getAttribute(a)
                  , {array: l, itemSize: u, normalized: f} = s
                  , d = new l.constructor(n * u)
                  , g = new xi(d,u,f);
                t.setAttribute(a, g)
            }
            if (e.getIndex() !== null) {
                const a = n > 65535 ? new Uint32Array(i) : new Uint16Array(i);
                t.setIndex(new xi(a,1))
            }
            this._geometryInitialized = !0
        }
    }
    _validateGeometry(e) {
        const t = this.geometry;
        if (!!e.getIndex() != !!t.getIndex())
            throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');
        for (const n in t.attributes) {
            if (!e.hasAttribute(n))
                throw new Error(`THREE.BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
            const i = e.getAttribute(n)
              , a = t.getAttribute(n);
            if (i.itemSize !== a.itemSize || i.normalized !== a.normalized)
                throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
        }
    }
    validateInstanceId(e) {
        const t = this._instanceInfo;
        if (e < 0 || e >= t.length || t[e].active === !1)
            throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`)
    }
    validateGeometryId(e) {
        const t = this._geometryInfo;
        if (e < 0 || e >= t.length || t[e].active === !1)
            throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`)
    }
    setCustomSort(e) {
        return this.customSort = e,
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new ea);
        const e = this.boundingBox
          , t = this._instanceInfo;
        e.makeEmpty();
        for (let n = 0, i = t.length; n < i; n++) {
            if (t[n].active === !1)
                continue;
            const a = t[n].geometryIndex;
            this.getMatrixAt(n, Is),
            this.getBoundingBoxAt(a, Sx).applyMatrix4(Is),
            e.union(Sx)
        }
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new ta);
        const e = this.boundingSphere
          , t = this._instanceInfo;
        e.makeEmpty();
        for (let n = 0, i = t.length; n < i; n++) {
            if (t[n].active === !1)
                continue;
            const a = t[n].geometryIndex;
            this.getMatrixAt(n, Is),
            this.getBoundingSphereAt(a, bd).applyMatrix4(Is),
            e.union(bd)
        }
    }
    addInstance(e) {
        if (this._instanceInfo.length >= this.maxInstanceCount && this._availableInstanceIds.length === 0)
            throw new Error("THREE.BatchedMesh: Maximum item count reached.");
        const n = {
            visible: !0,
            active: !0,
            geometryIndex: e
        };
        let i = null;
        this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort(MT),
        i = this._availableInstanceIds.shift(),
        this._instanceInfo[i] = n) : (i = this._instanceInfo.length,
        this._instanceInfo.push(n));
        const a = this._matricesTexture;
        Is.identity().toArray(a.image.data, i * 16),
        a.needsUpdate = !0;
        const s = this._colorsTexture;
        return s && (nj.toArray(s.image.data, i * 4),
        s.needsUpdate = !0),
        this._visibilityChanged = !0,
        i
    }
    addGeometry(e, t=-1, n=-1) {
        this._initializeGeometry(e),
        this._validateGeometry(e);
        const i = {
            vertexStart: -1,
            vertexCount: -1,
            reservedVertexCount: -1,
            indexStart: -1,
            indexCount: -1,
            reservedIndexCount: -1,
            start: -1,
            count: -1,
            boundingBox: null,
            boundingSphere: null,
            active: !0
        }
          , a = this._geometryInfo;
        i.vertexStart = this._nextVertexStart,
        i.reservedVertexCount = t === -1 ? e.getAttribute("position").count : t;
        const s = e.getIndex();
        if (s !== null && (i.indexStart = this._nextIndexStart,
        i.reservedIndexCount = n === -1 ? s.count : n),
        i.indexStart !== -1 && i.indexStart + i.reservedIndexCount > this._maxIndexCount || i.vertexStart + i.reservedVertexCount > this._maxVertexCount)
            throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");
        let u;
        return this._availableGeometryIds.length > 0 ? (this._availableGeometryIds.sort(MT),
        u = this._availableGeometryIds.shift(),
        a[u] = i) : (u = this._geometryCount,
        this._geometryCount++,
        a.push(i)),
        this.setGeometryAt(u, e),
        this._nextIndexStart = i.indexStart + i.reservedIndexCount,
        this._nextVertexStart = i.vertexStart + i.reservedVertexCount,
        u
    }
    setGeometryAt(e, t) {
        if (e >= this._geometryCount)
            throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
        this._validateGeometry(t);
        const n = this.geometry
          , i = n.getIndex() !== null
          , a = n.getIndex()
          , s = t.getIndex()
          , l = this._geometryInfo[e];
        if (i && s.count > l.reservedIndexCount || t.attributes.position.count > l.reservedVertexCount)
            throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");
        const u = l.vertexStart
          , f = l.reservedVertexCount;
        l.vertexCount = t.getAttribute("position").count;
        for (const d in n.attributes) {
            const g = t.getAttribute(d)
              , v = n.getAttribute(d);
            aj(g, v, u);
            const y = g.itemSize;
            for (let S = g.count, T = f; S < T; S++) {
                const M = u + S;
                for (let b = 0; b < y; b++)
                    v.setComponent(M, b, 0)
            }
            v.needsUpdate = !0,
            v.addUpdateRange(u * y, f * y)
        }
        if (i) {
            const d = l.indexStart
              , g = l.reservedIndexCount;
            l.indexCount = t.getIndex().count;
            for (let v = 0; v < s.count; v++)
                a.setX(d + v, u + s.getX(v));
            for (let v = s.count, y = g; v < y; v++)
                a.setX(d + v, u);
            a.needsUpdate = !0,
            a.addUpdateRange(d, l.reservedIndexCount)
        }
        return l.start = i ? l.indexStart : l.vertexStart,
        l.count = i ? l.indexCount : l.vertexCount,
        l.boundingBox = null,
        t.boundingBox !== null && (l.boundingBox = t.boundingBox.clone()),
        l.boundingSphere = null,
        t.boundingSphere !== null && (l.boundingSphere = t.boundingSphere.clone()),
        this._visibilityChanged = !0,
        e
    }
    deleteGeometry(e) {
        const t = this._geometryInfo;
        if (e >= t.length || t[e].active === !1)
            return this;
        const n = this._instanceInfo;
        for (let i = 0, a = n.length; i < a; i++)
            n[i].active && n[i].geometryIndex === e && this.deleteInstance(i);
        return t[e].active = !1,
        this._availableGeometryIds.push(e),
        this._visibilityChanged = !0,
        this
    }
    deleteInstance(e) {
        return this.validateInstanceId(e),
        this._instanceInfo[e].active = !1,
        this._availableInstanceIds.push(e),
        this._visibilityChanged = !0,
        this
    }
    optimize() {
        let e = 0
          , t = 0;
        const n = this._geometryInfo
          , i = n.map( (s, l) => l).sort( (s, l) => n[s].vertexStart - n[l].vertexStart)
          , a = this.geometry;
        for (let s = 0, l = n.length; s < l; s++) {
            const u = i[s]
              , f = n[u];
            if (f.active !== !1) {
                if (a.index !== null) {
                    if (f.indexStart !== t) {
                        const {indexStart: d, vertexStart: g, reservedIndexCount: v} = f
                          , y = a.index
                          , S = y.array
                          , T = e - g;
                        for (let M = d; M < d + v; M++)
                            S[M] = S[M] + T;
                        y.array.copyWithin(t, d, d + v),
                        y.addUpdateRange(t, v),
                        f.indexStart = t
                    }
                    t += f.reservedIndexCount
                }
                if (f.vertexStart !== e) {
                    const {vertexStart: d, reservedVertexCount: g} = f
                      , v = a.attributes;
                    for (const y in v) {
                        const S = v[y]
                          , {array: T, itemSize: M} = S;
                        T.copyWithin(e * M, d * M, (d + g) * M),
                        S.addUpdateRange(e * M, g * M)
                    }
                    f.vertexStart = e
                }
                e += f.reservedVertexCount,
                f.start = a.index ? f.indexStart : f.vertexStart,
                this._nextIndexStart = a.index ? f.indexStart + f.reservedIndexCount : 0,
                this._nextVertexStart = f.vertexStart + f.reservedVertexCount
            }
        }
        return this
    }
    getBoundingBoxAt(e, t) {
        if (e >= this._geometryCount)
            return null;
        const n = this.geometry
          , i = this._geometryInfo[e];
        if (i.boundingBox === null) {
            const a = new ea
              , s = n.index
              , l = n.attributes.position;
            for (let u = i.start, f = i.start + i.count; u < f; u++) {
                let d = u;
                s && (d = s.getX(d)),
                a.expandByPoint(Sv.fromBufferAttribute(l, d))
            }
            i.boundingBox = a
        }
        return t.copy(i.boundingBox),
        t
    }
    getBoundingSphereAt(e, t) {
        if (e >= this._geometryCount)
            return null;
        const n = this.geometry
          , i = this._geometryInfo[e];
        if (i.boundingSphere === null) {
            const a = new ta;
            this.getBoundingBoxAt(e, Sx),
            Sx.getCenter(a.center);
            const s = n.index
              , l = n.attributes.position;
            let u = 0;
            for (let f = i.start, d = i.start + i.count; f < d; f++) {
                let g = f;
                s && (g = s.getX(g)),
                Sv.fromBufferAttribute(l, g),
                u = Math.max(u, a.center.distanceToSquared(Sv))
            }
            a.radius = Math.sqrt(u),
            i.boundingSphere = a
        }
        return t.copy(i.boundingSphere),
        t
    }
    setMatrixAt(e, t) {
        this.validateInstanceId(e);
        const n = this._matricesTexture
          , i = this._matricesTexture.image.data;
        return t.toArray(i, e * 16),
        n.needsUpdate = !0,
        this
    }
    getMatrixAt(e, t) {
        return this.validateInstanceId(e),
        t.fromArray(this._matricesTexture.image.data, e * 16)
    }
    setColorAt(e, t) {
        return this.validateInstanceId(e),
        this._colorsTexture === null && this._initColorsTexture(),
        t.toArray(this._colorsTexture.image.data, e * 4),
        this._colorsTexture.needsUpdate = !0,
        this
    }
    getColorAt(e, t) {
        return this.validateInstanceId(e),
        t.fromArray(this._colorsTexture.image.data, e * 4)
    }
    setVisibleAt(e, t) {
        return this.validateInstanceId(e),
        this._instanceInfo[e].visible === t ? this : (this._instanceInfo[e].visible = t,
        this._visibilityChanged = !0,
        this)
    }
    getVisibleAt(e) {
        return this.validateInstanceId(e),
        this._instanceInfo[e].visible
    }
    setGeometryIdAt(e, t) {
        return this.validateInstanceId(e),
        this.validateGeometryId(t),
        this._instanceInfo[e].geometryIndex = t,
        this
    }
    getGeometryIdAt(e) {
        return this.validateInstanceId(e),
        this._instanceInfo[e].geometryIndex
    }
    getGeometryRangeAt(e, t={}) {
        this.validateGeometryId(e);
        const n = this._geometryInfo[e];
        return t.vertexStart = n.vertexStart,
        t.vertexCount = n.vertexCount,
        t.reservedVertexCount = n.reservedVertexCount,
        t.indexStart = n.indexStart,
        t.indexCount = n.indexCount,
        t.reservedIndexCount = n.reservedIndexCount,
        t.start = n.start,
        t.count = n.count,
        t
    }
    setInstanceCount(e) {
        const t = this._availableInstanceIds
          , n = this._instanceInfo;
        for (t.sort(MT); t[t.length - 1] === n.length - 1; )
            n.pop(),
            t.pop();
        if (e < n.length)
            throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);
        const i = new Int32Array(e)
          , a = new Int32Array(e);
        Md(this._multiDrawCounts, i),
        Md(this._multiDrawStarts, a),
        this._multiDrawCounts = i,
        this._multiDrawStarts = a,
        this._maxInstanceCount = e;
        const s = this._indirectTexture
          , l = this._matricesTexture
          , u = this._colorsTexture;
        s.dispose(),
        this._initIndirectTexture(),
        Md(s.image.data, this._indirectTexture.image.data),
        l.dispose(),
        this._initMatricesTexture(),
        Md(l.image.data, this._matricesTexture.image.data),
        u && (u.dispose(),
        this._initColorsTexture(),
        Md(u.image.data, this._colorsTexture.image.data))
    }
    setGeometrySize(e, t) {
        const n = [...this._geometryInfo].filter(l => l.active);
        if (Math.max(...n.map(l => l.vertexStart + l.reservedVertexCount)) > e)
            throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`);
        if (this.geometry.index && Math.max(...n.map(u => u.indexStart + u.reservedIndexCount)) > t)
            throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`);
        const a = this.geometry;
        a.dispose(),
        this._maxVertexCount = e,
        this._maxIndexCount = t,
        this._geometryInitialized && (this._geometryInitialized = !1,
        this.geometry = new Nn,
        this._initializeGeometry(a));
        const s = this.geometry;
        a.index && Md(a.index.array, s.index.array);
        for (const l in a.attributes)
            Md(a.attributes[l].array, s.attributes[l].array)
    }
    raycast(e, t) {
        const n = this._instanceInfo
          , i = this._geometryInfo
          , a = this.matrixWorld
          , s = this.geometry;
        Oa.material = this.material,
        Oa.geometry.index = s.index,
        Oa.geometry.attributes = s.attributes,
        Oa.geometry.boundingBox === null && (Oa.geometry.boundingBox = new ea),
        Oa.geometry.boundingSphere === null && (Oa.geometry.boundingSphere = new ta);
        for (let l = 0, u = n.length; l < u; l++) {
            if (!n[l].visible || !n[l].active)
                continue;
            const f = n[l].geometryIndex
              , d = i[f];
            Oa.geometry.setDrawRange(d.start, d.count),
            this.getMatrixAt(l, Oa.matrixWorld).premultiply(a),
            this.getBoundingBoxAt(f, Oa.geometry.boundingBox),
            this.getBoundingSphereAt(f, Oa.geometry.boundingSphere),
            Oa.raycast(e, bx);
            for (let g = 0, v = bx.length; g < v; g++) {
                const y = bx[g];
                y.object = this,
                y.batchId = l,
                t.push(y)
            }
            bx.length = 0
        }
        Oa.material = null,
        Oa.geometry.index = null,
        Oa.geometry.attributes = {},
        Oa.geometry.setDrawRange(0, 1 / 0)
    }
    copy(e) {
        return super.copy(e),
        this.geometry = e.geometry.clone(),
        this.perObjectFrustumCulled = e.perObjectFrustumCulled,
        this.sortObjects = e.sortObjects,
        this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null,
        this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null,
        this._geometryInfo = e._geometryInfo.map(t => ({
            ...t,
            boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
            boundingSphere: t.boundingSphere !== null ? t.boundingSphere.clone() : null
        })),
        this._instanceInfo = e._instanceInfo.map(t => ({
            ...t
        })),
        this._availableInstanceIds = e._availableInstanceIds.slice(),
        this._availableGeometryIds = e._availableGeometryIds.slice(),
        this._nextIndexStart = e._nextIndexStart,
        this._nextVertexStart = e._nextVertexStart,
        this._geometryCount = e._geometryCount,
        this._maxInstanceCount = e._maxInstanceCount,
        this._maxVertexCount = e._maxVertexCount,
        this._maxIndexCount = e._maxIndexCount,
        this._geometryInitialized = e._geometryInitialized,
        this._multiDrawCounts = e._multiDrawCounts.slice(),
        this._multiDrawStarts = e._multiDrawStarts.slice(),
        this._indirectTexture = e._indirectTexture.clone(),
        this._indirectTexture.image.data = this._indirectTexture.image.data.slice(),
        this._matricesTexture = e._matricesTexture.clone(),
        this._matricesTexture.image.data = this._matricesTexture.image.data.slice(),
        this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(),
        this._colorsTexture.image.data = this._colorsTexture.image.data.slice()),
        this
    }
    dispose() {
        this.geometry.dispose(),
        this._matricesTexture.dispose(),
        this._matricesTexture = null,
        this._indirectTexture.dispose(),
        this._indirectTexture = null,
        this._colorsTexture !== null && (this._colorsTexture.dispose(),
        this._colorsTexture = null)
    }
    onBeforeRender(e, t, n, i, a) {
        if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
            return;
        const s = i.getIndex()
          , l = s === null ? 1 : s.array.BYTES_PER_ELEMENT
          , u = this._instanceInfo
          , f = this._multiDrawStarts
          , d = this._multiDrawCounts
          , g = this._geometryInfo
          , v = this.perObjectFrustumCulled
          , y = this._indirectTexture
          , S = y.image.data
          , T = n.isArrayCamera ? ij : EU;
        v && !n.isArrayCamera && (Is.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld),
        EU.setFromProjectionMatrix(Is, n.coordinateSystem, n.reversedDepth));
        let M = 0;
        if (this.sortObjects) {
            Is.copy(this.matrixWorld).invert(),
            Sv.setFromMatrixPosition(n.matrixWorld).applyMatrix4(Is),
            wU.set(0, 0, -1).transformDirection(n.matrixWorld).transformDirection(Is);
            for (let C = 0, R = u.length; C < R; C++)
                if (u[C].visible && u[C].active) {
                    const O = u[C].geometryIndex;
                    this.getMatrixAt(C, Is),
                    this.getBoundingSphereAt(O, bd).applyMatrix4(Is);
                    let L = !1;
                    if (v && (L = !T.intersectsSphere(bd, n)),
                    !L) {
                        const z = g[O]
                          , I = rj.subVectors(bd.center, Sv).dot(wU);
                        TT.push(z.start, z.count, I, C)
                    }
                }
            const b = TT.list
              , A = this.customSort;
            A === null ? b.sort(a.transparent ? ej : $X) : A.call(this, b, n);
            for (let C = 0, R = b.length; C < R; C++) {
                const O = b[C];
                f[M] = O.start * l,
                d[M] = O.count,
                S[M] = O.index,
                M++
            }
            TT.reset()
        } else
            for (let b = 0, A = u.length; b < A; b++)
                if (u[b].visible && u[b].active) {
                    const C = u[b].geometryIndex;
                    let R = !1;
                    if (v && (this.getMatrixAt(b, Is),
                    this.getBoundingSphereAt(C, bd).applyMatrix4(Is),
                    R = !T.intersectsSphere(bd, n)),
                    !R) {
                        const O = g[C];
                        f[M] = O.start * l,
                        d[M] = O.count,
                        S[M] = b,
                        M++
                    }
                }
        y.needsUpdate = !0,
        this._multiDrawCount = M,
        this._visibilityChanged = !1
    }
    onBeforeShadow(e, t, n, i, a, s) {
        this.onBeforeRender(e, null, i, a, s)
    }
}
class _s extends Va {
    constructor(e) {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new kt(16777215),
        this.map = null,
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this
    }
}
const Rb = new he
  , Db = new he
  , AU = new vn
  , bv = new jg
  , Mx = new ta
  , ET = new he
  , CU = new he;
class xh extends ii {
    constructor(e=new Nn, t=new _s) {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.morphTargetDictionary = void 0,
        this.morphTargetInfluences = void 0,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , n = [0];
            for (let i = 1, a = t.count; i < a; i++)
                Rb.fromBufferAttribute(t, i - 1),
                Db.fromBufferAttribute(t, i),
                n[i] = n[i - 1],
                n[i] += Rb.distanceTo(Db);
            e.setAttribute("lineDistance", new Qt(n,1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const n = this.geometry
          , i = this.matrixWorld
          , a = e.params.Line.threshold
          , s = n.drawRange;
        if (n.boundingSphere === null && n.computeBoundingSphere(),
        Mx.copy(n.boundingSphere),
        Mx.applyMatrix4(i),
        Mx.radius += a,
        e.ray.intersectsSphere(Mx) === !1)
            return;
        AU.copy(i).invert(),
        bv.copy(e.ray).applyMatrix4(AU);
        const l = a / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , u = l * l
          , f = this.isLineSegments ? 2 : 1
          , d = n.index
          , v = n.attributes.position;
        if (d !== null) {
            const y = Math.max(0, s.start)
              , S = Math.min(d.count, s.start + s.count);
            for (let T = y, M = S - 1; T < M; T += f) {
                const b = d.getX(T)
                  , A = d.getX(T + 1)
                  , C = Tx(this, e, bv, u, b, A, T);
                C && t.push(C)
            }
            if (this.isLineLoop) {
                const T = d.getX(S - 1)
                  , M = d.getX(y)
                  , b = Tx(this, e, bv, u, T, M, S - 1);
                b && t.push(b)
            }
        } else {
            const y = Math.max(0, s.start)
              , S = Math.min(v.count, s.start + s.count);
            for (let T = y, M = S - 1; T < M; T += f) {
                const b = Tx(this, e, bv, u, T, T + 1, T);
                b && t.push(b)
            }
            if (this.isLineLoop) {
                const T = Tx(this, e, bv, u, S - 1, y, S - 1);
                T && t.push(T)
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , n = Object.keys(t);
        if (n.length > 0) {
            const i = t[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let a = 0, s = i.length; a < s; a++) {
                    const l = i[a].name || String(a);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[l] = a
                }
            }
        }
    }
}
function Tx(r, e, t, n, i, a, s) {
    const l = r.geometry.attributes.position;
    if (Rb.fromBufferAttribute(l, i),
    Db.fromBufferAttribute(l, a),
    t.distanceSqToSegment(Rb, Db, ET, CU) > n)
        return;
    ET.applyMatrix4(r.matrixWorld);
    const f = e.ray.origin.distanceTo(ET);
    if (!(f < e.near || f > e.far))
        return {
            distance: f,
            point: CU.clone().applyMatrix4(r.matrixWorld),
            index: s,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: r
        }
}
const RU = new he
  , DU = new he;
class lc extends xh {
    constructor(e, t) {
        super(e, t),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , n = [];
            for (let i = 0, a = t.count; i < a; i += 2)
                RU.fromBufferAttribute(t, i),
                DU.fromBufferAttribute(t, i + 1),
                n[i] = i === 0 ? 0 : n[i - 1],
                n[i + 1] = n[i] + RU.distanceTo(DU);
            e.setAttribute("lineDistance", new Qt(n,1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class UB extends xh {
    constructor(e, t) {
        super(e, t),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
}
class dC extends Va {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new kt(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const UU = new vn
  , hw = new jg
  , Ex = new ta
  , wx = new he;
class OB extends ii {
    constructor(e=new Nn, t=new dC) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.morphTargetDictionary = void 0,
        this.morphTargetInfluences = void 0,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        const n = this.geometry
          , i = this.matrixWorld
          , a = e.params.Points.threshold
          , s = n.drawRange;
        if (n.boundingSphere === null && n.computeBoundingSphere(),
        Ex.copy(n.boundingSphere),
        Ex.applyMatrix4(i),
        Ex.radius += a,
        e.ray.intersectsSphere(Ex) === !1)
            return;
        UU.copy(i).invert(),
        hw.copy(e.ray).applyMatrix4(UU);
        const l = a / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , u = l * l
          , f = n.index
          , g = n.attributes.position;
        if (f !== null) {
            const v = Math.max(0, s.start)
              , y = Math.min(f.count, s.start + s.count);
            for (let S = v, T = y; S < T; S++) {
                const M = f.getX(S);
                wx.fromBufferAttribute(g, M),
                OU(wx, M, u, i, e, t, this)
            }
        } else {
            const v = Math.max(0, s.start)
              , y = Math.min(g.count, s.start + s.count);
            for (let S = v, T = y; S < T; S++)
                wx.fromBufferAttribute(g, S),
                OU(wx, S, u, i, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , n = Object.keys(t);
        if (n.length > 0) {
            const i = t[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let a = 0, s = i.length; a < s; a++) {
                    const l = i[a].name || String(a);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[l] = a
                }
            }
        }
    }
}
function OU(r, e, t, n, i, a, s) {
    const l = hw.distanceSqToPoint(r);
    if (l < t) {
        const u = new he;
        hw.closestPointToPoint(r, u),
        u.applyMatrix4(n);
        const f = i.ray.origin.distanceTo(u);
        if (f < i.near || f > i.far)
            return;
        a.push({
            distance: f,
            distanceToRay: Math.sqrt(l),
            point: u,
            index: e,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: s
        })
    }
}
class NB extends _i {
    constructor(e, t, n, i, a=fi, s=fi, l, u, f) {
        super(e, t, n, i, a, s, l, u, f),
        this.isVideoTexture = !0,
        this.generateMipmaps = !1,
        this._requestVideoFrameCallbackId = 0;
        const d = this;
        function g() {
            d.needsUpdate = !0,
            d._requestVideoFrameCallbackId = e.requestVideoFrameCallback(g)
        }
        "requestVideoFrameCallback"in e && (this._requestVideoFrameCallbackId = e.requestVideoFrameCallback(g))
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const e = this.image;
        "requestVideoFrameCallback"in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
    dispose() {
        this._requestVideoFrameCallbackId !== 0 && this.source.data.cancelVideoFrameCallback(this._requestVideoFrameCallbackId),
        super.dispose()
    }
}
class sj extends NB {
    constructor(e, t, n, i, a, s, l, u) {
        super({}, e, t, n, i, a, s, l, u),
        this.isVideoFrameTexture = !0
    }
    update() {}
    clone() {
        return new this.constructor().copy(this)
    }
    setFrame(e) {
        this.image = e,
        this.needsUpdate = !0
    }
}
class oj extends _i {
    constructor(e, t) {
        super({
            width: e,
            height: t
        }),
        this.isFramebufferTexture = !0,
        this.magFilter = va,
        this.minFilter = va,
        this.generateMipmaps = !1,
        this.needsUpdate = !0
    }
}
class xM extends _i {
    constructor(e, t, n, i, a, s, l, u, f, d, g, v) {
        super(null, s, l, u, f, d, i, a, g, v),
        this.isCompressedTexture = !0,
        this.image = {
            width: t,
            height: n
        },
        this.mipmaps = e,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class lj extends xM {
    constructor(e, t, n, i, a, s) {
        super(e, t, n, a, s),
        this.isCompressedArrayTexture = !0,
        this.image.depth = i,
        this.wrapR = Cr,
        this.layerUpdates = new Set
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class uj extends xM {
    constructor(e, t, n) {
        super(void 0, e[0].width, e[0].height, t, n, ic),
        this.isCompressedCubeTexture = !0,
        this.isCubeTexture = !0,
        this.image = e
    }
}
class cj extends _i {
    constructor(e, t, n, i, a, s, l, u, f) {
        super(e, t, n, i, a, s, l, u, f),
        this.isCanvasTexture = !0,
        this.needsUpdate = !0
    }
}
class pC extends _i {
    constructor(e, t, n=rc, i, a, s, l=va, u=va, f, d=wg, g=1) {
        if (d !== wg && d !== Ag)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        const v = {
            width: e,
            height: t,
            depth: g
        };
        super(v, i, a, s, l, u, d, n, f),
        this.isDepthTexture = !0,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e) {
        return super.copy(e),
        this.source = new lh(Object.assign({}, e.image)),
        this.compareFunction = e.compareFunction,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction),
        t
    }
}
class mC extends _i {
    constructor(e=null) {
        super(),
        this.sourceTexture = e,
        this.isExternalTexture = !0
    }
    copy(e) {
        return super.copy(e),
        this.sourceTexture = e.sourceTexture,
        this
    }
}
class SM extends Nn {
    constructor(e=1, t=1, n=4, i=8, a=1) {
        super(),
        this.type = "CapsuleGeometry",
        this.parameters = {
            radius: e,
            height: t,
            capSegments: n,
            radialSegments: i,
            heightSegments: a
        },
        t = Math.max(0, t),
        n = Math.max(1, Math.floor(n)),
        i = Math.max(3, Math.floor(i)),
        a = Math.max(1, Math.floor(a));
        const s = []
          , l = []
          , u = []
          , f = []
          , d = t / 2
          , g = Math.PI / 2 * e
          , v = t
          , y = 2 * g + v
          , S = n * 2 + a
          , T = i + 1
          , M = new he
          , b = new he;
        for (let A = 0; A <= S; A++) {
            let C = 0
              , R = 0
              , O = 0
              , L = 0;
            if (A <= n) {
                const N = A / n
                  , P = N * Math.PI / 2;
                R = -d - e * Math.cos(P),
                O = e * Math.sin(P),
                L = -e * Math.cos(P),
                C = N * g
            } else if (A <= n + a) {
                const N = (A - n) / a;
                R = -d + N * t,
                O = e,
                L = 0,
                C = g + N * v
            } else {
                const N = (A - n - a) / n
                  , P = N * Math.PI / 2;
                R = d + e * Math.sin(P),
                O = e * Math.cos(P),
                L = e * Math.sin(P),
                C = g + v + N * g
            }
            const z = Math.max(0, Math.min(1, C / y));
            let I = 0;
            A === 0 ? I = .5 / i : A === S && (I = -.5 / i);
            for (let N = 0; N <= i; N++) {
                const P = N / i
                  , Y = P * Math.PI * 2
                  , V = Math.sin(Y)
                  , K = Math.cos(Y);
                b.x = -O * K,
                b.y = R,
                b.z = O * V,
                l.push(b.x, b.y, b.z),
                M.set(-O * K, L, O * V),
                M.normalize(),
                u.push(M.x, M.y, M.z),
                f.push(P + I, z)
            }
            if (A > 0) {
                const N = (A - 1) * T;
                for (let P = 0; P < i; P++) {
                    const Y = N + P
                      , V = N + P + 1
                      , K = A * T + P
                      , Z = A * T + P + 1;
                    s.push(Y, V, K),
                    s.push(V, Z, K)
                }
            }
        }
        this.setIndex(s),
        this.setAttribute("position", new Qt(l,3)),
        this.setAttribute("normal", new Qt(u,3)),
        this.setAttribute("uv", new Qt(f,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new SM(e.radius,e.height,e.capSegments,e.radialSegments,e.heightSegments)
    }
}
class bM extends Nn {
    constructor(e=1, t=32, n=0, i=Math.PI * 2) {
        super(),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: i
        },
        t = Math.max(3, t);
        const a = []
          , s = []
          , l = []
          , u = []
          , f = new he
          , d = new xt;
        s.push(0, 0, 0),
        l.push(0, 0, 1),
        u.push(.5, .5);
        for (let g = 0, v = 3; g <= t; g++,
        v += 3) {
            const y = n + g / t * i;
            f.x = e * Math.cos(y),
            f.y = e * Math.sin(y),
            s.push(f.x, f.y, f.z),
            l.push(0, 0, 1),
            d.x = (s[v] / e + 1) / 2,
            d.y = (s[v + 1] / e + 1) / 2,
            u.push(d.x, d.y)
        }
        for (let g = 1; g <= t; g++)
            a.push(g, g + 1, 0);
        this.setIndex(a),
        this.setAttribute("position", new Qt(s,3)),
        this.setAttribute("normal", new Qt(l,3)),
        this.setAttribute("uv", new Qt(u,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new bM(e.radius,e.segments,e.thetaStart,e.thetaLength)
    }
}
class g_ extends Nn {
    constructor(e=1, t=1, n=1, i=32, a=1, s=!1, l=0, u=Math.PI * 2) {
        super(),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: n,
            radialSegments: i,
            heightSegments: a,
            openEnded: s,
            thetaStart: l,
            thetaLength: u
        };
        const f = this;
        i = Math.floor(i),
        a = Math.floor(a);
        const d = []
          , g = []
          , v = []
          , y = [];
        let S = 0;
        const T = []
          , M = n / 2;
        let b = 0;
        A(),
        s === !1 && (e > 0 && C(!0),
        t > 0 && C(!1)),
        this.setIndex(d),
        this.setAttribute("position", new Qt(g,3)),
        this.setAttribute("normal", new Qt(v,3)),
        this.setAttribute("uv", new Qt(y,2));
        function A() {
            const R = new he
              , O = new he;
            let L = 0;
            const z = (t - e) / n;
            for (let I = 0; I <= a; I++) {
                const N = []
                  , P = I / a
                  , Y = P * (t - e) + e;
                for (let V = 0; V <= i; V++) {
                    const K = V / i
                      , Z = K * u + l
                      , oe = Math.sin(Z)
                      , H = Math.cos(Z);
                    O.x = Y * oe,
                    O.y = -P * n + M,
                    O.z = Y * H,
                    g.push(O.x, O.y, O.z),
                    R.set(oe, z, H).normalize(),
                    v.push(R.x, R.y, R.z),
                    y.push(K, 1 - P),
                    N.push(S++)
                }
                T.push(N)
            }
            for (let I = 0; I < i; I++)
                for (let N = 0; N < a; N++) {
                    const P = T[N][I]
                      , Y = T[N + 1][I]
                      , V = T[N + 1][I + 1]
                      , K = T[N][I + 1];
                    (e > 0 || N !== 0) && (d.push(P, Y, K),
                    L += 3),
                    (t > 0 || N !== a - 1) && (d.push(Y, V, K),
                    L += 3)
                }
            f.addGroup(b, L, 0),
            b += L
        }
        function C(R) {
            const O = S
              , L = new xt
              , z = new he;
            let I = 0;
            const N = R === !0 ? e : t
              , P = R === !0 ? 1 : -1;
            for (let V = 1; V <= i; V++)
                g.push(0, M * P, 0),
                v.push(0, P, 0),
                y.push(.5, .5),
                S++;
            const Y = S;
            for (let V = 0; V <= i; V++) {
                const Z = V / i * u + l
                  , oe = Math.cos(Z)
                  , H = Math.sin(Z);
                z.x = N * H,
                z.y = M * P,
                z.z = N * oe,
                g.push(z.x, z.y, z.z),
                v.push(0, P, 0),
                L.x = oe * .5 + .5,
                L.y = H * .5 * P + .5,
                y.push(L.x, L.y),
                S++
            }
            for (let V = 0; V < i; V++) {
                const K = O + V
                  , Z = Y + V;
                R === !0 ? d.push(Z, Z + 1, K) : d.push(Z + 1, Z, K),
                I += 3
            }
            f.addGroup(b, I, R === !0 ? 1 : 2),
            b += I
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new g_(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class v_ extends g_ {
    constructor(e=1, t=1, n=32, i=1, a=!1, s=0, l=Math.PI * 2) {
        super(0, e, t, n, i, a, s, l),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: n,
            heightSegments: i,
            openEnded: a,
            thetaStart: s,
            thetaLength: l
        }
    }
    static fromJSON(e) {
        return new v_(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class wh extends Nn {
    constructor(e=[], t=[], n=1, i=0) {
        super(),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: e,
            indices: t,
            radius: n,
            detail: i
        };
        const a = []
          , s = [];
        l(i),
        f(n),
        d(),
        this.setAttribute("position", new Qt(a,3)),
        this.setAttribute("normal", new Qt(a.slice(),3)),
        this.setAttribute("uv", new Qt(s,2)),
        i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
        function l(A) {
            const C = new he
              , R = new he
              , O = new he;
            for (let L = 0; L < t.length; L += 3)
                y(t[L + 0], C),
                y(t[L + 1], R),
                y(t[L + 2], O),
                u(C, R, O, A)
        }
        function u(A, C, R, O) {
            const L = O + 1
              , z = [];
            for (let I = 0; I <= L; I++) {
                z[I] = [];
                const N = A.clone().lerp(R, I / L)
                  , P = C.clone().lerp(R, I / L)
                  , Y = L - I;
                for (let V = 0; V <= Y; V++)
                    V === 0 && I === L ? z[I][V] = N : z[I][V] = N.clone().lerp(P, V / Y)
            }
            for (let I = 0; I < L; I++)
                for (let N = 0; N < 2 * (L - I) - 1; N++) {
                    const P = Math.floor(N / 2);
                    N % 2 === 0 ? (v(z[I][P + 1]),
                    v(z[I + 1][P]),
                    v(z[I][P])) : (v(z[I][P + 1]),
                    v(z[I + 1][P + 1]),
                    v(z[I + 1][P]))
                }
        }
        function f(A) {
            const C = new he;
            for (let R = 0; R < a.length; R += 3)
                C.x = a[R + 0],
                C.y = a[R + 1],
                C.z = a[R + 2],
                C.normalize().multiplyScalar(A),
                a[R + 0] = C.x,
                a[R + 1] = C.y,
                a[R + 2] = C.z
        }
        function d() {
            const A = new he;
            for (let C = 0; C < a.length; C += 3) {
                A.x = a[C + 0],
                A.y = a[C + 1],
                A.z = a[C + 2];
                const R = M(A) / 2 / Math.PI + .5
                  , O = b(A) / Math.PI + .5;
                s.push(R, 1 - O)
            }
            S(),
            g()
        }
        function g() {
            for (let A = 0; A < s.length; A += 6) {
                const C = s[A + 0]
                  , R = s[A + 2]
                  , O = s[A + 4]
                  , L = Math.max(C, R, O)
                  , z = Math.min(C, R, O);
                L > .9 && z < .1 && (C < .2 && (s[A + 0] += 1),
                R < .2 && (s[A + 2] += 1),
                O < .2 && (s[A + 4] += 1))
            }
        }
        function v(A) {
            a.push(A.x, A.y, A.z)
        }
        function y(A, C) {
            const R = A * 3;
            C.x = e[R + 0],
            C.y = e[R + 1],
            C.z = e[R + 2]
        }
        function S() {
            const A = new he
              , C = new he
              , R = new he
              , O = new he
              , L = new xt
              , z = new xt
              , I = new xt;
            for (let N = 0, P = 0; N < a.length; N += 9,
            P += 6) {
                A.set(a[N + 0], a[N + 1], a[N + 2]),
                C.set(a[N + 3], a[N + 4], a[N + 5]),
                R.set(a[N + 6], a[N + 7], a[N + 8]),
                L.set(s[P + 0], s[P + 1]),
                z.set(s[P + 2], s[P + 3]),
                I.set(s[P + 4], s[P + 5]),
                O.copy(A).add(C).add(R).divideScalar(3);
                const Y = M(O);
                T(L, P + 0, A, Y),
                T(z, P + 2, C, Y),
                T(I, P + 4, R, Y)
            }
        }
        function T(A, C, R, O) {
            O < 0 && A.x === 1 && (s[C] = A.x - 1),
            R.x === 0 && R.z === 0 && (s[C] = O / 2 / Math.PI + .5)
        }
        function M(A) {
            return Math.atan2(A.z, -A.x)
        }
        function b(A) {
            return Math.atan2(-A.y, Math.sqrt(A.x * A.x + A.z * A.z))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new wh(e.vertices,e.indices,e.radius,e.details)
    }
}
class MM extends wh {
    constructor(e=1, t=0) {
        const n = (1 + Math.sqrt(5)) / 2
          , i = 1 / n
          , a = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i]
          , s = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        super(a, s, e, t),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new MM(e.radius,e.detail)
    }
}
const Ax = new he
  , Cx = new he
  , wT = new he
  , Rx = new Vs;
class LB extends Nn {
    constructor(e=null, t=1) {
        if (super(),
        this.type = "EdgesGeometry",
        this.parameters = {
            geometry: e,
            thresholdAngle: t
        },
        e !== null) {
            const i = Math.pow(10, 4)
              , a = Math.cos(np * t)
              , s = e.getIndex()
              , l = e.getAttribute("position")
              , u = s ? s.count : l.count
              , f = [0, 0, 0]
              , d = ["a", "b", "c"]
              , g = new Array(3)
              , v = {}
              , y = [];
            for (let S = 0; S < u; S += 3) {
                s ? (f[0] = s.getX(S),
                f[1] = s.getX(S + 1),
                f[2] = s.getX(S + 2)) : (f[0] = S,
                f[1] = S + 1,
                f[2] = S + 2);
                const {a: T, b: M, c: b} = Rx;
                if (T.fromBufferAttribute(l, f[0]),
                M.fromBufferAttribute(l, f[1]),
                b.fromBufferAttribute(l, f[2]),
                Rx.getNormal(wT),
                g[0] = `${Math.round(T.x * i)},${Math.round(T.y * i)},${Math.round(T.z * i)}`,
                g[1] = `${Math.round(M.x * i)},${Math.round(M.y * i)},${Math.round(M.z * i)}`,
                g[2] = `${Math.round(b.x * i)},${Math.round(b.y * i)},${Math.round(b.z * i)}`,
                !(g[0] === g[1] || g[1] === g[2] || g[2] === g[0]))
                    for (let A = 0; A < 3; A++) {
                        const C = (A + 1) % 3
                          , R = g[A]
                          , O = g[C]
                          , L = Rx[d[A]]
                          , z = Rx[d[C]]
                          , I = `${R}_${O}`
                          , N = `${O}_${R}`;
                        N in v && v[N] ? (wT.dot(v[N].normal) <= a && (y.push(L.x, L.y, L.z),
                        y.push(z.x, z.y, z.z)),
                        v[N] = null) : I in v || (v[I] = {
                            index0: f[A],
                            index1: f[C],
                            normal: wT.clone()
                        })
                    }
            }
            for (const S in v)
                if (v[S]) {
                    const {index0: T, index1: M} = v[S];
                    Ax.fromBufferAttribute(l, T),
                    Cx.fromBufferAttribute(l, M),
                    y.push(Ax.x, Ax.y, Ax.z),
                    y.push(Cx.x, Cx.y, Cx.z)
                }
            this.setAttribute("position", new Qt(y,3))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
}
class $l {
    constructor() {
        this.type = "Curve",
        this.arcLengthDivisions = 200,
        this.needsUpdate = !1,
        this.cacheArcLengths = null
    }
    getPoint() {
        console.warn("THREE.Curve: .getPoint() not implemented.")
    }
    getPointAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getPoint(n, t)
    }
    getPoints(e=5) {
        const t = [];
        for (let n = 0; n <= e; n++)
            t.push(this.getPoint(n / e));
        return t
    }
    getSpacedPoints(e=5) {
        const t = [];
        for (let n = 0; n <= e; n++)
            t.push(this.getPointAt(n / e));
        return t
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e=this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let n, i = this.getPoint(0), a = 0;
        t.push(0);
        for (let s = 1; s <= e; s++)
            n = this.getPoint(s / e),
            a += n.distanceTo(i),
            t.push(a),
            i = n;
        return this.cacheArcLengths = t,
        t
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.getLengths()
    }
    getUtoTmapping(e, t=null) {
        const n = this.getLengths();
        let i = 0;
        const a = n.length;
        let s;
        t ? s = t : s = e * n[a - 1];
        let l = 0, u = a - 1, f;
        for (; l <= u; )
            if (i = Math.floor(l + (u - l) / 2),
            f = n[i] - s,
            f < 0)
                l = i + 1;
            else if (f > 0)
                u = i - 1;
            else {
                u = i;
                break
            }
        if (i = u,
        n[i] === s)
            return i / (a - 1);
        const d = n[i]
          , v = n[i + 1] - d
          , y = (s - d) / v;
        return (i + y) / (a - 1)
    }
    getTangent(e, t) {
        let i = e - 1e-4
          , a = e + 1e-4;
        i < 0 && (i = 0),
        a > 1 && (a = 1);
        const s = this.getPoint(i)
          , l = this.getPoint(a)
          , u = t || (s.isVector2 ? new xt : new he);
        return u.copy(l).sub(s).normalize(),
        u
    }
    getTangentAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getTangent(n, t)
    }
    computeFrenetFrames(e, t=!1) {
        const n = new he
          , i = []
          , a = []
          , s = []
          , l = new he
          , u = new vn;
        for (let y = 0; y <= e; y++) {
            const S = y / e;
            i[y] = this.getTangentAt(S, new he)
        }
        a[0] = new he,
        s[0] = new he;
        let f = Number.MAX_VALUE;
        const d = Math.abs(i[0].x)
          , g = Math.abs(i[0].y)
          , v = Math.abs(i[0].z);
        d <= f && (f = d,
        n.set(1, 0, 0)),
        g <= f && (f = g,
        n.set(0, 1, 0)),
        v <= f && n.set(0, 0, 1),
        l.crossVectors(i[0], n).normalize(),
        a[0].crossVectors(i[0], l),
        s[0].crossVectors(i[0], a[0]);
        for (let y = 1; y <= e; y++) {
            if (a[y] = a[y - 1].clone(),
            s[y] = s[y - 1].clone(),
            l.crossVectors(i[y - 1], i[y]),
            l.length() > Number.EPSILON) {
                l.normalize();
                const S = Math.acos(gn(i[y - 1].dot(i[y]), -1, 1));
                a[y].applyMatrix4(u.makeRotationAxis(l, S))
            }
            s[y].crossVectors(i[y], a[y])
        }
        if (t === !0) {
            let y = Math.acos(gn(a[0].dot(a[e]), -1, 1));
            y /= e,
            i[0].dot(l.crossVectors(a[0], a[e])) > 0 && (y = -y);
            for (let S = 1; S <= e; S++)
                a[S].applyMatrix4(u.makeRotationAxis(i[S], y * S)),
                s[S].crossVectors(i[S], a[S])
        }
        return {
            tangents: i,
            normals: a,
            binormals: s
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.7,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions,
        e.type = this.type,
        e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
}
class TM extends $l {
    constructor(e=0, t=0, n=1, i=1, a=0, s=Math.PI * 2, l=!1, u=0) {
        super(),
        this.isEllipseCurve = !0,
        this.type = "EllipseCurve",
        this.aX = e,
        this.aY = t,
        this.xRadius = n,
        this.yRadius = i,
        this.aStartAngle = a,
        this.aEndAngle = s,
        this.aClockwise = l,
        this.aRotation = u
    }
    getPoint(e, t=new xt) {
        const n = t
          , i = Math.PI * 2;
        let a = this.aEndAngle - this.aStartAngle;
        const s = Math.abs(a) < Number.EPSILON;
        for (; a < 0; )
            a += i;
        for (; a > i; )
            a -= i;
        a < Number.EPSILON && (s ? a = 0 : a = i),
        this.aClockwise === !0 && !s && (a === i ? a = -i : a = a - i);
        const l = this.aStartAngle + e * a;
        let u = this.aX + this.xRadius * Math.cos(l)
          , f = this.aY + this.yRadius * Math.sin(l);
        if (this.aRotation !== 0) {
            const d = Math.cos(this.aRotation)
              , g = Math.sin(this.aRotation)
              , v = u - this.aX
              , y = f - this.aY;
            u = v * d - y * g + this.aX,
            f = v * g + y * d + this.aY
        }
        return n.set(u, f)
    }
    copy(e) {
        return super.copy(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
}
class PB extends TM {
    constructor(e, t, n, i, a, s) {
        super(e, t, n, n, i, a, s),
        this.isArcCurve = !0,
        this.type = "ArcCurve"
    }
}
function gC() {
    let r = 0
      , e = 0
      , t = 0
      , n = 0;
    function i(a, s, l, u) {
        r = a,
        e = l,
        t = -3 * a + 3 * s - 2 * l - u,
        n = 2 * a - 2 * s + l + u
    }
    return {
        initCatmullRom: function(a, s, l, u, f) {
            i(s, l, f * (l - a), f * (u - s))
        },
        initNonuniformCatmullRom: function(a, s, l, u, f, d, g) {
            let v = (s - a) / f - (l - a) / (f + d) + (l - s) / d
              , y = (l - s) / d - (u - s) / (d + g) + (u - l) / g;
            v *= d,
            y *= d,
            i(s, l, v, y)
        },
        calc: function(a) {
            const s = a * a
              , l = s * a;
            return r + e * a + t * s + n * l
        }
    }
}
const Dx = new he
  , AT = new gC
  , CT = new gC
  , RT = new gC;
class BB extends $l {
    constructor(e=[], t=!1, n="centripetal", i=.5) {
        super(),
        this.isCatmullRomCurve3 = !0,
        this.type = "CatmullRomCurve3",
        this.points = e,
        this.closed = t,
        this.curveType = n,
        this.tension = i
    }
    getPoint(e, t=new he) {
        const n = t
          , i = this.points
          , a = i.length
          , s = (a - (this.closed ? 0 : 1)) * e;
        let l = Math.floor(s)
          , u = s - l;
        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / a) + 1) * a : u === 0 && l === a - 1 && (l = a - 2,
        u = 1);
        let f, d;
        this.closed || l > 0 ? f = i[(l - 1) % a] : (Dx.subVectors(i[0], i[1]).add(i[0]),
        f = Dx);
        const g = i[l % a]
          , v = i[(l + 1) % a];
        if (this.closed || l + 2 < a ? d = i[(l + 2) % a] : (Dx.subVectors(i[a - 1], i[a - 2]).add(i[a - 1]),
        d = Dx),
        this.curveType === "centripetal" || this.curveType === "chordal") {
            const y = this.curveType === "chordal" ? .5 : .25;
            let S = Math.pow(f.distanceToSquared(g), y)
              , T = Math.pow(g.distanceToSquared(v), y)
              , M = Math.pow(v.distanceToSquared(d), y);
            T < 1e-4 && (T = 1),
            S < 1e-4 && (S = T),
            M < 1e-4 && (M = T),
            AT.initNonuniformCatmullRom(f.x, g.x, v.x, d.x, S, T, M),
            CT.initNonuniformCatmullRom(f.y, g.y, v.y, d.y, S, T, M),
            RT.initNonuniformCatmullRom(f.z, g.z, v.z, d.z, S, T, M)
        } else
            this.curveType === "catmullrom" && (AT.initCatmullRom(f.x, g.x, v.x, d.x, this.tension),
            CT.initCatmullRom(f.y, g.y, v.y, d.y, this.tension),
            RT.initCatmullRom(f.z, g.z, v.z, d.z, this.tension));
        return n.set(AT.calc(u), CT.calc(u), RT.calc(u)),
        n
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new he().fromArray(i))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
}
function NU(r, e, t, n, i) {
    const a = (n - e) * .5
      , s = (i - t) * .5
      , l = r * r
      , u = r * l;
    return (2 * t - 2 * n + a + s) * u + (-3 * t + 3 * n - 2 * a - s) * l + a * r + t
}
function fj(r, e) {
    const t = 1 - r;
    return t * t * e
}
function hj(r, e) {
    return 2 * (1 - r) * r * e
}
function dj(r, e) {
    return r * r * e
}
function ay(r, e, t, n) {
    return fj(r, e) + hj(r, t) + dj(r, n)
}
function pj(r, e) {
    const t = 1 - r;
    return t * t * t * e
}
function mj(r, e) {
    const t = 1 - r;
    return 3 * t * t * r * e
}
function gj(r, e) {
    return 3 * (1 - r) * r * r * e
}
function vj(r, e) {
    return r * r * r * e
}
function sy(r, e, t, n, i) {
    return pj(r, e) + mj(r, t) + gj(r, n) + vj(r, i)
}
class vC extends $l {
    constructor(e=new xt, t=new xt, n=new xt, i=new xt) {
        super(),
        this.isCubicBezierCurve = !0,
        this.type = "CubicBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = n,
        this.v3 = i
    }
    getPoint(e, t=new xt) {
        const n = t
          , i = this.v0
          , a = this.v1
          , s = this.v2
          , l = this.v3;
        return n.set(sy(e, i.x, a.x, s.x, l.x), sy(e, i.y, a.y, s.y, l.y)),
        n
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class zB extends $l {
    constructor(e=new he, t=new he, n=new he, i=new he) {
        super(),
        this.isCubicBezierCurve3 = !0,
        this.type = "CubicBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = n,
        this.v3 = i
    }
    getPoint(e, t=new he) {
        const n = t
          , i = this.v0
          , a = this.v1
          , s = this.v2
          , l = this.v3;
        return n.set(sy(e, i.x, a.x, s.x, l.x), sy(e, i.y, a.y, s.y, l.y), sy(e, i.z, a.z, s.z, l.z)),
        n
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class yC extends $l {
    constructor(e=new xt, t=new xt) {
        super(),
        this.isLineCurve = !0,
        this.type = "LineCurve",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new xt) {
        const n = t;
        return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
        n.multiplyScalar(e).add(this.v1)),
        n
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t=new xt) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class IB extends $l {
    constructor(e=new he, t=new he) {
        super(),
        this.isLineCurve3 = !0,
        this.type = "LineCurve3",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new he) {
        const n = t;
        return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
        n.multiplyScalar(e).add(this.v1)),
        n
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t=new he) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class _C extends $l {
    constructor(e=new xt, t=new xt, n=new xt) {
        super(),
        this.isQuadraticBezierCurve = !0,
        this.type = "QuadraticBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = n
    }
    getPoint(e, t=new xt) {
        const n = t
          , i = this.v0
          , a = this.v1
          , s = this.v2;
        return n.set(ay(e, i.x, a.x, s.x), ay(e, i.y, a.y, s.y)),
        n
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class xC extends $l {
    constructor(e=new he, t=new he, n=new he) {
        super(),
        this.isQuadraticBezierCurve3 = !0,
        this.type = "QuadraticBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = n
    }
    getPoint(e, t=new he) {
        const n = t
          , i = this.v0
          , a = this.v1
          , s = this.v2;
        return n.set(ay(e, i.x, a.x, s.x), ay(e, i.y, a.y, s.y), ay(e, i.z, a.z, s.z)),
        n
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class SC extends $l {
    constructor(e=[]) {
        super(),
        this.isSplineCurve = !0,
        this.type = "SplineCurve",
        this.points = e
    }
    getPoint(e, t=new xt) {
        const n = t
          , i = this.points
          , a = (i.length - 1) * e
          , s = Math.floor(a)
          , l = a - s
          , u = i[s === 0 ? s : s - 1]
          , f = i[s]
          , d = i[s > i.length - 2 ? i.length - 1 : s + 1]
          , g = i[s > i.length - 3 ? i.length - 1 : s + 2];
        return n.set(NU(l, u.x, f.x, d.x, g.x), NU(l, u.y, f.y, d.y, g.y)),
        n
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new xt().fromArray(i))
        }
        return this
    }
}
var Ub = Object.freeze({
    __proto__: null,
    ArcCurve: PB,
    CatmullRomCurve3: BB,
    CubicBezierCurve: vC,
    CubicBezierCurve3: zB,
    EllipseCurve: TM,
    LineCurve: yC,
    LineCurve3: IB,
    QuadraticBezierCurve: _C,
    QuadraticBezierCurve3: xC,
    SplineCurve: SC
});
class FB extends $l {
    constructor() {
        super(),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0)
          , t = this.curves[this.curves.length - 1].getPoint(1);
        if (!e.equals(t)) {
            const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
            this.curves.push(new Ub[n](t,e))
        }
        return this
    }
    getPoint(e, t) {
        const n = e * this.getLength()
          , i = this.getCurveLengths();
        let a = 0;
        for (; a < i.length; ) {
            if (i[a] >= n) {
                const s = i[a] - n
                  , l = this.curves[a]
                  , u = l.getLength()
                  , f = u === 0 ? 0 : 1 - s / u;
                return l.getPointAt(f, t)
            }
            a++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.cacheLengths = null,
        this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let n = 0, i = this.curves.length; n < i; n++)
            t += this.curves[n].getLength(),
            e.push(t);
        return this.cacheLengths = e,
        e
    }
    getSpacedPoints(e=40) {
        const t = [];
        for (let n = 0; n <= e; n++)
            t.push(this.getPoint(n / e));
        return this.autoClose && t.push(t[0]),
        t
    }
    getPoints(e=12) {
        const t = [];
        let n;
        for (let i = 0, a = this.curves; i < a.length; i++) {
            const s = a[i]
              , l = s.isEllipseCurve ? e * 2 : s.isLineCurve || s.isLineCurve3 ? 1 : s.isSplineCurve ? e * s.points.length : e
              , u = s.getPoints(l);
            for (let f = 0; f < u.length; f++) {
                const d = u[f];
                n && n.equals(d) || (t.push(d),
                n = d)
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
        t
    }
    copy(e) {
        super.copy(e),
        this.curves = [];
        for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(i.clone())
        }
        return this.autoClose = e.autoClose,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose,
        e.curves = [];
        for (let t = 0, n = this.curves.length; t < n; t++) {
            const i = this.curves[t];
            e.curves.push(i.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.autoClose = e.autoClose,
        this.curves = [];
        for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(new Ub[i.type]().fromJSON(i))
        }
        return this
    }
}
class Ob extends FB {
    constructor(e) {
        super(),
        this.type = "Path",
        this.currentPoint = new xt,
        e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, n = e.length; t < n; t++)
            this.lineTo(e[t].x, e[t].y);
        return this
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t),
        this
    }
    lineTo(e, t) {
        const n = new yC(this.currentPoint.clone(),new xt(e,t));
        return this.curves.push(n),
        this.currentPoint.set(e, t),
        this
    }
    quadraticCurveTo(e, t, n, i) {
        const a = new _C(this.currentPoint.clone(),new xt(e,t),new xt(n,i));
        return this.curves.push(a),
        this.currentPoint.set(n, i),
        this
    }
    bezierCurveTo(e, t, n, i, a, s) {
        const l = new vC(this.currentPoint.clone(),new xt(e,t),new xt(n,i),new xt(a,s));
        return this.curves.push(l),
        this.currentPoint.set(a, s),
        this
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e)
          , n = new SC(t);
        return this.curves.push(n),
        this.currentPoint.copy(e[e.length - 1]),
        this
    }
    arc(e, t, n, i, a, s) {
        const l = this.currentPoint.x
          , u = this.currentPoint.y;
        return this.absarc(e + l, t + u, n, i, a, s),
        this
    }
    absarc(e, t, n, i, a, s) {
        return this.absellipse(e, t, n, n, i, a, s),
        this
    }
    ellipse(e, t, n, i, a, s, l, u) {
        const f = this.currentPoint.x
          , d = this.currentPoint.y;
        return this.absellipse(e + f, t + d, n, i, a, s, l, u),
        this
    }
    absellipse(e, t, n, i, a, s, l, u) {
        const f = new TM(e,t,n,i,a,s,l,u);
        if (this.curves.length > 0) {
            const g = f.getPoint(0);
            g.equals(this.currentPoint) || this.lineTo(g.x, g.y)
        }
        this.curves.push(f);
        const d = f.getPoint(1);
        return this.currentPoint.copy(d),
        this
    }
    copy(e) {
        return super.copy(e),
        this.currentPoint.copy(e.currentPoint),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.currentPoint.fromArray(e.currentPoint),
        this
    }
}
class ip extends Ob {
    constructor(e) {
        super(e),
        this.uuid = To(),
        this.type = "Shape",
        this.holes = []
    }
    getPointsHoles(e) {
        const t = [];
        for (let n = 0, i = this.holes.length; n < i; n++)
            t[n] = this.holes[n].getPoints(e);
        return t
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e),
        this.holes = [];
        for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(i.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid,
        e.holes = [];
        for (let t = 0, n = this.holes.length; t < n; t++) {
            const i = this.holes[t];
            e.holes.push(i.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.uuid = e.uuid,
        this.holes = [];
        for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(new Ob().fromJSON(i))
        }
        return this
    }
}
function yj(r, e, t=2) {
    const n = e && e.length
      , i = n ? e[0] * t : r.length;
    let a = HB(r, 0, i, t, !0);
    const s = [];
    if (!a || a.next === a.prev)
        return s;
    let l, u, f;
    if (n && (a = Mj(r, e, a, t)),
    r.length > 80 * t) {
        l = 1 / 0,
        u = 1 / 0;
        let d = -1 / 0
          , g = -1 / 0;
        for (let v = t; v < i; v += t) {
            const y = r[v]
              , S = r[v + 1];
            y < l && (l = y),
            S < u && (u = S),
            y > d && (d = y),
            S > g && (g = S)
        }
        f = Math.max(d - l, g - u),
        f = f !== 0 ? 32767 / f : 0
    }
    return Xy(a, s, t, l, u, f, 0),
    s
}
function HB(r, e, t, n, i) {
    let a;
    if (i === Lj(r, e, t, n) > 0)
        for (let s = e; s < t; s += n)
            a = LU(s / n | 0, r[s], r[s + 1], a);
    else
        for (let s = t - n; s >= e; s -= n)
            a = LU(s / n | 0, r[s], r[s + 1], a);
    return a && Og(a, a.next) && (Wy(a),
    a = a.next),
    a
}
function hp(r, e) {
    if (!r)
        return r;
    e || (e = r);
    let t = r, n;
    do
        if (n = !1,
        !t.steiner && (Og(t, t.next) || er(t.prev, t, t.next) === 0)) {
            if (Wy(t),
            t = e = t.prev,
            t === t.next)
                break;
            n = !0
        } else
            t = t.next;
    while (n || t !== e);
    return e
}
function Xy(r, e, t, n, i, a, s) {
    if (!r)
        return;
    !s && a && Cj(r, n, i, a);
    let l = r;
    for (; r.prev !== r.next; ) {
        const u = r.prev
          , f = r.next;
        if (a ? xj(r, n, i, a) : _j(r)) {
            e.push(u.i, r.i, f.i),
            Wy(r),
            r = f.next,
            l = f.next;
            continue
        }
        if (r = f,
        r === l) {
            s ? s === 1 ? (r = Sj(hp(r), e),
            Xy(r, e, t, n, i, a, 2)) : s === 2 && bj(r, e, t, n, i, a) : Xy(hp(r), e, t, n, i, a, 1);
            break
        }
    }
}
function _j(r) {
    const e = r.prev
      , t = r
      , n = r.next;
    if (er(e, t, n) >= 0)
        return !1;
    const i = e.x
      , a = t.x
      , s = n.x
      , l = e.y
      , u = t.y
      , f = n.y
      , d = Math.min(i, a, s)
      , g = Math.min(l, u, f)
      , v = Math.max(i, a, s)
      , y = Math.max(l, u, f);
    let S = n.next;
    for (; S !== e; ) {
        if (S.x >= d && S.x <= v && S.y >= g && S.y <= y && Nv(i, l, a, u, s, f, S.x, S.y) && er(S.prev, S, S.next) >= 0)
            return !1;
        S = S.next
    }
    return !0
}
function xj(r, e, t, n) {
    const i = r.prev
      , a = r
      , s = r.next;
    if (er(i, a, s) >= 0)
        return !1;
    const l = i.x
      , u = a.x
      , f = s.x
      , d = i.y
      , g = a.y
      , v = s.y
      , y = Math.min(l, u, f)
      , S = Math.min(d, g, v)
      , T = Math.max(l, u, f)
      , M = Math.max(d, g, v)
      , b = dw(y, S, e, t, n)
      , A = dw(T, M, e, t, n);
    let C = r.prevZ
      , R = r.nextZ;
    for (; C && C.z >= b && R && R.z <= A; ) {
        if (C.x >= y && C.x <= T && C.y >= S && C.y <= M && C !== i && C !== s && Nv(l, d, u, g, f, v, C.x, C.y) && er(C.prev, C, C.next) >= 0 || (C = C.prevZ,
        R.x >= y && R.x <= T && R.y >= S && R.y <= M && R !== i && R !== s && Nv(l, d, u, g, f, v, R.x, R.y) && er(R.prev, R, R.next) >= 0))
            return !1;
        R = R.nextZ
    }
    for (; C && C.z >= b; ) {
        if (C.x >= y && C.x <= T && C.y >= S && C.y <= M && C !== i && C !== s && Nv(l, d, u, g, f, v, C.x, C.y) && er(C.prev, C, C.next) >= 0)
            return !1;
        C = C.prevZ
    }
    for (; R && R.z <= A; ) {
        if (R.x >= y && R.x <= T && R.y >= S && R.y <= M && R !== i && R !== s && Nv(l, d, u, g, f, v, R.x, R.y) && er(R.prev, R, R.next) >= 0)
            return !1;
        R = R.nextZ
    }
    return !0
}
function Sj(r, e) {
    let t = r;
    do {
        const n = t.prev
          , i = t.next.next;
        !Og(n, i) && kB(n, t, t.next, i) && jy(n, i) && jy(i, n) && (e.push(n.i, t.i, i.i),
        Wy(t),
        Wy(t.next),
        t = r = i),
        t = t.next
    } while (t !== r);
    return hp(t)
}
function bj(r, e, t, n, i, a) {
    let s = r;
    do {
        let l = s.next.next;
        for (; l !== s.prev; ) {
            if (s.i !== l.i && Uj(s, l)) {
                let u = GB(s, l);
                s = hp(s, s.next),
                u = hp(u, u.next),
                Xy(s, e, t, n, i, a, 0),
                Xy(u, e, t, n, i, a, 0);
                return
            }
            l = l.next
        }
        s = s.next
    } while (s !== r)
}
function Mj(r, e, t, n) {
    const i = [];
    for (let a = 0, s = e.length; a < s; a++) {
        const l = e[a] * n
          , u = a < s - 1 ? e[a + 1] * n : r.length
          , f = HB(r, l, u, n, !1);
        f === f.next && (f.steiner = !0),
        i.push(Dj(f))
    }
    i.sort(Tj);
    for (let a = 0; a < i.length; a++)
        t = Ej(i[a], t);
    return t
}
function Tj(r, e) {
    let t = r.x - e.x;
    if (t === 0 && (t = r.y - e.y,
    t === 0)) {
        const n = (r.next.y - r.y) / (r.next.x - r.x)
          , i = (e.next.y - e.y) / (e.next.x - e.x);
        t = n - i
    }
    return t
}
function Ej(r, e) {
    const t = wj(r, e);
    if (!t)
        return e;
    const n = GB(t, r);
    return hp(n, n.next),
    hp(t, t.next)
}
function wj(r, e) {
    let t = e;
    const n = r.x
      , i = r.y;
    let a = -1 / 0, s;
    if (Og(r, t))
        return t;
    do {
        if (Og(r, t.next))
            return t.next;
        if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
            const g = t.x + (i - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (g <= n && g > a && (a = g,
            s = t.x < t.next.x ? t : t.next,
            g === n))
                return s
        }
        t = t.next
    } while (t !== e);
    if (!s)
        return null;
    const l = s
      , u = s.x
      , f = s.y;
    let d = 1 / 0;
    t = s;
    do {
        if (n >= t.x && t.x >= u && n !== t.x && VB(i < f ? n : a, i, u, f, i < f ? a : n, i, t.x, t.y)) {
            const g = Math.abs(i - t.y) / (n - t.x);
            jy(t, r) && (g < d || g === d && (t.x > s.x || t.x === s.x && Aj(s, t))) && (s = t,
            d = g)
        }
        t = t.next
    } while (t !== l);
    return s
}
function Aj(r, e) {
    return er(r.prev, r, e.prev) < 0 && er(e.next, r, r.next) < 0
}
function Cj(r, e, t, n) {
    let i = r;
    do
        i.z === 0 && (i.z = dw(i.x, i.y, e, t, n)),
        i.prevZ = i.prev,
        i.nextZ = i.next,
        i = i.next;
    while (i !== r);
    i.prevZ.nextZ = null,
    i.prevZ = null,
    Rj(i)
}
function Rj(r) {
    let e, t = 1;
    do {
        let n = r, i;
        r = null;
        let a = null;
        for (e = 0; n; ) {
            e++;
            let s = n
              , l = 0;
            for (let f = 0; f < t && (l++,
            s = s.nextZ,
            !!s); f++)
                ;
            let u = t;
            for (; l > 0 || u > 0 && s; )
                l !== 0 && (u === 0 || !s || n.z <= s.z) ? (i = n,
                n = n.nextZ,
                l--) : (i = s,
                s = s.nextZ,
                u--),
                a ? a.nextZ = i : r = i,
                i.prevZ = a,
                a = i;
            n = s
        }
        a.nextZ = null,
        t *= 2
    } while (e > 1);
    return r
}
function dw(r, e, t, n, i) {
    return r = (r - t) * i | 0,
    e = (e - n) * i | 0,
    r = (r | r << 8) & 16711935,
    r = (r | r << 4) & 252645135,
    r = (r | r << 2) & 858993459,
    r = (r | r << 1) & 1431655765,
    e = (e | e << 8) & 16711935,
    e = (e | e << 4) & 252645135,
    e = (e | e << 2) & 858993459,
    e = (e | e << 1) & 1431655765,
    r | e << 1
}
function Dj(r) {
    let e = r
      , t = r;
    do
        (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e),
        e = e.next;
    while (e !== r);
    return t
}
function VB(r, e, t, n, i, a, s, l) {
    return (i - s) * (e - l) >= (r - s) * (a - l) && (r - s) * (n - l) >= (t - s) * (e - l) && (t - s) * (a - l) >= (i - s) * (n - l)
}
function Nv(r, e, t, n, i, a, s, l) {
    return !(r === s && e === l) && VB(r, e, t, n, i, a, s, l)
}
function Uj(r, e) {
    return r.next.i !== e.i && r.prev.i !== e.i && !Oj(r, e) && (jy(r, e) && jy(e, r) && Nj(r, e) && (er(r.prev, r, e.prev) || er(r, e.prev, e)) || Og(r, e) && er(r.prev, r, r.next) > 0 && er(e.prev, e, e.next) > 0)
}
function er(r, e, t) {
    return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y)
}
function Og(r, e) {
    return r.x === e.x && r.y === e.y
}
function kB(r, e, t, n) {
    const i = Ox(er(r, e, t))
      , a = Ox(er(r, e, n))
      , s = Ox(er(t, n, r))
      , l = Ox(er(t, n, e));
    return !!(i !== a && s !== l || i === 0 && Ux(r, t, e) || a === 0 && Ux(r, n, e) || s === 0 && Ux(t, r, n) || l === 0 && Ux(t, e, n))
}
function Ux(r, e, t) {
    return e.x <= Math.max(r.x, t.x) && e.x >= Math.min(r.x, t.x) && e.y <= Math.max(r.y, t.y) && e.y >= Math.min(r.y, t.y)
}
function Ox(r) {
    return r > 0 ? 1 : r < 0 ? -1 : 0
}
function Oj(r, e) {
    let t = r;
    do {
        if (t.i !== r.i && t.next.i !== r.i && t.i !== e.i && t.next.i !== e.i && kB(t, t.next, r, e))
            return !0;
        t = t.next
    } while (t !== r);
    return !1
}
function jy(r, e) {
    return er(r.prev, r, r.next) < 0 ? er(r, e, r.next) >= 0 && er(r, r.prev, e) >= 0 : er(r, e, r.prev) < 0 || er(r, r.next, e) < 0
}
function Nj(r, e) {
    let t = r
      , n = !1;
    const i = (r.x + e.x) / 2
      , a = (r.y + e.y) / 2;
    do
        t.y > a != t.next.y > a && t.next.y !== t.y && i < (t.next.x - t.x) * (a - t.y) / (t.next.y - t.y) + t.x && (n = !n),
        t = t.next;
    while (t !== r);
    return n
}
function GB(r, e) {
    const t = pw(r.i, r.x, r.y)
      , n = pw(e.i, e.x, e.y)
      , i = r.next
      , a = e.prev;
    return r.next = e,
    e.prev = r,
    t.next = i,
    i.prev = t,
    n.next = t,
    t.prev = n,
    a.next = n,
    n.prev = a,
    n
}
function LU(r, e, t, n) {
    const i = pw(r, e, t);
    return n ? (i.next = n.next,
    i.prev = n,
    n.next.prev = i,
    n.next = i) : (i.prev = i,
    i.next = i),
    i
}
function Wy(r) {
    r.next.prev = r.prev,
    r.prev.next = r.next,
    r.prevZ && (r.prevZ.nextZ = r.nextZ),
    r.nextZ && (r.nextZ.prevZ = r.prevZ)
}
function pw(r, e, t) {
    return {
        i: r,
        x: e,
        y: t,
        prev: null,
        next: null,
        z: 0,
        prevZ: null,
        nextZ: null,
        steiner: !1
    }
}
function Lj(r, e, t, n) {
    let i = 0;
    for (let a = e, s = t - n; a < t; a += n)
        i += (r[s] - r[a]) * (r[a + 1] + r[s + 1]),
        s = a;
    return i
}
class Pj {
    static triangulate(e, t, n=2) {
        return yj(e, t, n)
    }
}
class Zl {
    static area(e) {
        const t = e.length;
        let n = 0;
        for (let i = t - 1, a = 0; a < t; i = a++)
            n += e[i].x * e[a].y - e[a].x * e[i].y;
        return n * .5
    }
    static isClockWise(e) {
        return Zl.area(e) < 0
    }
    static triangulateShape(e, t) {
        const n = []
          , i = []
          , a = [];
        PU(e),
        BU(n, e);
        let s = e.length;
        t.forEach(PU);
        for (let u = 0; u < t.length; u++)
            i.push(s),
            s += t[u].length,
            BU(n, t[u]);
        const l = Pj.triangulate(n, i);
        for (let u = 0; u < l.length; u += 3)
            a.push(l.slice(u, u + 3));
        return a
    }
}
function PU(r) {
    const e = r.length;
    e > 2 && r[e - 1].equals(r[0]) && r.pop()
}
function BU(r, e) {
    for (let t = 0; t < e.length; t++)
        r.push(e[t].x),
        r.push(e[t].y)
}
class EM extends Nn {
    constructor(e=new ip([new xt(.5,.5), new xt(-.5,.5), new xt(-.5,-.5), new xt(.5,-.5)]), t={}) {
        super(),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        e = Array.isArray(e) ? e : [e];
        const n = this
          , i = []
          , a = [];
        for (let l = 0, u = e.length; l < u; l++) {
            const f = e[l];
            s(f)
        }
        this.setAttribute("position", new Qt(i,3)),
        this.setAttribute("uv", new Qt(a,2)),
        this.computeVertexNormals();
        function s(l) {
            const u = []
              , f = t.curveSegments !== void 0 ? t.curveSegments : 12
              , d = t.steps !== void 0 ? t.steps : 1
              , g = t.depth !== void 0 ? t.depth : 1;
            let v = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0
              , y = t.bevelThickness !== void 0 ? t.bevelThickness : .2
              , S = t.bevelSize !== void 0 ? t.bevelSize : y - .1
              , T = t.bevelOffset !== void 0 ? t.bevelOffset : 0
              , M = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const b = t.extrudePath
              , A = t.UVGenerator !== void 0 ? t.UVGenerator : Bj;
            let C, R = !1, O, L, z, I;
            b && (C = b.getSpacedPoints(d),
            R = !0,
            v = !1,
            O = b.computeFrenetFrames(d, !1),
            L = new he,
            z = new he,
            I = new he),
            v || (M = 0,
            y = 0,
            S = 0,
            T = 0);
            const N = l.extractPoints(f);
            let P = N.shape;
            const Y = N.holes;
            if (!Zl.isClockWise(P)) {
                P = P.reverse();
                for (let Le = 0, Ne = Y.length; Le < Ne; Le++) {
                    const Oe = Y[Le];
                    Zl.isClockWise(Oe) && (Y[Le] = Oe.reverse())
                }
            }
            function K(Le) {
                const Oe = 10000000000000001e-36;
                let le = Le[0];
                for (let Pe = 1; Pe <= Le.length; Pe++) {
                    const He = Pe % Le.length
                      , Ve = Le[He]
                      , De = Ve.x - le.x
                      , vt = Ve.y - le.y
                      , J = De * De + vt * vt
                      , j = Math.max(Math.abs(Ve.x), Math.abs(Ve.y), Math.abs(le.x), Math.abs(le.y))
                      , ve = Oe * j * j;
                    if (J <= ve) {
                        Le.splice(He, 1),
                        Pe--;
                        continue
                    }
                    le = Ve
                }
            }
            K(P),
            Y.forEach(K);
            const Z = Y.length
              , oe = P;
            for (let Le = 0; Le < Z; Le++) {
                const Ne = Y[Le];
                P = P.concat(Ne)
            }
            function H(Le, Ne, Oe) {
                return Ne || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                Le.clone().addScaledVector(Ne, Oe)
            }
            const q = P.length;
            function Q(Le, Ne, Oe) {
                let le, Pe, He;
                const Ve = Le.x - Ne.x
                  , De = Le.y - Ne.y
                  , vt = Oe.x - Le.x
                  , J = Oe.y - Le.y
                  , j = Ve * Ve + De * De
                  , ve = Ve * J - De * vt;
                if (Math.abs(ve) > Number.EPSILON) {
                    const Be = Math.sqrt(j)
                      , we = Math.sqrt(vt * vt + J * J)
                      , Ce = Ne.x - De / Be
                      , it = Ne.y + Ve / Be
                      , lt = Oe.x - J / we
                      , Mt = Oe.y + vt / we
                      , pt = ((lt - Ce) * J - (Mt - it) * vt) / (Ve * J - De * vt);
                    le = Ce + Ve * pt - Le.x,
                    Pe = it + De * pt - Le.y;
                    const je = le * le + Pe * Pe;
                    if (je <= 2)
                        return new xt(le,Pe);
                    He = Math.sqrt(je / 2)
                } else {
                    let Be = !1;
                    Ve > Number.EPSILON ? vt > Number.EPSILON && (Be = !0) : Ve < -Number.EPSILON ? vt < -Number.EPSILON && (Be = !0) : Math.sign(De) === Math.sign(J) && (Be = !0),
                    Be ? (le = -De,
                    Pe = Ve,
                    He = Math.sqrt(j)) : (le = Ve,
                    Pe = De,
                    He = Math.sqrt(j / 2))
                }
                return new xt(le / He,Pe / He)
            }
            const se = [];
            for (let Le = 0, Ne = oe.length, Oe = Ne - 1, le = Le + 1; Le < Ne; Le++,
            Oe++,
            le++)
                Oe === Ne && (Oe = 0),
                le === Ne && (le = 0),
                se[Le] = Q(oe[Le], oe[Oe], oe[le]);
            const B = [];
            let W, te = se.concat();
            for (let Le = 0, Ne = Z; Le < Ne; Le++) {
                const Oe = Y[Le];
                W = [];
                for (let le = 0, Pe = Oe.length, He = Pe - 1, Ve = le + 1; le < Pe; le++,
                He++,
                Ve++)
                    He === Pe && (He = 0),
                    Ve === Pe && (Ve = 0),
                    W[le] = Q(Oe[le], Oe[He], Oe[Ve]);
                B.push(W),
                te = te.concat(W)
            }
            let fe;
            if (M === 0)
                fe = Zl.triangulateShape(oe, Y);
            else {
                const Le = []
                  , Ne = [];
                for (let Oe = 0; Oe < M; Oe++) {
                    const le = Oe / M
                      , Pe = y * Math.cos(le * Math.PI / 2)
                      , He = S * Math.sin(le * Math.PI / 2) + T;
                    for (let Ve = 0, De = oe.length; Ve < De; Ve++) {
                        const vt = H(oe[Ve], se[Ve], He);
                        Ze(vt.x, vt.y, -Pe),
                        le === 0 && Le.push(vt)
                    }
                    for (let Ve = 0, De = Z; Ve < De; Ve++) {
                        const vt = Y[Ve];
                        W = B[Ve];
                        const J = [];
                        for (let j = 0, ve = vt.length; j < ve; j++) {
                            const Be = H(vt[j], W[j], He);
                            Ze(Be.x, Be.y, -Pe),
                            le === 0 && J.push(Be)
                        }
                        le === 0 && Ne.push(J)
                    }
                }
                fe = Zl.triangulateShape(Le, Ne)
            }
            const pe = fe.length
              , _e = S + T;
            for (let Le = 0; Le < q; Le++) {
                const Ne = v ? H(P[Le], te[Le], _e) : P[Le];
                R ? (z.copy(O.normals[0]).multiplyScalar(Ne.x),
                L.copy(O.binormals[0]).multiplyScalar(Ne.y),
                I.copy(C[0]).add(z).add(L),
                Ze(I.x, I.y, I.z)) : Ze(Ne.x, Ne.y, 0)
            }
            for (let Le = 1; Le <= d; Le++)
                for (let Ne = 0; Ne < q; Ne++) {
                    const Oe = v ? H(P[Ne], te[Ne], _e) : P[Ne];
                    R ? (z.copy(O.normals[Le]).multiplyScalar(Oe.x),
                    L.copy(O.binormals[Le]).multiplyScalar(Oe.y),
                    I.copy(C[Le]).add(z).add(L),
                    Ze(I.x, I.y, I.z)) : Ze(Oe.x, Oe.y, g / d * Le)
                }
            for (let Le = M - 1; Le >= 0; Le--) {
                const Ne = Le / M
                  , Oe = y * Math.cos(Ne * Math.PI / 2)
                  , le = S * Math.sin(Ne * Math.PI / 2) + T;
                for (let Pe = 0, He = oe.length; Pe < He; Pe++) {
                    const Ve = H(oe[Pe], se[Pe], le);
                    Ze(Ve.x, Ve.y, g + Oe)
                }
                for (let Pe = 0, He = Y.length; Pe < He; Pe++) {
                    const Ve = Y[Pe];
                    W = B[Pe];
                    for (let De = 0, vt = Ve.length; De < vt; De++) {
                        const J = H(Ve[De], W[De], le);
                        R ? Ze(J.x, J.y + C[d - 1].y, C[d - 1].x + Oe) : Ze(J.x, J.y, g + Oe)
                    }
                }
            }
            ue(),
            ge();
            function ue() {
                const Le = i.length / 3;
                if (v) {
                    let Ne = 0
                      , Oe = q * Ne;
                    for (let le = 0; le < pe; le++) {
                        const Pe = fe[le];
                        ot(Pe[2] + Oe, Pe[1] + Oe, Pe[0] + Oe)
                    }
                    Ne = d + M * 2,
                    Oe = q * Ne;
                    for (let le = 0; le < pe; le++) {
                        const Pe = fe[le];
                        ot(Pe[0] + Oe, Pe[1] + Oe, Pe[2] + Oe)
                    }
                } else {
                    for (let Ne = 0; Ne < pe; Ne++) {
                        const Oe = fe[Ne];
                        ot(Oe[2], Oe[1], Oe[0])
                    }
                    for (let Ne = 0; Ne < pe; Ne++) {
                        const Oe = fe[Ne];
                        ot(Oe[0] + q * d, Oe[1] + q * d, Oe[2] + q * d)
                    }
                }
                n.addGroup(Le, i.length / 3 - Le, 0)
            }
            function ge() {
                const Le = i.length / 3;
                let Ne = 0;
                Te(oe, Ne),
                Ne += oe.length;
                for (let Oe = 0, le = Y.length; Oe < le; Oe++) {
                    const Pe = Y[Oe];
                    Te(Pe, Ne),
                    Ne += Pe.length
                }
                n.addGroup(Le, i.length / 3 - Le, 1)
            }
            function Te(Le, Ne) {
                let Oe = Le.length;
                for (; --Oe >= 0; ) {
                    const le = Oe;
                    let Pe = Oe - 1;
                    Pe < 0 && (Pe = Le.length - 1);
                    for (let He = 0, Ve = d + M * 2; He < Ve; He++) {
                        const De = q * He
                          , vt = q * (He + 1)
                          , J = Ne + le + De
                          , j = Ne + Pe + De
                          , ve = Ne + Pe + vt
                          , Be = Ne + le + vt;
                        tt(J, j, ve, Be)
                    }
                }
            }
            function Ze(Le, Ne, Oe) {
                u.push(Le),
                u.push(Ne),
                u.push(Oe)
            }
            function ot(Le, Ne, Oe) {
                $e(Le),
                $e(Ne),
                $e(Oe);
                const le = i.length / 3
                  , Pe = A.generateTopUV(n, i, le - 3, le - 2, le - 1);
                re(Pe[0]),
                re(Pe[1]),
                re(Pe[2])
            }
            function tt(Le, Ne, Oe, le) {
                $e(Le),
                $e(Ne),
                $e(le),
                $e(Ne),
                $e(Oe),
                $e(le);
                const Pe = i.length / 3
                  , He = A.generateSideWallUV(n, i, Pe - 6, Pe - 3, Pe - 2, Pe - 1);
                re(He[0]),
                re(He[1]),
                re(He[3]),
                re(He[1]),
                re(He[2]),
                re(He[3])
            }
            function $e(Le) {
                i.push(u[Le * 3 + 0]),
                i.push(u[Le * 3 + 1]),
                i.push(u[Le * 3 + 2])
            }
            function re(Le) {
                a.push(Le.x),
                a.push(Le.y)
            }
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes
          , n = this.parameters.options;
        return zj(t, n, e)
    }
    static fromJSON(e, t) {
        const n = [];
        for (let a = 0, s = e.shapes.length; a < s; a++) {
            const l = t[e.shapes[a]];
            n.push(l)
        }
        const i = e.options.extrudePath;
        return i !== void 0 && (e.options.extrudePath = new Ub[i.type]().fromJSON(i)),
        new EM(n,e.options)
    }
}
const Bj = {
    generateTopUV: function(r, e, t, n, i) {
        const a = e[t * 3]
          , s = e[t * 3 + 1]
          , l = e[n * 3]
          , u = e[n * 3 + 1]
          , f = e[i * 3]
          , d = e[i * 3 + 1];
        return [new xt(a,s), new xt(l,u), new xt(f,d)]
    },
    generateSideWallUV: function(r, e, t, n, i, a) {
        const s = e[t * 3]
          , l = e[t * 3 + 1]
          , u = e[t * 3 + 2]
          , f = e[n * 3]
          , d = e[n * 3 + 1]
          , g = e[n * 3 + 2]
          , v = e[i * 3]
          , y = e[i * 3 + 1]
          , S = e[i * 3 + 2]
          , T = e[a * 3]
          , M = e[a * 3 + 1]
          , b = e[a * 3 + 2];
        return Math.abs(l - d) < Math.abs(s - f) ? [new xt(s,1 - u), new xt(f,1 - g), new xt(v,1 - S), new xt(T,1 - b)] : [new xt(l,1 - u), new xt(d,1 - g), new xt(y,1 - S), new xt(M,1 - b)]
    }
};
function zj(r, e, t) {
    if (t.shapes = [],
    Array.isArray(r))
        for (let n = 0, i = r.length; n < i; n++) {
            const a = r[n];
            t.shapes.push(a.uuid)
        }
    else
        t.shapes.push(r.uuid);
    return t.options = Object.assign({}, e),
    e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()),
    t
}
class y_ extends wh {
    constructor(e=1, t=0) {
        const n = (1 + Math.sqrt(5)) / 2
          , i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1]
          , a = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        super(i, a, e, t),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new y_(e.radius,e.detail)
    }
}
class wM extends Nn {
    constructor(e=[new xt(0,-.5), new xt(.5,0), new xt(0,.5)], t=12, n=0, i=Math.PI * 2) {
        super(),
        this.type = "LatheGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: n,
            phiLength: i
        },
        t = Math.floor(t),
        i = gn(i, 0, Math.PI * 2);
        const a = []
          , s = []
          , l = []
          , u = []
          , f = []
          , d = 1 / t
          , g = new he
          , v = new xt
          , y = new he
          , S = new he
          , T = new he;
        let M = 0
          , b = 0;
        for (let A = 0; A <= e.length - 1; A++)
            switch (A) {
            case 0:
                M = e[A + 1].x - e[A].x,
                b = e[A + 1].y - e[A].y,
                y.x = b * 1,
                y.y = -M,
                y.z = b * 0,
                T.copy(y),
                y.normalize(),
                u.push(y.x, y.y, y.z);
                break;
            case e.length - 1:
                u.push(T.x, T.y, T.z);
                break;
            default:
                M = e[A + 1].x - e[A].x,
                b = e[A + 1].y - e[A].y,
                y.x = b * 1,
                y.y = -M,
                y.z = b * 0,
                S.copy(y),
                y.x += T.x,
                y.y += T.y,
                y.z += T.z,
                y.normalize(),
                u.push(y.x, y.y, y.z),
                T.copy(S)
            }
        for (let A = 0; A <= t; A++) {
            const C = n + A * d * i
              , R = Math.sin(C)
              , O = Math.cos(C);
            for (let L = 0; L <= e.length - 1; L++) {
                g.x = e[L].x * R,
                g.y = e[L].y,
                g.z = e[L].x * O,
                s.push(g.x, g.y, g.z),
                v.x = A / t,
                v.y = L / (e.length - 1),
                l.push(v.x, v.y);
                const z = u[3 * L + 0] * R
                  , I = u[3 * L + 1]
                  , N = u[3 * L + 0] * O;
                f.push(z, I, N)
            }
        }
        for (let A = 0; A < t; A++)
            for (let C = 0; C < e.length - 1; C++) {
                const R = C + A * e.length
                  , O = R
                  , L = R + e.length
                  , z = R + e.length + 1
                  , I = R + 1;
                a.push(O, L, I),
                a.push(z, I, L)
            }
        this.setIndex(a),
        this.setAttribute("position", new Qt(s,3)),
        this.setAttribute("uv", new Qt(l,2)),
        this.setAttribute("normal", new Qt(f,3))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new wM(e.points,e.segments,e.phiStart,e.phiLength)
    }
}
class __ extends wh {
    constructor(e=1, t=0) {
        const n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1]
          , i = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        super(n, i, e, t),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new __(e.radius,e.detail)
    }
}
class eu extends Nn {
    constructor(e=1, t=1, n=1, i=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: i
        };
        const a = e / 2
          , s = t / 2
          , l = Math.floor(n)
          , u = Math.floor(i)
          , f = l + 1
          , d = u + 1
          , g = e / l
          , v = t / u
          , y = []
          , S = []
          , T = []
          , M = [];
        for (let b = 0; b < d; b++) {
            const A = b * v - s;
            for (let C = 0; C < f; C++) {
                const R = C * g - a;
                S.push(R, -A, 0),
                T.push(0, 0, 1),
                M.push(C / l),
                M.push(1 - b / u)
            }
        }
        for (let b = 0; b < u; b++)
            for (let A = 0; A < l; A++) {
                const C = A + f * b
                  , R = A + f * (b + 1)
                  , O = A + 1 + f * (b + 1)
                  , L = A + 1 + f * b;
                y.push(C, R, L),
                y.push(R, O, L)
            }
        this.setIndex(y),
        this.setAttribute("position", new Qt(S,3)),
        this.setAttribute("normal", new Qt(T,3)),
        this.setAttribute("uv", new Qt(M,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new eu(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
class AM extends Nn {
    constructor(e=.5, t=1, n=32, i=1, a=0, s=Math.PI * 2) {
        super(),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: n,
            phiSegments: i,
            thetaStart: a,
            thetaLength: s
        },
        n = Math.max(3, n),
        i = Math.max(1, i);
        const l = []
          , u = []
          , f = []
          , d = [];
        let g = e;
        const v = (t - e) / i
          , y = new he
          , S = new xt;
        for (let T = 0; T <= i; T++) {
            for (let M = 0; M <= n; M++) {
                const b = a + M / n * s;
                y.x = g * Math.cos(b),
                y.y = g * Math.sin(b),
                u.push(y.x, y.y, y.z),
                f.push(0, 0, 1),
                S.x = (y.x / t + 1) / 2,
                S.y = (y.y / t + 1) / 2,
                d.push(S.x, S.y)
            }
            g += v
        }
        for (let T = 0; T < i; T++) {
            const M = T * (n + 1);
            for (let b = 0; b < n; b++) {
                const A = b + M
                  , C = A
                  , R = A + n + 1
                  , O = A + n + 2
                  , L = A + 1;
                l.push(C, R, L),
                l.push(R, O, L)
            }
        }
        this.setIndex(l),
        this.setAttribute("position", new Qt(u,3)),
        this.setAttribute("normal", new Qt(f,3)),
        this.setAttribute("uv", new Qt(d,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new AM(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)
    }
}
class CM extends Nn {
    constructor(e=new ip([new xt(0,.5), new xt(-.5,-.5), new xt(.5,-.5)]), t=12) {
        super(),
        this.type = "ShapeGeometry",
        this.parameters = {
            shapes: e,
            curveSegments: t
        };
        const n = []
          , i = []
          , a = []
          , s = [];
        let l = 0
          , u = 0;
        if (Array.isArray(e) === !1)
            f(e);
        else
            for (let d = 0; d < e.length; d++)
                f(e[d]),
                this.addGroup(l, u, d),
                l += u,
                u = 0;
        this.setIndex(n),
        this.setAttribute("position", new Qt(i,3)),
        this.setAttribute("normal", new Qt(a,3)),
        this.setAttribute("uv", new Qt(s,2));
        function f(d) {
            const g = i.length / 3
              , v = d.extractPoints(t);
            let y = v.shape;
            const S = v.holes;
            Zl.isClockWise(y) === !1 && (y = y.reverse());
            for (let M = 0, b = S.length; M < b; M++) {
                const A = S[M];
                Zl.isClockWise(A) === !0 && (S[M] = A.reverse())
            }
            const T = Zl.triangulateShape(y, S);
            for (let M = 0, b = S.length; M < b; M++) {
                const A = S[M];
                y = y.concat(A)
            }
            for (let M = 0, b = y.length; M < b; M++) {
                const A = y[M];
                i.push(A.x, A.y, 0),
                a.push(0, 0, 1),
                s.push(A.x, A.y)
            }
            for (let M = 0, b = T.length; M < b; M++) {
                const A = T[M]
                  , C = A[0] + g
                  , R = A[1] + g
                  , O = A[2] + g;
                n.push(C, R, O),
                u += 3
            }
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes;
        return Ij(t, e)
    }
    static fromJSON(e, t) {
        const n = [];
        for (let i = 0, a = e.shapes.length; i < a; i++) {
            const s = t[e.shapes[i]];
            n.push(s)
        }
        return new CM(n,e.curveSegments)
    }
}
function Ij(r, e) {
    if (e.shapes = [],
    Array.isArray(r))
        for (let t = 0, n = r.length; t < n; t++) {
            const i = r[t];
            e.shapes.push(i.uuid)
        }
    else
        e.shapes.push(r.uuid);
    return e
}
class x_ extends Nn {
    constructor(e=1, t=32, n=16, i=0, a=Math.PI * 2, s=0, l=Math.PI) {
        super(),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: n,
            phiStart: i,
            phiLength: a,
            thetaStart: s,
            thetaLength: l
        },
        t = Math.max(3, Math.floor(t)),
        n = Math.max(2, Math.floor(n));
        const u = Math.min(s + l, Math.PI);
        let f = 0;
        const d = []
          , g = new he
          , v = new he
          , y = []
          , S = []
          , T = []
          , M = [];
        for (let b = 0; b <= n; b++) {
            const A = []
              , C = b / n;
            let R = 0;
            b === 0 && s === 0 ? R = .5 / t : b === n && u === Math.PI && (R = -.5 / t);
            for (let O = 0; O <= t; O++) {
                const L = O / t;
                g.x = -e * Math.cos(i + L * a) * Math.sin(s + C * l),
                g.y = e * Math.cos(s + C * l),
                g.z = e * Math.sin(i + L * a) * Math.sin(s + C * l),
                S.push(g.x, g.y, g.z),
                v.copy(g).normalize(),
                T.push(v.x, v.y, v.z),
                M.push(L + R, 1 - C),
                A.push(f++)
            }
            d.push(A)
        }
        for (let b = 0; b < n; b++)
            for (let A = 0; A < t; A++) {
                const C = d[b][A + 1]
                  , R = d[b][A]
                  , O = d[b + 1][A]
                  , L = d[b + 1][A + 1];
                (b !== 0 || s > 0) && y.push(C, R, L),
                (b !== n - 1 || u < Math.PI) && y.push(R, O, L)
            }
        this.setIndex(y),
        this.setAttribute("position", new Qt(S,3)),
        this.setAttribute("normal", new Qt(T,3)),
        this.setAttribute("uv", new Qt(M,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new x_(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
    }
}
class RM extends wh {
    constructor(e=1, t=0) {
        const n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1]
          , i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        super(n, i, e, t),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new RM(e.radius,e.detail)
    }
}
class DM extends Nn {
    constructor(e=1, t=.4, n=12, i=48, a=Math.PI * 2) {
        super(),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: n,
            tubularSegments: i,
            arc: a
        },
        n = Math.floor(n),
        i = Math.floor(i);
        const s = []
          , l = []
          , u = []
          , f = []
          , d = new he
          , g = new he
          , v = new he;
        for (let y = 0; y <= n; y++)
            for (let S = 0; S <= i; S++) {
                const T = S / i * a
                  , M = y / n * Math.PI * 2;
                g.x = (e + t * Math.cos(M)) * Math.cos(T),
                g.y = (e + t * Math.cos(M)) * Math.sin(T),
                g.z = t * Math.sin(M),
                l.push(g.x, g.y, g.z),
                d.x = e * Math.cos(T),
                d.y = e * Math.sin(T),
                v.subVectors(g, d).normalize(),
                u.push(v.x, v.y, v.z),
                f.push(S / i),
                f.push(y / n)
            }
        for (let y = 1; y <= n; y++)
            for (let S = 1; S <= i; S++) {
                const T = (i + 1) * y + S - 1
                  , M = (i + 1) * (y - 1) + S - 1
                  , b = (i + 1) * (y - 1) + S
                  , A = (i + 1) * y + S;
                s.push(T, M, A),
                s.push(M, b, A)
            }
        this.setIndex(s),
        this.setAttribute("position", new Qt(l,3)),
        this.setAttribute("normal", new Qt(u,3)),
        this.setAttribute("uv", new Qt(f,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new DM(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)
    }
}
class UM extends Nn {
    constructor(e=1, t=.4, n=64, i=8, a=2, s=3) {
        super(),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: n,
            radialSegments: i,
            p: a,
            q: s
        },
        n = Math.floor(n),
        i = Math.floor(i);
        const l = []
          , u = []
          , f = []
          , d = []
          , g = new he
          , v = new he
          , y = new he
          , S = new he
          , T = new he
          , M = new he
          , b = new he;
        for (let C = 0; C <= n; ++C) {
            const R = C / n * a * Math.PI * 2;
            A(R, a, s, e, y),
            A(R + .01, a, s, e, S),
            M.subVectors(S, y),
            b.addVectors(S, y),
            T.crossVectors(M, b),
            b.crossVectors(T, M),
            T.normalize(),
            b.normalize();
            for (let O = 0; O <= i; ++O) {
                const L = O / i * Math.PI * 2
                  , z = -t * Math.cos(L)
                  , I = t * Math.sin(L);
                g.x = y.x + (z * b.x + I * T.x),
                g.y = y.y + (z * b.y + I * T.y),
                g.z = y.z + (z * b.z + I * T.z),
                u.push(g.x, g.y, g.z),
                v.subVectors(g, y).normalize(),
                f.push(v.x, v.y, v.z),
                d.push(C / n),
                d.push(O / i)
            }
        }
        for (let C = 1; C <= n; C++)
            for (let R = 1; R <= i; R++) {
                const O = (i + 1) * (C - 1) + (R - 1)
                  , L = (i + 1) * C + (R - 1)
                  , z = (i + 1) * C + R
                  , I = (i + 1) * (C - 1) + R;
                l.push(O, L, I),
                l.push(L, z, I)
            }
        this.setIndex(l),
        this.setAttribute("position", new Qt(u,3)),
        this.setAttribute("normal", new Qt(f,3)),
        this.setAttribute("uv", new Qt(d,2));
        function A(C, R, O, L, z) {
            const I = Math.cos(C)
              , N = Math.sin(C)
              , P = O / R * C
              , Y = Math.cos(P);
            z.x = L * (2 + Y) * .5 * I,
            z.y = L * (2 + Y) * N * .5,
            z.z = L * Math.sin(P) * .5
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new UM(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)
    }
}
class OM extends Nn {
    constructor(e=new xC(new he(-1,-1,0),new he(-1,1,0),new he(1,1,0)), t=64, n=1, i=8, a=!1) {
        super(),
        this.type = "TubeGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: n,
            radialSegments: i,
            closed: a
        };
        const s = e.computeFrenetFrames(t, a);
        this.tangents = s.tangents,
        this.normals = s.normals,
        this.binormals = s.binormals;
        const l = new he
          , u = new he
          , f = new xt;
        let d = new he;
        const g = []
          , v = []
          , y = []
          , S = [];
        T(),
        this.setIndex(S),
        this.setAttribute("position", new Qt(g,3)),
        this.setAttribute("normal", new Qt(v,3)),
        this.setAttribute("uv", new Qt(y,2));
        function T() {
            for (let C = 0; C < t; C++)
                M(C);
            M(a === !1 ? t : 0),
            A(),
            b()
        }
        function M(C) {
            d = e.getPointAt(C / t, d);
            const R = s.normals[C]
              , O = s.binormals[C];
            for (let L = 0; L <= i; L++) {
                const z = L / i * Math.PI * 2
                  , I = Math.sin(z)
                  , N = -Math.cos(z);
                u.x = N * R.x + I * O.x,
                u.y = N * R.y + I * O.y,
                u.z = N * R.z + I * O.z,
                u.normalize(),
                v.push(u.x, u.y, u.z),
                l.x = d.x + n * u.x,
                l.y = d.y + n * u.y,
                l.z = d.z + n * u.z,
                g.push(l.x, l.y, l.z)
            }
        }
        function b() {
            for (let C = 1; C <= t; C++)
                for (let R = 1; R <= i; R++) {
                    const O = (i + 1) * (C - 1) + (R - 1)
                      , L = (i + 1) * C + (R - 1)
                      , z = (i + 1) * C + R
                      , I = (i + 1) * (C - 1) + R;
                    S.push(O, L, I),
                    S.push(L, z, I)
                }
        }
        function A() {
            for (let C = 0; C <= t; C++)
                for (let R = 0; R <= i; R++)
                    f.x = C / t,
                    f.y = R / i,
                    y.push(f.x, f.y)
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.path = this.parameters.path.toJSON(),
        e
    }
    static fromJSON(e) {
        return new OM(new Ub[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)
    }
}
class XB extends Nn {
    constructor(e=null) {
        if (super(),
        this.type = "WireframeGeometry",
        this.parameters = {
            geometry: e
        },
        e !== null) {
            const t = []
              , n = new Set
              , i = new he
              , a = new he;
            if (e.index !== null) {
                const s = e.attributes.position
                  , l = e.index;
                let u = e.groups;
                u.length === 0 && (u = [{
                    start: 0,
                    count: l.count,
                    materialIndex: 0
                }]);
                for (let f = 0, d = u.length; f < d; ++f) {
                    const g = u[f]
                      , v = g.start
                      , y = g.count;
                    for (let S = v, T = v + y; S < T; S += 3)
                        for (let M = 0; M < 3; M++) {
                            const b = l.getX(S + M)
                              , A = l.getX(S + (M + 1) % 3);
                            i.fromBufferAttribute(s, b),
                            a.fromBufferAttribute(s, A),
                            zU(i, a, n) === !0 && (t.push(i.x, i.y, i.z),
                            t.push(a.x, a.y, a.z))
                        }
                }
            } else {
                const s = e.attributes.position;
                for (let l = 0, u = s.count / 3; l < u; l++)
                    for (let f = 0; f < 3; f++) {
                        const d = 3 * l + f
                          , g = 3 * l + (f + 1) % 3;
                        i.fromBufferAttribute(s, d),
                        a.fromBufferAttribute(s, g),
                        zU(i, a, n) === !0 && (t.push(i.x, i.y, i.z),
                        t.push(a.x, a.y, a.z))
                    }
            }
            this.setAttribute("position", new Qt(t,3))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
}
function zU(r, e, t) {
    const n = `${r.x},${r.y},${r.z}-${e.x},${e.y},${e.z}`
      , i = `${e.x},${e.y},${e.z}-${r.x},${r.y},${r.z}`;
    return t.has(n) === !0 || t.has(i) === !0 ? !1 : (t.add(n),
    t.add(i),
    !0)
}
var IU = Object.freeze({
    __proto__: null,
    BoxGeometry: yp,
    CapsuleGeometry: SM,
    CircleGeometry: bM,
    ConeGeometry: v_,
    CylinderGeometry: g_,
    DodecahedronGeometry: MM,
    EdgesGeometry: LB,
    ExtrudeGeometry: EM,
    IcosahedronGeometry: y_,
    LatheGeometry: wM,
    OctahedronGeometry: __,
    PlaneGeometry: eu,
    PolyhedronGeometry: wh,
    RingGeometry: AM,
    ShapeGeometry: CM,
    SphereGeometry: x_,
    TetrahedronGeometry: RM,
    TorusGeometry: DM,
    TorusKnotGeometry: UM,
    TubeGeometry: OM,
    WireframeGeometry: XB
});
class jB extends Va {
    constructor(e) {
        super(),
        this.isShadowMaterial = !0,
        this.type = "ShadowMaterial",
        this.color = new kt(0),
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.fog = e.fog,
        this
    }
}
class WB extends Ks {
    constructor(e) {
        super(e),
        this.isRawShaderMaterial = !0,
        this.type = "RawShaderMaterial"
    }
}
class bC extends Va {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.type = "MeshStandardMaterial",
        this.defines = {
            STANDARD: ""
        },
        this.color = new kt(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new kt(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Eh,
        this.normalScale = new xt(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Co,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class YB extends bC {
    constructor(e) {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.anisotropyRotation = 0,
        this.anisotropyMap = null,
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new xt(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return gn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new kt(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 1 / 0,
        this.attenuationColor = new kt(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new kt(1,1,1),
        this.specularColorMap = null,
        this._anisotropy = 0,
        this._clearcoat = 0,
        this._dispersion = 0,
        this._iridescence = 0,
        this._sheen = 0,
        this._transmission = 0,
        this.setValues(e)
    }
    get anisotropy() {
        return this._anisotropy
    }
    set anisotropy(e) {
        this._anisotropy > 0 != e > 0 && this.version++,
        this._anisotropy = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
        this._iridescence = e
    }
    get dispersion() {
        return this._dispersion
    }
    set dispersion(e) {
        this._dispersion > 0 != e > 0 && this.version++,
        this._dispersion = e
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.anisotropy = e.anisotropy,
        this.anisotropyRotation = e.anisotropyRotation,
        this.anisotropyMap = e.anisotropyMap,
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.dispersion = e.dispersion,
        this.ior = e.ior,
        this.iridescence = e.iridescence,
        this.iridescenceMap = e.iridescenceMap,
        this.iridescenceIOR = e.iridescenceIOR,
        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this
    }
}
class qB extends Va {
    constructor(e) {
        super(),
        this.isMeshPhongMaterial = !0,
        this.type = "MeshPhongMaterial",
        this.color = new kt(16777215),
        this.specular = new kt(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new kt(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Eh,
        this.normalScale = new xt(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Co,
        this.combine = c_,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class ZB extends Va {
    constructor(e) {
        super(),
        this.isMeshToonMaterial = !0,
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.color = new kt(16777215),
        this.map = null,
        this.gradientMap = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new kt(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Eh,
        this.normalScale = new xt(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.gradientMap = e.gradientMap,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
class KB extends Va {
    constructor(e) {
        super(),
        this.isMeshNormalMaterial = !0,
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Eh,
        this.normalScale = new xt(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.flatShading = !1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.flatShading = e.flatShading,
        this
    }
}
class QB extends Va {
    constructor(e) {
        super(),
        this.isMeshLambertMaterial = !0,
        this.type = "MeshLambertMaterial",
        this.color = new kt(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new kt(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Eh,
        this.normalScale = new xt(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Co,
        this.combine = c_,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class NM extends Va {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = uB,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class LM extends Va {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
class JB extends Va {
    constructor(e) {
        super(),
        this.isMeshMatcapMaterial = !0,
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new kt(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Eh,
        this.normalScale = new xt(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(e.color),
        this.matcap = e.matcap,
        this.map = e.map,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class $B extends _s {
    constructor(e) {
        super(),
        this.isLineDashedMaterial = !0,
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.scale = e.scale,
        this.dashSize = e.dashSize,
        this.gapSize = e.gapSize,
        this
    }
}
function Wd(r, e) {
    return !r || r.constructor === e ? r : typeof e.BYTES_PER_ELEMENT == "number" ? new e(r) : Array.prototype.slice.call(r)
}
function ez(r) {
    return ArrayBuffer.isView(r) && !(r instanceof DataView)
}
function tz(r) {
    function e(i, a) {
        return r[i] - r[a]
    }
    const t = r.length
      , n = new Array(t);
    for (let i = 0; i !== t; ++i)
        n[i] = i;
    return n.sort(e),
    n
}
function mw(r, e, t) {
    const n = r.length
      , i = new r.constructor(n);
    for (let a = 0, s = 0; s !== n; ++a) {
        const l = t[a] * e;
        for (let u = 0; u !== e; ++u)
            i[s++] = r[l + u]
    }
    return i
}
function MC(r, e, t, n) {
    let i = 1
      , a = r[0];
    for (; a !== void 0 && a[n] === void 0; )
        a = r[i++];
    if (a === void 0)
        return;
    let s = a[n];
    if (s !== void 0)
        if (Array.isArray(s))
            do
                s = a[n],
                s !== void 0 && (e.push(a.time),
                t.push(...s)),
                a = r[i++];
            while (a !== void 0);
        else if (s.toArray !== void 0)
            do
                s = a[n],
                s !== void 0 && (e.push(a.time),
                s.toArray(t, t.length)),
                a = r[i++];
            while (a !== void 0);
        else
            do
                s = a[n],
                s !== void 0 && (e.push(a.time),
                t.push(s)),
                a = r[i++];
            while (a !== void 0)
}
function Fj(r, e, t, n, i=30) {
    const a = r.clone();
    a.name = e;
    const s = [];
    for (let u = 0; u < a.tracks.length; ++u) {
        const f = a.tracks[u]
          , d = f.getValueSize()
          , g = []
          , v = [];
        for (let y = 0; y < f.times.length; ++y) {
            const S = f.times[y] * i;
            if (!(S < t || S >= n)) {
                g.push(f.times[y]);
                for (let T = 0; T < d; ++T)
                    v.push(f.values[y * d + T])
            }
        }
        g.length !== 0 && (f.times = Wd(g, f.times.constructor),
        f.values = Wd(v, f.values.constructor),
        s.push(f))
    }
    a.tracks = s;
    let l = 1 / 0;
    for (let u = 0; u < a.tracks.length; ++u)
        l > a.tracks[u].times[0] && (l = a.tracks[u].times[0]);
    for (let u = 0; u < a.tracks.length; ++u)
        a.tracks[u].shift(-1 * l);
    return a.resetDuration(),
    a
}
function Hj(r, e=0, t=r, n=30) {
    n <= 0 && (n = 30);
    const i = t.tracks.length
      , a = e / n;
    for (let s = 0; s < i; ++s) {
        const l = t.tracks[s]
          , u = l.ValueTypeName;
        if (u === "bool" || u === "string")
            continue;
        const f = r.tracks.find(function(b) {
            return b.name === l.name && b.ValueTypeName === u
        });
        if (f === void 0)
            continue;
        let d = 0;
        const g = l.getValueSize();
        l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = g / 3);
        let v = 0;
        const y = f.getValueSize();
        f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (v = y / 3);
        const S = l.times.length - 1;
        let T;
        if (a <= l.times[0]) {
            const b = d
              , A = g - d;
            T = l.values.slice(b, A)
        } else if (a >= l.times[S]) {
            const b = S * g + d
              , A = b + g - d;
            T = l.values.slice(b, A)
        } else {
            const b = l.createInterpolant()
              , A = d
              , C = g - d;
            b.evaluate(a),
            T = b.resultBuffer.slice(A, C)
        }
        u === "quaternion" && new qs().fromArray(T).normalize().conjugate().toArray(T);
        const M = f.times.length;
        for (let b = 0; b < M; ++b) {
            const A = b * y + v;
            if (u === "quaternion")
                qs.multiplyQuaternionsFlat(f.values, A, T, 0, f.values, A);
            else {
                const C = y - v * 2;
                for (let R = 0; R < C; ++R)
                    f.values[A + R] -= T[R]
            }
        }
    }
    return r.blendMode = nC,
    r
}
class Vj {
    static convertArray(e, t) {
        return Wd(e, t)
    }
    static isTypedArray(e) {
        return ez(e)
    }
    static getKeyframeOrder(e) {
        return tz(e)
    }
    static sortedArray(e, t, n) {
        return mw(e, t, n)
    }
    static flattenJSON(e, t, n, i) {
        MC(e, t, n, i)
    }
    static subclip(e, t, n, i, a=30) {
        return Fj(e, t, n, i, a)
    }
    static makeClipAdditive(e, t=0, n=e, i=30) {
        return Hj(e, t, n, i)
    }
}
class S_ {
    constructor(e, t, n, i) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = i !== void 0 ? i : new t.constructor(n),
        this.sampleValues = t,
        this.valueSize = n,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let n = this._cachedIndex
          , i = t[n]
          , a = t[n - 1];
        e: {
            t: {
                let s;
                n: {
                    i: if (!(e < i)) {
                        for (let l = n + 2; ; ) {
                            if (i === void 0) {
                                if (e < a)
                                    break i;
                                return n = t.length,
                                this._cachedIndex = n,
                                this.copySampleValue_(n - 1)
                            }
                            if (n === l)
                                break;
                            if (a = i,
                            i = t[++n],
                            e < i)
                                break t
                        }
                        s = t.length;
                        break n
                    }
                    if (!(e >= a)) {
                        const l = t[1];
                        e < l && (n = 2,
                        a = l);
                        for (let u = n - 2; ; ) {
                            if (a === void 0)
                                return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                            if (n === u)
                                break;
                            if (i = a,
                            a = t[--n - 1],
                            e >= a)
                                break t
                        }
                        s = n,
                        n = 0;
                        break n
                    }
                    break e
                }
                for (; n < s; ) {
                    const l = n + s >>> 1;
                    e < t[l] ? s = l : n = l + 1
                }
                if (i = t[n],
                a = t[n - 1],
                a === void 0)
                    return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                if (i === void 0)
                    return n = t.length,
                    this._cachedIndex = n,
                    this.copySampleValue_(n - 1)
            }
            this._cachedIndex = n,
            this.intervalChanged_(n, a, i)
        }
        return this.interpolate_(n, a, e, i)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , n = this.sampleValues
          , i = this.valueSize
          , a = e * i;
        for (let s = 0; s !== i; ++s)
            t[s] = n[a + s];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class nz extends S_ {
    constructor(e, t, n, i) {
        super(e, t, n, i),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: Gd,
            endingEnd: Gd
        }
    }
    intervalChanged_(e, t, n) {
        const i = this.parameterPositions;
        let a = e - 2
          , s = e + 1
          , l = i[a]
          , u = i[s];
        if (l === void 0)
            switch (this.getSettings_().endingStart) {
            case Xd:
                a = e,
                l = 2 * t - n;
                break;
            case Fy:
                a = i.length - 2,
                l = t + i[a] - i[a + 1];
                break;
            default:
                a = e,
                l = n
            }
        if (u === void 0)
            switch (this.getSettings_().endingEnd) {
            case Xd:
                s = e,
                u = 2 * n - t;
                break;
            case Fy:
                s = 1,
                u = n + i[1] - i[0];
                break;
            default:
                s = e - 1,
                u = t
            }
        const f = (n - t) * .5
          , d = this.valueSize;
        this._weightPrev = f / (t - l),
        this._weightNext = f / (u - n),
        this._offsetPrev = a * d,
        this._offsetNext = s * d
    }
    interpolate_(e, t, n, i) {
        const a = this.resultBuffer
          , s = this.sampleValues
          , l = this.valueSize
          , u = e * l
          , f = u - l
          , d = this._offsetPrev
          , g = this._offsetNext
          , v = this._weightPrev
          , y = this._weightNext
          , S = (n - t) / (i - t)
          , T = S * S
          , M = T * S
          , b = -v * M + 2 * v * T - v * S
          , A = (1 + v) * M + (-1.5 - 2 * v) * T + (-.5 + v) * S + 1
          , C = (-1 - y) * M + (1.5 + y) * T + .5 * S
          , R = y * M - y * T;
        for (let O = 0; O !== l; ++O)
            a[O] = b * s[d + O] + A * s[f + O] + C * s[u + O] + R * s[g + O];
        return a
    }
}
class TC extends S_ {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e, t, n, i) {
        const a = this.resultBuffer
          , s = this.sampleValues
          , l = this.valueSize
          , u = e * l
          , f = u - l
          , d = (n - t) / (i - t)
          , g = 1 - d;
        for (let v = 0; v !== l; ++v)
            a[v] = s[f + v] * g + s[u + v] * d;
        return a
    }
}
class iz extends S_ {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class ol {
    constructor(e, t, n, i) {
        if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = Wd(t, this.TimeBufferType),
        this.values = Wd(n, this.ValueBufferType),
        this.setInterpolation(i || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let n;
        if (t.toJSON !== this.toJSON)
            n = t.toJSON(e);
        else {
            n = {
                name: e.name,
                times: Wd(e.times, Array),
                values: Wd(e.values, Array)
            };
            const i = e.getInterpolation();
            i !== e.DefaultInterpolation && (n.interpolation = i)
        }
        return n.type = e.ValueTypeName,
        n
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new iz(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new TC(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new nz(this.times,this.values,this.getValueSize(),e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
        case Iy:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case Cb:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case _S:
            t = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (t === void 0) {
            const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else
                    throw new Error(n);
            return console.warn("THREE.KeyframeTrack:", n),
            this
        }
        return this.createInterpolant = t,
        this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return Iy;
        case this.InterpolantFactoryMethodLinear:
            return Cb;
        case this.InterpolantFactoryMethodSmooth:
            return _S
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n)
                t[n] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n)
                t[n] *= e
        }
        return this
    }
    trim(e, t) {
        const n = this.times
          , i = n.length;
        let a = 0
          , s = i - 1;
        for (; a !== i && n[a] < e; )
            ++a;
        for (; s !== -1 && n[s] > t; )
            --s;
        if (++s,
        a !== 0 || s !== i) {
            a >= s && (s = Math.max(s, 1),
            a = s - 1);
            const l = this.getValueSize();
            this.times = n.slice(a, s),
            this.values = this.values.slice(a * l, s * l)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        e = !1);
        const n = this.times
          , i = this.values
          , a = n.length;
        a === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        e = !1);
        let s = null;
        for (let l = 0; l !== a; l++) {
            const u = n[l];
            if (typeof u == "number" && isNaN(u)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, l, u),
                e = !1;
                break
            }
            if (s !== null && s > u) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, l, u, s),
                e = !1;
                break
            }
            s = u
        }
        if (i !== void 0 && ez(i))
            for (let l = 0, u = i.length; l !== u; ++l) {
                const f = i[l];
                if (isNaN(f)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, l, f),
                    e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = this.times.slice()
          , t = this.values.slice()
          , n = this.getValueSize()
          , i = this.getInterpolation() === _S
          , a = e.length - 1;
        let s = 1;
        for (let l = 1; l < a; ++l) {
            let u = !1;
            const f = e[l]
              , d = e[l + 1];
            if (f !== d && (l !== 1 || f !== e[0]))
                if (i)
                    u = !0;
                else {
                    const g = l * n
                      , v = g - n
                      , y = g + n;
                    for (let S = 0; S !== n; ++S) {
                        const T = t[g + S];
                        if (T !== t[v + S] || T !== t[y + S]) {
                            u = !0;
                            break
                        }
                    }
                }
            if (u) {
                if (l !== s) {
                    e[s] = e[l];
                    const g = l * n
                      , v = s * n;
                    for (let y = 0; y !== n; ++y)
                        t[v + y] = t[g + y]
                }
                ++s
            }
        }
        if (a > 0) {
            e[s] = e[a];
            for (let l = a * n, u = s * n, f = 0; f !== n; ++f)
                t[u + f] = t[l + f];
            ++s
        }
        return s !== e.length ? (this.times = e.slice(0, s),
        this.values = t.slice(0, s * n)) : (this.times = e,
        this.values = t),
        this
    }
    clone() {
        const e = this.times.slice()
          , t = this.values.slice()
          , n = this.constructor
          , i = new n(this.name,e,t);
        return i.createInterpolant = this.createInterpolant,
        i
    }
}
ol.prototype.ValueTypeName = "";
ol.prototype.TimeBufferType = Float32Array;
ol.prototype.ValueBufferType = Float32Array;
ol.prototype.DefaultInterpolation = Cb;
class _p extends ol {
    constructor(e, t, n) {
        super(e, t, n)
    }
}
_p.prototype.ValueTypeName = "bool";
_p.prototype.ValueBufferType = Array;
_p.prototype.DefaultInterpolation = Iy;
_p.prototype.InterpolantFactoryMethodLinear = void 0;
_p.prototype.InterpolantFactoryMethodSmooth = void 0;
class EC extends ol {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
}
EC.prototype.ValueTypeName = "color";
class Yy extends ol {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
}
Yy.prototype.ValueTypeName = "number";
class rz extends S_ {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e, t, n, i) {
        const a = this.resultBuffer
          , s = this.sampleValues
          , l = this.valueSize
          , u = (n - t) / (i - t);
        let f = e * l;
        for (let d = f + l; f !== d; f += 4)
            qs.slerpFlat(a, 0, s, f - l, s, f, u);
        return a
    }
}
class b_ extends ol {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    InterpolantFactoryMethodLinear(e) {
        return new rz(this.times,this.values,this.getValueSize(),e)
    }
}
b_.prototype.ValueTypeName = "quaternion";
b_.prototype.InterpolantFactoryMethodSmooth = void 0;
class xp extends ol {
    constructor(e, t, n) {
        super(e, t, n)
    }
}
xp.prototype.ValueTypeName = "string";
xp.prototype.ValueBufferType = Array;
xp.prototype.DefaultInterpolation = Iy;
xp.prototype.InterpolantFactoryMethodLinear = void 0;
xp.prototype.InterpolantFactoryMethodSmooth = void 0;
class qy extends ol {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
}
qy.prototype.ValueTypeName = "vector";
class Zy {
    constructor(e="", t=-1, n=[], i=fM) {
        this.name = e,
        this.tracks = n,
        this.duration = t,
        this.blendMode = i,
        this.uuid = To(),
        this.userData = {},
        this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = []
          , n = e.tracks
          , i = 1 / (e.fps || 1);
        for (let s = 0, l = n.length; s !== l; ++s)
            t.push(Gj(n[s]).scale(i));
        const a = new this(e.name,e.duration,t,e.blendMode);
        return a.uuid = e.uuid,
        a.userData = JSON.parse(e.userData || "{}"),
        a
    }
    static toJSON(e) {
        const t = []
          , n = e.tracks
          , i = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode,
            userData: JSON.stringify(e.userData)
        };
        for (let a = 0, s = n.length; a !== s; ++a)
            t.push(ol.toJSON(n[a]));
        return i
    }
    static CreateFromMorphTargetSequence(e, t, n, i) {
        const a = t.length
          , s = [];
        for (let l = 0; l < a; l++) {
            let u = []
              , f = [];
            u.push((l + a - 1) % a, l, (l + 1) % a),
            f.push(0, 1, 0);
            const d = tz(u);
            u = mw(u, 1, d),
            f = mw(f, 1, d),
            !i && u[0] === 0 && (u.push(a),
            f.push(f[0])),
            s.push(new Yy(".morphTargetInfluences[" + t[l].name + "]",u,f).scale(1 / n))
        }
        return new this(e,-1,s)
    }
    static findByName(e, t) {
        let n = e;
        if (!Array.isArray(e)) {
            const i = e;
            n = i.geometry && i.geometry.animations || i.animations
        }
        for (let i = 0; i < n.length; i++)
            if (n[i].name === t)
                return n[i];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, n) {
        const i = {}
          , a = /^([\w-]*?)([\d]+)$/;
        for (let l = 0, u = e.length; l < u; l++) {
            const f = e[l]
              , d = f.name.match(a);
            if (d && d.length > 1) {
                const g = d[1];
                let v = i[g];
                v || (i[g] = v = []),
                v.push(f)
            }
        }
        const s = [];
        for (const l in i)
            s.push(this.CreateFromMorphTargetSequence(l, i[l], t, n));
        return s
    }
    static parseAnimation(e, t) {
        if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"),
        !e)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
        const n = function(g, v, y, S, T) {
            if (y.length !== 0) {
                const M = []
                  , b = [];
                MC(y, M, b, S),
                M.length !== 0 && T.push(new g(v,M,b))
            }
        }
          , i = []
          , a = e.name || "default"
          , s = e.fps || 30
          , l = e.blendMode;
        let u = e.length || -1;
        const f = e.hierarchy || [];
        for (let g = 0; g < f.length; g++) {
            const v = f[g].keys;
            if (!(!v || v.length === 0))
                if (v[0].morphTargets) {
                    const y = {};
                    let S;
                    for (S = 0; S < v.length; S++)
                        if (v[S].morphTargets)
                            for (let T = 0; T < v[S].morphTargets.length; T++)
                                y[v[S].morphTargets[T]] = -1;
                    for (const T in y) {
                        const M = []
                          , b = [];
                        for (let A = 0; A !== v[S].morphTargets.length; ++A) {
                            const C = v[S];
                            M.push(C.time),
                            b.push(C.morphTarget === T ? 1 : 0)
                        }
                        i.push(new Yy(".morphTargetInfluence[" + T + "]",M,b))
                    }
                    u = y.length * s
                } else {
                    const y = ".bones[" + t[g].name + "]";
                    n(qy, y + ".position", v, "pos", i),
                    n(b_, y + ".quaternion", v, "rot", i),
                    n(qy, y + ".scale", v, "scl", i)
                }
        }
        return i.length === 0 ? null : new this(a,u,i,l)
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let n = 0, i = e.length; n !== i; ++n) {
            const a = this.tracks[n];
            t = Math.max(t, a.times[a.times.length - 1])
        }
        return this.duration = t,
        this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let n = 0; n < this.tracks.length; n++)
            e.push(this.tracks[n].clone());
        const t = new this.constructor(this.name,this.duration,e,this.blendMode);
        return t.userData = JSON.parse(JSON.stringify(this.userData)),
        t
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}
function kj(r) {
    switch (r.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return Yy;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return qy;
    case "color":
        return EC;
    case "quaternion":
        return b_;
    case "bool":
    case "boolean":
        return _p;
    case "string":
        return xp
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r)
}
function Gj(r) {
    if (r.type === void 0)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = kj(r.type);
    if (r.times === void 0) {
        const t = []
          , n = [];
        MC(r.keys, t, n, "value"),
        r.times = t,
        r.values = n
    }
    return e.parse !== void 0 ? e.parse(r) : new e(r.name,r.times,r.values,r.interpolation)
}
const Xu = {
    enabled: !1,
    files: {},
    add: function(r, e) {
        this.enabled !== !1 && (this.files[r] = e)
    },
    get: function(r) {
        if (this.enabled !== !1)
            return this.files[r]
    },
    remove: function(r) {
        delete this.files[r]
    },
    clear: function() {
        this.files = {}
    }
};
class PM {
    constructor(e, t, n) {
        const i = this;
        let a = !1, s = 0, l = 0, u;
        const f = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = n,
        this.abortController = new AbortController,
        this.itemStart = function(d) {
            l++,
            a === !1 && i.onStart !== void 0 && i.onStart(d, s, l),
            a = !0
        }
        ,
        this.itemEnd = function(d) {
            s++,
            i.onProgress !== void 0 && i.onProgress(d, s, l),
            s === l && (a = !1,
            i.onLoad !== void 0 && i.onLoad())
        }
        ,
        this.itemError = function(d) {
            i.onError !== void 0 && i.onError(d)
        }
        ,
        this.resolveURL = function(d) {
            return u ? u(d) : d
        }
        ,
        this.setURLModifier = function(d) {
            return u = d,
            this
        }
        ,
        this.addHandler = function(d, g) {
            return f.push(d, g),
            this
        }
        ,
        this.removeHandler = function(d) {
            const g = f.indexOf(d);
            return g !== -1 && f.splice(g, 2),
            this
        }
        ,
        this.getHandler = function(d) {
            for (let g = 0, v = f.length; g < v; g += 2) {
                const y = f[g]
                  , S = f[g + 1];
                if (y.global && (y.lastIndex = 0),
                y.test(d))
                    return S
            }
            return null
        }
        ,
        this.abort = function() {
            return this.abortController.abort(),
            this.abortController = new AbortController,
            this
        }
    }
}
const az = new PM;
class xs {
    constructor(e) {
        this.manager = e !== void 0 ? e : az,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const n = this;
        return new Promise(function(i, a) {
            n.load(e, i, t, a)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
    abort() {
        return this
    }
}
xs.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Vc = {};
class Xj extends Error {
    constructor(e, t) {
        super(e),
        this.response = t
    }
}
class Eo extends xs {
    constructor(e) {
        super(e),
        this.mimeType = "",
        this.responseType = "",
        this._abortController = new AbortController
    }
    load(e, t, n, i) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const a = Xu.get(`file:${e}`);
        if (a !== void 0)
            return this.manager.itemStart(e),
            setTimeout( () => {
                t && t(a),
                this.manager.itemEnd(e)
            }
            , 0),
            a;
        if (Vc[e] !== void 0) {
            Vc[e].push({
                onLoad: t,
                onProgress: n,
                onError: i
            });
            return
        }
        Vc[e] = [],
        Vc[e].push({
            onLoad: t,
            onProgress: n,
            onError: i
        });
        const s = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin",
            signal: typeof AbortSignal.any == "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal
        })
          , l = this.mimeType
          , u = this.responseType;
        fetch(s).then(f => {
            if (f.status === 200 || f.status === 0) {
                if (f.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream > "u" || f.body === void 0 || f.body.getReader === void 0)
                    return f;
                const d = Vc[e]
                  , g = f.body.getReader()
                  , v = f.headers.get("X-File-Size") || f.headers.get("Content-Length")
                  , y = v ? parseInt(v) : 0
                  , S = y !== 0;
                let T = 0;
                const M = new ReadableStream({
                    start(b) {
                        A();
                        function A() {
                            g.read().then( ({done: C, value: R}) => {
                                if (C)
                                    b.close();
                                else {
                                    T += R.byteLength;
                                    const O = new ProgressEvent("progress",{
                                        lengthComputable: S,
                                        loaded: T,
                                        total: y
                                    });
                                    for (let L = 0, z = d.length; L < z; L++) {
                                        const I = d[L];
                                        I.onProgress && I.onProgress(O)
                                    }
                                    b.enqueue(R),
                                    A()
                                }
                            }
                            , C => {
                                b.error(C)
                            }
                            )
                        }
                    }
                });
                return new Response(M)
            } else
                throw new Xj(`fetch for "${f.url}" responded with ${f.status}: ${f.statusText}`,f)
        }
        ).then(f => {
            switch (u) {
            case "arraybuffer":
                return f.arrayBuffer();
            case "blob":
                return f.blob();
            case "document":
                return f.text().then(d => new DOMParser().parseFromString(d, l));
            case "json":
                return f.json();
            default:
                if (l === "")
                    return f.text();
                {
                    const g = /charset="?([^;"\s]*)"?/i.exec(l)
                      , v = g && g[1] ? g[1].toLowerCase() : void 0
                      , y = new TextDecoder(v);
                    return f.arrayBuffer().then(S => y.decode(S))
                }
            }
        }
        ).then(f => {
            Xu.add(`file:${e}`, f);
            const d = Vc[e];
            delete Vc[e];
            for (let g = 0, v = d.length; g < v; g++) {
                const y = d[g];
                y.onLoad && y.onLoad(f)
            }
        }
        ).catch(f => {
            const d = Vc[e];
            if (d === void 0)
                throw this.manager.itemError(e),
                f;
            delete Vc[e];
            for (let g = 0, v = d.length; g < v; g++) {
                const y = d[g];
                y.onError && y.onError(f)
            }
            this.manager.itemError(e)
        }
        ).finally( () => {
            this.manager.itemEnd(e)
        }
        ),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
    abort() {
        return this._abortController.abort(),
        this._abortController = new AbortController,
        this
    }
}
class jj extends xs {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const a = this
          , s = new Eo(this.manager);
        s.setPath(this.path),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials),
        s.load(e, function(l) {
            try {
                t(a.parse(JSON.parse(l)))
            } catch (u) {
                i ? i(u) : console.error(u),
                a.manager.itemError(e)
            }
        }, n, i)
    }
    parse(e) {
        const t = [];
        for (let n = 0; n < e.length; n++) {
            const i = Zy.parse(e[n]);
            t.push(i)
        }
        return t
    }
}
class Wj extends xs {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const a = this
          , s = []
          , l = new xM
          , u = new Eo(this.manager);
        u.setPath(this.path),
        u.setResponseType("arraybuffer"),
        u.setRequestHeader(this.requestHeader),
        u.setWithCredentials(a.withCredentials);
        let f = 0;
        function d(g) {
            u.load(e[g], function(v) {
                const y = a.parse(v, !0);
                s[g] = {
                    width: y.width,
                    height: y.height,
                    format: y.format,
                    mipmaps: y.mipmaps
                },
                f += 1,
                f === 6 && (y.mipmapCount === 1 && (l.minFilter = fi),
                l.image = s,
                l.format = y.format,
                l.needsUpdate = !0,
                t && t(l))
            }, n, i)
        }
        if (Array.isArray(e))
            for (let g = 0, v = e.length; g < v; ++g)
                d(g);
        else
            u.load(e, function(g) {
                const v = a.parse(g, !0);
                if (v.isCubemap) {
                    const y = v.mipmaps.length / v.mipmapCount;
                    for (let S = 0; S < y; S++) {
                        s[S] = {
                            mipmaps: []
                        };
                        for (let T = 0; T < v.mipmapCount; T++)
                            s[S].mipmaps.push(v.mipmaps[S * v.mipmapCount + T]),
                            s[S].format = v.format,
                            s[S].width = v.width,
                            s[S].height = v.height
                    }
                    l.image = s
                } else
                    l.image.width = v.width,
                    l.image.height = v.height,
                    l.mipmaps = v.mipmaps;
                v.mipmapCount === 1 && (l.minFilter = fi),
                l.format = v.format,
                l.needsUpdate = !0,
                t && t(l)
            }, n, i);
        return l
    }
}
const Pm = new WeakMap;
class Ky extends xs {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const a = this
          , s = Xu.get(`image:${e}`);
        if (s !== void 0) {
            if (s.complete === !0)
                a.manager.itemStart(e),
                setTimeout(function() {
                    t && t(s),
                    a.manager.itemEnd(e)
                }, 0);
            else {
                let g = Pm.get(s);
                g === void 0 && (g = [],
                Pm.set(s, g)),
                g.push({
                    onLoad: t,
                    onError: i
                })
            }
            return s
        }
        const l = ky("img");
        function u() {
            d(),
            t && t(this);
            const g = Pm.get(this) || [];
            for (let v = 0; v < g.length; v++) {
                const y = g[v];
                y.onLoad && y.onLoad(this)
            }
            Pm.delete(this),
            a.manager.itemEnd(e)
        }
        function f(g) {
            d(),
            i && i(g),
            Xu.remove(`image:${e}`);
            const v = Pm.get(this) || [];
            for (let y = 0; y < v.length; y++) {
                const S = v[y];
                S.onError && S.onError(g)
            }
            Pm.delete(this),
            a.manager.itemError(e),
            a.manager.itemEnd(e)
        }
        function d() {
            l.removeEventListener("load", u, !1),
            l.removeEventListener("error", f, !1)
        }
        return l.addEventListener("load", u, !1),
        l.addEventListener("error", f, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (l.crossOrigin = this.crossOrigin),
        Xu.add(`image:${e}`, l),
        a.manager.itemStart(e),
        l.src = e,
        l
    }
}
class sz extends xs {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const a = new p_;
        a.colorSpace = pa;
        const s = new Ky(this.manager);
        s.setCrossOrigin(this.crossOrigin),
        s.setPath(this.path);
        let l = 0;
        function u(f) {
            s.load(e[f], function(d) {
                a.images[f] = d,
                l++,
                l === 6 && (a.needsUpdate = !0,
                t && t(a))
            }, void 0, i)
        }
        for (let f = 0; f < e.length; ++f)
            u(f);
        return a
    }
}
class wC extends xs {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const a = this
          , s = new Kl
          , l = new Eo(this.manager);
        return l.setResponseType("arraybuffer"),
        l.setRequestHeader(this.requestHeader),
        l.setPath(this.path),
        l.setWithCredentials(a.withCredentials),
        l.load(e, function(u) {
            let f;
            try {
                f = a.parse(u)
            } catch (d) {
                if (i !== void 0)
                    i(d);
                else {
                    console.error(d);
                    return
                }
            }
            f.image !== void 0 ? s.image = f.image : f.data !== void 0 && (s.image.width = f.width,
            s.image.height = f.height,
            s.image.data = f.data),
            s.wrapS = f.wrapS !== void 0 ? f.wrapS : Cr,
            s.wrapT = f.wrapT !== void 0 ? f.wrapT : Cr,
            s.magFilter = f.magFilter !== void 0 ? f.magFilter : fi,
            s.minFilter = f.minFilter !== void 0 ? f.minFilter : fi,
            s.anisotropy = f.anisotropy !== void 0 ? f.anisotropy : 1,
            f.colorSpace !== void 0 && (s.colorSpace = f.colorSpace),
            f.flipY !== void 0 && (s.flipY = f.flipY),
            f.format !== void 0 && (s.format = f.format),
            f.type !== void 0 && (s.type = f.type),
            f.mipmaps !== void 0 && (s.mipmaps = f.mipmaps,
            s.minFilter = Gu),
            f.mipmapCount === 1 && (s.minFilter = fi),
            f.generateMipmaps !== void 0 && (s.generateMipmaps = f.generateMipmaps),
            s.needsUpdate = !0,
            t && t(s, f)
        }, n, i),
        s
    }
}
class Yj extends xs {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const a = new _i
          , s = new Ky(this.manager);
        return s.setCrossOrigin(this.crossOrigin),
        s.setPath(this.path),
        s.load(e, function(l) {
            a.image = l,
            a.needsUpdate = !0,
            t !== void 0 && t(a)
        }, n, i),
        a
    }
}
class Ah extends ii {
    constructor(e, t=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new kt(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        this.target !== void 0 && (t.object.target = this.target.uuid),
        t
    }
}
class oz extends Ah {
    constructor(e, t, n) {
        super(e, n),
        this.isHemisphereLight = !0,
        this.type = "HemisphereLight",
        this.position.copy(ii.DEFAULT_UP),
        this.updateMatrix(),
        this.groundColor = new kt(t)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.groundColor.copy(e.groundColor),
        this
    }
}
const DT = new vn
  , FU = new he
  , HU = new he;
class AC {
    constructor(e) {
        this.camera = e,
        this.intensity = 1,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new xt(512,512),
        this.mapType = ys,
        this.map = null,
        this.mapPass = null,
        this.matrix = new vn,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new Wg,
        this._frameExtents = new xt(1,1),
        this._viewportCount = 1,
        this._viewports = [new Qn(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera
          , n = this.matrix;
        FU.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(FU),
        HU.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(HU),
        t.updateMatrixWorld(),
        DT.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(DT, t.coordinateSystem, t.reversedDepth),
        t.reversedDepth ? n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1) : n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        n.multiply(DT)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.intensity = e.intensity,
        this.bias = e.bias,
        this.radius = e.radius,
        this.autoUpdate = e.autoUpdate,
        this.needsUpdate = e.needsUpdate,
        this.normalBias = e.normalBias,
        this.blurSamples = e.blurSamples,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.intensity !== 1 && (e.intensity = this.intensity),
        this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class qj extends AC {
    constructor() {
        super(new Jr(50,1,.5,500)),
        this.isSpotLightShadow = !0,
        this.focus = 1,
        this.aspect = 1
    }
    updateMatrices(e) {
        const t = this.camera
          , n = Rg * 2 * e.angle * this.focus
          , i = this.mapSize.width / this.mapSize.height * this.aspect
          , a = e.distance || t.far;
        (n !== t.fov || i !== t.aspect || a !== t.far) && (t.fov = n,
        t.aspect = i,
        t.far = a,
        t.updateProjectionMatrix()),
        super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e),
        this.focus = e.focus,
        this
    }
}
class lz extends Ah {
    constructor(e, t, n=0, i=Math.PI / 3, a=0, s=2) {
        super(e, t),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(ii.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new ii,
        this.distance = n,
        this.angle = i,
        this.penumbra = a,
        this.decay = s,
        this.map = null,
        this.shadow = new qj
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.angle = e.angle,
        this.penumbra = e.penumbra,
        this.decay = e.decay,
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
const VU = new vn
  , Mv = new he
  , UT = new he;
class Zj extends AC {
    constructor() {
        super(new Jr(90,1,.5,500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new xt(4,2),
        this._viewportCount = 6,
        this._viewports = [new Qn(2,1,1,1), new Qn(0,1,1,1), new Qn(3,1,1,1), new Qn(1,1,1,1), new Qn(3,0,1,1), new Qn(1,0,1,1)],
        this._cubeDirections = [new he(1,0,0), new he(-1,0,0), new he(0,0,1), new he(0,0,-1), new he(0,1,0), new he(0,-1,0)],
        this._cubeUps = [new he(0,1,0), new he(0,1,0), new he(0,1,0), new he(0,1,0), new he(0,0,1), new he(0,0,-1)]
    }
    updateMatrices(e, t=0) {
        const n = this.camera
          , i = this.matrix
          , a = e.distance || n.far;
        a !== n.far && (n.far = a,
        n.updateProjectionMatrix()),
        Mv.setFromMatrixPosition(e.matrixWorld),
        n.position.copy(Mv),
        UT.copy(n.position),
        UT.add(this._cubeDirections[t]),
        n.up.copy(this._cubeUps[t]),
        n.lookAt(UT),
        n.updateMatrixWorld(),
        i.makeTranslation(-Mv.x, -Mv.y, -Mv.z),
        VU.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(VU, n.coordinateSystem, n.reversedDepth)
    }
}
class uz extends Ah {
    constructor(e, t, n=0, i=2) {
        super(e, t),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = n,
        this.decay = i,
        this.shadow = new Zj
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this
    }
}
class Yg extends pM {
    constructor(e=-1, t=1, n=1, i=-1, a=.1, s=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = n,
        this.bottom = i,
        this.near = a,
        this.far = s,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, n, i, a, s) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = n,
        this.view.offsetY = i,
        this.view.width = a,
        this.view.height = s,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , n = (this.right + this.left) / 2
          , i = (this.top + this.bottom) / 2;
        let a = n - e
          , s = n + e
          , l = i + t
          , u = i - t;
        if (this.view !== null && this.view.enabled) {
            const f = (this.right - this.left) / this.view.fullWidth / this.zoom
              , d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            a += f * this.view.offsetX,
            s = a + f * this.view.width,
            l -= d * this.view.offsetY,
            u = l - d * this.view.height
        }
        this.projectionMatrix.makeOrthographic(a, s, l, u, this.near, this.far, this.coordinateSystem, this.reversedDepth),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
class Kj extends AC {
    constructor() {
        super(new Yg(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class cz extends Ah {
    constructor(e, t) {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(ii.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new ii,
        this.shadow = new Kj
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class fz extends Ah {
    constructor(e, t) {
        super(e, t),
        this.isAmbientLight = !0,
        this.type = "AmbientLight"
    }
}
class hz extends Ah {
    constructor(e, t, n=10, i=10) {
        super(e, t),
        this.isRectAreaLight = !0,
        this.type = "RectAreaLight",
        this.width = n,
        this.height = i
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI)
    }
    copy(e) {
        return super.copy(e),
        this.width = e.width,
        this.height = e.height,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.width = this.width,
        t.object.height = this.height,
        t
    }
}
class dz {
    constructor() {
        this.isSphericalHarmonics3 = !0,
        this.coefficients = [];
        for (let e = 0; e < 9; e++)
            this.coefficients.push(new he)
    }
    set(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].copy(e[t]);
        return this
    }
    zero() {
        for (let e = 0; e < 9; e++)
            this.coefficients[e].set(0, 0, 0);
        return this
    }
    getAt(e, t) {
        const n = e.x
          , i = e.y
          , a = e.z
          , s = this.coefficients;
        return t.copy(s[0]).multiplyScalar(.282095),
        t.addScaledVector(s[1], .488603 * i),
        t.addScaledVector(s[2], .488603 * a),
        t.addScaledVector(s[3], .488603 * n),
        t.addScaledVector(s[4], 1.092548 * (n * i)),
        t.addScaledVector(s[5], 1.092548 * (i * a)),
        t.addScaledVector(s[6], .315392 * (3 * a * a - 1)),
        t.addScaledVector(s[7], 1.092548 * (n * a)),
        t.addScaledVector(s[8], .546274 * (n * n - i * i)),
        t
    }
    getIrradianceAt(e, t) {
        const n = e.x
          , i = e.y
          , a = e.z
          , s = this.coefficients;
        return t.copy(s[0]).multiplyScalar(.886227),
        t.addScaledVector(s[1], 2 * .511664 * i),
        t.addScaledVector(s[2], 2 * .511664 * a),
        t.addScaledVector(s[3], 2 * .511664 * n),
        t.addScaledVector(s[4], 2 * .429043 * n * i),
        t.addScaledVector(s[5], 2 * .429043 * i * a),
        t.addScaledVector(s[6], .743125 * a * a - .247708),
        t.addScaledVector(s[7], 2 * .429043 * n * a),
        t.addScaledVector(s[8], .429043 * (n * n - i * i)),
        t
    }
    add(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].add(e.coefficients[t]);
        return this
    }
    addScaledSH(e, t) {
        for (let n = 0; n < 9; n++)
            this.coefficients[n].addScaledVector(e.coefficients[n], t);
        return this
    }
    scale(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].multiplyScalar(e);
        return this
    }
    lerp(e, t) {
        for (let n = 0; n < 9; n++)
            this.coefficients[n].lerp(e.coefficients[n], t);
        return this
    }
    equals(e) {
        for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t]))
                return !1;
        return !0
    }
    copy(e) {
        return this.set(e.coefficients)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    fromArray(e, t=0) {
        const n = this.coefficients;
        for (let i = 0; i < 9; i++)
            n[i].fromArray(e, t + i * 3);
        return this
    }
    toArray(e=[], t=0) {
        const n = this.coefficients;
        for (let i = 0; i < 9; i++)
            n[i].toArray(e, t + i * 3);
        return e
    }
    static getBasisAt(e, t) {
        const n = e.x
          , i = e.y
          , a = e.z;
        t[0] = .282095,
        t[1] = .488603 * i,
        t[2] = .488603 * a,
        t[3] = .488603 * n,
        t[4] = 1.092548 * n * i,
        t[5] = 1.092548 * i * a,
        t[6] = .315392 * (3 * a * a - 1),
        t[7] = 1.092548 * n * a,
        t[8] = .546274 * (n * n - i * i)
    }
}
class pz extends Ah {
    constructor(e=new dz, t=1) {
        super(void 0, t),
        this.isLightProbe = !0,
        this.sh = e
    }
    copy(e) {
        return super.copy(e),
        this.sh.copy(e.sh),
        this
    }
    fromJSON(e) {
        return this.intensity = e.intensity,
        this.sh.fromArray(e.sh),
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.sh = this.sh.toArray(),
        t
    }
}
class BM extends xs {
    constructor(e) {
        super(e),
        this.textures = {}
    }
    load(e, t, n, i) {
        const a = this
          , s = new Eo(a.manager);
        s.setPath(a.path),
        s.setRequestHeader(a.requestHeader),
        s.setWithCredentials(a.withCredentials),
        s.load(e, function(l) {
            try {
                t(a.parse(JSON.parse(l)))
            } catch (u) {
                i ? i(u) : console.error(u),
                a.manager.itemError(e)
            }
        }, n, i)
    }
    parse(e) {
        const t = this.textures;
        function n(a) {
            return t[a] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", a),
            t[a]
        }
        const i = this.createMaterialFromType(e.type);
        if (e.uuid !== void 0 && (i.uuid = e.uuid),
        e.name !== void 0 && (i.name = e.name),
        e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color),
        e.roughness !== void 0 && (i.roughness = e.roughness),
        e.metalness !== void 0 && (i.metalness = e.metalness),
        e.sheen !== void 0 && (i.sheen = e.sheen),
        e.sheenColor !== void 0 && (i.sheenColor = new kt().setHex(e.sheenColor)),
        e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness),
        e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive),
        e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular),
        e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity),
        e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor),
        e.shininess !== void 0 && (i.shininess = e.shininess),
        e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
        e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness),
        e.dispersion !== void 0 && (i.dispersion = e.dispersion),
        e.iridescence !== void 0 && (i.iridescence = e.iridescence),
        e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR),
        e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange),
        e.transmission !== void 0 && (i.transmission = e.transmission),
        e.thickness !== void 0 && (i.thickness = e.thickness),
        e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance),
        e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor),
        e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy),
        e.anisotropyRotation !== void 0 && (i.anisotropyRotation = e.anisotropyRotation),
        e.fog !== void 0 && (i.fog = e.fog),
        e.flatShading !== void 0 && (i.flatShading = e.flatShading),
        e.blending !== void 0 && (i.blending = e.blending),
        e.combine !== void 0 && (i.combine = e.combine),
        e.side !== void 0 && (i.side = e.side),
        e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
        e.opacity !== void 0 && (i.opacity = e.opacity),
        e.transparent !== void 0 && (i.transparent = e.transparent),
        e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
        e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash),
        e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc),
        e.depthTest !== void 0 && (i.depthTest = e.depthTest),
        e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
        e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
        e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc),
        e.blendDst !== void 0 && (i.blendDst = e.blendDst),
        e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation),
        e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha),
        e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha),
        e.blendEquationAlpha !== void 0 && (i.blendEquationAlpha = e.blendEquationAlpha),
        e.blendColor !== void 0 && i.blendColor !== void 0 && i.blendColor.setHex(e.blendColor),
        e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha),
        e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask),
        e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
        e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
        e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask),
        e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
        e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
        e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
        e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
        e.wireframe !== void 0 && (i.wireframe = e.wireframe),
        e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth),
        e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap),
        e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin),
        e.rotation !== void 0 && (i.rotation = e.rotation),
        e.linewidth !== void 0 && (i.linewidth = e.linewidth),
        e.dashSize !== void 0 && (i.dashSize = e.dashSize),
        e.gapSize !== void 0 && (i.gapSize = e.gapSize),
        e.scale !== void 0 && (i.scale = e.scale),
        e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset),
        e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor),
        e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits),
        e.dithering !== void 0 && (i.dithering = e.dithering),
        e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage),
        e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha),
        e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass),
        e.visible !== void 0 && (i.visible = e.visible),
        e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
        e.userData !== void 0 && (i.userData = e.userData),
        e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors),
        e.uniforms !== void 0)
            for (const a in e.uniforms) {
                const s = e.uniforms[a];
                switch (i.uniforms[a] = {},
                s.type) {
                case "t":
                    i.uniforms[a].value = n(s.value);
                    break;
                case "c":
                    i.uniforms[a].value = new kt().setHex(s.value);
                    break;
                case "v2":
                    i.uniforms[a].value = new xt().fromArray(s.value);
                    break;
                case "v3":
                    i.uniforms[a].value = new he().fromArray(s.value);
                    break;
                case "v4":
                    i.uniforms[a].value = new Qn().fromArray(s.value);
                    break;
                case "m3":
                    i.uniforms[a].value = new An().fromArray(s.value);
                    break;
                case "m4":
                    i.uniforms[a].value = new vn().fromArray(s.value);
                    break;
                default:
                    i.uniforms[a].value = s.value
                }
            }
        if (e.defines !== void 0 && (i.defines = e.defines),
        e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
        e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader),
        e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion),
        e.extensions !== void 0)
            for (const a in e.extensions)
                i.extensions[a] = e.extensions[a];
        if (e.lights !== void 0 && (i.lights = e.lights),
        e.clipping !== void 0 && (i.clipping = e.clipping),
        e.size !== void 0 && (i.size = e.size),
        e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation),
        e.map !== void 0 && (i.map = n(e.map)),
        e.matcap !== void 0 && (i.matcap = n(e.matcap)),
        e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)),
        e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)),
        e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
        e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)),
        e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType),
        e.normalScale !== void 0) {
            let a = e.normalScale;
            Array.isArray(a) === !1 && (a = [a, a]),
            i.normalScale = new xt().fromArray(a)
        }
        return e.displacementMap !== void 0 && (i.displacementMap = n(e.displacementMap)),
        e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale),
        e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias),
        e.roughnessMap !== void 0 && (i.roughnessMap = n(e.roughnessMap)),
        e.metalnessMap !== void 0 && (i.metalnessMap = n(e.metalnessMap)),
        e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)),
        e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity),
        e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)),
        e.specularIntensityMap !== void 0 && (i.specularIntensityMap = n(e.specularIntensityMap)),
        e.specularColorMap !== void 0 && (i.specularColorMap = n(e.specularColorMap)),
        e.envMap !== void 0 && (i.envMap = n(e.envMap)),
        e.envMapRotation !== void 0 && i.envMapRotation.fromArray(e.envMapRotation),
        e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity),
        e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
        e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio),
        e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)),
        e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity),
        e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)),
        e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity),
        e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)),
        e.clearcoatMap !== void 0 && (i.clearcoatMap = n(e.clearcoatMap)),
        e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
        e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)),
        e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new xt().fromArray(e.clearcoatNormalScale)),
        e.iridescenceMap !== void 0 && (i.iridescenceMap = n(e.iridescenceMap)),
        e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = n(e.iridescenceThicknessMap)),
        e.transmissionMap !== void 0 && (i.transmissionMap = n(e.transmissionMap)),
        e.thicknessMap !== void 0 && (i.thicknessMap = n(e.thicknessMap)),
        e.anisotropyMap !== void 0 && (i.anisotropyMap = n(e.anisotropyMap)),
        e.sheenColorMap !== void 0 && (i.sheenColorMap = n(e.sheenColorMap)),
        e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = n(e.sheenRoughnessMap)),
        i
    }
    setTextures(e) {
        return this.textures = e,
        this
    }
    createMaterialFromType(e) {
        return BM.createMaterialFromType(e)
    }
    static createMaterialFromType(e) {
        const t = {
            ShadowMaterial: jB,
            SpriteMaterial: fC,
            RawShaderMaterial: WB,
            ShaderMaterial: Ks,
            PointsMaterial: dC,
            MeshPhysicalMaterial: YB,
            MeshStandardMaterial: bC,
            MeshPhongMaterial: qB,
            MeshToonMaterial: ZB,
            MeshNormalMaterial: KB,
            MeshLambertMaterial: QB,
            MeshDepthMaterial: NM,
            MeshDistanceMaterial: LM,
            MeshBasicMaterial: oc,
            MeshMatcapMaterial: JB,
            LineDashedMaterial: $B,
            LineBasicMaterial: _s,
            Material: Va
        };
        return new t[e]
    }
}
class gw {
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class CC extends Nn {
    constructor() {
        super(),
        this.isInstancedBufferGeometry = !0,
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0
    }
    copy(e) {
        return super.copy(e),
        this.instanceCount = e.instanceCount,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.instanceCount = this.instanceCount,
        e.isInstancedBufferGeometry = !0,
        e
    }
}
class mz extends xs {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const a = this
          , s = new Eo(a.manager);
        s.setPath(a.path),
        s.setRequestHeader(a.requestHeader),
        s.setWithCredentials(a.withCredentials),
        s.load(e, function(l) {
            try {
                t(a.parse(JSON.parse(l)))
            } catch (u) {
                i ? i(u) : console.error(u),
                a.manager.itemError(e)
            }
        }, n, i)
    }
    parse(e) {
        const t = {}
          , n = {};
        function i(y, S) {
            if (t[S] !== void 0)
                return t[S];
            const M = y.interleavedBuffers[S]
              , b = a(y, M.buffer)
              , A = ng(M.type, b)
              , C = new vM(A,M.stride);
            return C.uuid = M.uuid,
            t[S] = C,
            C
        }
        function a(y, S) {
            if (n[S] !== void 0)
                return n[S];
            const M = y.arrayBuffers[S]
              , b = new Uint32Array(M).buffer;
            return n[S] = b,
            b
        }
        const s = e.isInstancedBufferGeometry ? new CC : new Nn
          , l = e.data.index;
        if (l !== void 0) {
            const y = ng(l.type, l.array);
            s.setIndex(new xi(y,1))
        }
        const u = e.data.attributes;
        for (const y in u) {
            const S = u[y];
            let T;
            if (S.isInterleavedBufferAttribute) {
                const M = i(e.data, S.data);
                T = new cp(M,S.itemSize,S.offset,S.normalized)
            } else {
                const M = ng(S.type, S.array)
                  , b = S.isInstancedBufferAttribute ? fp : xi;
                T = new b(M,S.itemSize,S.normalized)
            }
            S.name !== void 0 && (T.name = S.name),
            S.usage !== void 0 && T.setUsage(S.usage),
            s.setAttribute(y, T)
        }
        const f = e.data.morphAttributes;
        if (f)
            for (const y in f) {
                const S = f[y]
                  , T = [];
                for (let M = 0, b = S.length; M < b; M++) {
                    const A = S[M];
                    let C;
                    if (A.isInterleavedBufferAttribute) {
                        const R = i(e.data, A.data);
                        C = new cp(R,A.itemSize,A.offset,A.normalized)
                    } else {
                        const R = ng(A.type, A.array);
                        C = new xi(R,A.itemSize,A.normalized)
                    }
                    A.name !== void 0 && (C.name = A.name),
                    T.push(C)
                }
                s.morphAttributes[y] = T
            }
        e.data.morphTargetsRelative && (s.morphTargetsRelative = !0);
        const g = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (g !== void 0)
            for (let y = 0, S = g.length; y !== S; ++y) {
                const T = g[y];
                s.addGroup(T.start, T.count, T.materialIndex)
            }
        const v = e.data.boundingSphere;
        return v !== void 0 && (s.boundingSphere = new ta().fromJSON(v)),
        e.name && (s.name = e.name),
        e.userData && (s.userData = e.userData),
        s
    }
}
class Qj extends xs {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const a = this
          , s = this.path === "" ? gw.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || s;
        const l = new Eo(this.manager);
        l.setPath(this.path),
        l.setRequestHeader(this.requestHeader),
        l.setWithCredentials(this.withCredentials),
        l.load(e, function(u) {
            let f = null;
            try {
                f = JSON.parse(u)
            } catch (g) {
                i !== void 0 && i(g),
                console.error("THREE:ObjectLoader: Can't parse " + e + ".", g.message);
                return
            }
            const d = f.metadata;
            if (d === void 0 || d.type === void 0 || d.type.toLowerCase() === "geometry") {
                i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)),
                console.error("THREE.ObjectLoader: Can't load " + e);
                return
            }
            a.parse(f, t)
        }, n, i)
    }
    async loadAsync(e, t) {
        const n = this
          , i = this.path === "" ? gw.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || i;
        const a = new Eo(this.manager);
        a.setPath(this.path),
        a.setRequestHeader(this.requestHeader),
        a.setWithCredentials(this.withCredentials);
        const s = await a.loadAsync(e, t)
          , l = JSON.parse(s)
          , u = l.metadata;
        if (u === void 0 || u.type === void 0 || u.type.toLowerCase() === "geometry")
            throw new Error("THREE.ObjectLoader: Can't load " + e);
        return await n.parseAsync(l)
    }
    parse(e, t) {
        const n = this.parseAnimations(e.animations)
          , i = this.parseShapes(e.shapes)
          , a = this.parseGeometries(e.geometries, i)
          , s = this.parseImages(e.images, function() {
            t !== void 0 && t(f)
        })
          , l = this.parseTextures(e.textures, s)
          , u = this.parseMaterials(e.materials, l)
          , f = this.parseObject(e.object, a, u, l, n)
          , d = this.parseSkeletons(e.skeletons, f);
        if (this.bindSkeletons(f, d),
        this.bindLightTargets(f),
        t !== void 0) {
            let g = !1;
            for (const v in s)
                if (s[v].data instanceof HTMLImageElement) {
                    g = !0;
                    break
                }
            g === !1 && t(f)
        }
        return f
    }
    async parseAsync(e) {
        const t = this.parseAnimations(e.animations)
          , n = this.parseShapes(e.shapes)
          , i = this.parseGeometries(e.geometries, n)
          , a = await this.parseImagesAsync(e.images)
          , s = this.parseTextures(e.textures, a)
          , l = this.parseMaterials(e.materials, s)
          , u = this.parseObject(e.object, i, l, s, t)
          , f = this.parseSkeletons(e.skeletons, u);
        return this.bindSkeletons(u, f),
        this.bindLightTargets(u),
        u
    }
    parseShapes(e) {
        const t = {};
        if (e !== void 0)
            for (let n = 0, i = e.length; n < i; n++) {
                const a = new ip().fromJSON(e[n]);
                t[a.uuid] = a
            }
        return t
    }
    parseSkeletons(e, t) {
        const n = {}
          , i = {};
        if (t.traverse(function(a) {
            a.isBone && (i[a.uuid] = a)
        }),
        e !== void 0)
            for (let a = 0, s = e.length; a < s; a++) {
                const l = new yM().fromJSON(e[a], i);
                n[l.uuid] = l
            }
        return n
    }
    parseGeometries(e, t) {
        const n = {};
        if (e !== void 0) {
            const i = new mz;
            for (let a = 0, s = e.length; a < s; a++) {
                let l;
                const u = e[a];
                switch (u.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                    l = i.parse(u);
                    break;
                default:
                    u.type in IU ? l = IU[u.type].fromJSON(u, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${u.type}"`)
                }
                l.uuid = u.uuid,
                u.name !== void 0 && (l.name = u.name),
                u.userData !== void 0 && (l.userData = u.userData),
                n[u.uuid] = l
            }
        }
        return n
    }
    parseMaterials(e, t) {
        const n = {}
          , i = {};
        if (e !== void 0) {
            const a = new BM;
            a.setTextures(t);
            for (let s = 0, l = e.length; s < l; s++) {
                const u = e[s];
                n[u.uuid] === void 0 && (n[u.uuid] = a.parse(u)),
                i[u.uuid] = n[u.uuid]
            }
        }
        return i
    }
    parseAnimations(e) {
        const t = {};
        if (e !== void 0)
            for (let n = 0; n < e.length; n++) {
                const i = e[n]
                  , a = Zy.parse(i);
                t[a.uuid] = a
            }
        return t
    }
    parseImages(e, t) {
        const n = this
          , i = {};
        let a;
        function s(u) {
            return n.manager.itemStart(u),
            a.load(u, function() {
                n.manager.itemEnd(u)
            }, void 0, function() {
                n.manager.itemError(u),
                n.manager.itemEnd(u)
            })
        }
        function l(u) {
            if (typeof u == "string") {
                const f = u
                  , d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : n.resourcePath + f;
                return s(d)
            } else
                return u.data ? {
                    data: ng(u.type, u.data),
                    width: u.width,
                    height: u.height
                } : null
        }
        if (e !== void 0 && e.length > 0) {
            const u = new PM(t);
            a = new Ky(u),
            a.setCrossOrigin(this.crossOrigin);
            for (let f = 0, d = e.length; f < d; f++) {
                const g = e[f]
                  , v = g.url;
                if (Array.isArray(v)) {
                    const y = [];
                    for (let S = 0, T = v.length; S < T; S++) {
                        const M = v[S]
                          , b = l(M);
                        b !== null && (b instanceof HTMLImageElement ? y.push(b) : y.push(new Kl(b.data,b.width,b.height)))
                    }
                    i[g.uuid] = new lh(y)
                } else {
                    const y = l(g.url);
                    i[g.uuid] = new lh(y)
                }
            }
        }
        return i
    }
    async parseImagesAsync(e) {
        const t = this
          , n = {};
        let i;
        async function a(s) {
            if (typeof s == "string") {
                const l = s
                  , u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l) ? l : t.resourcePath + l;
                return await i.loadAsync(u)
            } else
                return s.data ? {
                    data: ng(s.type, s.data),
                    width: s.width,
                    height: s.height
                } : null
        }
        if (e !== void 0 && e.length > 0) {
            i = new Ky(this.manager),
            i.setCrossOrigin(this.crossOrigin);
            for (let s = 0, l = e.length; s < l; s++) {
                const u = e[s]
                  , f = u.url;
                if (Array.isArray(f)) {
                    const d = [];
                    for (let g = 0, v = f.length; g < v; g++) {
                        const y = f[g]
                          , S = await a(y);
                        S !== null && (S instanceof HTMLImageElement ? d.push(S) : d.push(new Kl(S.data,S.width,S.height)))
                    }
                    n[u.uuid] = new lh(d)
                } else {
                    const d = await a(u.url);
                    n[u.uuid] = new lh(d)
                }
            }
        }
        return n
    }
    parseTextures(e, t) {
        function n(a, s) {
            return typeof a == "number" ? a : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a),
            s[a])
        }
        const i = {};
        if (e !== void 0)
            for (let a = 0, s = e.length; a < s; a++) {
                const l = e[a];
                l.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', l.uuid),
                t[l.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", l.image);
                const u = t[l.image]
                  , f = u.data;
                let d;
                Array.isArray(f) ? (d = new p_,
                f.length === 6 && (d.needsUpdate = !0)) : (f && f.data ? d = new Kl : d = new _i,
                f && (d.needsUpdate = !0)),
                d.source = u,
                d.uuid = l.uuid,
                l.name !== void 0 && (d.name = l.name),
                l.mapping !== void 0 && (d.mapping = n(l.mapping, Jj)),
                l.channel !== void 0 && (d.channel = l.channel),
                l.offset !== void 0 && d.offset.fromArray(l.offset),
                l.repeat !== void 0 && d.repeat.fromArray(l.repeat),
                l.center !== void 0 && d.center.fromArray(l.center),
                l.rotation !== void 0 && (d.rotation = l.rotation),
                l.wrap !== void 0 && (d.wrapS = n(l.wrap[0], kU),
                d.wrapT = n(l.wrap[1], kU)),
                l.format !== void 0 && (d.format = l.format),
                l.internalFormat !== void 0 && (d.internalFormat = l.internalFormat),
                l.type !== void 0 && (d.type = l.type),
                l.colorSpace !== void 0 && (d.colorSpace = l.colorSpace),
                l.minFilter !== void 0 && (d.minFilter = n(l.minFilter, GU)),
                l.magFilter !== void 0 && (d.magFilter = n(l.magFilter, GU)),
                l.anisotropy !== void 0 && (d.anisotropy = l.anisotropy),
                l.flipY !== void 0 && (d.flipY = l.flipY),
                l.generateMipmaps !== void 0 && (d.generateMipmaps = l.generateMipmaps),
                l.premultiplyAlpha !== void 0 && (d.premultiplyAlpha = l.premultiplyAlpha),
                l.unpackAlignment !== void 0 && (d.unpackAlignment = l.unpackAlignment),
                l.compareFunction !== void 0 && (d.compareFunction = l.compareFunction),
                l.userData !== void 0 && (d.userData = l.userData),
                i[l.uuid] = d
            }
        return i
    }
    parseObject(e, t, n, i, a) {
        let s;
        function l(v) {
            return t[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", v),
            t[v]
        }
        function u(v) {
            if (v !== void 0) {
                if (Array.isArray(v)) {
                    const y = [];
                    for (let S = 0, T = v.length; S < T; S++) {
                        const M = v[S];
                        n[M] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", M),
                        y.push(n[M])
                    }
                    return y
                }
                return n[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", v),
                n[v]
            }
        }
        function f(v) {
            return i[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", v),
            i[v]
        }
        let d, g;
        switch (e.type) {
        case "Scene":
            s = new m_,
            e.background !== void 0 && (Number.isInteger(e.background) ? s.background = new kt(e.background) : s.background = f(e.background)),
            e.environment !== void 0 && (s.environment = f(e.environment)),
            e.fog !== void 0 && (e.fog.type === "Fog" ? s.fog = new gM(e.fog.color,e.fog.near,e.fog.far) : e.fog.type === "FogExp2" && (s.fog = new mM(e.fog.color,e.fog.density)),
            e.fog.name !== "" && (s.fog.name = e.fog.name)),
            e.backgroundBlurriness !== void 0 && (s.backgroundBlurriness = e.backgroundBlurriness),
            e.backgroundIntensity !== void 0 && (s.backgroundIntensity = e.backgroundIntensity),
            e.backgroundRotation !== void 0 && s.backgroundRotation.fromArray(e.backgroundRotation),
            e.environmentIntensity !== void 0 && (s.environmentIntensity = e.environmentIntensity),
            e.environmentRotation !== void 0 && s.environmentRotation.fromArray(e.environmentRotation);
            break;
        case "PerspectiveCamera":
            s = new Jr(e.fov,e.aspect,e.near,e.far),
            e.focus !== void 0 && (s.focus = e.focus),
            e.zoom !== void 0 && (s.zoom = e.zoom),
            e.filmGauge !== void 0 && (s.filmGauge = e.filmGauge),
            e.filmOffset !== void 0 && (s.filmOffset = e.filmOffset),
            e.view !== void 0 && (s.view = Object.assign({}, e.view));
            break;
        case "OrthographicCamera":
            s = new Yg(e.left,e.right,e.top,e.bottom,e.near,e.far),
            e.zoom !== void 0 && (s.zoom = e.zoom),
            e.view !== void 0 && (s.view = Object.assign({}, e.view));
            break;
        case "AmbientLight":
            s = new fz(e.color,e.intensity);
            break;
        case "DirectionalLight":
            s = new cz(e.color,e.intensity),
            s.target = e.target || "";
            break;
        case "PointLight":
            s = new uz(e.color,e.intensity,e.distance,e.decay);
            break;
        case "RectAreaLight":
            s = new hz(e.color,e.intensity,e.width,e.height);
            break;
        case "SpotLight":
            s = new lz(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay),
            s.target = e.target || "";
            break;
        case "HemisphereLight":
            s = new oz(e.color,e.groundColor,e.intensity);
            break;
        case "LightProbe":
            s = new pz().fromJSON(e);
            break;
        case "SkinnedMesh":
            d = l(e.geometry),
            g = u(e.material),
            s = new CB(d,g),
            e.bindMode !== void 0 && (s.bindMode = e.bindMode),
            e.bindMatrix !== void 0 && s.bindMatrix.fromArray(e.bindMatrix),
            e.skeleton !== void 0 && (s.skeleton = e.skeleton);
            break;
        case "Mesh":
            d = l(e.geometry),
            g = u(e.material),
            s = new Ni(d,g);
            break;
        case "InstancedMesh":
            d = l(e.geometry),
            g = u(e.material);
            const v = e.count
              , y = e.instanceMatrix
              , S = e.instanceColor;
            s = new RB(d,g,v),
            s.instanceMatrix = new fp(new Float32Array(y.array),16),
            S !== void 0 && (s.instanceColor = new fp(new Float32Array(S.array),S.itemSize));
            break;
        case "BatchedMesh":
            d = l(e.geometry),
            g = u(e.material),
            s = new DB(e.maxInstanceCount,e.maxVertexCount,e.maxIndexCount,g),
            s.geometry = d,
            s.perObjectFrustumCulled = e.perObjectFrustumCulled,
            s.sortObjects = e.sortObjects,
            s._drawRanges = e.drawRanges,
            s._reservedRanges = e.reservedRanges,
            s._geometryInfo = e.geometryInfo.map(T => {
                let M = null
                  , b = null;
                return T.boundingBox !== void 0 && (M = new ea().fromJSON(T.boundingBox)),
                T.boundingSphere !== void 0 && (b = new ta().fromJSON(T.boundingSphere)),
                {
                    ...T,
                    boundingBox: M,
                    boundingSphere: b
                }
            }
            ),
            s._instanceInfo = e.instanceInfo,
            s._availableInstanceIds = e._availableInstanceIds,
            s._availableGeometryIds = e._availableGeometryIds,
            s._nextIndexStart = e.nextIndexStart,
            s._nextVertexStart = e.nextVertexStart,
            s._geometryCount = e.geometryCount,
            s._maxInstanceCount = e.maxInstanceCount,
            s._maxVertexCount = e.maxVertexCount,
            s._maxIndexCount = e.maxIndexCount,
            s._geometryInitialized = e.geometryInitialized,
            s._matricesTexture = f(e.matricesTexture.uuid),
            s._indirectTexture = f(e.indirectTexture.uuid),
            e.colorsTexture !== void 0 && (s._colorsTexture = f(e.colorsTexture.uuid)),
            e.boundingSphere !== void 0 && (s.boundingSphere = new ta().fromJSON(e.boundingSphere)),
            e.boundingBox !== void 0 && (s.boundingBox = new ea().fromJSON(e.boundingBox));
            break;
        case "LOD":
            s = new AB;
            break;
        case "Line":
            s = new xh(l(e.geometry),u(e.material));
            break;
        case "LineLoop":
            s = new UB(l(e.geometry),u(e.material));
            break;
        case "LineSegments":
            s = new lc(l(e.geometry),u(e.material));
            break;
        case "PointCloud":
        case "Points":
            s = new OB(l(e.geometry),u(e.material));
            break;
        case "Sprite":
            s = new wB(u(e.material));
            break;
        case "Group":
            s = new ig;
            break;
        case "Bone":
            s = new hC;
            break;
        default:
            s = new ii
        }
        if (s.uuid = e.uuid,
        e.name !== void 0 && (s.name = e.name),
        e.matrix !== void 0 ? (s.matrix.fromArray(e.matrix),
        e.matrixAutoUpdate !== void 0 && (s.matrixAutoUpdate = e.matrixAutoUpdate),
        s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (e.position !== void 0 && s.position.fromArray(e.position),
        e.rotation !== void 0 && s.rotation.fromArray(e.rotation),
        e.quaternion !== void 0 && s.quaternion.fromArray(e.quaternion),
        e.scale !== void 0 && s.scale.fromArray(e.scale)),
        e.up !== void 0 && s.up.fromArray(e.up),
        e.castShadow !== void 0 && (s.castShadow = e.castShadow),
        e.receiveShadow !== void 0 && (s.receiveShadow = e.receiveShadow),
        e.shadow && (e.shadow.intensity !== void 0 && (s.shadow.intensity = e.shadow.intensity),
        e.shadow.bias !== void 0 && (s.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 && (s.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (s.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 && s.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 && (s.shadow.camera = this.parseObject(e.shadow.camera))),
        e.visible !== void 0 && (s.visible = e.visible),
        e.frustumCulled !== void 0 && (s.frustumCulled = e.frustumCulled),
        e.renderOrder !== void 0 && (s.renderOrder = e.renderOrder),
        e.userData !== void 0 && (s.userData = e.userData),
        e.layers !== void 0 && (s.layers.mask = e.layers),
        e.children !== void 0) {
            const v = e.children;
            for (let y = 0; y < v.length; y++)
                s.add(this.parseObject(v[y], t, n, i, a))
        }
        if (e.animations !== void 0) {
            const v = e.animations;
            for (let y = 0; y < v.length; y++) {
                const S = v[y];
                s.animations.push(a[S])
            }
        }
        if (e.type === "LOD") {
            e.autoUpdate !== void 0 && (s.autoUpdate = e.autoUpdate);
            const v = e.levels;
            for (let y = 0; y < v.length; y++) {
                const S = v[y]
                  , T = s.getObjectByProperty("uuid", S.object);
                T !== void 0 && s.addLevel(T, S.distance, S.hysteresis)
            }
        }
        return s
    }
    bindSkeletons(e, t) {
        Object.keys(t).length !== 0 && e.traverse(function(n) {
            if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
                const i = t[n.skeleton];
                i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(i, n.bindMatrix)
            }
        })
    }
    bindLightTargets(e) {
        e.traverse(function(t) {
            if (t.isDirectionalLight || t.isSpotLight) {
                const n = t.target
                  , i = e.getObjectByProperty("uuid", n);
                i !== void 0 ? t.target = i : t.target = new ii
            }
        })
    }
}
const Jj = {
    UVMapping: yh,
    CubeReflectionMapping: ic,
    CubeRefractionMapping: _h,
    EquirectangularReflectionMapping: Mg,
    EquirectangularRefractionMapping: Py,
    CubeUVReflectionMapping: Xg
}
  , kU = {
    RepeatWrapping: By,
    ClampToEdgeWrapping: Cr,
    MirroredRepeatWrapping: zy
}
  , GU = {
    NearestFilter: va,
    NearestMipmapNearestFilter: KA,
    NearestMipmapLinearFilter: tg,
    LinearFilter: fi,
    LinearMipmapNearestFilter: $v,
    LinearMipmapLinearFilter: Gu
}
  , OT = new WeakMap;
class $j extends xs {
    constructor(e) {
        super(e),
        this.isImageBitmapLoader = !0,
        typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        },
        this._abortController = new AbortController
    }
    setOptions(e) {
        return this.options = e,
        this
    }
    load(e, t, n, i) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const a = this
          , s = Xu.get(`image-bitmap:${e}`);
        if (s !== void 0) {
            if (a.manager.itemStart(e),
            s.then) {
                s.then(f => {
                    if (OT.has(s) === !0)
                        i && i(OT.get(s)),
                        a.manager.itemError(e),
                        a.manager.itemEnd(e);
                    else
                        return t && t(f),
                        a.manager.itemEnd(e),
                        f
                }
                );
                return
            }
            return setTimeout(function() {
                t && t(s),
                a.manager.itemEnd(e)
            }, 0),
            s
        }
        const l = {};
        l.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
        l.headers = this.requestHeader,
        l.signal = typeof AbortSignal.any == "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal;
        const u = fetch(e, l).then(function(f) {
            return f.blob()
        }).then(function(f) {
            return createImageBitmap(f, Object.assign(a.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(f) {
            return Xu.add(`image-bitmap:${e}`, f),
            t && t(f),
            a.manager.itemEnd(e),
            f
        }).catch(function(f) {
            i && i(f),
            OT.set(u, f),
            Xu.remove(`image-bitmap:${e}`),
            a.manager.itemError(e),
            a.manager.itemEnd(e)
        });
        Xu.add(`image-bitmap:${e}`, u),
        a.manager.itemStart(e)
    }
    abort() {
        return this._abortController.abort(),
        this._abortController = new AbortController,
        this
    }
}
let Nx;
class RC {
    static getContext() {
        return Nx === void 0 && (Nx = new (window.AudioContext || window.webkitAudioContext)),
        Nx
    }
    static setContext(e) {
        Nx = e
    }
}
class eW extends xs {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const a = this
          , s = new Eo(this.manager);
        s.setResponseType("arraybuffer"),
        s.setPath(this.path),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials),
        s.load(e, function(u) {
            try {
                const f = u.slice(0);
                RC.getContext().decodeAudioData(f, function(g) {
                    t(g)
                }).catch(l)
            } catch (f) {
                l(f)
            }
        }, n, i);
        function l(u) {
            i ? i(u) : console.error(u),
            a.manager.itemError(e)
        }
    }
}
const XU = new vn
  , jU = new vn
  , Td = new vn;
class tW {
    constructor() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new Jr,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new Jr,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1,
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }
    update(e) {
        const t = this._cache;
        if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
            t.focus = e.focus,
            t.fov = e.fov,
            t.aspect = e.aspect * this.aspect,
            t.near = e.near,
            t.far = e.far,
            t.zoom = e.zoom,
            t.eyeSep = this.eyeSep,
            Td.copy(e.projectionMatrix);
            const i = t.eyeSep / 2
              , a = i * t.near / t.focus
              , s = t.near * Math.tan(np * t.fov * .5) / t.zoom;
            let l, u;
            jU.elements[12] = -i,
            XU.elements[12] = i,
            l = -s * t.aspect + a,
            u = s * t.aspect + a,
            Td.elements[0] = 2 * t.near / (u - l),
            Td.elements[8] = (u + l) / (u - l),
            this.cameraL.projectionMatrix.copy(Td),
            l = -s * t.aspect - a,
            u = s * t.aspect - a,
            Td.elements[0] = 2 * t.near / (u - l),
            Td.elements[8] = (u + l) / (u - l),
            this.cameraR.projectionMatrix.copy(Td)
        }
        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(jU),
        this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(XU)
    }
}
class gz extends Jr {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.isMultiViewCamera = !1,
        this.cameras = e
    }
}
class DC {
    constructor(e=!0) {
        this.autoStart = e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start() {
        this.startTime = performance.now(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop() {
        this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(),
        this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running)
            return this.start(),
            0;
        if (this.running) {
            const t = performance.now();
            e = (t - this.oldTime) / 1e3,
            this.oldTime = t,
            this.elapsedTime += e
        }
        return e
    }
}
const Ed = new he
  , NT = new qs
  , nW = new he
  , wd = new he
  , Ad = new he;
class iW extends ii {
    constructor() {
        super(),
        this.type = "AudioListener",
        this.context = RC.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0,
        this._clock = new DC
    }
    getInput() {
        return this.gain
    }
    removeFilter() {
        return this.filter !== null && (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        this.filter = null),
        this
    }
    getFilter() {
        return this.filter
    }
    setFilter(e) {
        return this.filter !== null ? (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
        this.filter = e,
        this.gain.connect(this.filter),
        this.filter.connect(this.context.destination),
        this
    }
    getMasterVolume() {
        return this.gain.gain.value
    }
    setMasterVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const t = this.context.listener;
        if (this.timeDelta = this._clock.getDelta(),
        this.matrixWorld.decompose(Ed, NT, nW),
        wd.set(0, 0, -1).applyQuaternion(NT),
        Ad.set(0, 1, 0).applyQuaternion(NT),
        t.positionX) {
            const n = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime(Ed.x, n),
            t.positionY.linearRampToValueAtTime(Ed.y, n),
            t.positionZ.linearRampToValueAtTime(Ed.z, n),
            t.forwardX.linearRampToValueAtTime(wd.x, n),
            t.forwardY.linearRampToValueAtTime(wd.y, n),
            t.forwardZ.linearRampToValueAtTime(wd.z, n),
            t.upX.linearRampToValueAtTime(Ad.x, n),
            t.upY.linearRampToValueAtTime(Ad.y, n),
            t.upZ.linearRampToValueAtTime(Ad.z, n)
        } else
            t.setPosition(Ed.x, Ed.y, Ed.z),
            t.setOrientation(wd.x, wd.y, wd.z, Ad.x, Ad.y, Ad.z)
    }
}
class vz extends ii {
    constructor(e) {
        super(),
        this.type = "Audio",
        this.listener = e,
        this.context = e.context,
        this.gain = this.context.createGain(),
        this.gain.connect(e.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.loopStart = 0,
        this.loopEnd = 0,
        this.offset = 0,
        this.duration = void 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.source = null,
        this.sourceType = "empty",
        this._startedAt = 0,
        this._progress = 0,
        this._connected = !1,
        this.filters = []
    }
    getOutput() {
        return this.gain
    }
    setNodeSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "audioNode",
        this.source = e,
        this.connect(),
        this
    }
    setMediaElementSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaNode",
        this.source = this.context.createMediaElementSource(e),
        this.connect(),
        this
    }
    setMediaStreamSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaStreamNode",
        this.source = this.context.createMediaStreamSource(e),
        this.connect(),
        this
    }
    setBuffer(e) {
        return this.buffer = e,
        this.sourceType = "buffer",
        this.autoplay && this.play(),
        this
    }
    play(e=0) {
        if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return
        }
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        this._startedAt = this.context.currentTime + e;
        const t = this.context.createBufferSource();
        return t.buffer = this.buffer,
        t.loop = this.loop,
        t.loopStart = this.loopStart,
        t.loopEnd = this.loopEnd,
        t.onended = this.onEnded.bind(this),
        t.start(this._startedAt, this._progress + this.offset, this.duration),
        this.isPlaying = !0,
        this.source = t,
        this.setDetune(this.detune),
        this.setPlaybackRate(this.playbackRate),
        this.connect()
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
        this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1),
        this
    }
    stop(e=0) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this._progress = 0,
        this.source !== null && (this.source.stop(this.context.currentTime + e),
        this.source.onended = null),
        this.isPlaying = !1,
        this
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else
            this.source.connect(this.getOutput());
        return this._connected = !0,
        this
    }
    disconnect() {
        if (this._connected !== !1) {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this._connected = !1,
            this
        }
    }
    getFilters() {
        return this.filters
    }
    setFilters(e) {
        return e || (e = []),
        this._connected === !0 ? (this.disconnect(),
        this.filters = e.slice(),
        this.connect()) : this.filters = e.slice(),
        this
    }
    setDetune(e) {
        return this.detune = e,
        this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
        this
    }
    getDetune() {
        return this.detune
    }
    getFilter() {
        return this.getFilters()[0]
    }
    setFilter(e) {
        return this.setFilters(e ? [e] : [])
    }
    setPlaybackRate(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.playbackRate = e,
        this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
        this
    }
    getPlaybackRate() {
        return this.playbackRate
    }
    onEnded() {
        this.isPlaying = !1,
        this._progress = 0
    }
    getLoop() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
        !1) : this.loop
    }
    setLoop(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.loop = e,
        this.isPlaying === !0 && (this.source.loop = this.loop),
        this
    }
    setLoopStart(e) {
        return this.loopStart = e,
        this
    }
    setLoopEnd(e) {
        return this.loopEnd = e,
        this
    }
    getVolume() {
        return this.gain.gain.value
    }
    setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
    copy(e, t) {
        return super.copy(e, t),
        e.sourceType !== "buffer" ? (console.warn("THREE.Audio: Audio source type cannot be copied."),
        this) : (this.autoplay = e.autoplay,
        this.buffer = e.buffer,
        this.detune = e.detune,
        this.loop = e.loop,
        this.loopStart = e.loopStart,
        this.loopEnd = e.loopEnd,
        this.offset = e.offset,
        this.duration = e.duration,
        this.playbackRate = e.playbackRate,
        this.hasPlaybackControl = e.hasPlaybackControl,
        this.sourceType = e.sourceType,
        this.filters = e.filters.slice(),
        this)
    }
    clone(e) {
        return new this.constructor(this.listener).copy(this, e)
    }
}
const Cd = new he
  , WU = new qs
  , rW = new he
  , Rd = new he;
class aW extends vz {
    constructor(e) {
        super(e),
        this.panner = this.context.createPanner(),
        this.panner.panningModel = "HRTF",
        this.panner.connect(this.gain)
    }
    connect() {
        return super.connect(),
        this.panner.connect(this.gain),
        this
    }
    disconnect() {
        return super.disconnect(),
        this.panner.disconnect(this.gain),
        this
    }
    getOutput() {
        return this.panner
    }
    getRefDistance() {
        return this.panner.refDistance
    }
    setRefDistance(e) {
        return this.panner.refDistance = e,
        this
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor
    }
    setRolloffFactor(e) {
        return this.panner.rolloffFactor = e,
        this
    }
    getDistanceModel() {
        return this.panner.distanceModel
    }
    setDistanceModel(e) {
        return this.panner.distanceModel = e,
        this
    }
    getMaxDistance() {
        return this.panner.maxDistance
    }
    setMaxDistance(e) {
        return this.panner.maxDistance = e,
        this
    }
    setDirectionalCone(e, t, n) {
        return this.panner.coneInnerAngle = e,
        this.panner.coneOuterAngle = t,
        this.panner.coneOuterGain = n,
        this
    }
    updateMatrixWorld(e) {
        if (super.updateMatrixWorld(e),
        this.hasPlaybackControl === !0 && this.isPlaying === !1)
            return;
        this.matrixWorld.decompose(Cd, WU, rW),
        Rd.set(0, 0, 1).applyQuaternion(WU);
        const t = this.panner;
        if (t.positionX) {
            const n = this.context.currentTime + this.listener.timeDelta;
            t.positionX.linearRampToValueAtTime(Cd.x, n),
            t.positionY.linearRampToValueAtTime(Cd.y, n),
            t.positionZ.linearRampToValueAtTime(Cd.z, n),
            t.orientationX.linearRampToValueAtTime(Rd.x, n),
            t.orientationY.linearRampToValueAtTime(Rd.y, n),
            t.orientationZ.linearRampToValueAtTime(Rd.z, n)
        } else
            t.setPosition(Cd.x, Cd.y, Cd.z),
            t.setOrientation(Rd.x, Rd.y, Rd.z)
    }
}
class sW {
    constructor(e, t=2048) {
        this.analyser = e.context.createAnalyser(),
        this.analyser.fftSize = t,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        e.getOutput().connect(this.analyser)
    }
    getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data),
        this.data
    }
    getAverageFrequency() {
        let e = 0;
        const t = this.getFrequencyData();
        for (let n = 0; n < t.length; n++)
            e += t[n];
        return e / t.length
    }
}
class yz {
    constructor(e, t, n) {
        this.binding = e,
        this.valueSize = n;
        let i, a, s;
        switch (t) {
        case "quaternion":
            i = this._slerp,
            a = this._slerpAdditive,
            s = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(n * 6),
            this._workIndex = 5;
            break;
        case "string":
        case "bool":
            i = this._select,
            a = this._select,
            s = this._setAdditiveIdentityOther,
            this.buffer = new Array(n * 5);
            break;
        default:
            i = this._lerp,
            a = this._lerpAdditive,
            s = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(n * 5)
        }
        this._mixBufferRegion = i,
        this._mixBufferRegionAdditive = a,
        this._setIdentity = s,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    accumulate(e, t) {
        const n = this.buffer
          , i = this.valueSize
          , a = e * i + i;
        let s = this.cumulativeWeight;
        if (s === 0) {
            for (let l = 0; l !== i; ++l)
                n[a + l] = n[l];
            s = t
        } else {
            s += t;
            const l = t / s;
            this._mixBufferRegion(n, a, 0, l, i)
        }
        this.cumulativeWeight = s
    }
    accumulateAdditive(e) {
        const t = this.buffer
          , n = this.valueSize
          , i = n * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
        this._mixBufferRegionAdditive(t, i, 0, e, n),
        this.cumulativeWeightAdditive += e
    }
    apply(e) {
        const t = this.valueSize
          , n = this.buffer
          , i = e * t + t
          , a = this.cumulativeWeight
          , s = this.cumulativeWeightAdditive
          , l = this.binding;
        if (this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        a < 1) {
            const u = t * this._origIndex;
            this._mixBufferRegion(n, i, u, 1 - a, t)
        }
        s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
        for (let u = t, f = t + t; u !== f; ++u)
            if (n[u] !== n[u + t]) {
                l.setValue(n, i);
                break
            }
    }
    saveOriginalState() {
        const e = this.binding
          , t = this.buffer
          , n = this.valueSize
          , i = n * this._origIndex;
        e.getValue(t, i);
        for (let a = n, s = i; a !== s; ++a)
            t[a] = t[i + a % n];
        this._setIdentity(),
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        const e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e)
    }
    _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize
          , t = e + this.valueSize;
        for (let n = e; n < t; n++)
            this.buffer[n] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
        this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize
          , t = this._addIndex * this.valueSize;
        for (let n = 0; n < this.valueSize; n++)
            this.buffer[t + n] = this.buffer[e + n]
    }
    _select(e, t, n, i, a) {
        if (i >= .5)
            for (let s = 0; s !== a; ++s)
                e[t + s] = e[n + s]
    }
    _slerp(e, t, n, i) {
        qs.slerpFlat(e, t, e, t, e, n, i)
    }
    _slerpAdditive(e, t, n, i, a) {
        const s = this._workIndex * a;
        qs.multiplyQuaternionsFlat(e, s, e, t, e, n),
        qs.slerpFlat(e, t, e, t, e, s, i)
    }
    _lerp(e, t, n, i, a) {
        const s = 1 - i;
        for (let l = 0; l !== a; ++l) {
            const u = t + l;
            e[u] = e[u] * s + e[n + l] * i
        }
    }
    _lerpAdditive(e, t, n, i, a) {
        for (let s = 0; s !== a; ++s) {
            const l = t + s;
            e[l] = e[l] + e[n + s] * i
        }
    }
}
const UC = "\\[\\]\\.:\\/"
  , oW = new RegExp("[" + UC + "]","g")
  , OC = "[^" + UC + "]"
  , lW = "[^" + UC.replace("\\.", "") + "]"
  , uW = /((?:WC+[\/:])*)/.source.replace("WC", OC)
  , cW = /(WCOD+)?/.source.replace("WCOD", lW)
  , fW = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", OC)
  , hW = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", OC)
  , dW = new RegExp("^" + uW + cW + fW + hW + "$")
  , pW = ["material", "materials", "bones", "map"];
class mW {
    constructor(e, t, n) {
        const i = n || ni.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, i)
    }
    getValue(e, t) {
        this.bind();
        const n = this._targetGroup.nCachedObjects_
          , i = this._bindings[n];
        i !== void 0 && i.getValue(e, t)
    }
    setValue(e, t) {
        const n = this._bindings;
        for (let i = this._targetGroup.nCachedObjects_, a = n.length; i !== a; ++i)
            n[i].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
            e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
            e[t].unbind()
    }
}
class ni {
    constructor(e, t, n) {
        this.path = t,
        this.parsedPath = n || ni.parseTrackName(t),
        this.node = ni.findNode(e, this.parsedPath.nodeName),
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(e, t, n) {
        return e && e.isAnimationObjectGroup ? new ni.Composite(e,t,n) : new ni(e,t,n)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(oW, "")
    }
    static parseTrackName(e) {
        const t = dW.exec(e);
        if (t === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const n = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
        }
          , i = n.nodeName && n.nodeName.lastIndexOf(".");
        if (i !== void 0 && i !== -1) {
            const a = n.nodeName.substring(i + 1);
            pW.indexOf(a) !== -1 && (n.nodeName = n.nodeName.substring(0, i),
            n.objectName = a)
        }
        if (n.propertyName === null || n.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return n
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
            return e;
        if (e.skeleton) {
            const n = e.skeleton.getBoneByName(t);
            if (n !== void 0)
                return n
        }
        if (e.children) {
            const n = function(a) {
                for (let s = 0; s < a.length; s++) {
                    const l = a[s];
                    if (l.name === t || l.uuid === t)
                        return l;
                    const u = n(l.children);
                    if (u)
                        return u
                }
                return null
            }
              , i = n(e.children);
            if (i)
                return i
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, a = n.length; i !== a; ++i)
            e[t++] = n[i]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, a = n.length; i !== a; ++i)
            n[i] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, a = n.length; i !== a; ++i)
            n[i] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, a = n.length; i !== a; ++i)
            n[i] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(),
        this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(),
        this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath
          , n = t.objectName
          , i = t.propertyName;
        let a = t.propertyIndex;
        if (e || (e = ni.findNode(this.rootNode, t.nodeName),
        this.node = e),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !e) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return
        }
        if (n) {
            let f = t.objectIndex;
            switch (n) {
            case "materials":
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                e = e.skeleton.bones;
                for (let d = 0; d < e.length; d++)
                    if (e[d].name === f) {
                        f = d;
                        break
                    }
                break;
            case "map":
                if ("map"in e) {
                    e = e.map;
                    break
                }
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.map) {
                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                    return
                }
                e = e.material.map;
                break;
            default:
                if (e[n] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                e = e[n]
            }
            if (f !== void 0) {
                if (e[f] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[f]
            }
        }
        const s = e[i];
        if (s === void 0) {
            const f = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + f + "." + i + " but it wasn't found.", e);
            return
        }
        let l = this.Versioning.None;
        this.targetObject = e,
        e.isMaterial === !0 ? l = this.Versioning.NeedsUpdate : e.isObject3D === !0 && (l = this.Versioning.MatrixWorldNeedsUpdate);
        let u = this.BindingType.Direct;
        if (a !== void 0) {
            if (i === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[a] !== void 0 && (a = e.morphTargetDictionary[a])
            }
            u = this.BindingType.ArrayElement,
            this.resolvedProperty = s,
            this.propertyIndex = a
        } else
            s.fromArray !== void 0 && s.toArray !== void 0 ? (u = this.BindingType.HasFromToArray,
            this.resolvedProperty = s) : Array.isArray(s) ? (u = this.BindingType.EntireArray,
            this.resolvedProperty = s) : this.propertyName = i;
        this.getValue = this.GetterByBindingType[u],
        this.setValue = this.SetterByBindingTypeAndVersioning[u][l]
    }
    unbind() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
ni.Composite = mW;
ni.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
ni.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
ni.prototype.GetterByBindingType = [ni.prototype._getValue_direct, ni.prototype._getValue_array, ni.prototype._getValue_arrayElement, ni.prototype._getValue_toArray];
ni.prototype.SetterByBindingTypeAndVersioning = [[ni.prototype._setValue_direct, ni.prototype._setValue_direct_setNeedsUpdate, ni.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [ni.prototype._setValue_array, ni.prototype._setValue_array_setNeedsUpdate, ni.prototype._setValue_array_setMatrixWorldNeedsUpdate], [ni.prototype._setValue_arrayElement, ni.prototype._setValue_arrayElement_setNeedsUpdate, ni.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [ni.prototype._setValue_fromArray, ni.prototype._setValue_fromArray_setNeedsUpdate, ni.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class gW {
    constructor() {
        this.isAnimationObjectGroup = !0,
        this.uuid = To(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        const e = {};
        this._indicesByUUID = e;
        for (let n = 0, i = arguments.length; n !== i; ++n)
            e[arguments[n].uuid] = n;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        const t = this;
        this.stats = {
            objects: {
                get total() {
                    return t._objects.length
                },
                get inUse() {
                    return this.total - t.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return t._bindings.length
            }
        }
    }
    add() {
        const e = this._objects
          , t = this._indicesByUUID
          , n = this._paths
          , i = this._parsedPaths
          , a = this._bindings
          , s = a.length;
        let l, u = e.length, f = this.nCachedObjects_;
        for (let d = 0, g = arguments.length; d !== g; ++d) {
            const v = arguments[d]
              , y = v.uuid;
            let S = t[y];
            if (S === void 0) {
                S = u++,
                t[y] = S,
                e.push(v);
                for (let T = 0, M = s; T !== M; ++T)
                    a[T].push(new ni(v,n[T],i[T]))
            } else if (S < f) {
                l = e[S];
                const T = --f
                  , M = e[T];
                t[M.uuid] = S,
                e[S] = M,
                t[y] = T,
                e[T] = v;
                for (let b = 0, A = s; b !== A; ++b) {
                    const C = a[b]
                      , R = C[T];
                    let O = C[S];
                    C[S] = R,
                    O === void 0 && (O = new ni(v,n[b],i[b])),
                    C[T] = O
                }
            } else
                e[S] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
        }
        this.nCachedObjects_ = f
    }
    remove() {
        const e = this._objects
          , t = this._indicesByUUID
          , n = this._bindings
          , i = n.length;
        let a = this.nCachedObjects_;
        for (let s = 0, l = arguments.length; s !== l; ++s) {
            const u = arguments[s]
              , f = u.uuid
              , d = t[f];
            if (d !== void 0 && d >= a) {
                const g = a++
                  , v = e[g];
                t[v.uuid] = d,
                e[d] = v,
                t[f] = g,
                e[g] = u;
                for (let y = 0, S = i; y !== S; ++y) {
                    const T = n[y]
                      , M = T[g]
                      , b = T[d];
                    T[d] = M,
                    T[g] = b
                }
            }
        }
        this.nCachedObjects_ = a
    }
    uncache() {
        const e = this._objects
          , t = this._indicesByUUID
          , n = this._bindings
          , i = n.length;
        let a = this.nCachedObjects_
          , s = e.length;
        for (let l = 0, u = arguments.length; l !== u; ++l) {
            const f = arguments[l]
              , d = f.uuid
              , g = t[d];
            if (g !== void 0)
                if (delete t[d],
                g < a) {
                    const v = --a
                      , y = e[v]
                      , S = --s
                      , T = e[S];
                    t[y.uuid] = g,
                    e[g] = y,
                    t[T.uuid] = v,
                    e[v] = T,
                    e.pop();
                    for (let M = 0, b = i; M !== b; ++M) {
                        const A = n[M]
                          , C = A[v]
                          , R = A[S];
                        A[g] = C,
                        A[v] = R,
                        A.pop()
                    }
                } else {
                    const v = --s
                      , y = e[v];
                    v > 0 && (t[y.uuid] = g),
                    e[g] = y,
                    e.pop();
                    for (let S = 0, T = i; S !== T; ++S) {
                        const M = n[S];
                        M[g] = M[v],
                        M.pop()
                    }
                }
        }
        this.nCachedObjects_ = a
    }
    subscribe_(e, t) {
        const n = this._bindingsIndicesByPath;
        let i = n[e];
        const a = this._bindings;
        if (i !== void 0)
            return a[i];
        const s = this._paths
          , l = this._parsedPaths
          , u = this._objects
          , f = u.length
          , d = this.nCachedObjects_
          , g = new Array(f);
        i = a.length,
        n[e] = i,
        s.push(e),
        l.push(t),
        a.push(g);
        for (let v = d, y = u.length; v !== y; ++v) {
            const S = u[v];
            g[v] = new ni(S,e,t)
        }
        return g
    }
    unsubscribe_(e) {
        const t = this._bindingsIndicesByPath
          , n = t[e];
        if (n !== void 0) {
            const i = this._paths
              , a = this._parsedPaths
              , s = this._bindings
              , l = s.length - 1
              , u = s[l]
              , f = e[l];
            t[f] = n,
            s[n] = u,
            s.pop(),
            a[n] = a[l],
            a.pop(),
            i[n] = i[l],
            i.pop()
        }
    }
}
class _z {
    constructor(e, t, n=null, i=t.blendMode) {
        this._mixer = e,
        this._clip = t,
        this._localRoot = n,
        this.blendMode = i;
        const a = t.tracks
          , s = a.length
          , l = new Array(s)
          , u = {
            endingStart: Gd,
            endingEnd: Gd
        };
        for (let f = 0; f !== s; ++f) {
            const d = a[f].createInterpolant(null);
            l[f] = d,
            d.settings = u
        }
        this._interpolantSettings = u,
        this._interpolants = l,
        this._propertyBindings = new Array(s),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = oB,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this),
        this
    }
    stop() {
        return this._mixer._deactivateAction(this),
        this.reset()
    }
    reset() {
        return this.paused = !1,
        this.enabled = !0,
        this.time = 0,
        this._loopCount = -1,
        this._startTime = null,
        this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt(e) {
        return this._startTime = e,
        this
    }
    setLoop(e, t) {
        return this.loop = e,
        this.repetitions = t,
        this
    }
    setEffectiveWeight(e) {
        return this.weight = e,
        this._effectiveWeight = this.enabled ? e : 0,
        this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1)
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0)
    }
    crossFadeFrom(e, t, n=!1) {
        if (e.fadeOut(t),
        this.fadeIn(t),
        n === !0) {
            const i = this._clip.duration
              , a = e._clip.duration
              , s = a / i
              , l = i / a;
            e.warp(1, s, t),
            this.warp(l, 1, t)
        }
        return this
    }
    crossFadeTo(e, t, n=!1) {
        return e.crossFadeFrom(this, t, n)
    }
    stopFading() {
        const e = this._weightInterpolant;
        return e !== null && (this._weightInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    setEffectiveTimeScale(e) {
        return this.timeScale = e,
        this._effectiveTimeScale = this.paused ? 0 : e,
        this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration(e) {
        return this.timeScale = this._clip.duration / e,
        this.stopWarping()
    }
    syncWith(e) {
        return this.time = e.time,
        this.timeScale = e.timeScale,
        this.stopWarping()
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e)
    }
    warp(e, t, n) {
        const i = this._mixer
          , a = i.time
          , s = this.timeScale;
        let l = this._timeScaleInterpolant;
        l === null && (l = i._lendControlInterpolant(),
        this._timeScaleInterpolant = l);
        const u = l.parameterPositions
          , f = l.sampleValues;
        return u[0] = a,
        u[1] = a + n,
        f[0] = e / s,
        f[1] = t / s,
        this
    }
    stopWarping() {
        const e = this._timeScaleInterpolant;
        return e !== null && (this._timeScaleInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update(e, t, n, i) {
        if (!this.enabled) {
            this._updateWeight(e);
            return
        }
        const a = this._startTime;
        if (a !== null) {
            const u = (e - a) * n;
            u < 0 || n === 0 ? t = 0 : (this._startTime = null,
            t = n * u)
        }
        t *= this._updateTimeScale(e);
        const s = this._updateTime(t)
          , l = this._updateWeight(e);
        if (l > 0) {
            const u = this._interpolants
              , f = this._propertyBindings;
            switch (this.blendMode) {
            case nC:
                for (let d = 0, g = u.length; d !== g; ++d)
                    u[d].evaluate(s),
                    f[d].accumulateAdditive(l);
                break;
            case fM:
            default:
                for (let d = 0, g = u.length; d !== g; ++d)
                    u[d].evaluate(s),
                    f[d].accumulate(i, l)
            }
        }
    }
    _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
            t = this.weight;
            const n = this._weightInterpolant;
            if (n !== null) {
                const i = n.evaluate(e)[0];
                t *= i,
                e > n.parameterPositions[1] && (this.stopFading(),
                i === 0 && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = t,
        t
    }
    _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
            t = this.timeScale;
            const n = this._timeScaleInterpolant;
            if (n !== null) {
                const i = n.evaluate(e)[0];
                t *= i,
                e > n.parameterPositions[1] && (this.stopWarping(),
                t === 0 ? this.paused = !0 : this.timeScale = t)
            }
        }
        return this._effectiveTimeScale = t,
        t
    }
    _updateTime(e) {
        const t = this._clip.duration
          , n = this.loop;
        let i = this.time + e
          , a = this._loopCount;
        const s = n === lB;
        if (e === 0)
            return a === -1 ? i : s && (a & 1) === 1 ? t - i : i;
        if (n === sB) {
            a === -1 && (this._loopCount = 0,
            this._setEndings(!0, !0, !1));
            e: {
                if (i >= t)
                    i = t;
                else if (i < 0)
                    i = 0;
                else {
                    this.time = i;
                    break e
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = i,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                })
            }
        } else {
            if (a === -1 && (e >= 0 ? (a = 0,
            this._setEndings(!0, this.repetitions === 0, s)) : this._setEndings(this.repetitions === 0, !0, s)),
            i >= t || i < 0) {
                const l = Math.floor(i / t);
                i -= t * l,
                a += Math.abs(l);
                const u = this.repetitions - a;
                if (u <= 0)
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    i = e > 0 ? t : 0,
                    this.time = i,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e > 0 ? 1 : -1
                    });
                else {
                    if (u === 1) {
                        const f = e < 0;
                        this._setEndings(f, !f, s)
                    } else
                        this._setEndings(!1, !1, s);
                    this._loopCount = a,
                    this.time = i,
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: l
                    })
                }
            } else
                this.time = i;
            if (s && (a & 1) === 1)
                return t - i
        }
        return i
    }
    _setEndings(e, t, n) {
        const i = this._interpolantSettings;
        n ? (i.endingStart = Xd,
        i.endingEnd = Xd) : (e ? i.endingStart = this.zeroSlopeAtStart ? Xd : Gd : i.endingStart = Fy,
        t ? i.endingEnd = this.zeroSlopeAtEnd ? Xd : Gd : i.endingEnd = Fy)
    }
    _scheduleFading(e, t, n) {
        const i = this._mixer
          , a = i.time;
        let s = this._weightInterpolant;
        s === null && (s = i._lendControlInterpolant(),
        this._weightInterpolant = s);
        const l = s.parameterPositions
          , u = s.sampleValues;
        return l[0] = a,
        u[0] = t,
        l[1] = a + e,
        u[1] = n,
        this
    }
}
const vW = new Float32Array(1);
class yW extends sc {
    constructor(e) {
        super(),
        this._root = e,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    _bindAction(e, t) {
        const n = e._localRoot || this._root
          , i = e._clip.tracks
          , a = i.length
          , s = e._propertyBindings
          , l = e._interpolants
          , u = n.uuid
          , f = this._bindingsByRootAndName;
        let d = f[u];
        d === void 0 && (d = {},
        f[u] = d);
        for (let g = 0; g !== a; ++g) {
            const v = i[g]
              , y = v.name;
            let S = d[y];
            if (S !== void 0)
                ++S.referenceCount,
                s[g] = S;
            else {
                if (S = s[g],
                S !== void 0) {
                    S._cacheIndex === null && (++S.referenceCount,
                    this._addInactiveBinding(S, u, y));
                    continue
                }
                const T = t && t._propertyBindings[g].binding.parsedPath;
                S = new yz(ni.create(n, y, T),v.ValueTypeName,v.getValueSize()),
                ++S.referenceCount,
                this._addInactiveBinding(S, u, y),
                s[g] = S
            }
            l[g].resultBuffer = S.buffer
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                const n = (e._localRoot || this._root).uuid
                  , i = e._clip.uuid
                  , a = this._actionsByClip[i];
                this._bindAction(e, a && a.knownActions[0]),
                this._addInactiveAction(e, i, n)
            }
            const t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
                const a = t[n];
                a.useCount++ === 0 && (this._lendBinding(a),
                a.saveOriginalState())
            }
            this._lendAction(e)
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
                const a = t[n];
                --a.useCount === 0 && (a.restoreOriginalState(),
                this._takeBackBinding(a))
            }
            this._takeBackAction(e)
        }
    }
    _initMemoryManager() {
        this._actions = [],
        this._nActiveActions = 0,
        this._actionsByClip = {},
        this._bindings = [],
        this._nActiveBindings = 0,
        this._bindingsByRootAndName = {},
        this._controlInterpolants = [],
        this._nActiveControlInterpolants = 0;
        const e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length
                },
                get inUse() {
                    return e._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return e._bindings.length
                },
                get inUse() {
                    return e._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length
                },
                get inUse() {
                    return e._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction(e) {
        const t = e._cacheIndex;
        return t !== null && t < this._nActiveActions
    }
    _addInactiveAction(e, t, n) {
        const i = this._actions
          , a = this._actionsByClip;
        let s = a[t];
        if (s === void 0)
            s = {
                knownActions: [e],
                actionByRoot: {}
            },
            e._byClipCacheIndex = 0,
            a[t] = s;
        else {
            const l = s.knownActions;
            e._byClipCacheIndex = l.length,
            l.push(e)
        }
        e._cacheIndex = i.length,
        i.push(e),
        s.actionByRoot[n] = e
    }
    _removeInactiveAction(e) {
        const t = this._actions
          , n = t[t.length - 1]
          , i = e._cacheIndex;
        n._cacheIndex = i,
        t[i] = n,
        t.pop(),
        e._cacheIndex = null;
        const a = e._clip.uuid
          , s = this._actionsByClip
          , l = s[a]
          , u = l.knownActions
          , f = u[u.length - 1]
          , d = e._byClipCacheIndex;
        f._byClipCacheIndex = d,
        u[d] = f,
        u.pop(),
        e._byClipCacheIndex = null;
        const g = l.actionByRoot
          , v = (e._localRoot || this._root).uuid;
        delete g[v],
        u.length === 0 && delete s[a],
        this._removeInactiveBindingsForAction(e)
    }
    _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let n = 0, i = t.length; n !== i; ++n) {
            const a = t[n];
            --a.referenceCount === 0 && this._removeInactiveBinding(a)
        }
    }
    _lendAction(e) {
        const t = this._actions
          , n = e._cacheIndex
          , i = this._nActiveActions++
          , a = t[i];
        e._cacheIndex = i,
        t[i] = e,
        a._cacheIndex = n,
        t[n] = a
    }
    _takeBackAction(e) {
        const t = this._actions
          , n = e._cacheIndex
          , i = --this._nActiveActions
          , a = t[i];
        e._cacheIndex = i,
        t[i] = e,
        a._cacheIndex = n,
        t[n] = a
    }
    _addInactiveBinding(e, t, n) {
        const i = this._bindingsByRootAndName
          , a = this._bindings;
        let s = i[t];
        s === void 0 && (s = {},
        i[t] = s),
        s[n] = e,
        e._cacheIndex = a.length,
        a.push(e)
    }
    _removeInactiveBinding(e) {
        const t = this._bindings
          , n = e.binding
          , i = n.rootNode.uuid
          , a = n.path
          , s = this._bindingsByRootAndName
          , l = s[i]
          , u = t[t.length - 1]
          , f = e._cacheIndex;
        u._cacheIndex = f,
        t[f] = u,
        t.pop(),
        delete l[a],
        Object.keys(l).length === 0 && delete s[i]
    }
    _lendBinding(e) {
        const t = this._bindings
          , n = e._cacheIndex
          , i = this._nActiveBindings++
          , a = t[i];
        e._cacheIndex = i,
        t[i] = e,
        a._cacheIndex = n,
        t[n] = a
    }
    _takeBackBinding(e) {
        const t = this._bindings
          , n = e._cacheIndex
          , i = --this._nActiveBindings
          , a = t[i];
        e._cacheIndex = i,
        t[i] = e,
        a._cacheIndex = n,
        t[n] = a
    }
    _lendControlInterpolant() {
        const e = this._controlInterpolants
          , t = this._nActiveControlInterpolants++;
        let n = e[t];
        return n === void 0 && (n = new TC(new Float32Array(2),new Float32Array(2),1,vW),
        n.__cacheIndex = t,
        e[t] = n),
        n
    }
    _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants
          , n = e.__cacheIndex
          , i = --this._nActiveControlInterpolants
          , a = t[i];
        e.__cacheIndex = i,
        t[i] = e,
        a.__cacheIndex = n,
        t[n] = a
    }
    clipAction(e, t, n) {
        const i = t || this._root
          , a = i.uuid;
        let s = typeof e == "string" ? Zy.findByName(i, e) : e;
        const l = s !== null ? s.uuid : e
          , u = this._actionsByClip[l];
        let f = null;
        if (n === void 0 && (s !== null ? n = s.blendMode : n = fM),
        u !== void 0) {
            const g = u.actionByRoot[a];
            if (g !== void 0 && g.blendMode === n)
                return g;
            f = u.knownActions[0],
            s === null && (s = f._clip)
        }
        if (s === null)
            return null;
        const d = new _z(this,s,t,n);
        return this._bindAction(d, f),
        this._addInactiveAction(d, l, a),
        d
    }
    existingAction(e, t) {
        const n = t || this._root
          , i = n.uuid
          , a = typeof e == "string" ? Zy.findByName(n, e) : e
          , s = a ? a.uuid : e
          , l = this._actionsByClip[s];
        return l !== void 0 && l.actionByRoot[i] || null
    }
    stopAllAction() {
        const e = this._actions
          , t = this._nActiveActions;
        for (let n = t - 1; n >= 0; --n)
            e[n].stop();
        return this
    }
    update(e) {
        e *= this.timeScale;
        const t = this._actions
          , n = this._nActiveActions
          , i = this.time += e
          , a = Math.sign(e)
          , s = this._accuIndex ^= 1;
        for (let f = 0; f !== n; ++f)
            t[f]._update(i, e, a, s);
        const l = this._bindings
          , u = this._nActiveBindings;
        for (let f = 0; f !== u; ++f)
            l[f].apply(s);
        return this
    }
    setTime(e) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
        return this.update(e)
    }
    getRoot() {
        return this._root
    }
    uncacheClip(e) {
        const t = this._actions
          , n = e.uuid
          , i = this._actionsByClip
          , a = i[n];
        if (a !== void 0) {
            const s = a.knownActions;
            for (let l = 0, u = s.length; l !== u; ++l) {
                const f = s[l];
                this._deactivateAction(f);
                const d = f._cacheIndex
                  , g = t[t.length - 1];
                f._cacheIndex = null,
                f._byClipCacheIndex = null,
                g._cacheIndex = d,
                t[d] = g,
                t.pop(),
                this._removeInactiveBindingsForAction(f)
            }
            delete i[n]
        }
    }
    uncacheRoot(e) {
        const t = e.uuid
          , n = this._actionsByClip;
        for (const s in n) {
            const l = n[s].actionByRoot
              , u = l[t];
            u !== void 0 && (this._deactivateAction(u),
            this._removeInactiveAction(u))
        }
        const i = this._bindingsByRootAndName
          , a = i[t];
        if (a !== void 0)
            for (const s in a) {
                const l = a[s];
                l.restoreOriginalState(),
                this._removeInactiveBinding(l)
            }
    }
    uncacheAction(e, t) {
        const n = this.existingAction(e, t);
        n !== null && (this._deactivateAction(n),
        this._removeInactiveAction(n))
    }
}
class _W extends sC {
    constructor(e=1, t=1, n=1, i={}) {
        super(e, t, i),
        this.isRenderTarget3D = !0,
        this.depth = n,
        this.texture = new dM(null,e,t,n),
        this._setTextureOptions(i),
        this.texture.isRenderTargetTexture = !0
    }
}
class NC {
    constructor(e) {
        this.value = e
    }
    clone() {
        return new NC(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}
let xW = 0;
class SW extends sc {
    constructor() {
        super(),
        this.isUniformsGroup = !0,
        Object.defineProperty(this, "id", {
            value: xW++
        }),
        this.name = "",
        this.usage = Vy,
        this.uniforms = []
    }
    add(e) {
        return this.uniforms.push(e),
        this
    }
    remove(e) {
        const t = this.uniforms.indexOf(e);
        return t !== -1 && this.uniforms.splice(t, 1),
        this
    }
    setName(e) {
        return this.name = e,
        this
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    copy(e) {
        this.name = e.name,
        this.usage = e.usage;
        const t = e.uniforms;
        this.uniforms.length = 0;
        for (let n = 0, i = t.length; n < i; n++) {
            const a = Array.isArray(t[n]) ? t[n] : [t[n]];
            for (let s = 0; s < a.length; s++)
                this.uniforms.push(a[s].clone())
        }
        return this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class bW extends vM {
    constructor(e, t, n=1) {
        super(e, t),
        this.isInstancedInterleavedBuffer = !0,
        this.meshPerAttribute = n
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    clone(e) {
        const t = super.clone(e);
        return t.meshPerAttribute = this.meshPerAttribute,
        t
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.isInstancedInterleavedBuffer = !0,
        t.meshPerAttribute = this.meshPerAttribute,
        t
    }
}
class MW {
    constructor(e, t, n, i, a, s=!1) {
        this.isGLBufferAttribute = !0,
        this.name = "",
        this.buffer = e,
        this.type = t,
        this.itemSize = n,
        this.elementSize = i,
        this.count = a,
        this.normalized = s,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setBuffer(e) {
        return this.buffer = e,
        this
    }
    setType(e, t) {
        return this.type = e,
        this.elementSize = t,
        this
    }
    setItemSize(e) {
        return this.itemSize = e,
        this
    }
    setCount(e) {
        return this.count = e,
        this
    }
}
const YU = new vn;
class LC {
    constructor(e, t, n=0, i=1 / 0) {
        this.ray = new jg(e,t),
        this.near = n,
        this.far = i,
        this.camera = null,
        this.layers = new Dg,
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(e, t) {
        this.ray.set(e, t)
    }
    setFromCamera(e, t) {
        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
        this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
    }
    setFromXRController(e) {
        return YU.identity().extractRotation(e.matrixWorld),
        this.ray.origin.setFromMatrixPosition(e.matrixWorld),
        this.ray.direction.set(0, 0, -1).applyMatrix4(YU),
        this
    }
    intersectObject(e, t=!0, n=[]) {
        return vw(e, this, n, t),
        n.sort(qU),
        n
    }
    intersectObjects(e, t=!0, n=[]) {
        for (let i = 0, a = e.length; i < a; i++)
            vw(e[i], this, n, t);
        return n.sort(qU),
        n
    }
}
function qU(r, e) {
    return r.distance - e.distance
}
function vw(r, e, t, n) {
    let i = !0;
    if (r.layers.test(e.layers) && r.raycast(e, t) === !1 && (i = !1),
    i === !0 && n === !0) {
        const a = r.children;
        for (let s = 0, l = a.length; s < l; s++)
            vw(a[s], e, t, !0)
    }
}
class TW {
    constructor() {
        this._previousTime = 0,
        this._currentTime = 0,
        this._startTime = performance.now(),
        this._delta = 0,
        this._elapsed = 0,
        this._timescale = 1,
        this._document = null,
        this._pageVisibilityHandler = null
    }
    connect(e) {
        this._document = e,
        e.hidden !== void 0 && (this._pageVisibilityHandler = EW.bind(this),
        e.addEventListener("visibilitychange", this._pageVisibilityHandler, !1))
    }
    disconnect() {
        this._pageVisibilityHandler !== null && (this._document.removeEventListener("visibilitychange", this._pageVisibilityHandler),
        this._pageVisibilityHandler = null),
        this._document = null
    }
    getDelta() {
        return this._delta / 1e3
    }
    getElapsed() {
        return this._elapsed / 1e3
    }
    getTimescale() {
        return this._timescale
    }
    setTimescale(e) {
        return this._timescale = e,
        this
    }
    reset() {
        return this._currentTime = performance.now() - this._startTime,
        this
    }
    dispose() {
        this.disconnect()
    }
    update(e) {
        return this._pageVisibilityHandler !== null && this._document.hidden === !0 ? this._delta = 0 : (this._previousTime = this._currentTime,
        this._currentTime = (e !== void 0 ? e : performance.now()) - this._startTime,
        this._delta = (this._currentTime - this._previousTime) * this._timescale,
        this._elapsed += this._delta),
        this
    }
}
function EW() {
    this._document.hidden === !1 && this.reset()
}
class wW {
    constructor(e=1, t=0, n=0) {
        this.radius = e,
        this.phi = t,
        this.theta = n
    }
    set(e, t, n) {
        return this.radius = e,
        this.phi = t,
        this.theta = n,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.phi = e.phi,
        this.theta = e.theta,
        this
    }
    makeSafe() {
        return this.phi = gn(this.phi, 1e-6, Math.PI - 1e-6),
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, n) {
        return this.radius = Math.sqrt(e * e + t * t + n * n),
        this.radius === 0 ? (this.theta = 0,
        this.phi = 0) : (this.theta = Math.atan2(e, n),
        this.phi = Math.acos(gn(t / this.radius, -1, 1))),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class AW {
    constructor(e=1, t=0, n=0) {
        this.radius = e,
        this.theta = t,
        this.y = n
    }
    set(e, t, n) {
        return this.radius = e,
        this.theta = t,
        this.y = n,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.theta = e.theta,
        this.y = e.y,
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, n) {
        return this.radius = Math.sqrt(e * e + n * n),
        this.theta = Math.atan2(e, n),
        this.y = t,
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class PC {
    constructor(e, t, n, i) {
        PC.prototype.isMatrix2 = !0,
        this.elements = [1, 0, 0, 1],
        e !== void 0 && this.set(e, t, n, i)
    }
    identity() {
        return this.set(1, 0, 0, 1),
        this
    }
    fromArray(e, t=0) {
        for (let n = 0; n < 4; n++)
            this.elements[n] = e[n + t];
        return this
    }
    set(e, t, n, i) {
        const a = this.elements;
        return a[0] = e,
        a[2] = t,
        a[1] = n,
        a[3] = i,
        this
    }
}
const ZU = new xt;
class CW {
    constructor(e=new xt(1 / 0,1 / 0), t=new xt(-1 / 0,-1 / 0)) {
        this.isBox2 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const n = ZU.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(n),
        this.max.copy(e).add(n),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = 1 / 0,
        this.max.x = this.max.y = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    containsPoint(e) {
        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
    }
    intersectsBox(e) {
        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, ZU).distanceTo(e)
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const KU = new he
  , Lx = new he
  , Bm = new he
  , zm = new he
  , LT = new he
  , RW = new he
  , DW = new he;
class UW {
    constructor(e=new he, t=new he) {
        this.start = e,
        this.end = t
    }
    set(e, t) {
        return this.start.copy(e),
        this.end.copy(t),
        this
    }
    copy(e) {
        return this.start.copy(e.start),
        this.end.copy(e.end),
        this
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(e) {
        return e.subVectors(this.end, this.start)
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }
    distance() {
        return this.start.distanceTo(this.end)
    }
    at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start)
    }
    closestPointToPointParameter(e, t) {
        KU.subVectors(e, this.start),
        Lx.subVectors(this.end, this.start);
        const n = Lx.dot(Lx);
        let a = Lx.dot(KU) / n;
        return t && (a = gn(a, 0, 1)),
        a
    }
    closestPointToPoint(e, t, n) {
        const i = this.closestPointToPointParameter(e, t);
        return this.delta(n).multiplyScalar(i).add(this.start)
    }
    distanceSqToLine3(e, t=RW, n=DW) {
        const i = 10000000000000001e-32;
        let a, s;
        const l = this.start
          , u = e.start
          , f = this.end
          , d = e.end;
        Bm.subVectors(f, l),
        zm.subVectors(d, u),
        LT.subVectors(l, u);
        const g = Bm.dot(Bm)
          , v = zm.dot(zm)
          , y = zm.dot(LT);
        if (g <= i && v <= i)
            return t.copy(l),
            n.copy(u),
            t.sub(n),
            t.dot(t);
        if (g <= i)
            a = 0,
            s = y / v,
            s = gn(s, 0, 1);
        else {
            const S = Bm.dot(LT);
            if (v <= i)
                s = 0,
                a = gn(-S / g, 0, 1);
            else {
                const T = Bm.dot(zm)
                  , M = g * v - T * T;
                M !== 0 ? a = gn((T * y - S * v) / M, 0, 1) : a = 0,
                s = (T * a + y) / v,
                s < 0 ? (s = 0,
                a = gn(-S / g, 0, 1)) : s > 1 && (s = 1,
                a = gn((T - S) / g, 0, 1))
            }
        }
        return t.copy(l).add(Bm.multiplyScalar(a)),
        n.copy(u).add(zm.multiplyScalar(s)),
        t.sub(n),
        t.dot(t)
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e),
        this.end.applyMatrix4(e),
        this
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const QU = new he;
class OW extends ii {
    constructor(e, t) {
        super(),
        this.light = e,
        this.matrixAutoUpdate = !1,
        this.color = t,
        this.type = "SpotLightHelper";
        const n = new Nn
          , i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (let s = 0, l = 1, u = 32; s < u; s++,
        l++) {
            const f = s / u * Math.PI * 2
              , d = l / u * Math.PI * 2;
            i.push(Math.cos(f), Math.sin(f), 1, Math.cos(d), Math.sin(d), 1)
        }
        n.setAttribute("position", new Qt(i,3));
        const a = new _s({
            fog: !1,
            toneMapped: !1
        });
        this.cone = new lc(n,a),
        this.add(this.cone),
        this.update()
    }
    dispose() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1),
        this.parent ? (this.parent.updateWorldMatrix(!0),
        this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld),
        this.matrixWorld.copy(this.light.matrixWorld);
        const e = this.light.distance ? this.light.distance : 1e3
          , t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e),
        QU.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt(QU),
        this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
}
const Kf = new he
  , Px = new vn
  , PT = new vn;
class NW extends lc {
    constructor(e) {
        const t = xz(e)
          , n = new Nn
          , i = []
          , a = [];
        for (let f = 0; f < t.length; f++) {
            const d = t[f];
            d.parent && d.parent.isBone && (i.push(0, 0, 0),
            i.push(0, 0, 0),
            a.push(0, 0, 0),
            a.push(0, 0, 0))
        }
        n.setAttribute("position", new Qt(i,3)),
        n.setAttribute("color", new Qt(a,3));
        const s = new _s({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        super(n, s),
        this.isSkeletonHelper = !0,
        this.type = "SkeletonHelper",
        this.root = e,
        this.bones = t,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1;
        const l = new kt(255)
          , u = new kt(65280);
        this.setColors(l, u)
    }
    updateMatrixWorld(e) {
        const t = this.bones
          , n = this.geometry
          , i = n.getAttribute("position");
        PT.copy(this.root.matrixWorld).invert();
        for (let a = 0, s = 0; a < t.length; a++) {
            const l = t[a];
            l.parent && l.parent.isBone && (Px.multiplyMatrices(PT, l.matrixWorld),
            Kf.setFromMatrixPosition(Px),
            i.setXYZ(s, Kf.x, Kf.y, Kf.z),
            Px.multiplyMatrices(PT, l.parent.matrixWorld),
            Kf.setFromMatrixPosition(Px),
            i.setXYZ(s + 1, Kf.x, Kf.y, Kf.z),
            s += 2)
        }
        n.getAttribute("position").needsUpdate = !0,
        super.updateMatrixWorld(e)
    }
    setColors(e, t) {
        const i = this.geometry.getAttribute("color");
        for (let a = 0; a < i.count; a += 2)
            i.setXYZ(a, e.r, e.g, e.b),
            i.setXYZ(a + 1, t.r, t.g, t.b);
        return i.needsUpdate = !0,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function xz(r) {
    const e = [];
    r.isBone === !0 && e.push(r);
    for (let t = 0; t < r.children.length; t++)
        e.push(...xz(r.children[t]));
    return e
}
class LW extends Ni {
    constructor(e, t, n) {
        const i = new x_(t,4,2)
          , a = new oc({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        });
        super(i, a),
        this.light = e,
        this.color = n,
        this.type = "PointLightHelper",
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
}
const PW = new he
  , JU = new kt
  , $U = new kt;
class BW extends ii {
    constructor(e, t, n) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = n,
        this.type = "HemisphereLightHelper";
        const i = new __(t);
        i.rotateY(Math.PI * .5),
        this.material = new oc({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        }),
        this.color === void 0 && (this.material.vertexColors = !0);
        const a = i.getAttribute("position")
          , s = new Float32Array(a.count * 3);
        i.setAttribute("color", new xi(s,3)),
        this.add(new Ni(i,this.material)),
        this.update()
    }
    dispose() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    update() {
        const e = this.children[0];
        if (this.color !== void 0)
            this.material.color.set(this.color);
        else {
            const t = e.geometry.getAttribute("color");
            JU.copy(this.light.color),
            $U.copy(this.light.groundColor);
            for (let n = 0, i = t.count; n < i; n++) {
                const a = n < i / 2 ? JU : $U;
                t.setXYZ(n, a.r, a.g, a.b)
            }
            t.needsUpdate = !0
        }
        this.light.updateWorldMatrix(!0, !1),
        e.lookAt(PW.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
}
class zW extends lc {
    constructor(e=10, t=10, n=4473924, i=8947848) {
        n = new kt(n),
        i = new kt(i);
        const a = t / 2
          , s = e / t
          , l = e / 2
          , u = []
          , f = [];
        for (let v = 0, y = 0, S = -l; v <= t; v++,
        S += s) {
            u.push(-l, 0, S, l, 0, S),
            u.push(S, 0, -l, S, 0, l);
            const T = v === a ? n : i;
            T.toArray(f, y),
            y += 3,
            T.toArray(f, y),
            y += 3,
            T.toArray(f, y),
            y += 3,
            T.toArray(f, y),
            y += 3
        }
        const d = new Nn;
        d.setAttribute("position", new Qt(u,3)),
        d.setAttribute("color", new Qt(f,3));
        const g = new _s({
            vertexColors: !0,
            toneMapped: !1
        });
        super(d, g),
        this.type = "GridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class IW extends lc {
    constructor(e=10, t=16, n=8, i=64, a=4473924, s=8947848) {
        a = new kt(a),
        s = new kt(s);
        const l = []
          , u = [];
        if (t > 1)
            for (let g = 0; g < t; g++) {
                const v = g / t * (Math.PI * 2)
                  , y = Math.sin(v) * e
                  , S = Math.cos(v) * e;
                l.push(0, 0, 0),
                l.push(y, 0, S);
                const T = g & 1 ? a : s;
                u.push(T.r, T.g, T.b),
                u.push(T.r, T.g, T.b)
            }
        for (let g = 0; g < n; g++) {
            const v = g & 1 ? a : s
              , y = e - e / n * g;
            for (let S = 0; S < i; S++) {
                let T = S / i * (Math.PI * 2)
                  , M = Math.sin(T) * y
                  , b = Math.cos(T) * y;
                l.push(M, 0, b),
                u.push(v.r, v.g, v.b),
                T = (S + 1) / i * (Math.PI * 2),
                M = Math.sin(T) * y,
                b = Math.cos(T) * y,
                l.push(M, 0, b),
                u.push(v.r, v.g, v.b)
            }
        }
        const f = new Nn;
        f.setAttribute("position", new Qt(l,3)),
        f.setAttribute("color", new Qt(u,3));
        const d = new _s({
            vertexColors: !0,
            toneMapped: !1
        });
        super(f, d),
        this.type = "PolarGridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
const eO = new he
  , Bx = new he
  , tO = new he;
class FW extends ii {
    constructor(e, t, n) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = n,
        this.type = "DirectionalLightHelper",
        t === void 0 && (t = 1);
        let i = new Nn;
        i.setAttribute("position", new Qt([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3));
        const a = new _s({
            fog: !1,
            toneMapped: !1
        });
        this.lightPlane = new xh(i,a),
        this.add(this.lightPlane),
        i = new Nn,
        i.setAttribute("position", new Qt([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new xh(i,a),
        this.add(this.targetLine),
        this.update()
    }
    dispose() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1),
        eO.setFromMatrixPosition(this.light.matrixWorld),
        Bx.setFromMatrixPosition(this.light.target.matrixWorld),
        tO.subVectors(Bx, eO),
        this.lightPlane.lookAt(Bx),
        this.color !== void 0 ? (this.lightPlane.material.color.set(this.color),
        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
        this.targetLine.material.color.copy(this.light.color)),
        this.targetLine.lookAt(Bx),
        this.targetLine.scale.z = tO.length()
    }
}
const zx = new he
  , or = new pM;
class HW extends lc {
    constructor(e) {
        const t = new Nn
          , n = new _s({
            color: 16777215,
            vertexColors: !0,
            toneMapped: !1
        })
          , i = []
          , a = []
          , s = {};
        l("n1", "n2"),
        l("n2", "n4"),
        l("n4", "n3"),
        l("n3", "n1"),
        l("f1", "f2"),
        l("f2", "f4"),
        l("f4", "f3"),
        l("f3", "f1"),
        l("n1", "f1"),
        l("n2", "f2"),
        l("n3", "f3"),
        l("n4", "f4"),
        l("p", "n1"),
        l("p", "n2"),
        l("p", "n3"),
        l("p", "n4"),
        l("u1", "u2"),
        l("u2", "u3"),
        l("u3", "u1"),
        l("c", "t"),
        l("p", "c"),
        l("cn1", "cn2"),
        l("cn3", "cn4"),
        l("cf1", "cf2"),
        l("cf3", "cf4");
        function l(S, T) {
            u(S),
            u(T)
        }
        function u(S) {
            i.push(0, 0, 0),
            a.push(0, 0, 0),
            s[S] === void 0 && (s[S] = []),
            s[S].push(i.length / 3 - 1)
        }
        t.setAttribute("position", new Qt(i,3)),
        t.setAttribute("color", new Qt(a,3)),
        super(t, n),
        this.type = "CameraHelper",
        this.camera = e,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = s,
        this.update();
        const f = new kt(16755200)
          , d = new kt(16711680)
          , g = new kt(43775)
          , v = new kt(16777215)
          , y = new kt(3355443);
        this.setColors(f, d, g, v, y)
    }
    setColors(e, t, n, i, a) {
        const l = this.geometry.getAttribute("color");
        return l.setXYZ(0, e.r, e.g, e.b),
        l.setXYZ(1, e.r, e.g, e.b),
        l.setXYZ(2, e.r, e.g, e.b),
        l.setXYZ(3, e.r, e.g, e.b),
        l.setXYZ(4, e.r, e.g, e.b),
        l.setXYZ(5, e.r, e.g, e.b),
        l.setXYZ(6, e.r, e.g, e.b),
        l.setXYZ(7, e.r, e.g, e.b),
        l.setXYZ(8, e.r, e.g, e.b),
        l.setXYZ(9, e.r, e.g, e.b),
        l.setXYZ(10, e.r, e.g, e.b),
        l.setXYZ(11, e.r, e.g, e.b),
        l.setXYZ(12, e.r, e.g, e.b),
        l.setXYZ(13, e.r, e.g, e.b),
        l.setXYZ(14, e.r, e.g, e.b),
        l.setXYZ(15, e.r, e.g, e.b),
        l.setXYZ(16, e.r, e.g, e.b),
        l.setXYZ(17, e.r, e.g, e.b),
        l.setXYZ(18, e.r, e.g, e.b),
        l.setXYZ(19, e.r, e.g, e.b),
        l.setXYZ(20, e.r, e.g, e.b),
        l.setXYZ(21, e.r, e.g, e.b),
        l.setXYZ(22, e.r, e.g, e.b),
        l.setXYZ(23, e.r, e.g, e.b),
        l.setXYZ(24, t.r, t.g, t.b),
        l.setXYZ(25, t.r, t.g, t.b),
        l.setXYZ(26, t.r, t.g, t.b),
        l.setXYZ(27, t.r, t.g, t.b),
        l.setXYZ(28, t.r, t.g, t.b),
        l.setXYZ(29, t.r, t.g, t.b),
        l.setXYZ(30, t.r, t.g, t.b),
        l.setXYZ(31, t.r, t.g, t.b),
        l.setXYZ(32, n.r, n.g, n.b),
        l.setXYZ(33, n.r, n.g, n.b),
        l.setXYZ(34, n.r, n.g, n.b),
        l.setXYZ(35, n.r, n.g, n.b),
        l.setXYZ(36, n.r, n.g, n.b),
        l.setXYZ(37, n.r, n.g, n.b),
        l.setXYZ(38, i.r, i.g, i.b),
        l.setXYZ(39, i.r, i.g, i.b),
        l.setXYZ(40, a.r, a.g, a.b),
        l.setXYZ(41, a.r, a.g, a.b),
        l.setXYZ(42, a.r, a.g, a.b),
        l.setXYZ(43, a.r, a.g, a.b),
        l.setXYZ(44, a.r, a.g, a.b),
        l.setXYZ(45, a.r, a.g, a.b),
        l.setXYZ(46, a.r, a.g, a.b),
        l.setXYZ(47, a.r, a.g, a.b),
        l.setXYZ(48, a.r, a.g, a.b),
        l.setXYZ(49, a.r, a.g, a.b),
        l.needsUpdate = !0,
        this
    }
    update() {
        const e = this.geometry
          , t = this.pointMap
          , n = 1
          , i = 1;
        let a, s;
        if (or.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
        this.camera.reversedDepth === !0)
            a = 1,
            s = 0;
        else if (this.camera.coordinateSystem === bo)
            a = -1,
            s = 1;
        else if (this.camera.coordinateSystem === Cg)
            a = 0,
            s = 1;
        else
            throw new Error("THREE.CameraHelper.update(): Invalid coordinate system: " + this.camera.coordinateSystem);
        pr("c", t, e, or, 0, 0, a),
        pr("t", t, e, or, 0, 0, s),
        pr("n1", t, e, or, -1, -1, a),
        pr("n2", t, e, or, n, -1, a),
        pr("n3", t, e, or, -1, i, a),
        pr("n4", t, e, or, n, i, a),
        pr("f1", t, e, or, -1, -1, s),
        pr("f2", t, e, or, n, -1, s),
        pr("f3", t, e, or, -1, i, s),
        pr("f4", t, e, or, n, i, s),
        pr("u1", t, e, or, n * .7, i * 1.1, a),
        pr("u2", t, e, or, -1 * .7, i * 1.1, a),
        pr("u3", t, e, or, 0, i * 2, a),
        pr("cf1", t, e, or, -1, 0, s),
        pr("cf2", t, e, or, n, 0, s),
        pr("cf3", t, e, or, 0, -1, s),
        pr("cf4", t, e, or, 0, i, s),
        pr("cn1", t, e, or, -1, 0, a),
        pr("cn2", t, e, or, n, 0, a),
        pr("cn3", t, e, or, 0, -1, a),
        pr("cn4", t, e, or, 0, i, a),
        e.getAttribute("position").needsUpdate = !0
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function pr(r, e, t, n, i, a, s) {
    zx.set(i, a, s).unproject(n);
    const l = e[r];
    if (l !== void 0) {
        const u = t.getAttribute("position");
        for (let f = 0, d = l.length; f < d; f++)
            u.setXYZ(l[f], zx.x, zx.y, zx.z)
    }
}
const Ix = new ea;
class VW extends lc {
    constructor(e, t=16776960) {
        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , i = new Float32Array(8 * 3)
          , a = new Nn;
        a.setIndex(new xi(n,1)),
        a.setAttribute("position", new xi(i,3)),
        super(a, new _s({
            color: t,
            toneMapped: !1
        })),
        this.object = e,
        this.type = "BoxHelper",
        this.matrixAutoUpdate = !1,
        this.update()
    }
    update() {
        if (this.object !== void 0 && Ix.setFromObject(this.object),
        Ix.isEmpty())
            return;
        const e = Ix.min
          , t = Ix.max
          , n = this.geometry.attributes.position
          , i = n.array;
        i[0] = t.x,
        i[1] = t.y,
        i[2] = t.z,
        i[3] = e.x,
        i[4] = t.y,
        i[5] = t.z,
        i[6] = e.x,
        i[7] = e.y,
        i[8] = t.z,
        i[9] = t.x,
        i[10] = e.y,
        i[11] = t.z,
        i[12] = t.x,
        i[13] = t.y,
        i[14] = e.z,
        i[15] = e.x,
        i[16] = t.y,
        i[17] = e.z,
        i[18] = e.x,
        i[19] = e.y,
        i[20] = e.z,
        i[21] = t.x,
        i[22] = e.y,
        i[23] = e.z,
        n.needsUpdate = !0,
        this.geometry.computeBoundingSphere()
    }
    setFromObject(e) {
        return this.object = e,
        this.update(),
        this
    }
    copy(e, t) {
        return super.copy(e, t),
        this.object = e.object,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class kW extends lc {
    constructor(e, t=16776960) {
        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1]
          , a = new Nn;
        a.setIndex(new xi(n,1)),
        a.setAttribute("position", new Qt(i,3)),
        super(a, new _s({
            color: t,
            toneMapped: !1
        })),
        this.box = e,
        this.type = "Box3Helper",
        this.geometry.computeBoundingSphere()
    }
    updateMatrixWorld(e) {
        const t = this.box;
        t.isEmpty() || (t.getCenter(this.position),
        t.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        super.updateMatrixWorld(e))
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class GW extends xh {
    constructor(e, t=1, n=16776960) {
        const i = n
          , a = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0]
          , s = new Nn;
        s.setAttribute("position", new Qt(a,3)),
        s.computeBoundingSphere(),
        super(s, new _s({
            color: i,
            toneMapped: !1
        })),
        this.type = "PlaneHelper",
        this.plane = e,
        this.size = t;
        const l = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0]
          , u = new Nn;
        u.setAttribute("position", new Qt(l,3)),
        u.computeBoundingSphere(),
        this.add(new Ni(u,new oc({
            color: i,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
        })))
    }
    updateMatrixWorld(e) {
        this.position.set(0, 0, 0),
        this.scale.set(.5 * this.size, .5 * this.size, 1),
        this.lookAt(this.plane.normal),
        this.translateZ(-this.plane.constant),
        super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose(),
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
}
const nO = new he;
let Fx, BT;
class XW extends ii {
    constructor(e=new he(0,0,1), t=new he(0,0,0), n=1, i=16776960, a=n * .2, s=a * .2) {
        super(),
        this.type = "ArrowHelper",
        Fx === void 0 && (Fx = new Nn,
        Fx.setAttribute("position", new Qt([0, 0, 0, 0, 1, 0],3)),
        BT = new v_(.5,1,5,1),
        BT.translate(0, -.5, 0)),
        this.position.copy(t),
        this.line = new xh(Fx,new _s({
            color: i,
            toneMapped: !1
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new Ni(BT,new oc({
            color: i,
            toneMapped: !1
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(e),
        this.setLength(n, a, s)
    }
    setDirection(e) {
        if (e.y > .99999)
            this.quaternion.set(0, 0, 0, 1);
        else if (e.y < -.99999)
            this.quaternion.set(1, 0, 0, 0);
        else {
            nO.set(e.z, 0, -e.x).normalize();
            const t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(nO, t)
        }
    }
    setLength(e, t=e * .2, n=t * .2) {
        this.line.scale.set(1, Math.max(1e-4, e - t), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(n, t, n),
        this.cone.position.y = e,
        this.cone.updateMatrix()
    }
    setColor(e) {
        this.line.material.color.set(e),
        this.cone.material.color.set(e)
    }
    copy(e) {
        return super.copy(e, !1),
        this.line.copy(e.line),
        this.cone.copy(e.cone),
        this
    }
    dispose() {
        this.line.geometry.dispose(),
        this.line.material.dispose(),
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
}
class jW extends lc {
    constructor(e=1) {
        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
          , n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]
          , i = new Nn;
        i.setAttribute("position", new Qt(t,3)),
        i.setAttribute("color", new Qt(n,3));
        const a = new _s({
            vertexColors: !0,
            toneMapped: !1
        });
        super(i, a),
        this.type = "AxesHelper"
    }
    setColors(e, t, n) {
        const i = new kt
          , a = this.geometry.attributes.color.array;
        return i.set(e),
        i.toArray(a, 0),
        i.toArray(a, 3),
        i.set(t),
        i.toArray(a, 6),
        i.toArray(a, 9),
        i.set(n),
        i.toArray(a, 12),
        i.toArray(a, 15),
        this.geometry.attributes.color.needsUpdate = !0,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class WW {
    constructor() {
        this.type = "ShapePath",
        this.color = new kt,
        this.subPaths = [],
        this.currentPath = null
    }
    moveTo(e, t) {
        return this.currentPath = new Ob,
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(e, t),
        this
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t),
        this
    }
    quadraticCurveTo(e, t, n, i) {
        return this.currentPath.quadraticCurveTo(e, t, n, i),
        this
    }
    bezierCurveTo(e, t, n, i, a, s) {
        return this.currentPath.bezierCurveTo(e, t, n, i, a, s),
        this
    }
    splineThru(e) {
        return this.currentPath.splineThru(e),
        this
    }
    toShapes(e) {
        function t(b) {
            const A = [];
            for (let C = 0, R = b.length; C < R; C++) {
                const O = b[C]
                  , L = new ip;
                L.curves = O.curves,
                A.push(L)
            }
            return A
        }
        function n(b, A) {
            const C = A.length;
            let R = !1;
            for (let O = C - 1, L = 0; L < C; O = L++) {
                let z = A[O]
                  , I = A[L]
                  , N = I.x - z.x
                  , P = I.y - z.y;
                if (Math.abs(P) > Number.EPSILON) {
                    if (P < 0 && (z = A[L],
                    N = -N,
                    I = A[O],
                    P = -P),
                    b.y < z.y || b.y > I.y)
                        continue;
                    if (b.y === z.y) {
                        if (b.x === z.x)
                            return !0
                    } else {
                        const Y = P * (b.x - z.x) - N * (b.y - z.y);
                        if (Y === 0)
                            return !0;
                        if (Y < 0)
                            continue;
                        R = !R
                    }
                } else {
                    if (b.y !== z.y)
                        continue;
                    if (I.x <= b.x && b.x <= z.x || z.x <= b.x && b.x <= I.x)
                        return !0
                }
            }
            return R
        }
        const i = Zl.isClockWise
          , a = this.subPaths;
        if (a.length === 0)
            return [];
        let s, l, u;
        const f = [];
        if (a.length === 1)
            return l = a[0],
            u = new ip,
            u.curves = l.curves,
            f.push(u),
            f;
        let d = !i(a[0].getPoints());
        d = e ? !d : d;
        const g = []
          , v = [];
        let y = [], S = 0, T;
        v[S] = void 0,
        y[S] = [];
        for (let b = 0, A = a.length; b < A; b++)
            l = a[b],
            T = l.getPoints(),
            s = i(T),
            s = e ? !s : s,
            s ? (!d && v[S] && S++,
            v[S] = {
                s: new ip,
                p: T
            },
            v[S].s.curves = l.curves,
            d && S++,
            y[S] = []) : y[S].push({
                h: l,
                p: T[0]
            });
        if (!v[0])
            return t(a);
        if (v.length > 1) {
            let b = !1
              , A = 0;
            for (let C = 0, R = v.length; C < R; C++)
                g[C] = [];
            for (let C = 0, R = v.length; C < R; C++) {
                const O = y[C];
                for (let L = 0; L < O.length; L++) {
                    const z = O[L];
                    let I = !0;
                    for (let N = 0; N < v.length; N++)
                        n(z.p, v[N].p) && (C !== N && A++,
                        I ? (I = !1,
                        g[N].push(z)) : b = !0);
                    I && g[C].push(z)
                }
            }
            A > 0 && b === !1 && (y = g)
        }
        let M;
        for (let b = 0, A = v.length; b < A; b++) {
            u = v[b].s,
            f.push(u),
            M = y[b];
            for (let C = 0, R = M.length; C < R; C++)
                u.holes.push(M[C].h)
        }
        return f
    }
}
class YW extends sc {
    constructor(e, t=null) {
        super(),
        this.object = e,
        this.domElement = t,
        this.enabled = !0,
        this.state = -1,
        this.keys = {},
        this.mouseButtons = {
            LEFT: null,
            MIDDLE: null,
            RIGHT: null
        },
        this.touches = {
            ONE: null,
            TWO: null
        }
    }
    connect(e) {
        if (e === void 0) {
            console.warn("THREE.Controls: connect() now requires an element.");
            return
        }
        this.domElement !== null && this.disconnect(),
        this.domElement = e
    }
    disconnect() {}
    dispose() {}
    update() {}
}
function qW(r, e) {
    const t = r.image && r.image.width ? r.image.width / r.image.height : 1;
    return t > e ? (r.repeat.x = 1,
    r.repeat.y = t / e,
    r.offset.x = 0,
    r.offset.y = (1 - r.repeat.y) / 2) : (r.repeat.x = e / t,
    r.repeat.y = 1,
    r.offset.x = (1 - r.repeat.x) / 2,
    r.offset.y = 0),
    r
}
function ZW(r, e) {
    const t = r.image && r.image.width ? r.image.width / r.image.height : 1;
    return t > e ? (r.repeat.x = e / t,
    r.repeat.y = 1,
    r.offset.x = (1 - r.repeat.x) / 2,
    r.offset.y = 0) : (r.repeat.x = 1,
    r.repeat.y = t / e,
    r.offset.x = 0,
    r.offset.y = (1 - r.repeat.y) / 2),
    r
}
function KW(r) {
    return r.repeat.x = 1,
    r.repeat.y = 1,
    r.offset.x = 0,
    r.offset.y = 0,
    r
}
function yw(r, e, t, n) {
    const i = QW(n);
    switch (t) {
    case $A:
        return r * e;
    case h_:
        return r * e / i.components * i.byteLength;
    case d_:
        return r * e / i.components * i.byteLength;
    case tC:
        return r * e * 2 / i.components * i.byteLength;
    case uM:
        return r * e * 2 / i.components * i.byteLength;
    case eC:
        return r * e * 3 / i.components * i.byteLength;
    case vr:
        return r * e * 4 / i.components * i.byteLength;
    case cM:
        return r * e * 4 / i.components * i.byteLength;
    case ey:
    case ty:
        return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case ny:
    case iy:
        return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case tb:
    case ib:
        return Math.max(r, 16) * Math.max(e, 8) / 4;
    case eb:
    case nb:
        return Math.max(r, 8) * Math.max(e, 8) / 2;
    case rb:
    case ab:
        return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case sb:
        return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case ob:
        return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case lb:
        return Math.floor((r + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case ub:
        return Math.floor((r + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case cb:
        return Math.floor((r + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case fb:
        return Math.floor((r + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case hb:
        return Math.floor((r + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case db:
        return Math.floor((r + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case pb:
        return Math.floor((r + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case mb:
        return Math.floor((r + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case gb:
        return Math.floor((r + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case vb:
        return Math.floor((r + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case yb:
        return Math.floor((r + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case _b:
        return Math.floor((r + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case xb:
        return Math.floor((r + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case Sb:
    case bb:
    case Mb:
        return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
    case Tb:
    case Eb:
        return Math.ceil(r / 4) * Math.ceil(e / 4) * 8;
    case wb:
    case Ab:
        return Math.ceil(r / 4) * Math.ceil(e / 4) * 16
    }
    throw new Error(`Unable to determine texture byte length for ${t} format.`)
}
function QW(r) {
    switch (r) {
    case ys:
    case aM:
        return {
            byteLength: 1,
            components: 1
        };
    case Tg:
    case sM:
    case $r:
        return {
            byteLength: 2,
            components: 1
        };
    case oM:
    case lM:
        return {
            byteLength: 2,
            components: 4
        };
    case rc:
    case f_:
    case tr:
        return {
            byteLength: 4,
            components: 1
        };
    case QA:
    case JA:
        return {
            byteLength: 4,
            components: 3
        }
    }
    throw new Error(`Unknown texture type ${r}.`)
}
class JW {
    static contain(e, t) {
        return qW(e, t)
    }
    static cover(e, t) {
        return ZW(e, t)
    }
    static fill(e) {
        return KW(e)
    }
    static getByteLength(e, t, n, i) {
        return yw(e, t, n, i)
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: u_
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = u_);
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
function Sz() {
    let r = null
      , e = !1
      , t = null
      , n = null;
    function i(a, s) {
        t(a, s),
        n = r.requestAnimationFrame(i)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (n = r.requestAnimationFrame(i),
            e = !0)
        },
        stop: function() {
            r.cancelAnimationFrame(n),
            e = !1
        },
        setAnimationLoop: function(a) {
            t = a
        },
        setContext: function(a) {
            r = a
        }
    }
}
function $W(r) {
    const e = new WeakMap;
    function t(l, u) {
        const f = l.array
          , d = l.usage
          , g = f.byteLength
          , v = r.createBuffer();
        r.bindBuffer(u, v),
        r.bufferData(u, f, d),
        l.onUploadCallback();
        let y;
        if (f instanceof Float32Array)
            y = r.FLOAT;
        else if (typeof Float16Array < "u" && f instanceof Float16Array)
            y = r.HALF_FLOAT;
        else if (f instanceof Uint16Array)
            l.isFloat16BufferAttribute ? y = r.HALF_FLOAT : y = r.UNSIGNED_SHORT;
        else if (f instanceof Int16Array)
            y = r.SHORT;
        else if (f instanceof Uint32Array)
            y = r.UNSIGNED_INT;
        else if (f instanceof Int32Array)
            y = r.INT;
        else if (f instanceof Int8Array)
            y = r.BYTE;
        else if (f instanceof Uint8Array)
            y = r.UNSIGNED_BYTE;
        else if (f instanceof Uint8ClampedArray)
            y = r.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + f);
        return {
            buffer: v,
            type: y,
            bytesPerElement: f.BYTES_PER_ELEMENT,
            version: l.version,
            size: g
        }
    }
    function n(l, u, f) {
        const d = u.array
          , g = u.updateRanges;
        if (r.bindBuffer(f, l),
        g.length === 0)
            r.bufferSubData(f, 0, d);
        else {
            g.sort( (y, S) => y.start - S.start);
            let v = 0;
            for (let y = 1; y < g.length; y++) {
                const S = g[v]
                  , T = g[y];
                T.start <= S.start + S.count + 1 ? S.count = Math.max(S.count, T.start + T.count - S.start) : (++v,
                g[v] = T)
            }
            g.length = v + 1;
            for (let y = 0, S = g.length; y < S; y++) {
                const T = g[y];
                r.bufferSubData(f, T.start * d.BYTES_PER_ELEMENT, d, T.start, T.count)
            }
            u.clearUpdateRanges()
        }
        u.onUploadCallback()
    }
    function i(l) {
        return l.isInterleavedBufferAttribute && (l = l.data),
        e.get(l)
    }
    function a(l) {
        l.isInterleavedBufferAttribute && (l = l.data);
        const u = e.get(l);
        u && (r.deleteBuffer(u.buffer),
        e.delete(l))
    }
    function s(l, u) {
        if (l.isInterleavedBufferAttribute && (l = l.data),
        l.isGLBufferAttribute) {
            const d = e.get(l);
            (!d || d.version < l.version) && e.set(l, {
                buffer: l.buffer,
                type: l.type,
                bytesPerElement: l.elementSize,
                version: l.version
            });
            return
        }
        const f = e.get(l);
        if (f === void 0)
            e.set(l, t(l, u));
        else if (f.version < l.version) {
            if (f.size !== l.array.byteLength)
                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            n(f.buffer, l, u),
            f.version = l.version
        }
    }
    return {
        get: i,
        remove: a,
        update: s
    }
}
var eY = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`
  , tY = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`
  , nY = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`
  , iY = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , rY = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`
  , aY = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , sY = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , oY = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , lY = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`
  , uY = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`
  , cY = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`
  , fY = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , hY = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`
  , dY = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , pY = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , mY = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`
  , gY = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , vY = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , yY = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , _Y = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , xY = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , SY = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`
  , bY = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`
  , MY = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`
  , TY = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , EY = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , wY = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , AY = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`
  , CY = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , RY = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , DY = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , UY = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
  , OY = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , NY = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , LY = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , PY = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , BY = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , zY = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , IY = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , FY = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , HY = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , VY = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , kY = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , GY = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , XY = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , jY = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , WY = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`
  , YY = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , qY = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , ZY = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , KY = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , QY = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`
  , JY = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , $Y = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , eq = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , tq = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`
  , nq = `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , iq = `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , rq = `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , aq = `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`
  , sq = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , oq = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , lq = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , uq = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , cq = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , fq = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , hq = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`
  , dq = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , pq = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , mq = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`
  , gq = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , vq = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`
  , yq = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , _q = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , xq = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , Sq = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , bq = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`
  , Mq = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`
  , Tq = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`
  , Eq = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`
  , wq = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , Aq = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , Cq = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`
  , Rq = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , Dq = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , Uq = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , Oq = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , Nq = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , Lq = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , Pq = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		float depth = unpackRGBAToDepth( texture2D( depths, uv ) );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			return step( depth, compare );
		#else
			return step( compare, depth );
		#endif
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow( sampler2D shadow, vec2 uv, float compare ) {
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			float hard_shadow = step( distribution.x, compare );
		#else
			float hard_shadow = step( compare, distribution.x );
		#endif
		if ( hard_shadow != 1.0 ) {
			float distance = compare - distribution.x;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`
  , Bq = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , zq = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , Iq = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , Fq = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , Hq = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`
  , Vq = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , kq = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , Gq = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , Xq = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , jq = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , Wq = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , Yq = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`
  , qq = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`
  , Zq = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , Kq = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , Qq = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`
  , Jq = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const $q = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , eZ = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , tZ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , nZ = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , iZ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , rZ = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , aZ = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , sZ = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSED_DEPTH_BUFFER
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`
  , oZ = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , lZ = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , uZ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , cZ = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , fZ = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , hZ = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , dZ = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , pZ = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , mZ = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , gZ = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vZ = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , yZ = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , _Z = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , xZ = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , SZ = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , bZ = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , MZ = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , TZ = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , EZ = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , wZ = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , AZ = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , CZ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , RZ = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , DZ = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , UZ = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , OZ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , Un = {
    alphahash_fragment: eY,
    alphahash_pars_fragment: tY,
    alphamap_fragment: nY,
    alphamap_pars_fragment: iY,
    alphatest_fragment: rY,
    alphatest_pars_fragment: aY,
    aomap_fragment: sY,
    aomap_pars_fragment: oY,
    batching_pars_vertex: lY,
    batching_vertex: uY,
    begin_vertex: cY,
    beginnormal_vertex: fY,
    bsdfs: hY,
    iridescence_fragment: dY,
    bumpmap_pars_fragment: pY,
    clipping_planes_fragment: mY,
    clipping_planes_pars_fragment: gY,
    clipping_planes_pars_vertex: vY,
    clipping_planes_vertex: yY,
    color_fragment: _Y,
    color_pars_fragment: xY,
    color_pars_vertex: SY,
    color_vertex: bY,
    common: MY,
    cube_uv_reflection_fragment: TY,
    defaultnormal_vertex: EY,
    displacementmap_pars_vertex: wY,
    displacementmap_vertex: AY,
    emissivemap_fragment: CY,
    emissivemap_pars_fragment: RY,
    colorspace_fragment: DY,
    colorspace_pars_fragment: UY,
    envmap_fragment: OY,
    envmap_common_pars_fragment: NY,
    envmap_pars_fragment: LY,
    envmap_pars_vertex: PY,
    envmap_physical_pars_fragment: WY,
    envmap_vertex: BY,
    fog_vertex: zY,
    fog_pars_vertex: IY,
    fog_fragment: FY,
    fog_pars_fragment: HY,
    gradientmap_pars_fragment: VY,
    lightmap_pars_fragment: kY,
    lights_lambert_fragment: GY,
    lights_lambert_pars_fragment: XY,
    lights_pars_begin: jY,
    lights_toon_fragment: YY,
    lights_toon_pars_fragment: qY,
    lights_phong_fragment: ZY,
    lights_phong_pars_fragment: KY,
    lights_physical_fragment: QY,
    lights_physical_pars_fragment: JY,
    lights_fragment_begin: $Y,
    lights_fragment_maps: eq,
    lights_fragment_end: tq,
    logdepthbuf_fragment: nq,
    logdepthbuf_pars_fragment: iq,
    logdepthbuf_pars_vertex: rq,
    logdepthbuf_vertex: aq,
    map_fragment: sq,
    map_pars_fragment: oq,
    map_particle_fragment: lq,
    map_particle_pars_fragment: uq,
    metalnessmap_fragment: cq,
    metalnessmap_pars_fragment: fq,
    morphinstance_vertex: hq,
    morphcolor_vertex: dq,
    morphnormal_vertex: pq,
    morphtarget_pars_vertex: mq,
    morphtarget_vertex: gq,
    normal_fragment_begin: vq,
    normal_fragment_maps: yq,
    normal_pars_fragment: _q,
    normal_pars_vertex: xq,
    normal_vertex: Sq,
    normalmap_pars_fragment: bq,
    clearcoat_normal_fragment_begin: Mq,
    clearcoat_normal_fragment_maps: Tq,
    clearcoat_pars_fragment: Eq,
    iridescence_pars_fragment: wq,
    opaque_fragment: Aq,
    packing: Cq,
    premultiplied_alpha_fragment: Rq,
    project_vertex: Dq,
    dithering_fragment: Uq,
    dithering_pars_fragment: Oq,
    roughnessmap_fragment: Nq,
    roughnessmap_pars_fragment: Lq,
    shadowmap_pars_fragment: Pq,
    shadowmap_pars_vertex: Bq,
    shadowmap_vertex: zq,
    shadowmask_pars_fragment: Iq,
    skinbase_vertex: Fq,
    skinning_pars_vertex: Hq,
    skinning_vertex: Vq,
    skinnormal_vertex: kq,
    specularmap_fragment: Gq,
    specularmap_pars_fragment: Xq,
    tonemapping_fragment: jq,
    tonemapping_pars_fragment: Wq,
    transmission_fragment: Yq,
    transmission_pars_fragment: qq,
    uv_pars_fragment: Zq,
    uv_pars_vertex: Kq,
    uv_vertex: Qq,
    worldpos_vertex: Jq,
    background_vert: $q,
    background_frag: eZ,
    backgroundCube_vert: tZ,
    backgroundCube_frag: nZ,
    cube_vert: iZ,
    cube_frag: rZ,
    depth_vert: aZ,
    depth_frag: sZ,
    distanceRGBA_vert: oZ,
    distanceRGBA_frag: lZ,
    equirect_vert: uZ,
    equirect_frag: cZ,
    linedashed_vert: fZ,
    linedashed_frag: hZ,
    meshbasic_vert: dZ,
    meshbasic_frag: pZ,
    meshlambert_vert: mZ,
    meshlambert_frag: gZ,
    meshmatcap_vert: vZ,
    meshmatcap_frag: yZ,
    meshnormal_vert: _Z,
    meshnormal_frag: xZ,
    meshphong_vert: SZ,
    meshphong_frag: bZ,
    meshphysical_vert: MZ,
    meshphysical_frag: TZ,
    meshtoon_vert: EZ,
    meshtoon_frag: wZ,
    points_vert: AZ,
    points_frag: CZ,
    shadow_vert: RZ,
    shadow_frag: DZ,
    sprite_vert: UZ,
    sprite_frag: OZ
}
  , Ht = {
    common: {
        diffuse: {
            value: new kt(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new An
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new An
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        },
        specularMapTransform: {
            value: new An
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        envMapRotation: {
            value: new An
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        },
        aoMapTransform: {
            value: new An
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        },
        lightMapTransform: {
            value: new An
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpMapTransform: {
            value: new An
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalMapTransform: {
            value: new An
        },
        normalScale: {
            value: new xt(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementMapTransform: {
            value: new An
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        },
        emissiveMapTransform: {
            value: new An
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        },
        metalnessMapTransform: {
            value: new An
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        },
        roughnessMapTransform: {
            value: new An
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new kt(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new kt(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new An
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new An
        }
    },
    sprite: {
        diffuse: {
            value: new kt(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new xt(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new An
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new An
        },
        alphaTest: {
            value: 0
        }
    }
}
  , Yl = {
    basic: {
        uniforms: ls([Ht.common, Ht.specularmap, Ht.envmap, Ht.aomap, Ht.lightmap, Ht.fog]),
        vertexShader: Un.meshbasic_vert,
        fragmentShader: Un.meshbasic_frag
    },
    lambert: {
        uniforms: ls([Ht.common, Ht.specularmap, Ht.envmap, Ht.aomap, Ht.lightmap, Ht.emissivemap, Ht.bumpmap, Ht.normalmap, Ht.displacementmap, Ht.fog, Ht.lights, {
            emissive: {
                value: new kt(0)
            }
        }]),
        vertexShader: Un.meshlambert_vert,
        fragmentShader: Un.meshlambert_frag
    },
    phong: {
        uniforms: ls([Ht.common, Ht.specularmap, Ht.envmap, Ht.aomap, Ht.lightmap, Ht.emissivemap, Ht.bumpmap, Ht.normalmap, Ht.displacementmap, Ht.fog, Ht.lights, {
            emissive: {
                value: new kt(0)
            },
            specular: {
                value: new kt(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: Un.meshphong_vert,
        fragmentShader: Un.meshphong_frag
    },
    standard: {
        uniforms: ls([Ht.common, Ht.envmap, Ht.aomap, Ht.lightmap, Ht.emissivemap, Ht.bumpmap, Ht.normalmap, Ht.displacementmap, Ht.roughnessmap, Ht.metalnessmap, Ht.fog, Ht.lights, {
            emissive: {
                value: new kt(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: Un.meshphysical_vert,
        fragmentShader: Un.meshphysical_frag
    },
    toon: {
        uniforms: ls([Ht.common, Ht.aomap, Ht.lightmap, Ht.emissivemap, Ht.bumpmap, Ht.normalmap, Ht.displacementmap, Ht.gradientmap, Ht.fog, Ht.lights, {
            emissive: {
                value: new kt(0)
            }
        }]),
        vertexShader: Un.meshtoon_vert,
        fragmentShader: Un.meshtoon_frag
    },
    matcap: {
        uniforms: ls([Ht.common, Ht.bumpmap, Ht.normalmap, Ht.displacementmap, Ht.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: Un.meshmatcap_vert,
        fragmentShader: Un.meshmatcap_frag
    },
    points: {
        uniforms: ls([Ht.points, Ht.fog]),
        vertexShader: Un.points_vert,
        fragmentShader: Un.points_frag
    },
    dashed: {
        uniforms: ls([Ht.common, Ht.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: Un.linedashed_vert,
        fragmentShader: Un.linedashed_frag
    },
    depth: {
        uniforms: ls([Ht.common, Ht.displacementmap]),
        vertexShader: Un.depth_vert,
        fragmentShader: Un.depth_frag
    },
    normal: {
        uniforms: ls([Ht.common, Ht.bumpmap, Ht.normalmap, Ht.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: Un.meshnormal_vert,
        fragmentShader: Un.meshnormal_frag
    },
    sprite: {
        uniforms: ls([Ht.sprite, Ht.fog]),
        vertexShader: Un.sprite_vert,
        fragmentShader: Un.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new An
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: Un.background_vert,
        fragmentShader: Un.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            },
            backgroundRotation: {
                value: new An
            }
        },
        vertexShader: Un.backgroundCube_vert,
        fragmentShader: Un.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: Un.cube_vert,
        fragmentShader: Un.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: Un.equirect_vert,
        fragmentShader: Un.equirect_frag
    },
    distanceRGBA: {
        uniforms: ls([Ht.common, Ht.displacementmap, {
            referencePosition: {
                value: new he
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: Un.distanceRGBA_vert,
        fragmentShader: Un.distanceRGBA_frag
    },
    shadow: {
        uniforms: ls([Ht.lights, Ht.fog, {
            color: {
                value: new kt(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: Un.shadow_vert,
        fragmentShader: Un.shadow_frag
    }
};
Yl.physical = {
    uniforms: ls([Yl.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new An
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new An
        },
        clearcoatNormalScale: {
            value: new xt(1,1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new An
        },
        dispersion: {
            value: 0
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new An
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new An
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new kt(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new An
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new An
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new An
        },
        transmissionSamplerSize: {
            value: new xt
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new An
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new kt(0)
        },
        specularColor: {
            value: new kt(1,1,1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new An
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new An
        },
        anisotropyVector: {
            value: new xt
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new An
        }
    }]),
    vertexShader: Un.meshphysical_vert,
    fragmentShader: Un.meshphysical_frag
};
const Hx = {
    r: 0,
    b: 0,
    g: 0
}
  , Dd = new Co
  , NZ = new vn;
function LZ(r, e, t, n, i, a, s) {
    const l = new kt(0);
    let u = a === !0 ? 0 : 1, f, d, g = null, v = 0, y = null;
    function S(C) {
        let R = C.isScene === !0 ? C.background : null;
        return R && R.isTexture && (R = (C.backgroundBlurriness > 0 ? t : e).get(R)),
        R
    }
    function T(C) {
        let R = !1;
        const O = S(C);
        O === null ? b(l, u) : O && O.isColor && (b(O, 1),
        R = !0);
        const L = r.xr.getEnvironmentBlendMode();
        L === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, s) : L === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, s),
        (r.autoClear || R) && (n.buffers.depth.setTest(!0),
        n.buffers.depth.setMask(!0),
        n.buffers.color.setMask(!0),
        r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil))
    }
    function M(C, R) {
        const O = S(R);
        O && (O.isCubeTexture || O.mapping === Xg) ? (d === void 0 && (d = new Ni(new yp(1,1,1),new Ks({
            name: "BackgroundCubeMaterial",
            uniforms: Ug(Yl.backgroundCube.uniforms),
            vertexShader: Yl.backgroundCube.vertexShader,
            fragmentShader: Yl.backgroundCube.fragmentShader,
            side: vs,
            depthTest: !1,
            depthWrite: !1,
            fog: !1,
            allowOverride: !1
        })),
        d.geometry.deleteAttribute("normal"),
        d.geometry.deleteAttribute("uv"),
        d.onBeforeRender = function(L, z, I) {
            this.matrixWorld.copyPosition(I.matrixWorld)
        }
        ,
        Object.defineProperty(d.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        i.update(d)),
        Dd.copy(R.backgroundRotation),
        Dd.x *= -1,
        Dd.y *= -1,
        Dd.z *= -1,
        O.isCubeTexture && O.isRenderTargetTexture === !1 && (Dd.y *= -1,
        Dd.z *= -1),
        d.material.uniforms.envMap.value = O,
        d.material.uniforms.flipEnvMap.value = O.isCubeTexture && O.isRenderTargetTexture === !1 ? -1 : 1,
        d.material.uniforms.backgroundBlurriness.value = R.backgroundBlurriness,
        d.material.uniforms.backgroundIntensity.value = R.backgroundIntensity,
        d.material.uniforms.backgroundRotation.value.setFromMatrix4(NZ.makeRotationFromEuler(Dd)),
        d.material.toneMapped = Kn.getTransfer(O.colorSpace) !== yi,
        (g !== O || v !== O.version || y !== r.toneMapping) && (d.material.needsUpdate = !0,
        g = O,
        v = O.version,
        y = r.toneMapping),
        d.layers.enableAll(),
        C.unshift(d, d.geometry, d.material, 0, 0, null)) : O && O.isTexture && (f === void 0 && (f = new Ni(new eu(2,2),new Ks({
            name: "BackgroundMaterial",
            uniforms: Ug(Yl.background.uniforms),
            vertexShader: Yl.background.vertexShader,
            fragmentShader: Yl.background.fragmentShader,
            side: tf,
            depthTest: !1,
            depthWrite: !1,
            fog: !1,
            allowOverride: !1
        })),
        f.geometry.deleteAttribute("normal"),
        Object.defineProperty(f.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        i.update(f)),
        f.material.uniforms.t2D.value = O,
        f.material.uniforms.backgroundIntensity.value = R.backgroundIntensity,
        f.material.toneMapped = Kn.getTransfer(O.colorSpace) !== yi,
        O.matrixAutoUpdate === !0 && O.updateMatrix(),
        f.material.uniforms.uvTransform.value.copy(O.matrix),
        (g !== O || v !== O.version || y !== r.toneMapping) && (f.material.needsUpdate = !0,
        g = O,
        v = O.version,
        y = r.toneMapping),
        f.layers.enableAll(),
        C.unshift(f, f.geometry, f.material, 0, 0, null))
    }
    function b(C, R) {
        C.getRGB(Hx, MB(r)),
        n.buffers.color.setClear(Hx.r, Hx.g, Hx.b, R, s)
    }
    function A() {
        d !== void 0 && (d.geometry.dispose(),
        d.material.dispose(),
        d = void 0),
        f !== void 0 && (f.geometry.dispose(),
        f.material.dispose(),
        f = void 0)
    }
    return {
        getClearColor: function() {
            return l
        },
        setClearColor: function(C, R=1) {
            l.set(C),
            u = R,
            b(l, u)
        },
        getClearAlpha: function() {
            return u
        },
        setClearAlpha: function(C) {
            u = C,
            b(l, u)
        },
        render: T,
        addToRenderList: M,
        dispose: A
    }
}
function PZ(r, e) {
    const t = r.getParameter(r.MAX_VERTEX_ATTRIBS)
      , n = {}
      , i = v(null);
    let a = i
      , s = !1;
    function l(P, Y, V, K, Z) {
        let oe = !1;
        const H = g(K, V, Y);
        a !== H && (a = H,
        f(a.object)),
        oe = y(P, K, V, Z),
        oe && S(P, K, V, Z),
        Z !== null && e.update(Z, r.ELEMENT_ARRAY_BUFFER),
        (oe || s) && (s = !1,
        R(P, Y, V, K),
        Z !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e.get(Z).buffer))
    }
    function u() {
        return r.createVertexArray()
    }
    function f(P) {
        return r.bindVertexArray(P)
    }
    function d(P) {
        return r.deleteVertexArray(P)
    }
    function g(P, Y, V) {
        const K = V.wireframe === !0;
        let Z = n[P.id];
        Z === void 0 && (Z = {},
        n[P.id] = Z);
        let oe = Z[Y.id];
        oe === void 0 && (oe = {},
        Z[Y.id] = oe);
        let H = oe[K];
        return H === void 0 && (H = v(u()),
        oe[K] = H),
        H
    }
    function v(P) {
        const Y = []
          , V = []
          , K = [];
        for (let Z = 0; Z < t; Z++)
            Y[Z] = 0,
            V[Z] = 0,
            K[Z] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: Y,
            enabledAttributes: V,
            attributeDivisors: K,
            object: P,
            attributes: {},
            index: null
        }
    }
    function y(P, Y, V, K) {
        const Z = a.attributes
          , oe = Y.attributes;
        let H = 0;
        const q = V.getAttributes();
        for (const Q in q)
            if (q[Q].location >= 0) {
                const B = Z[Q];
                let W = oe[Q];
                if (W === void 0 && (Q === "instanceMatrix" && P.instanceMatrix && (W = P.instanceMatrix),
                Q === "instanceColor" && P.instanceColor && (W = P.instanceColor)),
                B === void 0 || B.attribute !== W || W && B.data !== W.data)
                    return !0;
                H++
            }
        return a.attributesNum !== H || a.index !== K
    }
    function S(P, Y, V, K) {
        const Z = {}
          , oe = Y.attributes;
        let H = 0;
        const q = V.getAttributes();
        for (const Q in q)
            if (q[Q].location >= 0) {
                let B = oe[Q];
                B === void 0 && (Q === "instanceMatrix" && P.instanceMatrix && (B = P.instanceMatrix),
                Q === "instanceColor" && P.instanceColor && (B = P.instanceColor));
                const W = {};
                W.attribute = B,
                B && B.data && (W.data = B.data),
                Z[Q] = W,
                H++
            }
        a.attributes = Z,
        a.attributesNum = H,
        a.index = K
    }
    function T() {
        const P = a.newAttributes;
        for (let Y = 0, V = P.length; Y < V; Y++)
            P[Y] = 0
    }
    function M(P) {
        b(P, 0)
    }
    function b(P, Y) {
        const V = a.newAttributes
          , K = a.enabledAttributes
          , Z = a.attributeDivisors;
        V[P] = 1,
        K[P] === 0 && (r.enableVertexAttribArray(P),
        K[P] = 1),
        Z[P] !== Y && (r.vertexAttribDivisor(P, Y),
        Z[P] = Y)
    }
    function A() {
        const P = a.newAttributes
          , Y = a.enabledAttributes;
        for (let V = 0, K = Y.length; V < K; V++)
            Y[V] !== P[V] && (r.disableVertexAttribArray(V),
            Y[V] = 0)
    }
    function C(P, Y, V, K, Z, oe, H) {
        H === !0 ? r.vertexAttribIPointer(P, Y, V, Z, oe) : r.vertexAttribPointer(P, Y, V, K, Z, oe)
    }
    function R(P, Y, V, K) {
        T();
        const Z = K.attributes
          , oe = V.getAttributes()
          , H = Y.defaultAttributeValues;
        for (const q in oe) {
            const Q = oe[q];
            if (Q.location >= 0) {
                let se = Z[q];
                if (se === void 0 && (q === "instanceMatrix" && P.instanceMatrix && (se = P.instanceMatrix),
                q === "instanceColor" && P.instanceColor && (se = P.instanceColor)),
                se !== void 0) {
                    const B = se.normalized
                      , W = se.itemSize
                      , te = e.get(se);
                    if (te === void 0)
                        continue;
                    const fe = te.buffer
                      , pe = te.type
                      , _e = te.bytesPerElement
                      , ue = pe === r.INT || pe === r.UNSIGNED_INT || se.gpuType === f_;
                    if (se.isInterleavedBufferAttribute) {
                        const ge = se.data
                          , Te = ge.stride
                          , Ze = se.offset;
                        if (ge.isInstancedInterleavedBuffer) {
                            for (let ot = 0; ot < Q.locationSize; ot++)
                                b(Q.location + ot, ge.meshPerAttribute);
                            P.isInstancedMesh !== !0 && K._maxInstanceCount === void 0 && (K._maxInstanceCount = ge.meshPerAttribute * ge.count)
                        } else
                            for (let ot = 0; ot < Q.locationSize; ot++)
                                M(Q.location + ot);
                        r.bindBuffer(r.ARRAY_BUFFER, fe);
                        for (let ot = 0; ot < Q.locationSize; ot++)
                            C(Q.location + ot, W / Q.locationSize, pe, B, Te * _e, (Ze + W / Q.locationSize * ot) * _e, ue)
                    } else {
                        if (se.isInstancedBufferAttribute) {
                            for (let ge = 0; ge < Q.locationSize; ge++)
                                b(Q.location + ge, se.meshPerAttribute);
                            P.isInstancedMesh !== !0 && K._maxInstanceCount === void 0 && (K._maxInstanceCount = se.meshPerAttribute * se.count)
                        } else
                            for (let ge = 0; ge < Q.locationSize; ge++)
                                M(Q.location + ge);
                        r.bindBuffer(r.ARRAY_BUFFER, fe);
                        for (let ge = 0; ge < Q.locationSize; ge++)
                            C(Q.location + ge, W / Q.locationSize, pe, B, W * _e, W / Q.locationSize * ge * _e, ue)
                    }
                } else if (H !== void 0) {
                    const B = H[q];
                    if (B !== void 0)
                        switch (B.length) {
                        case 2:
                            r.vertexAttrib2fv(Q.location, B);
                            break;
                        case 3:
                            r.vertexAttrib3fv(Q.location, B);
                            break;
                        case 4:
                            r.vertexAttrib4fv(Q.location, B);
                            break;
                        default:
                            r.vertexAttrib1fv(Q.location, B)
                        }
                }
            }
        }
        A()
    }
    function O() {
        I();
        for (const P in n) {
            const Y = n[P];
            for (const V in Y) {
                const K = Y[V];
                for (const Z in K)
                    d(K[Z].object),
                    delete K[Z];
                delete Y[V]
            }
            delete n[P]
        }
    }
    function L(P) {
        if (n[P.id] === void 0)
            return;
        const Y = n[P.id];
        for (const V in Y) {
            const K = Y[V];
            for (const Z in K)
                d(K[Z].object),
                delete K[Z];
            delete Y[V]
        }
        delete n[P.id]
    }
    function z(P) {
        for (const Y in n) {
            const V = n[Y];
            if (V[P.id] === void 0)
                continue;
            const K = V[P.id];
            for (const Z in K)
                d(K[Z].object),
                delete K[Z];
            delete V[P.id]
        }
    }
    function I() {
        N(),
        s = !0,
        a !== i && (a = i,
        f(a.object))
    }
    function N() {
        i.geometry = null,
        i.program = null,
        i.wireframe = !1
    }
    return {
        setup: l,
        reset: I,
        resetDefaultState: N,
        dispose: O,
        releaseStatesOfGeometry: L,
        releaseStatesOfProgram: z,
        initAttributes: T,
        enableAttribute: M,
        disableUnusedAttributes: A
    }
}
function BZ(r, e, t) {
    let n;
    function i(f) {
        n = f
    }
    function a(f, d) {
        r.drawArrays(n, f, d),
        t.update(d, n, 1)
    }
    function s(f, d, g) {
        g !== 0 && (r.drawArraysInstanced(n, f, d, g),
        t.update(d, n, g))
    }
    function l(f, d, g) {
        if (g === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, f, 0, d, 0, g);
        let y = 0;
        for (let S = 0; S < g; S++)
            y += d[S];
        t.update(y, n, 1)
    }
    function u(f, d, g, v) {
        if (g === 0)
            return;
        const y = e.get("WEBGL_multi_draw");
        if (y === null)
            for (let S = 0; S < f.length; S++)
                s(f[S], d[S], v[S]);
        else {
            y.multiDrawArraysInstancedWEBGL(n, f, 0, d, 0, v, 0, g);
            let S = 0;
            for (let T = 0; T < g; T++)
                S += d[T] * v[T];
            t.update(S, n, 1)
        }
    }
    this.setMode = i,
    this.render = a,
    this.renderInstances = s,
    this.renderMultiDraw = l,
    this.renderMultiDrawInstances = u
}
function zZ(r, e, t, n) {
    let i;
    function a() {
        if (i !== void 0)
            return i;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const z = e.get("EXT_texture_filter_anisotropic");
            i = r.getParameter(z.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            i = 0;
        return i
    }
    function s(z) {
        return !(z !== vr && n.convert(z) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT))
    }
    function l(z) {
        const I = z === $r && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
        return !(z !== ys && n.convert(z) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) && z !== tr && !I)
    }
    function u(z) {
        if (z === "highp") {
            if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0)
                return "highp";
            z = "mediump"
        }
        return z === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    let f = t.precision !== void 0 ? t.precision : "highp";
    const d = u(f);
    d !== f && (console.warn("THREE.WebGLRenderer:", f, "not supported, using", d, "instead."),
    f = d);
    const g = t.logarithmicDepthBuffer === !0
      , v = t.reversedDepthBuffer === !0 && e.has("EXT_clip_control")
      , y = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS)
      , S = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , T = r.getParameter(r.MAX_TEXTURE_SIZE)
      , M = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE)
      , b = r.getParameter(r.MAX_VERTEX_ATTRIBS)
      , A = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS)
      , C = r.getParameter(r.MAX_VARYING_VECTORS)
      , R = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS)
      , O = S > 0
      , L = r.getParameter(r.MAX_SAMPLES);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: a,
        getMaxPrecision: u,
        textureFormatReadable: s,
        textureTypeReadable: l,
        precision: f,
        logarithmicDepthBuffer: g,
        reversedDepthBuffer: v,
        maxTextures: y,
        maxVertexTextures: S,
        maxTextureSize: T,
        maxCubemapSize: M,
        maxAttributes: b,
        maxVertexUniforms: A,
        maxVaryings: C,
        maxFragmentUniforms: R,
        vertexTextures: O,
        maxSamples: L
    }
}
function IZ(r) {
    const e = this;
    let t = null
      , n = 0
      , i = !1
      , a = !1;
    const s = new nh
      , l = new An
      , u = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = u,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(g, v) {
        const y = g.length !== 0 || v || n !== 0 || i;
        return i = v,
        n = g.length,
        y
    }
    ,
    this.beginShadows = function() {
        a = !0,
        d(null)
    }
    ,
    this.endShadows = function() {
        a = !1
    }
    ,
    this.setGlobalState = function(g, v) {
        t = d(g, v, 0)
    }
    ,
    this.setState = function(g, v, y) {
        const S = g.clippingPlanes
          , T = g.clipIntersection
          , M = g.clipShadows
          , b = r.get(g);
        if (!i || S === null || S.length === 0 || a && !M)
            a ? d(null) : f();
        else {
            const A = a ? 0 : n
              , C = A * 4;
            let R = b.clippingState || null;
            u.value = R,
            R = d(S, v, C, y);
            for (let O = 0; O !== C; ++O)
                R[O] = t[O];
            b.clippingState = R,
            this.numIntersection = T ? this.numPlanes : 0,
            this.numPlanes += A
        }
    }
    ;
    function f() {
        u.value !== t && (u.value = t,
        u.needsUpdate = n > 0),
        e.numPlanes = n,
        e.numIntersection = 0
    }
    function d(g, v, y, S) {
        const T = g !== null ? g.length : 0;
        let M = null;
        if (T !== 0) {
            if (M = u.value,
            S !== !0 || M === null) {
                const b = y + T * 4
                  , A = v.matrixWorldInverse;
                l.getNormalMatrix(A),
                (M === null || M.length < b) && (M = new Float32Array(b));
                for (let C = 0, R = y; C !== T; ++C,
                R += 4)
                    s.copy(g[C]).applyMatrix4(A, l),
                    s.normal.toArray(M, R),
                    M[R + 3] = s.constant
            }
            u.value = M,
            u.needsUpdate = !0
        }
        return e.numPlanes = T,
        e.numIntersection = 0,
        M
    }
}
function FZ(r) {
    let e = new WeakMap;
    function t(s, l) {
        return l === Mg ? s.mapping = ic : l === Py && (s.mapping = _h),
        s
    }
    function n(s) {
        if (s && s.isTexture) {
            const l = s.mapping;
            if (l === Mg || l === Py)
                if (e.has(s)) {
                    const u = e.get(s).texture;
                    return t(u, s.mapping)
                } else {
                    const u = s.image;
                    if (u && u.height > 0) {
                        const f = new cC(u.height);
                        return f.fromEquirectangularTexture(r, s),
                        e.set(s, f),
                        s.addEventListener("dispose", i),
                        t(f.texture, s.mapping)
                    } else
                        return null
                }
        }
        return s
    }
    function i(s) {
        const l = s.target;
        l.removeEventListener("dispose", i);
        const u = e.get(l);
        u !== void 0 && (e.delete(l),
        u.dispose())
    }
    function a() {
        e = new WeakMap
    }
    return {
        get: n,
        dispose: a
    }
}
const rg = 4
  , iO = [.125, .215, .35, .446, .526, .582]
  , Fd = 20
  , zT = new Yg
  , rO = new kt;
let IT = null
  , FT = 0
  , HT = 0
  , VT = !1;
const Bd = (1 + Math.sqrt(5)) / 2
  , Im = 1 / Bd
  , aO = [new he(-Bd,Im,0), new he(Bd,Im,0), new he(-Im,0,Bd), new he(Im,0,Bd), new he(0,Bd,-Im), new he(0,Bd,Im), new he(-1,1,-1), new he(1,1,-1), new he(-1,1,1), new he(1,1,1)]
  , HZ = new he;
class _w {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, n=.1, i=100, a={}) {
        const {size: s=256, position: l=HZ} = a;
        IT = this._renderer.getRenderTarget(),
        FT = this._renderer.getActiveCubeFace(),
        HT = this._renderer.getActiveMipmapLevel(),
        VT = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1,
        this._setSize(s);
        const u = this._allocateTargets();
        return u.depthBuffer = !0,
        this._sceneToCubeUV(e, n, i, u, l),
        t > 0 && this._blur(u, 0, 0, t),
        this._applyPMREM(u),
        this._cleanup(u),
        u
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = lO(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = oO(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(IT, FT, HT),
        this._renderer.xr.enabled = VT,
        e.scissorTest = !1,
        Vx(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === ic || e.mapping === _h ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        IT = this._renderer.getRenderTarget(),
        FT = this._renderer.getActiveCubeFace(),
        HT = this._renderer.getActiveMipmapLevel(),
        VT = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1;
        const n = t || this._allocateTargets();
        return this._textureToCubeUV(e, n),
        this._applyPMREM(n),
        this._cleanup(n),
        n
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , n = {
            magFilter: fi,
            minFilter: fi,
            generateMipmaps: !1,
            type: $r,
            format: vr,
            colorSpace: Jl,
            depthBuffer: !1
        }
          , i = sO(e, t, n);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = sO(e, t, n);
            const {_lodMax: a} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = VZ(a)),
            this._blurMaterial = kZ(a, e, t)
        }
        return i
    }
    _compileMaterial(e) {
        const t = new Ni(this._lodPlanes[0],e);
        this._renderer.compile(t, zT)
    }
    _sceneToCubeUV(e, t, n, i, a) {
        const u = new Jr(90,1,t,n)
          , f = [1, -1, 1, 1, 1, 1]
          , d = [1, 1, 1, -1, -1, -1]
          , g = this._renderer
          , v = g.autoClear
          , y = g.toneMapping;
        g.getClearColor(rO),
        g.toneMapping = Ju,
        g.autoClear = !1,
        g.state.buffers.depth.getReversed() && (g.setRenderTarget(i),
        g.clearDepth(),
        g.setRenderTarget(null));
        const T = new oc({
            name: "PMREM.Background",
            side: vs,
            depthWrite: !1,
            depthTest: !1
        })
          , M = new Ni(new yp,T);
        let b = !1;
        const A = e.background;
        A ? A.isColor && (T.color.copy(A),
        e.background = null,
        b = !0) : (T.color.copy(rO),
        b = !0);
        for (let C = 0; C < 6; C++) {
            const R = C % 3;
            R === 0 ? (u.up.set(0, f[C], 0),
            u.position.set(a.x, a.y, a.z),
            u.lookAt(a.x + d[C], a.y, a.z)) : R === 1 ? (u.up.set(0, 0, f[C]),
            u.position.set(a.x, a.y, a.z),
            u.lookAt(a.x, a.y + d[C], a.z)) : (u.up.set(0, f[C], 0),
            u.position.set(a.x, a.y, a.z),
            u.lookAt(a.x, a.y, a.z + d[C]));
            const O = this._cubeSize;
            Vx(i, R * O, C > 2 ? O : 0, O, O),
            g.setRenderTarget(i),
            b && g.render(M, u),
            g.render(e, u)
        }
        M.geometry.dispose(),
        M.material.dispose(),
        g.toneMapping = y,
        g.autoClear = v,
        e.background = A
    }
    _textureToCubeUV(e, t) {
        const n = this._renderer
          , i = e.mapping === ic || e.mapping === _h;
        i ? (this._cubemapMaterial === null && (this._cubemapMaterial = lO()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = oO());
        const a = i ? this._cubemapMaterial : this._equirectMaterial
          , s = new Ni(this._lodPlanes[0],a)
          , l = a.uniforms;
        l.envMap.value = e;
        const u = this._cubeSize;
        Vx(t, 0, 0, 3 * u, 2 * u),
        n.setRenderTarget(t),
        n.render(s, zT)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , n = t.autoClear;
        t.autoClear = !1;
        const i = this._lodPlanes.length;
        for (let a = 1; a < i; a++) {
            const s = Math.sqrt(this._sigmas[a] * this._sigmas[a] - this._sigmas[a - 1] * this._sigmas[a - 1])
              , l = aO[(i - a - 1) % aO.length];
            this._blur(e, a - 1, a, s, l)
        }
        t.autoClear = n
    }
    _blur(e, t, n, i, a) {
        const s = this._pingPongRenderTarget;
        this._halfBlur(e, s, t, n, i, "latitudinal", a),
        this._halfBlur(s, e, n, n, i, "longitudinal", a)
    }
    _halfBlur(e, t, n, i, a, s, l) {
        const u = this._renderer
          , f = this._blurMaterial;
        s !== "latitudinal" && s !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const d = 3
          , g = new Ni(this._lodPlanes[i],f)
          , v = f.uniforms
          , y = this._sizeLods[n] - 1
          , S = isFinite(a) ? Math.PI / (2 * y) : 2 * Math.PI / (2 * Fd - 1)
          , T = a / S
          , M = isFinite(a) ? 1 + Math.floor(d * T) : Fd;
        M > Fd && console.warn(`sigmaRadians, ${a}, is too large and will clip, as it requested ${M} samples when the maximum is set to ${Fd}`);
        const b = [];
        let A = 0;
        for (let z = 0; z < Fd; ++z) {
            const I = z / T
              , N = Math.exp(-I * I / 2);
            b.push(N),
            z === 0 ? A += N : z < M && (A += 2 * N)
        }
        for (let z = 0; z < b.length; z++)
            b[z] = b[z] / A;
        v.envMap.value = e.texture,
        v.samples.value = M,
        v.weights.value = b,
        v.latitudinal.value = s === "latitudinal",
        l && (v.poleAxis.value = l);
        const {_lodMax: C} = this;
        v.dTheta.value = S,
        v.mipInt.value = C - n;
        const R = this._sizeLods[i]
          , O = 3 * R * (i > C - rg ? i - C + rg : 0)
          , L = 4 * (this._cubeSize - R);
        Vx(t, O, L, 3 * R, 2 * R),
        u.setRenderTarget(t),
        u.render(g, zT)
    }
}
function VZ(r) {
    const e = []
      , t = []
      , n = [];
    let i = r;
    const a = r - rg + 1 + iO.length;
    for (let s = 0; s < a; s++) {
        const l = Math.pow(2, i);
        t.push(l);
        let u = 1 / l;
        s > r - rg ? u = iO[s - r + rg - 1] : s === 0 && (u = 0),
        n.push(u);
        const f = 1 / (l - 2)
          , d = -f
          , g = 1 + f
          , v = [d, d, g, d, g, g, d, d, g, g, d, g]
          , y = 6
          , S = 6
          , T = 3
          , M = 2
          , b = 1
          , A = new Float32Array(T * S * y)
          , C = new Float32Array(M * S * y)
          , R = new Float32Array(b * S * y);
        for (let L = 0; L < y; L++) {
            const z = L % 3 * 2 / 3 - 1
              , I = L > 2 ? 0 : -1
              , N = [z, I, 0, z + 2 / 3, I, 0, z + 2 / 3, I + 1, 0, z, I, 0, z + 2 / 3, I + 1, 0, z, I + 1, 0];
            A.set(N, T * S * L),
            C.set(v, M * S * L);
            const P = [L, L, L, L, L, L];
            R.set(P, b * S * L)
        }
        const O = new Nn;
        O.setAttribute("position", new xi(A,T)),
        O.setAttribute("uv", new xi(C,M)),
        O.setAttribute("faceIndex", new xi(R,b)),
        e.push(O),
        i > rg && i--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: n
    }
}
function sO(r, e, t) {
    const n = new sl(r,e,t);
    return n.texture.mapping = Xg,
    n.texture.name = "PMREM.cubeUv",
    n.scissorTest = !0,
    n
}
function Vx(r, e, t, n, i) {
    r.viewport.set(e, t, n, i),
    r.scissor.set(e, t, n, i)
}
function kZ(r, e, t) {
    const n = new Float32Array(Fd)
      , i = new he(0,1,0);
    return new Ks({
        name: "SphericalGaussianBlur",
        defines: {
            n: Fd,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${r}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: n
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: i
            }
        },
        vertexShader: BC(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: Qu,
        depthTest: !1,
        depthWrite: !1
    })
}
function oO() {
    return new Ks({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: BC(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: Qu,
        depthTest: !1,
        depthWrite: !1
    })
}
function lO() {
    return new Ks({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: BC(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: Qu,
        depthTest: !1,
        depthWrite: !1
    })
}
function BC() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function GZ(r) {
    let e = new WeakMap
      , t = null;
    function n(l) {
        if (l && l.isTexture) {
            const u = l.mapping
              , f = u === Mg || u === Py
              , d = u === ic || u === _h;
            if (f || d) {
                let g = e.get(l);
                const v = g !== void 0 ? g.texture.pmremVersion : 0;
                if (l.isRenderTargetTexture && l.pmremVersion !== v)
                    return t === null && (t = new _w(r)),
                    g = f ? t.fromEquirectangular(l, g) : t.fromCubemap(l, g),
                    g.texture.pmremVersion = l.pmremVersion,
                    e.set(l, g),
                    g.texture;
                if (g !== void 0)
                    return g.texture;
                {
                    const y = l.image;
                    return f && y && y.height > 0 || d && y && i(y) ? (t === null && (t = new _w(r)),
                    g = f ? t.fromEquirectangular(l) : t.fromCubemap(l),
                    g.texture.pmremVersion = l.pmremVersion,
                    e.set(l, g),
                    l.addEventListener("dispose", a),
                    g.texture) : null
                }
            }
        }
        return l
    }
    function i(l) {
        let u = 0;
        const f = 6;
        for (let d = 0; d < f; d++)
            l[d] !== void 0 && u++;
        return u === f
    }
    function a(l) {
        const u = l.target;
        u.removeEventListener("dispose", a);
        const f = e.get(u);
        f !== void 0 && (e.delete(u),
        f.dispose())
    }
    function s() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: n,
        dispose: s
    }
}
function XZ(r) {
    const e = {};
    function t(n) {
        if (e[n] !== void 0)
            return e[n];
        let i;
        switch (n) {
        case "WEBGL_depth_texture":
            i = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            i = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            i = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            i = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            i = r.getExtension(n)
        }
        return e[n] = i,
        i
    }
    return {
        has: function(n) {
            return t(n) !== null
        },
        init: function() {
            t("EXT_color_buffer_float"),
            t("WEBGL_clip_cull_distance"),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture"),
            t("WEBGL_render_shared_exponent")
        },
        get: function(n) {
            const i = t(n);
            return i === null && Gy("THREE.WebGLRenderer: " + n + " extension not supported."),
            i
        }
    }
}
function jZ(r, e, t, n) {
    const i = {}
      , a = new WeakMap;
    function s(g) {
        const v = g.target;
        v.index !== null && e.remove(v.index);
        for (const S in v.attributes)
            e.remove(v.attributes[S]);
        v.removeEventListener("dispose", s),
        delete i[v.id];
        const y = a.get(v);
        y && (e.remove(y),
        a.delete(v)),
        n.releaseStatesOfGeometry(v),
        v.isInstancedBufferGeometry === !0 && delete v._maxInstanceCount,
        t.memory.geometries--
    }
    function l(g, v) {
        return i[v.id] === !0 || (v.addEventListener("dispose", s),
        i[v.id] = !0,
        t.memory.geometries++),
        v
    }
    function u(g) {
        const v = g.attributes;
        for (const y in v)
            e.update(v[y], r.ARRAY_BUFFER)
    }
    function f(g) {
        const v = []
          , y = g.index
          , S = g.attributes.position;
        let T = 0;
        if (y !== null) {
            const A = y.array;
            T = y.version;
            for (let C = 0, R = A.length; C < R; C += 3) {
                const O = A[C + 0]
                  , L = A[C + 1]
                  , z = A[C + 2];
                v.push(O, L, L, z, z, O)
            }
        } else if (S !== void 0) {
            const A = S.array;
            T = S.version;
            for (let C = 0, R = A.length / 3 - 1; C < R; C += 3) {
                const O = C + 0
                  , L = C + 1
                  , z = C + 2;
                v.push(O, L, L, z, z, O)
            }
        } else
            return;
        const M = new (_B(v) ? lC : oC)(v,1);
        M.version = T;
        const b = a.get(g);
        b && e.remove(b),
        a.set(g, M)
    }
    function d(g) {
        const v = a.get(g);
        if (v) {
            const y = g.index;
            y !== null && v.version < y.version && f(g)
        } else
            f(g);
        return a.get(g)
    }
    return {
        get: l,
        update: u,
        getWireframeAttribute: d
    }
}
function WZ(r, e, t) {
    let n;
    function i(v) {
        n = v
    }
    let a, s;
    function l(v) {
        a = v.type,
        s = v.bytesPerElement
    }
    function u(v, y) {
        r.drawElements(n, y, a, v * s),
        t.update(y, n, 1)
    }
    function f(v, y, S) {
        S !== 0 && (r.drawElementsInstanced(n, y, a, v * s, S),
        t.update(y, n, S))
    }
    function d(v, y, S) {
        if (S === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, y, 0, a, v, 0, S);
        let M = 0;
        for (let b = 0; b < S; b++)
            M += y[b];
        t.update(M, n, 1)
    }
    function g(v, y, S, T) {
        if (S === 0)
            return;
        const M = e.get("WEBGL_multi_draw");
        if (M === null)
            for (let b = 0; b < v.length; b++)
                f(v[b] / s, y[b], T[b]);
        else {
            M.multiDrawElementsInstancedWEBGL(n, y, 0, a, v, 0, T, 0, S);
            let b = 0;
            for (let A = 0; A < S; A++)
                b += y[A] * T[A];
            t.update(b, n, 1)
        }
    }
    this.setMode = i,
    this.setIndex = l,
    this.render = u,
    this.renderInstances = f,
    this.renderMultiDraw = d,
    this.renderMultiDrawInstances = g
}
function YZ(r) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function n(a, s, l) {
        switch (t.calls++,
        s) {
        case r.TRIANGLES:
            t.triangles += l * (a / 3);
            break;
        case r.LINES:
            t.lines += l * (a / 2);
            break;
        case r.LINE_STRIP:
            t.lines += l * (a - 1);
            break;
        case r.LINE_LOOP:
            t.lines += l * a;
            break;
        case r.POINTS:
            t.points += l * a;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", s);
            break
        }
    }
    function i() {
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: i,
        update: n
    }
}
function qZ(r, e, t) {
    const n = new WeakMap
      , i = new Qn;
    function a(s, l, u) {
        const f = s.morphTargetInfluences
          , d = l.morphAttributes.position || l.morphAttributes.normal || l.morphAttributes.color
          , g = d !== void 0 ? d.length : 0;
        let v = n.get(l);
        if (v === void 0 || v.count !== g) {
            let P = function() {
                I.dispose(),
                n.delete(l),
                l.removeEventListener("dispose", P)
            };
            var y = P;
            v !== void 0 && v.texture.dispose();
            const S = l.morphAttributes.position !== void 0
              , T = l.morphAttributes.normal !== void 0
              , M = l.morphAttributes.color !== void 0
              , b = l.morphAttributes.position || []
              , A = l.morphAttributes.normal || []
              , C = l.morphAttributes.color || [];
            let R = 0;
            S === !0 && (R = 1),
            T === !0 && (R = 2),
            M === !0 && (R = 3);
            let O = l.attributes.position.count * R
              , L = 1;
            O > e.maxTextureSize && (L = Math.ceil(O / e.maxTextureSize),
            O = e.maxTextureSize);
            const z = new Float32Array(O * L * 4 * g)
              , I = new hM(z,O,L,g);
            I.type = tr,
            I.needsUpdate = !0;
            const N = R * 4;
            for (let Y = 0; Y < g; Y++) {
                const V = b[Y]
                  , K = A[Y]
                  , Z = C[Y]
                  , oe = O * L * 4 * Y;
                for (let H = 0; H < V.count; H++) {
                    const q = H * N;
                    S === !0 && (i.fromBufferAttribute(V, H),
                    z[oe + q + 0] = i.x,
                    z[oe + q + 1] = i.y,
                    z[oe + q + 2] = i.z,
                    z[oe + q + 3] = 0),
                    T === !0 && (i.fromBufferAttribute(K, H),
                    z[oe + q + 4] = i.x,
                    z[oe + q + 5] = i.y,
                    z[oe + q + 6] = i.z,
                    z[oe + q + 7] = 0),
                    M === !0 && (i.fromBufferAttribute(Z, H),
                    z[oe + q + 8] = i.x,
                    z[oe + q + 9] = i.y,
                    z[oe + q + 10] = i.z,
                    z[oe + q + 11] = Z.itemSize === 4 ? i.w : 1)
                }
            }
            v = {
                count: g,
                texture: I,
                size: new xt(O,L)
            },
            n.set(l, v),
            l.addEventListener("dispose", P)
        }
        if (s.isInstancedMesh === !0 && s.morphTexture !== null)
            u.getUniforms().setValue(r, "morphTexture", s.morphTexture, t);
        else {
            let S = 0;
            for (let M = 0; M < f.length; M++)
                S += f[M];
            const T = l.morphTargetsRelative ? 1 : 1 - S;
            u.getUniforms().setValue(r, "morphTargetBaseInfluence", T),
            u.getUniforms().setValue(r, "morphTargetInfluences", f)
        }
        u.getUniforms().setValue(r, "morphTargetsTexture", v.texture, t),
        u.getUniforms().setValue(r, "morphTargetsTextureSize", v.size)
    }
    return {
        update: a
    }
}
function ZZ(r, e, t, n) {
    let i = new WeakMap;
    function a(u) {
        const f = n.render.frame
          , d = u.geometry
          , g = e.get(u, d);
        if (i.get(g) !== f && (e.update(g),
        i.set(g, f)),
        u.isInstancedMesh && (u.hasEventListener("dispose", l) === !1 && u.addEventListener("dispose", l),
        i.get(u) !== f && (t.update(u.instanceMatrix, r.ARRAY_BUFFER),
        u.instanceColor !== null && t.update(u.instanceColor, r.ARRAY_BUFFER),
        i.set(u, f))),
        u.isSkinnedMesh) {
            const v = u.skeleton;
            i.get(v) !== f && (v.update(),
            i.set(v, f))
        }
        return g
    }
    function s() {
        i = new WeakMap
    }
    function l(u) {
        const f = u.target;
        f.removeEventListener("dispose", l),
        t.remove(f.instanceMatrix),
        f.instanceColor !== null && t.remove(f.instanceColor)
    }
    return {
        update: a,
        dispose: s
    }
}
const bz = new _i
  , uO = new pC(1,1)
  , Mz = new hM
  , Tz = new dM
  , Ez = new p_
  , cO = []
  , fO = []
  , hO = new Float32Array(16)
  , dO = new Float32Array(9)
  , pO = new Float32Array(4);
function qg(r, e, t) {
    const n = r[0];
    if (n <= 0 || n > 0)
        return r;
    const i = e * t;
    let a = cO[i];
    if (a === void 0 && (a = new Float32Array(i),
    cO[i] = a),
    e !== 0) {
        n.toArray(a, 0);
        for (let s = 1, l = 0; s !== e; ++s)
            l += t,
            r[s].toArray(a, l)
    }
    return a
}
function Fr(r, e) {
    if (r.length !== e.length)
        return !1;
    for (let t = 0, n = r.length; t < n; t++)
        if (r[t] !== e[t])
            return !1;
    return !0
}
function Hr(r, e) {
    for (let t = 0, n = e.length; t < n; t++)
        r[t] = e[t]
}
function zM(r, e) {
    let t = fO[e];
    t === void 0 && (t = new Int32Array(e),
    fO[e] = t);
    for (let n = 0; n !== e; ++n)
        t[n] = r.allocateTextureUnit();
    return t
}
function KZ(r, e) {
    const t = this.cache;
    t[0] !== e && (r.uniform1f(this.addr, e),
    t[0] = e)
}
function QZ(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Fr(t, e))
            return;
        r.uniform2fv(this.addr, e),
        Hr(t, e)
    }
}
function JZ(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (Fr(t, e))
            return;
        r.uniform3fv(this.addr, e),
        Hr(t, e)
    }
}
function $Z(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Fr(t, e))
            return;
        r.uniform4fv(this.addr, e),
        Hr(t, e)
    }
}
function eK(r, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (Fr(t, e))
            return;
        r.uniformMatrix2fv(this.addr, !1, e),
        Hr(t, e)
    } else {
        if (Fr(t, n))
            return;
        pO.set(n),
        r.uniformMatrix2fv(this.addr, !1, pO),
        Hr(t, n)
    }
}
function tK(r, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (Fr(t, e))
            return;
        r.uniformMatrix3fv(this.addr, !1, e),
        Hr(t, e)
    } else {
        if (Fr(t, n))
            return;
        dO.set(n),
        r.uniformMatrix3fv(this.addr, !1, dO),
        Hr(t, n)
    }
}
function nK(r, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (Fr(t, e))
            return;
        r.uniformMatrix4fv(this.addr, !1, e),
        Hr(t, e)
    } else {
        if (Fr(t, n))
            return;
        hO.set(n),
        r.uniformMatrix4fv(this.addr, !1, hO),
        Hr(t, n)
    }
}
function iK(r, e) {
    const t = this.cache;
    t[0] !== e && (r.uniform1i(this.addr, e),
    t[0] = e)
}
function rK(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (r.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Fr(t, e))
            return;
        r.uniform2iv(this.addr, e),
        Hr(t, e)
    }
}
function aK(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (Fr(t, e))
            return;
        r.uniform3iv(this.addr, e),
        Hr(t, e)
    }
}
function sK(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Fr(t, e))
            return;
        r.uniform4iv(this.addr, e),
        Hr(t, e)
    }
}
function oK(r, e) {
    const t = this.cache;
    t[0] !== e && (r.uniform1ui(this.addr, e),
    t[0] = e)
}
function lK(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (r.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Fr(t, e))
            return;
        r.uniform2uiv(this.addr, e),
        Hr(t, e)
    }
}
function uK(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (Fr(t, e))
            return;
        r.uniform3uiv(this.addr, e),
        Hr(t, e)
    }
}
function cK(r, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Fr(t, e))
            return;
        r.uniform4uiv(this.addr, e),
        Hr(t, e)
    }
}
function fK(r, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i),
    n[0] = i);
    let a;
    this.type === r.SAMPLER_2D_SHADOW ? (uO.compareFunction = rC,
    a = uO) : a = bz,
    t.setTexture2D(e || a, i)
}
function hK(r, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i),
    n[0] = i),
    t.setTexture3D(e || Tz, i)
}
function dK(r, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i),
    n[0] = i),
    t.setTextureCube(e || Ez, i)
}
function pK(r, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i),
    n[0] = i),
    t.setTexture2DArray(e || Mz, i)
}
function mK(r) {
    switch (r) {
    case 5126:
        return KZ;
    case 35664:
        return QZ;
    case 35665:
        return JZ;
    case 35666:
        return $Z;
    case 35674:
        return eK;
    case 35675:
        return tK;
    case 35676:
        return nK;
    case 5124:
    case 35670:
        return iK;
    case 35667:
    case 35671:
        return rK;
    case 35668:
    case 35672:
        return aK;
    case 35669:
    case 35673:
        return sK;
    case 5125:
        return oK;
    case 36294:
        return lK;
    case 36295:
        return uK;
    case 36296:
        return cK;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return fK;
    case 35679:
    case 36299:
    case 36307:
        return hK;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return dK;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return pK
    }
}
function gK(r, e) {
    r.uniform1fv(this.addr, e)
}
function vK(r, e) {
    const t = qg(e, this.size, 2);
    r.uniform2fv(this.addr, t)
}
function yK(r, e) {
    const t = qg(e, this.size, 3);
    r.uniform3fv(this.addr, t)
}
function _K(r, e) {
    const t = qg(e, this.size, 4);
    r.uniform4fv(this.addr, t)
}
function xK(r, e) {
    const t = qg(e, this.size, 4);
    r.uniformMatrix2fv(this.addr, !1, t)
}
function SK(r, e) {
    const t = qg(e, this.size, 9);
    r.uniformMatrix3fv(this.addr, !1, t)
}
function bK(r, e) {
    const t = qg(e, this.size, 16);
    r.uniformMatrix4fv(this.addr, !1, t)
}
function MK(r, e) {
    r.uniform1iv(this.addr, e)
}
function TK(r, e) {
    r.uniform2iv(this.addr, e)
}
function EK(r, e) {
    r.uniform3iv(this.addr, e)
}
function wK(r, e) {
    r.uniform4iv(this.addr, e)
}
function AK(r, e) {
    r.uniform1uiv(this.addr, e)
}
function CK(r, e) {
    r.uniform2uiv(this.addr, e)
}
function RK(r, e) {
    r.uniform3uiv(this.addr, e)
}
function DK(r, e) {
    r.uniform4uiv(this.addr, e)
}
function UK(r, e, t) {
    const n = this.cache
      , i = e.length
      , a = zM(t, i);
    Fr(n, a) || (r.uniform1iv(this.addr, a),
    Hr(n, a));
    for (let s = 0; s !== i; ++s)
        t.setTexture2D(e[s] || bz, a[s])
}
function OK(r, e, t) {
    const n = this.cache
      , i = e.length
      , a = zM(t, i);
    Fr(n, a) || (r.uniform1iv(this.addr, a),
    Hr(n, a));
    for (let s = 0; s !== i; ++s)
        t.setTexture3D(e[s] || Tz, a[s])
}
function NK(r, e, t) {
    const n = this.cache
      , i = e.length
      , a = zM(t, i);
    Fr(n, a) || (r.uniform1iv(this.addr, a),
    Hr(n, a));
    for (let s = 0; s !== i; ++s)
        t.setTextureCube(e[s] || Ez, a[s])
}
function LK(r, e, t) {
    const n = this.cache
      , i = e.length
      , a = zM(t, i);
    Fr(n, a) || (r.uniform1iv(this.addr, a),
    Hr(n, a));
    for (let s = 0; s !== i; ++s)
        t.setTexture2DArray(e[s] || Mz, a[s])
}
function PK(r) {
    switch (r) {
    case 5126:
        return gK;
    case 35664:
        return vK;
    case 35665:
        return yK;
    case 35666:
        return _K;
    case 35674:
        return xK;
    case 35675:
        return SK;
    case 35676:
        return bK;
    case 5124:
    case 35670:
        return MK;
    case 35667:
    case 35671:
        return TK;
    case 35668:
    case 35672:
        return EK;
    case 35669:
    case 35673:
        return wK;
    case 5125:
        return AK;
    case 36294:
        return CK;
    case 36295:
        return RK;
    case 36296:
        return DK;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return UK;
    case 35679:
    case 36299:
    case 36307:
        return OK;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return NK;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return LK
    }
}
class BK {
    constructor(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.type = t.type,
        this.setValue = mK(t.type)
    }
}
class zK {
    constructor(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.type = t.type,
        this.size = t.size,
        this.setValue = PK(t.type)
    }
}
class IK {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, n) {
        const i = this.seq;
        for (let a = 0, s = i.length; a !== s; ++a) {
            const l = i[a];
            l.setValue(e, t[l.id], n)
        }
    }
}
const kT = /(\w+)(\])?(\[|\.)?/g;
function mO(r, e) {
    r.seq.push(e),
    r.map[e.id] = e
}
function FK(r, e, t) {
    const n = r.name
      , i = n.length;
    for (kT.lastIndex = 0; ; ) {
        const a = kT.exec(n)
          , s = kT.lastIndex;
        let l = a[1];
        const u = a[2] === "]"
          , f = a[3];
        if (u && (l = l | 0),
        f === void 0 || f === "[" && s + 2 === i) {
            mO(t, f === void 0 ? new BK(l,r,e) : new zK(l,r,e));
            break
        } else {
            let g = t.map[l];
            g === void 0 && (g = new IK(l),
            mO(t, g)),
            t = g
        }
    }
}
class SS {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let i = 0; i < n; ++i) {
            const a = e.getActiveUniform(t, i)
              , s = e.getUniformLocation(t, a.name);
            FK(a, s, this)
        }
    }
    setValue(e, t, n, i) {
        const a = this.map[t];
        a !== void 0 && a.setValue(e, n, i)
    }
    setOptional(e, t, n) {
        const i = t[n];
        i !== void 0 && this.setValue(e, n, i)
    }
    static upload(e, t, n, i) {
        for (let a = 0, s = t.length; a !== s; ++a) {
            const l = t[a]
              , u = n[l.id];
            u.needsUpdate !== !1 && l.setValue(e, u.value, i)
        }
    }
    static seqWithValue(e, t) {
        const n = [];
        for (let i = 0, a = e.length; i !== a; ++i) {
            const s = e[i];
            s.id in t && n.push(s)
        }
        return n
    }
}
function gO(r, e, t) {
    const n = r.createShader(e);
    return r.shaderSource(n, t),
    r.compileShader(n),
    n
}
const HK = 37297;
let VK = 0;
function kK(r, e) {
    const t = r.split(`
`)
      , n = []
      , i = Math.max(e - 6, 0)
      , a = Math.min(e + 6, t.length);
    for (let s = i; s < a; s++) {
        const l = s + 1;
        n.push(`${l === e ? ">" : " "} ${l}: ${t[s]}`)
    }
    return n.join(`
`)
}
const vO = new An;
function GK(r) {
    Kn._getMatrix(vO, Kn.workingColorSpace, r);
    const e = `mat3( ${vO.elements.map(t => t.toFixed(4))} )`;
    switch (Kn.getTransfer(r)) {
    case Hy:
        return [e, "LinearTransferOETF"];
    case yi:
        return [e, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space: ", r),
        [e, "LinearTransferOETF"]
    }
}
function yO(r, e, t) {
    const n = r.getShaderParameter(e, r.COMPILE_STATUS)
      , a = (r.getShaderInfoLog(e) || "").trim();
    if (n && a === "")
        return "";
    const s = /ERROR: 0:(\d+)/.exec(a);
    if (s) {
        const l = parseInt(s[1]);
        return t.toUpperCase() + `

` + a + `

` + kK(r.getShaderSource(e), l)
    } else
        return a
}
function XK(r, e) {
    const t = GK(e);
    return [`vec4 ${r}( vec4 value ) {`, `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`, "}"].join(`
`)
}
function jK(r, e) {
    let t;
    switch (e) {
    case $P:
        t = "Linear";
        break;
    case eB:
        t = "Reinhard";
        break;
    case tB:
        t = "Cineon";
        break;
    case ZA:
        t = "ACESFilmic";
        break;
    case iB:
        t = "AgX";
        break;
    case rB:
        t = "Neutral";
        break;
    case nB:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + r + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
const kx = new he;
function WK() {
    Kn.getLuminanceCoefficients(kx);
    const r = kx.x.toFixed(4)
      , e = kx.y.toFixed(4)
      , t = kx.z.toFixed(4);
    return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${r}, ${e}, ${t} );`, "	return dot( weights, rgb );", "}"].join(`
`)
}
function YK(r) {
    return [r.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Lv).join(`
`)
}
function qK(r) {
    const e = [];
    for (const t in r) {
        const n = r[t];
        n !== !1 && e.push("#define " + t + " " + n)
    }
    return e.join(`
`)
}
function ZK(r, e) {
    const t = {}
      , n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < n; i++) {
        const a = r.getActiveAttrib(e, i)
          , s = a.name;
        let l = 1;
        a.type === r.FLOAT_MAT2 && (l = 2),
        a.type === r.FLOAT_MAT3 && (l = 3),
        a.type === r.FLOAT_MAT4 && (l = 4),
        t[s] = {
            type: a.type,
            location: r.getAttribLocation(e, s),
            locationSize: l
        }
    }
    return t
}
function Lv(r) {
    return r !== ""
}
function _O(r, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function xO(r, e) {
    return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const KK = /^[ \t]*#include +<([\w\d./]+)>/gm;
function xw(r) {
    return r.replace(KK, JK)
}
const QK = new Map;
function JK(r, e) {
    let t = Un[e];
    if (t === void 0) {
        const n = QK.get(e);
        if (n !== void 0)
            t = Un[n],
            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
        else
            throw new Error("Can not resolve #include <" + e + ">")
    }
    return xw(t)
}
const $K = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function SO(r) {
    return r.replace($K, eQ)
}
function eQ(r, e, t, n) {
    let i = "";
    for (let a = parseInt(e); a < parseInt(t); a++)
        i += n.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
    return i
}
function bO(r) {
    let e = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;
    return r.precision === "highp" ? e += `
#define HIGH_PRECISION` : r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function tQ(r) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return r.shadowMapType === rM ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === Jv ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === Wl && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function nQ(r) {
    let e = "ENVMAP_TYPE_CUBE";
    if (r.envMap)
        switch (r.envMapMode) {
        case ic:
        case _h:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case Xg:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function iQ(r) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (r.envMap)
        switch (r.envMapMode) {
        case _h:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function rQ(r) {
    let e = "ENVMAP_BLENDING_NONE";
    if (r.envMap)
        switch (r.combine) {
        case c_:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case QP:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case JP:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function aQ(r) {
    const e = r.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , n = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: n,
        maxMip: t
    }
}
function sQ(r, e, t, n) {
    const i = r.getContext()
      , a = t.defines;
    let s = t.vertexShader
      , l = t.fragmentShader;
    const u = tQ(t)
      , f = nQ(t)
      , d = iQ(t)
      , g = rQ(t)
      , v = aQ(t)
      , y = YK(t)
      , S = qK(a)
      , T = i.createProgram();
    let M, b, A = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (M = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, S].filter(Lv).join(`
`),
    M.length > 0 && (M += `
`),
    b = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, S].filter(Lv).join(`
`),
    b.length > 0 && (b += `
`)) : (M = [bO(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, S, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.batchingColor ? "#define USE_BATCHING_COLOR" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + d : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + u : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", t.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Lv).join(`
`),
    b = [bO(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, S, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + f : "", t.envMap ? "#define " + d : "", t.envMap ? "#define " + g : "", v ? "#define CUBEUV_TEXEL_WIDTH " + v.texelWidth : "", v ? "#define CUBEUV_TEXEL_HEIGHT " + v.texelHeight : "", v ? "#define CUBEUV_MAX_MIP " + v.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.dispersion ? "#define USE_DISPERSION" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + u : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", t.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Ju ? "#define TONE_MAPPING" : "", t.toneMapping !== Ju ? Un.tonemapping_pars_fragment : "", t.toneMapping !== Ju ? jK("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", Un.colorspace_pars_fragment, XK("linearToOutputTexel", t.outputColorSpace), WK(), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(Lv).join(`
`)),
    s = xw(s),
    s = _O(s, t),
    s = xO(s, t),
    l = xw(l),
    l = _O(l, t),
    l = xO(l, t),
    s = SO(s),
    l = SO(l),
    t.isRawShaderMaterial !== !0 && (A = `#version 300 es
`,
    M = [y, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + M,
    b = ["#define varying in", t.glslVersion === fw ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === fw ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + b);
    const C = A + M + s
      , R = A + b + l
      , O = gO(i, i.VERTEX_SHADER, C)
      , L = gO(i, i.FRAGMENT_SHADER, R);
    i.attachShader(T, O),
    i.attachShader(T, L),
    t.index0AttributeName !== void 0 ? i.bindAttribLocation(T, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(T, 0, "position"),
    i.linkProgram(T);
    function z(Y) {
        if (r.debug.checkShaderErrors) {
            const V = i.getProgramInfoLog(T) || ""
              , K = i.getShaderInfoLog(O) || ""
              , Z = i.getShaderInfoLog(L) || ""
              , oe = V.trim()
              , H = K.trim()
              , q = Z.trim();
            let Q = !0
              , se = !0;
            if (i.getProgramParameter(T, i.LINK_STATUS) === !1)
                if (Q = !1,
                typeof r.debug.onShaderError == "function")
                    r.debug.onShaderError(i, T, O, L);
                else {
                    const B = yO(i, O, "vertex")
                      , W = yO(i, L, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(T, i.VALIDATE_STATUS) + `

Material Name: ` + Y.name + `
Material Type: ` + Y.type + `

Program Info Log: ` + oe + `
` + B + `
` + W)
                }
            else
                oe !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", oe) : (H === "" || q === "") && (se = !1);
            se && (Y.diagnostics = {
                runnable: Q,
                programLog: oe,
                vertexShader: {
                    log: H,
                    prefix: M
                },
                fragmentShader: {
                    log: q,
                    prefix: b
                }
            })
        }
        i.deleteShader(O),
        i.deleteShader(L),
        I = new SS(i,T),
        N = ZK(i, T)
    }
    let I;
    this.getUniforms = function() {
        return I === void 0 && z(this),
        I
    }
    ;
    let N;
    this.getAttributes = function() {
        return N === void 0 && z(this),
        N
    }
    ;
    let P = t.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return P === !1 && (P = i.getProgramParameter(T, HK)),
        P
    }
    ,
    this.destroy = function() {
        n.releaseStatesOfProgram(this),
        i.deleteProgram(T),
        this.program = void 0
    }
    ,
    this.type = t.shaderType,
    this.name = t.shaderName,
    this.id = VK++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = T,
    this.vertexShader = O,
    this.fragmentShader = L,
    this
}
let oQ = 0;
class lQ {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , n = e.fragmentShader
          , i = this._getShaderStage(t)
          , a = this._getShaderStage(n)
          , s = this._getShaderCacheForMaterial(e);
        return s.has(i) === !1 && (s.add(i),
        i.usedTimes++),
        s.has(a) === !1 && (s.add(a),
        a.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const n of t)
            n.usedTimes--,
            n.usedTimes === 0 && this.shaderCache.delete(n.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let n = t.get(e);
        return n === void 0 && (n = new Set,
        t.set(e, n)),
        n
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let n = t.get(e);
        return n === void 0 && (n = new uQ(e),
        t.set(e, n)),
        n
    }
}
class uQ {
    constructor(e) {
        this.id = oQ++,
        this.code = e,
        this.usedTimes = 0
    }
}
function cQ(r, e, t, n, i, a, s) {
    const l = new Dg
      , u = new lQ
      , f = new Set
      , d = []
      , g = i.logarithmicDepthBuffer
      , v = i.vertexTextures;
    let y = i.precision;
    const S = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function T(N) {
        return f.add(N),
        N === 0 ? "uv" : `uv${N}`
    }
    function M(N, P, Y, V, K) {
        const Z = V.fog
          , oe = K.geometry
          , H = N.isMeshStandardMaterial ? V.environment : null
          , q = (N.isMeshStandardMaterial ? t : e).get(N.envMap || H)
          , Q = q && q.mapping === Xg ? q.image.height : null
          , se = S[N.type];
        N.precision !== null && (y = i.getMaxPrecision(N.precision),
        y !== N.precision && console.warn("THREE.WebGLProgram.getParameters:", N.precision, "not supported, using", y, "instead."));
        const B = oe.morphAttributes.position || oe.morphAttributes.normal || oe.morphAttributes.color
          , W = B !== void 0 ? B.length : 0;
        let te = 0;
        oe.morphAttributes.position !== void 0 && (te = 1),
        oe.morphAttributes.normal !== void 0 && (te = 2),
        oe.morphAttributes.color !== void 0 && (te = 3);
        let fe, pe, _e, ue;
        if (se) {
            const bt = Yl[se];
            fe = bt.vertexShader,
            pe = bt.fragmentShader
        } else
            fe = N.vertexShader,
            pe = N.fragmentShader,
            u.update(N),
            _e = u.getVertexShaderID(N),
            ue = u.getFragmentShaderID(N);
        const ge = r.getRenderTarget()
          , Te = r.state.buffers.depth.getReversed()
          , Ze = K.isInstancedMesh === !0
          , ot = K.isBatchedMesh === !0
          , tt = !!N.map
          , $e = !!N.matcap
          , re = !!q
          , Le = !!N.aoMap
          , Ne = !!N.lightMap
          , Oe = !!N.bumpMap
          , le = !!N.normalMap
          , Pe = !!N.displacementMap
          , He = !!N.emissiveMap
          , Ve = !!N.metalnessMap
          , De = !!N.roughnessMap
          , vt = N.anisotropy > 0
          , J = N.clearcoat > 0
          , j = N.dispersion > 0
          , ve = N.iridescence > 0
          , Be = N.sheen > 0
          , we = N.transmission > 0
          , Ce = vt && !!N.anisotropyMap
          , it = J && !!N.clearcoatMap
          , lt = J && !!N.clearcoatNormalMap
          , Mt = J && !!N.clearcoatRoughnessMap
          , pt = ve && !!N.iridescenceMap
          , je = ve && !!N.iridescenceThicknessMap
          , Ye = Be && !!N.sheenColorMap
          , ct = Be && !!N.sheenRoughnessMap
          , _t = !!N.specularMap
          , ut = !!N.specularColorMap
          , Ut = !!N.specularIntensityMap
          , me = we && !!N.transmissionMap
          , Ee = we && !!N.thicknessMap
          , at = !!N.gradientMap
          , Ct = !!N.alphaMap
          , rt = N.alphaTest > 0
          , Ge = !!N.alphaHash
          , wt = !!N.extensions;
        let Ot = Ju;
        N.toneMapped && (ge === null || ge.isXRRenderTarget === !0) && (Ot = r.toneMapping);
        const Nt = {
            shaderID: se,
            shaderType: N.type,
            shaderName: N.name,
            vertexShader: fe,
            fragmentShader: pe,
            defines: N.defines,
            customVertexShaderID: _e,
            customFragmentShaderID: ue,
            isRawShaderMaterial: N.isRawShaderMaterial === !0,
            glslVersion: N.glslVersion,
            precision: y,
            batching: ot,
            batchingColor: ot && K._colorsTexture !== null,
            instancing: Ze,
            instancingColor: Ze && K.instanceColor !== null,
            instancingMorph: Ze && K.morphTexture !== null,
            supportsVertexTextures: v,
            outputColorSpace: ge === null ? r.outputColorSpace : ge.isXRRenderTarget === !0 ? ge.texture.colorSpace : Jl,
            alphaToCoverage: !!N.alphaToCoverage,
            map: tt,
            matcap: $e,
            envMap: re,
            envMapMode: re && q.mapping,
            envMapCubeUVHeight: Q,
            aoMap: Le,
            lightMap: Ne,
            bumpMap: Oe,
            normalMap: le,
            displacementMap: v && Pe,
            emissiveMap: He,
            normalMapObjectSpace: le && N.normalMapType === cB,
            normalMapTangentSpace: le && N.normalMapType === Eh,
            metalnessMap: Ve,
            roughnessMap: De,
            anisotropy: vt,
            anisotropyMap: Ce,
            clearcoat: J,
            clearcoatMap: it,
            clearcoatNormalMap: lt,
            clearcoatRoughnessMap: Mt,
            dispersion: j,
            iridescence: ve,
            iridescenceMap: pt,
            iridescenceThicknessMap: je,
            sheen: Be,
            sheenColorMap: Ye,
            sheenRoughnessMap: ct,
            specularMap: _t,
            specularColorMap: ut,
            specularIntensityMap: Ut,
            transmission: we,
            transmissionMap: me,
            thicknessMap: Ee,
            gradientMap: at,
            opaque: N.transparent === !1 && N.blending === tp && N.alphaToCoverage === !1,
            alphaMap: Ct,
            alphaTest: rt,
            alphaHash: Ge,
            combine: N.combine,
            mapUv: tt && T(N.map.channel),
            aoMapUv: Le && T(N.aoMap.channel),
            lightMapUv: Ne && T(N.lightMap.channel),
            bumpMapUv: Oe && T(N.bumpMap.channel),
            normalMapUv: le && T(N.normalMap.channel),
            displacementMapUv: Pe && T(N.displacementMap.channel),
            emissiveMapUv: He && T(N.emissiveMap.channel),
            metalnessMapUv: Ve && T(N.metalnessMap.channel),
            roughnessMapUv: De && T(N.roughnessMap.channel),
            anisotropyMapUv: Ce && T(N.anisotropyMap.channel),
            clearcoatMapUv: it && T(N.clearcoatMap.channel),
            clearcoatNormalMapUv: lt && T(N.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: Mt && T(N.clearcoatRoughnessMap.channel),
            iridescenceMapUv: pt && T(N.iridescenceMap.channel),
            iridescenceThicknessMapUv: je && T(N.iridescenceThicknessMap.channel),
            sheenColorMapUv: Ye && T(N.sheenColorMap.channel),
            sheenRoughnessMapUv: ct && T(N.sheenRoughnessMap.channel),
            specularMapUv: _t && T(N.specularMap.channel),
            specularColorMapUv: ut && T(N.specularColorMap.channel),
            specularIntensityMapUv: Ut && T(N.specularIntensityMap.channel),
            transmissionMapUv: me && T(N.transmissionMap.channel),
            thicknessMapUv: Ee && T(N.thicknessMap.channel),
            alphaMapUv: Ct && T(N.alphaMap.channel),
            vertexTangents: !!oe.attributes.tangent && (le || vt),
            vertexColors: N.vertexColors,
            vertexAlphas: N.vertexColors === !0 && !!oe.attributes.color && oe.attributes.color.itemSize === 4,
            pointsUvs: K.isPoints === !0 && !!oe.attributes.uv && (tt || Ct),
            fog: !!Z,
            useFog: N.fog === !0,
            fogExp2: !!Z && Z.isFogExp2,
            flatShading: N.flatShading === !0 && N.wireframe === !1,
            sizeAttenuation: N.sizeAttenuation === !0,
            logarithmicDepthBuffer: g,
            reversedDepthBuffer: Te,
            skinning: K.isSkinnedMesh === !0,
            morphTargets: oe.morphAttributes.position !== void 0,
            morphNormals: oe.morphAttributes.normal !== void 0,
            morphColors: oe.morphAttributes.color !== void 0,
            morphTargetsCount: W,
            morphTextureStride: te,
            numDirLights: P.directional.length,
            numPointLights: P.point.length,
            numSpotLights: P.spot.length,
            numSpotLightMaps: P.spotLightMap.length,
            numRectAreaLights: P.rectArea.length,
            numHemiLights: P.hemi.length,
            numDirLightShadows: P.directionalShadowMap.length,
            numPointLightShadows: P.pointShadowMap.length,
            numSpotLightShadows: P.spotShadowMap.length,
            numSpotLightShadowsWithMaps: P.numSpotLightShadowsWithMaps,
            numLightProbes: P.numLightProbes,
            numClippingPlanes: s.numPlanes,
            numClipIntersection: s.numIntersection,
            dithering: N.dithering,
            shadowMapEnabled: r.shadowMap.enabled && Y.length > 0,
            shadowMapType: r.shadowMap.type,
            toneMapping: Ot,
            decodeVideoTexture: tt && N.map.isVideoTexture === !0 && Kn.getTransfer(N.map.colorSpace) === yi,
            decodeVideoTextureEmissive: He && N.emissiveMap.isVideoTexture === !0 && Kn.getTransfer(N.emissiveMap.colorSpace) === yi,
            premultipliedAlpha: N.premultipliedAlpha,
            doubleSided: N.side === tl,
            flipSided: N.side === vs,
            useDepthPacking: N.depthPacking >= 0,
            depthPacking: N.depthPacking || 0,
            index0AttributeName: N.index0AttributeName,
            extensionClipCullDistance: wt && N.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (wt && N.extensions.multiDraw === !0 || ot) && n.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: N.customProgramCacheKey()
        };
        return Nt.vertexUv1s = f.has(1),
        Nt.vertexUv2s = f.has(2),
        Nt.vertexUv3s = f.has(3),
        f.clear(),
        Nt
    }
    function b(N) {
        const P = [];
        if (N.shaderID ? P.push(N.shaderID) : (P.push(N.customVertexShaderID),
        P.push(N.customFragmentShaderID)),
        N.defines !== void 0)
            for (const Y in N.defines)
                P.push(Y),
                P.push(N.defines[Y]);
        return N.isRawShaderMaterial === !1 && (A(P, N),
        C(P, N),
        P.push(r.outputColorSpace)),
        P.push(N.customProgramCacheKey),
        P.join()
    }
    function A(N, P) {
        N.push(P.precision),
        N.push(P.outputColorSpace),
        N.push(P.envMapMode),
        N.push(P.envMapCubeUVHeight),
        N.push(P.mapUv),
        N.push(P.alphaMapUv),
        N.push(P.lightMapUv),
        N.push(P.aoMapUv),
        N.push(P.bumpMapUv),
        N.push(P.normalMapUv),
        N.push(P.displacementMapUv),
        N.push(P.emissiveMapUv),
        N.push(P.metalnessMapUv),
        N.push(P.roughnessMapUv),
        N.push(P.anisotropyMapUv),
        N.push(P.clearcoatMapUv),
        N.push(P.clearcoatNormalMapUv),
        N.push(P.clearcoatRoughnessMapUv),
        N.push(P.iridescenceMapUv),
        N.push(P.iridescenceThicknessMapUv),
        N.push(P.sheenColorMapUv),
        N.push(P.sheenRoughnessMapUv),
        N.push(P.specularMapUv),
        N.push(P.specularColorMapUv),
        N.push(P.specularIntensityMapUv),
        N.push(P.transmissionMapUv),
        N.push(P.thicknessMapUv),
        N.push(P.combine),
        N.push(P.fogExp2),
        N.push(P.sizeAttenuation),
        N.push(P.morphTargetsCount),
        N.push(P.morphAttributeCount),
        N.push(P.numDirLights),
        N.push(P.numPointLights),
        N.push(P.numSpotLights),
        N.push(P.numSpotLightMaps),
        N.push(P.numHemiLights),
        N.push(P.numRectAreaLights),
        N.push(P.numDirLightShadows),
        N.push(P.numPointLightShadows),
        N.push(P.numSpotLightShadows),
        N.push(P.numSpotLightShadowsWithMaps),
        N.push(P.numLightProbes),
        N.push(P.shadowMapType),
        N.push(P.toneMapping),
        N.push(P.numClippingPlanes),
        N.push(P.numClipIntersection),
        N.push(P.depthPacking)
    }
    function C(N, P) {
        l.disableAll(),
        P.supportsVertexTextures && l.enable(0),
        P.instancing && l.enable(1),
        P.instancingColor && l.enable(2),
        P.instancingMorph && l.enable(3),
        P.matcap && l.enable(4),
        P.envMap && l.enable(5),
        P.normalMapObjectSpace && l.enable(6),
        P.normalMapTangentSpace && l.enable(7),
        P.clearcoat && l.enable(8),
        P.iridescence && l.enable(9),
        P.alphaTest && l.enable(10),
        P.vertexColors && l.enable(11),
        P.vertexAlphas && l.enable(12),
        P.vertexUv1s && l.enable(13),
        P.vertexUv2s && l.enable(14),
        P.vertexUv3s && l.enable(15),
        P.vertexTangents && l.enable(16),
        P.anisotropy && l.enable(17),
        P.alphaHash && l.enable(18),
        P.batching && l.enable(19),
        P.dispersion && l.enable(20),
        P.batchingColor && l.enable(21),
        P.gradientMap && l.enable(22),
        N.push(l.mask),
        l.disableAll(),
        P.fog && l.enable(0),
        P.useFog && l.enable(1),
        P.flatShading && l.enable(2),
        P.logarithmicDepthBuffer && l.enable(3),
        P.reversedDepthBuffer && l.enable(4),
        P.skinning && l.enable(5),
        P.morphTargets && l.enable(6),
        P.morphNormals && l.enable(7),
        P.morphColors && l.enable(8),
        P.premultipliedAlpha && l.enable(9),
        P.shadowMapEnabled && l.enable(10),
        P.doubleSided && l.enable(11),
        P.flipSided && l.enable(12),
        P.useDepthPacking && l.enable(13),
        P.dithering && l.enable(14),
        P.transmission && l.enable(15),
        P.sheen && l.enable(16),
        P.opaque && l.enable(17),
        P.pointsUvs && l.enable(18),
        P.decodeVideoTexture && l.enable(19),
        P.decodeVideoTextureEmissive && l.enable(20),
        P.alphaToCoverage && l.enable(21),
        N.push(l.mask)
    }
    function R(N) {
        const P = S[N.type];
        let Y;
        if (P) {
            const V = Yl[P];
            Y = uC.clone(V.uniforms)
        } else
            Y = N.uniforms;
        return Y
    }
    function O(N, P) {
        let Y;
        for (let V = 0, K = d.length; V < K; V++) {
            const Z = d[V];
            if (Z.cacheKey === P) {
                Y = Z,
                ++Y.usedTimes;
                break
            }
        }
        return Y === void 0 && (Y = new sQ(r,P,N,a),
        d.push(Y)),
        Y
    }
    function L(N) {
        if (--N.usedTimes === 0) {
            const P = d.indexOf(N);
            d[P] = d[d.length - 1],
            d.pop(),
            N.destroy()
        }
    }
    function z(N) {
        u.remove(N)
    }
    function I() {
        u.dispose()
    }
    return {
        getParameters: M,
        getProgramCacheKey: b,
        getUniforms: R,
        acquireProgram: O,
        releaseProgram: L,
        releaseShaderCache: z,
        programs: d,
        dispose: I
    }
}
function fQ() {
    let r = new WeakMap;
    function e(s) {
        return r.has(s)
    }
    function t(s) {
        let l = r.get(s);
        return l === void 0 && (l = {},
        r.set(s, l)),
        l
    }
    function n(s) {
        r.delete(s)
    }
    function i(s, l, u) {
        r.get(s)[l] = u
    }
    function a() {
        r = new WeakMap
    }
    return {
        has: e,
        get: t,
        remove: n,
        update: i,
        dispose: a
    }
}
function hQ(r, e) {
    return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id
}
function MO(r, e) {
    return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id
}
function TO() {
    const r = [];
    let e = 0;
    const t = []
      , n = []
      , i = [];
    function a() {
        e = 0,
        t.length = 0,
        n.length = 0,
        i.length = 0
    }
    function s(g, v, y, S, T, M) {
        let b = r[e];
        return b === void 0 ? (b = {
            id: g.id,
            object: g,
            geometry: v,
            material: y,
            groupOrder: S,
            renderOrder: g.renderOrder,
            z: T,
            group: M
        },
        r[e] = b) : (b.id = g.id,
        b.object = g,
        b.geometry = v,
        b.material = y,
        b.groupOrder = S,
        b.renderOrder = g.renderOrder,
        b.z = T,
        b.group = M),
        e++,
        b
    }
    function l(g, v, y, S, T, M) {
        const b = s(g, v, y, S, T, M);
        y.transmission > 0 ? n.push(b) : y.transparent === !0 ? i.push(b) : t.push(b)
    }
    function u(g, v, y, S, T, M) {
        const b = s(g, v, y, S, T, M);
        y.transmission > 0 ? n.unshift(b) : y.transparent === !0 ? i.unshift(b) : t.unshift(b)
    }
    function f(g, v) {
        t.length > 1 && t.sort(g || hQ),
        n.length > 1 && n.sort(v || MO),
        i.length > 1 && i.sort(v || MO)
    }
    function d() {
        for (let g = e, v = r.length; g < v; g++) {
            const y = r[g];
            if (y.id === null)
                break;
            y.id = null,
            y.object = null,
            y.geometry = null,
            y.material = null,
            y.group = null
        }
    }
    return {
        opaque: t,
        transmissive: n,
        transparent: i,
        init: a,
        push: l,
        unshift: u,
        finish: d,
        sort: f
    }
}
function dQ() {
    let r = new WeakMap;
    function e(n, i) {
        const a = r.get(n);
        let s;
        return a === void 0 ? (s = new TO,
        r.set(n, [s])) : i >= a.length ? (s = new TO,
        a.push(s)) : s = a[i],
        s
    }
    function t() {
        r = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function pQ() {
    const r = {};
    return {
        get: function(e) {
            if (r[e.id] !== void 0)
                return r[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new he,
                    color: new kt
                };
                break;
            case "SpotLight":
                t = {
                    position: new he,
                    direction: new he,
                    color: new kt,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new he,
                    color: new kt,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new he,
                    skyColor: new kt,
                    groundColor: new kt
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new kt,
                    position: new he,
                    halfWidth: new he,
                    halfHeight: new he
                };
                break
            }
            return r[e.id] = t,
            t
        }
    }
}
function mQ() {
    const r = {};
    return {
        get: function(e) {
            if (r[e.id] !== void 0)
                return r[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new xt
                };
                break;
            case "SpotLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new xt
                };
                break;
            case "PointLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new xt,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return r[e.id] = t,
            t
        }
    }
}
let gQ = 0;
function vQ(r, e) {
    return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0)
}
function yQ(r) {
    const e = new pQ
      , t = mQ()
      , n = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0
    };
    for (let f = 0; f < 9; f++)
        n.probe.push(new he);
    const i = new he
      , a = new vn
      , s = new vn;
    function l(f) {
        let d = 0
          , g = 0
          , v = 0;
        for (let N = 0; N < 9; N++)
            n.probe[N].set(0, 0, 0);
        let y = 0
          , S = 0
          , T = 0
          , M = 0
          , b = 0
          , A = 0
          , C = 0
          , R = 0
          , O = 0
          , L = 0
          , z = 0;
        f.sort(vQ);
        for (let N = 0, P = f.length; N < P; N++) {
            const Y = f[N]
              , V = Y.color
              , K = Y.intensity
              , Z = Y.distance
              , oe = Y.shadow && Y.shadow.map ? Y.shadow.map.texture : null;
            if (Y.isAmbientLight)
                d += V.r * K,
                g += V.g * K,
                v += V.b * K;
            else if (Y.isLightProbe) {
                for (let H = 0; H < 9; H++)
                    n.probe[H].addScaledVector(Y.sh.coefficients[H], K);
                z++
            } else if (Y.isDirectionalLight) {
                const H = e.get(Y);
                if (H.color.copy(Y.color).multiplyScalar(Y.intensity),
                Y.castShadow) {
                    const q = Y.shadow
                      , Q = t.get(Y);
                    Q.shadowIntensity = q.intensity,
                    Q.shadowBias = q.bias,
                    Q.shadowNormalBias = q.normalBias,
                    Q.shadowRadius = q.radius,
                    Q.shadowMapSize = q.mapSize,
                    n.directionalShadow[y] = Q,
                    n.directionalShadowMap[y] = oe,
                    n.directionalShadowMatrix[y] = Y.shadow.matrix,
                    A++
                }
                n.directional[y] = H,
                y++
            } else if (Y.isSpotLight) {
                const H = e.get(Y);
                H.position.setFromMatrixPosition(Y.matrixWorld),
                H.color.copy(V).multiplyScalar(K),
                H.distance = Z,
                H.coneCos = Math.cos(Y.angle),
                H.penumbraCos = Math.cos(Y.angle * (1 - Y.penumbra)),
                H.decay = Y.decay,
                n.spot[T] = H;
                const q = Y.shadow;
                if (Y.map && (n.spotLightMap[O] = Y.map,
                O++,
                q.updateMatrices(Y),
                Y.castShadow && L++),
                n.spotLightMatrix[T] = q.matrix,
                Y.castShadow) {
                    const Q = t.get(Y);
                    Q.shadowIntensity = q.intensity,
                    Q.shadowBias = q.bias,
                    Q.shadowNormalBias = q.normalBias,
                    Q.shadowRadius = q.radius,
                    Q.shadowMapSize = q.mapSize,
                    n.spotShadow[T] = Q,
                    n.spotShadowMap[T] = oe,
                    R++
                }
                T++
            } else if (Y.isRectAreaLight) {
                const H = e.get(Y);
                H.color.copy(V).multiplyScalar(K),
                H.halfWidth.set(Y.width * .5, 0, 0),
                H.halfHeight.set(0, Y.height * .5, 0),
                n.rectArea[M] = H,
                M++
            } else if (Y.isPointLight) {
                const H = e.get(Y);
                if (H.color.copy(Y.color).multiplyScalar(Y.intensity),
                H.distance = Y.distance,
                H.decay = Y.decay,
                Y.castShadow) {
                    const q = Y.shadow
                      , Q = t.get(Y);
                    Q.shadowIntensity = q.intensity,
                    Q.shadowBias = q.bias,
                    Q.shadowNormalBias = q.normalBias,
                    Q.shadowRadius = q.radius,
                    Q.shadowMapSize = q.mapSize,
                    Q.shadowCameraNear = q.camera.near,
                    Q.shadowCameraFar = q.camera.far,
                    n.pointShadow[S] = Q,
                    n.pointShadowMap[S] = oe,
                    n.pointShadowMatrix[S] = Y.shadow.matrix,
                    C++
                }
                n.point[S] = H,
                S++
            } else if (Y.isHemisphereLight) {
                const H = e.get(Y);
                H.skyColor.copy(Y.color).multiplyScalar(K),
                H.groundColor.copy(Y.groundColor).multiplyScalar(K),
                n.hemi[b] = H,
                b++
            }
        }
        M > 0 && (r.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = Ht.LTC_FLOAT_1,
        n.rectAreaLTC2 = Ht.LTC_FLOAT_2) : (n.rectAreaLTC1 = Ht.LTC_HALF_1,
        n.rectAreaLTC2 = Ht.LTC_HALF_2)),
        n.ambient[0] = d,
        n.ambient[1] = g,
        n.ambient[2] = v;
        const I = n.hash;
        (I.directionalLength !== y || I.pointLength !== S || I.spotLength !== T || I.rectAreaLength !== M || I.hemiLength !== b || I.numDirectionalShadows !== A || I.numPointShadows !== C || I.numSpotShadows !== R || I.numSpotMaps !== O || I.numLightProbes !== z) && (n.directional.length = y,
        n.spot.length = T,
        n.rectArea.length = M,
        n.point.length = S,
        n.hemi.length = b,
        n.directionalShadow.length = A,
        n.directionalShadowMap.length = A,
        n.pointShadow.length = C,
        n.pointShadowMap.length = C,
        n.spotShadow.length = R,
        n.spotShadowMap.length = R,
        n.directionalShadowMatrix.length = A,
        n.pointShadowMatrix.length = C,
        n.spotLightMatrix.length = R + O - L,
        n.spotLightMap.length = O,
        n.numSpotLightShadowsWithMaps = L,
        n.numLightProbes = z,
        I.directionalLength = y,
        I.pointLength = S,
        I.spotLength = T,
        I.rectAreaLength = M,
        I.hemiLength = b,
        I.numDirectionalShadows = A,
        I.numPointShadows = C,
        I.numSpotShadows = R,
        I.numSpotMaps = O,
        I.numLightProbes = z,
        n.version = gQ++)
    }
    function u(f, d) {
        let g = 0
          , v = 0
          , y = 0
          , S = 0
          , T = 0;
        const M = d.matrixWorldInverse;
        for (let b = 0, A = f.length; b < A; b++) {
            const C = f[b];
            if (C.isDirectionalLight) {
                const R = n.directional[g];
                R.direction.setFromMatrixPosition(C.matrixWorld),
                i.setFromMatrixPosition(C.target.matrixWorld),
                R.direction.sub(i),
                R.direction.transformDirection(M),
                g++
            } else if (C.isSpotLight) {
                const R = n.spot[y];
                R.position.setFromMatrixPosition(C.matrixWorld),
                R.position.applyMatrix4(M),
                R.direction.setFromMatrixPosition(C.matrixWorld),
                i.setFromMatrixPosition(C.target.matrixWorld),
                R.direction.sub(i),
                R.direction.transformDirection(M),
                y++
            } else if (C.isRectAreaLight) {
                const R = n.rectArea[S];
                R.position.setFromMatrixPosition(C.matrixWorld),
                R.position.applyMatrix4(M),
                s.identity(),
                a.copy(C.matrixWorld),
                a.premultiply(M),
                s.extractRotation(a),
                R.halfWidth.set(C.width * .5, 0, 0),
                R.halfHeight.set(0, C.height * .5, 0),
                R.halfWidth.applyMatrix4(s),
                R.halfHeight.applyMatrix4(s),
                S++
            } else if (C.isPointLight) {
                const R = n.point[v];
                R.position.setFromMatrixPosition(C.matrixWorld),
                R.position.applyMatrix4(M),
                v++
            } else if (C.isHemisphereLight) {
                const R = n.hemi[T];
                R.direction.setFromMatrixPosition(C.matrixWorld),
                R.direction.transformDirection(M),
                T++
            }
        }
    }
    return {
        setup: l,
        setupView: u,
        state: n
    }
}
function EO(r) {
    const e = new yQ(r)
      , t = []
      , n = [];
    function i(d) {
        f.camera = d,
        t.length = 0,
        n.length = 0
    }
    function a(d) {
        t.push(d)
    }
    function s(d) {
        n.push(d)
    }
    function l() {
        e.setup(t)
    }
    function u(d) {
        e.setupView(t, d)
    }
    const f = {
        lightsArray: t,
        shadowsArray: n,
        camera: null,
        lights: e,
        transmissionRenderTarget: {}
    };
    return {
        init: i,
        state: f,
        setupLights: l,
        setupLightsView: u,
        pushLight: a,
        pushShadow: s
    }
}
function _Q(r) {
    let e = new WeakMap;
    function t(i, a=0) {
        const s = e.get(i);
        let l;
        return s === void 0 ? (l = new EO(r),
        e.set(i, [l])) : a >= s.length ? (l = new EO(r),
        s.push(l)) : l = s[a],
        l
    }
    function n() {
        e = new WeakMap
    }
    return {
        get: t,
        dispose: n
    }
}
const xQ = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , SQ = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function bQ(r, e, t) {
    let n = new Wg;
    const i = new xt
      , a = new xt
      , s = new Qn
      , l = new NM({
        depthPacking: iC
    })
      , u = new LM
      , f = {}
      , d = t.maxTextureSize
      , g = {
        [tf]: vs,
        [vs]: tf,
        [tl]: tl
    }
      , v = new Ks({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new xt
            },
            radius: {
                value: 4
            }
        },
        vertexShader: xQ,
        fragmentShader: SQ
    })
      , y = v.clone();
    y.defines.HORIZONTAL_PASS = 1;
    const S = new Nn;
    S.setAttribute("position", new xi(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const T = new Ni(S,v)
      , M = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = rM;
    let b = this.type;
    this.render = function(L, z, I) {
        if (M.enabled === !1 || M.autoUpdate === !1 && M.needsUpdate === !1 || L.length === 0)
            return;
        const N = r.getRenderTarget()
          , P = r.getActiveCubeFace()
          , Y = r.getActiveMipmapLevel()
          , V = r.state;
        V.setBlending(Qu),
        V.buffers.depth.getReversed() === !0 ? V.buffers.color.setClear(0, 0, 0, 0) : V.buffers.color.setClear(1, 1, 1, 1),
        V.buffers.depth.setTest(!0),
        V.setScissorTest(!1);
        const K = b !== Wl && this.type === Wl
          , Z = b === Wl && this.type !== Wl;
        for (let oe = 0, H = L.length; oe < H; oe++) {
            const q = L[oe]
              , Q = q.shadow;
            if (Q === void 0) {
                console.warn("THREE.WebGLShadowMap:", q, "has no shadow.");
                continue
            }
            if (Q.autoUpdate === !1 && Q.needsUpdate === !1)
                continue;
            i.copy(Q.mapSize);
            const se = Q.getFrameExtents();
            if (i.multiply(se),
            a.copy(Q.mapSize),
            (i.x > d || i.y > d) && (i.x > d && (a.x = Math.floor(d / se.x),
            i.x = a.x * se.x,
            Q.mapSize.x = a.x),
            i.y > d && (a.y = Math.floor(d / se.y),
            i.y = a.y * se.y,
            Q.mapSize.y = a.y)),
            Q.map === null || K === !0 || Z === !0) {
                const W = this.type !== Wl ? {
                    minFilter: va,
                    magFilter: va
                } : {};
                Q.map !== null && Q.map.dispose(),
                Q.map = new sl(i.x,i.y,W),
                Q.map.texture.name = q.name + ".shadowMap",
                Q.camera.updateProjectionMatrix()
            }
            r.setRenderTarget(Q.map),
            r.clear();
            const B = Q.getViewportCount();
            for (let W = 0; W < B; W++) {
                const te = Q.getViewport(W);
                s.set(a.x * te.x, a.y * te.y, a.x * te.z, a.y * te.w),
                V.viewport(s),
                Q.updateMatrices(q, W),
                n = Q.getFrustum(),
                R(z, I, Q.camera, q, this.type)
            }
            Q.isPointLightShadow !== !0 && this.type === Wl && A(Q, I),
            Q.needsUpdate = !1
        }
        b = this.type,
        M.needsUpdate = !1,
        r.setRenderTarget(N, P, Y)
    }
    ;
    function A(L, z) {
        const I = e.update(T);
        v.defines.VSM_SAMPLES !== L.blurSamples && (v.defines.VSM_SAMPLES = L.blurSamples,
        y.defines.VSM_SAMPLES = L.blurSamples,
        v.needsUpdate = !0,
        y.needsUpdate = !0),
        L.mapPass === null && (L.mapPass = new sl(i.x,i.y)),
        v.uniforms.shadow_pass.value = L.map.texture,
        v.uniforms.resolution.value = L.mapSize,
        v.uniforms.radius.value = L.radius,
        r.setRenderTarget(L.mapPass),
        r.clear(),
        r.renderBufferDirect(z, null, I, v, T, null),
        y.uniforms.shadow_pass.value = L.mapPass.texture,
        y.uniforms.resolution.value = L.mapSize,
        y.uniforms.radius.value = L.radius,
        r.setRenderTarget(L.map),
        r.clear(),
        r.renderBufferDirect(z, null, I, y, T, null)
    }
    function C(L, z, I, N) {
        let P = null;
        const Y = I.isPointLight === !0 ? L.customDistanceMaterial : L.customDepthMaterial;
        if (Y !== void 0)
            P = Y;
        else if (P = I.isPointLight === !0 ? u : l,
        r.localClippingEnabled && z.clipShadows === !0 && Array.isArray(z.clippingPlanes) && z.clippingPlanes.length !== 0 || z.displacementMap && z.displacementScale !== 0 || z.alphaMap && z.alphaTest > 0 || z.map && z.alphaTest > 0 || z.alphaToCoverage === !0) {
            const V = P.uuid
              , K = z.uuid;
            let Z = f[V];
            Z === void 0 && (Z = {},
            f[V] = Z);
            let oe = Z[K];
            oe === void 0 && (oe = P.clone(),
            Z[K] = oe,
            z.addEventListener("dispose", O)),
            P = oe
        }
        if (P.visible = z.visible,
        P.wireframe = z.wireframe,
        N === Wl ? P.side = z.shadowSide !== null ? z.shadowSide : z.side : P.side = z.shadowSide !== null ? z.shadowSide : g[z.side],
        P.alphaMap = z.alphaMap,
        P.alphaTest = z.alphaToCoverage === !0 ? .5 : z.alphaTest,
        P.map = z.map,
        P.clipShadows = z.clipShadows,
        P.clippingPlanes = z.clippingPlanes,
        P.clipIntersection = z.clipIntersection,
        P.displacementMap = z.displacementMap,
        P.displacementScale = z.displacementScale,
        P.displacementBias = z.displacementBias,
        P.wireframeLinewidth = z.wireframeLinewidth,
        P.linewidth = z.linewidth,
        I.isPointLight === !0 && P.isMeshDistanceMaterial === !0) {
            const V = r.properties.get(P);
            V.light = I
        }
        return P
    }
    function R(L, z, I, N, P) {
        if (L.visible === !1)
            return;
        if (L.layers.test(z.layers) && (L.isMesh || L.isLine || L.isPoints) && (L.castShadow || L.receiveShadow && P === Wl) && (!L.frustumCulled || n.intersectsObject(L))) {
            L.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse, L.matrixWorld);
            const K = e.update(L)
              , Z = L.material;
            if (Array.isArray(Z)) {
                const oe = K.groups;
                for (let H = 0, q = oe.length; H < q; H++) {
                    const Q = oe[H]
                      , se = Z[Q.materialIndex];
                    if (se && se.visible) {
                        const B = C(L, se, N, P);
                        L.onBeforeShadow(r, L, z, I, K, B, Q),
                        r.renderBufferDirect(I, null, K, B, L, Q),
                        L.onAfterShadow(r, L, z, I, K, B, Q)
                    }
                }
            } else if (Z.visible) {
                const oe = C(L, Z, N, P);
                L.onBeforeShadow(r, L, z, I, K, oe, null),
                r.renderBufferDirect(I, null, K, oe, L, null),
                L.onAfterShadow(r, L, z, I, K, oe, null)
            }
        }
        const V = L.children;
        for (let K = 0, Z = V.length; K < Z; K++)
            R(V[K], z, I, N, P)
    }
    function O(L) {
        L.target.removeEventListener("dispose", O);
        for (const I in f) {
            const N = f[I]
              , P = L.target.uuid;
            P in N && (N[P].dispose(),
            delete N[P])
        }
    }
}
const MQ = {
    [YS]: qS,
    [ZS]: JS,
    [KS]: $S,
    [up]: QS,
    [qS]: YS,
    [JS]: ZS,
    [$S]: KS,
    [QS]: up
};
function TQ(r, e) {
    function t() {
        let me = !1;
        const Ee = new Qn;
        let at = null;
        const Ct = new Qn(0,0,0,0);
        return {
            setMask: function(rt) {
                at !== rt && !me && (r.colorMask(rt, rt, rt, rt),
                at = rt)
            },
            setLocked: function(rt) {
                me = rt
            },
            setClear: function(rt, Ge, wt, Ot, Nt) {
                Nt === !0 && (rt *= Ot,
                Ge *= Ot,
                wt *= Ot),
                Ee.set(rt, Ge, wt, Ot),
                Ct.equals(Ee) === !1 && (r.clearColor(rt, Ge, wt, Ot),
                Ct.copy(Ee))
            },
            reset: function() {
                me = !1,
                at = null,
                Ct.set(-1, 0, 0, 0)
            }
        }
    }
    function n() {
        let me = !1
          , Ee = !1
          , at = null
          , Ct = null
          , rt = null;
        return {
            setReversed: function(Ge) {
                if (Ee !== Ge) {
                    const wt = e.get("EXT_clip_control");
                    Ge ? wt.clipControlEXT(wt.LOWER_LEFT_EXT, wt.ZERO_TO_ONE_EXT) : wt.clipControlEXT(wt.LOWER_LEFT_EXT, wt.NEGATIVE_ONE_TO_ONE_EXT),
                    Ee = Ge;
                    const Ot = rt;
                    rt = null,
                    this.setClear(Ot)
                }
            },
            getReversed: function() {
                return Ee
            },
            setTest: function(Ge) {
                Ge ? ge(r.DEPTH_TEST) : Te(r.DEPTH_TEST)
            },
            setMask: function(Ge) {
                at !== Ge && !me && (r.depthMask(Ge),
                at = Ge)
            },
            setFunc: function(Ge) {
                if (Ee && (Ge = MQ[Ge]),
                Ct !== Ge) {
                    switch (Ge) {
                    case YS:
                        r.depthFunc(r.NEVER);
                        break;
                    case qS:
                        r.depthFunc(r.ALWAYS);
                        break;
                    case ZS:
                        r.depthFunc(r.LESS);
                        break;
                    case up:
                        r.depthFunc(r.LEQUAL);
                        break;
                    case KS:
                        r.depthFunc(r.EQUAL);
                        break;
                    case QS:
                        r.depthFunc(r.GEQUAL);
                        break;
                    case JS:
                        r.depthFunc(r.GREATER);
                        break;
                    case $S:
                        r.depthFunc(r.NOTEQUAL);
                        break;
                    default:
                        r.depthFunc(r.LEQUAL)
                    }
                    Ct = Ge
                }
            },
            setLocked: function(Ge) {
                me = Ge
            },
            setClear: function(Ge) {
                rt !== Ge && (Ee && (Ge = 1 - Ge),
                r.clearDepth(Ge),
                rt = Ge)
            },
            reset: function() {
                me = !1,
                at = null,
                Ct = null,
                rt = null,
                Ee = !1
            }
        }
    }
    function i() {
        let me = !1
          , Ee = null
          , at = null
          , Ct = null
          , rt = null
          , Ge = null
          , wt = null
          , Ot = null
          , Nt = null;
        return {
            setTest: function(bt) {
                me || (bt ? ge(r.STENCIL_TEST) : Te(r.STENCIL_TEST))
            },
            setMask: function(bt) {
                Ee !== bt && !me && (r.stencilMask(bt),
                Ee = bt)
            },
            setFunc: function(bt, Bt, Gt) {
                (at !== bt || Ct !== Bt || rt !== Gt) && (r.stencilFunc(bt, Bt, Gt),
                at = bt,
                Ct = Bt,
                rt = Gt)
            },
            setOp: function(bt, Bt, Gt) {
                (Ge !== bt || wt !== Bt || Ot !== Gt) && (r.stencilOp(bt, Bt, Gt),
                Ge = bt,
                wt = Bt,
                Ot = Gt)
            },
            setLocked: function(bt) {
                me = bt
            },
            setClear: function(bt) {
                Nt !== bt && (r.clearStencil(bt),
                Nt = bt)
            },
            reset: function() {
                me = !1,
                Ee = null,
                at = null,
                Ct = null,
                rt = null,
                Ge = null,
                wt = null,
                Ot = null,
                Nt = null
            }
        }
    }
    const a = new t
      , s = new n
      , l = new i
      , u = new WeakMap
      , f = new WeakMap;
    let d = {}
      , g = {}
      , v = new WeakMap
      , y = []
      , S = null
      , T = !1
      , M = null
      , b = null
      , A = null
      , C = null
      , R = null
      , O = null
      , L = null
      , z = new kt(0,0,0)
      , I = 0
      , N = !1
      , P = null
      , Y = null
      , V = null
      , K = null
      , Z = null;
    const oe = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let H = !1
      , q = 0;
    const Q = r.getParameter(r.VERSION);
    Q.indexOf("WebGL") !== -1 ? (q = parseFloat(/^WebGL (\d)/.exec(Q)[1]),
    H = q >= 1) : Q.indexOf("OpenGL ES") !== -1 && (q = parseFloat(/^OpenGL ES (\d)/.exec(Q)[1]),
    H = q >= 2);
    let se = null
      , B = {};
    const W = r.getParameter(r.SCISSOR_BOX)
      , te = r.getParameter(r.VIEWPORT)
      , fe = new Qn().fromArray(W)
      , pe = new Qn().fromArray(te);
    function _e(me, Ee, at, Ct) {
        const rt = new Uint8Array(4)
          , Ge = r.createTexture();
        r.bindTexture(me, Ge),
        r.texParameteri(me, r.TEXTURE_MIN_FILTER, r.NEAREST),
        r.texParameteri(me, r.TEXTURE_MAG_FILTER, r.NEAREST);
        for (let wt = 0; wt < at; wt++)
            me === r.TEXTURE_3D || me === r.TEXTURE_2D_ARRAY ? r.texImage3D(Ee, 0, r.RGBA, 1, 1, Ct, 0, r.RGBA, r.UNSIGNED_BYTE, rt) : r.texImage2D(Ee + wt, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, rt);
        return Ge
    }
    const ue = {};
    ue[r.TEXTURE_2D] = _e(r.TEXTURE_2D, r.TEXTURE_2D, 1),
    ue[r.TEXTURE_CUBE_MAP] = _e(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    ue[r.TEXTURE_2D_ARRAY] = _e(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1),
    ue[r.TEXTURE_3D] = _e(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1),
    a.setClear(0, 0, 0, 1),
    s.setClear(1),
    l.setClear(0),
    ge(r.DEPTH_TEST),
    s.setFunc(up),
    Oe(!1),
    le(rw),
    ge(r.CULL_FACE),
    Le(Qu);
    function ge(me) {
        d[me] !== !0 && (r.enable(me),
        d[me] = !0)
    }
    function Te(me) {
        d[me] !== !1 && (r.disable(me),
        d[me] = !1)
    }
    function Ze(me, Ee) {
        return g[me] !== Ee ? (r.bindFramebuffer(me, Ee),
        g[me] = Ee,
        me === r.DRAW_FRAMEBUFFER && (g[r.FRAMEBUFFER] = Ee),
        me === r.FRAMEBUFFER && (g[r.DRAW_FRAMEBUFFER] = Ee),
        !0) : !1
    }
    function ot(me, Ee) {
        let at = y
          , Ct = !1;
        if (me) {
            at = v.get(Ee),
            at === void 0 && (at = [],
            v.set(Ee, at));
            const rt = me.textures;
            if (at.length !== rt.length || at[0] !== r.COLOR_ATTACHMENT0) {
                for (let Ge = 0, wt = rt.length; Ge < wt; Ge++)
                    at[Ge] = r.COLOR_ATTACHMENT0 + Ge;
                at.length = rt.length,
                Ct = !0
            }
        } else
            at[0] !== r.BACK && (at[0] = r.BACK,
            Ct = !0);
        Ct && r.drawBuffers(at)
    }
    function tt(me) {
        return S !== me ? (r.useProgram(me),
        S = me,
        !0) : !1
    }
    const $e = {
        [rh]: r.FUNC_ADD,
        [LP]: r.FUNC_SUBTRACT,
        [PP]: r.FUNC_REVERSE_SUBTRACT
    };
    $e[BP] = r.MIN,
    $e[zP] = r.MAX;
    const re = {
        [IP]: r.ZERO,
        [FP]: r.ONE,
        [HP]: r.SRC_COLOR,
        [jS]: r.SRC_ALPHA,
        [WP]: r.SRC_ALPHA_SATURATE,
        [XP]: r.DST_COLOR,
        [kP]: r.DST_ALPHA,
        [VP]: r.ONE_MINUS_SRC_COLOR,
        [WS]: r.ONE_MINUS_SRC_ALPHA,
        [jP]: r.ONE_MINUS_DST_COLOR,
        [GP]: r.ONE_MINUS_DST_ALPHA,
        [YP]: r.CONSTANT_COLOR,
        [qP]: r.ONE_MINUS_CONSTANT_COLOR,
        [ZP]: r.CONSTANT_ALPHA,
        [KP]: r.ONE_MINUS_CONSTANT_ALPHA
    };
    function Le(me, Ee, at, Ct, rt, Ge, wt, Ot, Nt, bt) {
        if (me === Qu) {
            T === !0 && (Te(r.BLEND),
            T = !1);
            return
        }
        if (T === !1 && (ge(r.BLEND),
        T = !0),
        me !== NP) {
            if (me !== M || bt !== N) {
                if ((b !== rh || R !== rh) && (r.blendEquation(r.FUNC_ADD),
                b = rh,
                R = rh),
                bt)
                    switch (me) {
                    case tp:
                        r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                        break;
                    case aw:
                        r.blendFunc(r.ONE, r.ONE);
                        break;
                    case sw:
                        r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
                        break;
                    case ow:
                        r.blendFuncSeparate(r.DST_COLOR, r.ONE_MINUS_SRC_ALPHA, r.ZERO, r.ONE);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", me);
                        break
                    }
                else
                    switch (me) {
                    case tp:
                        r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                        break;
                    case aw:
                        r.blendFuncSeparate(r.SRC_ALPHA, r.ONE, r.ONE, r.ONE);
                        break;
                    case sw:
                        console.error("THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");
                        break;
                    case ow:
                        console.error("THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", me);
                        break
                    }
                A = null,
                C = null,
                O = null,
                L = null,
                z.set(0, 0, 0),
                I = 0,
                M = me,
                N = bt
            }
            return
        }
        rt = rt || Ee,
        Ge = Ge || at,
        wt = wt || Ct,
        (Ee !== b || rt !== R) && (r.blendEquationSeparate($e[Ee], $e[rt]),
        b = Ee,
        R = rt),
        (at !== A || Ct !== C || Ge !== O || wt !== L) && (r.blendFuncSeparate(re[at], re[Ct], re[Ge], re[wt]),
        A = at,
        C = Ct,
        O = Ge,
        L = wt),
        (Ot.equals(z) === !1 || Nt !== I) && (r.blendColor(Ot.r, Ot.g, Ot.b, Nt),
        z.copy(Ot),
        I = Nt),
        M = me,
        N = !1
    }
    function Ne(me, Ee) {
        me.side === tl ? Te(r.CULL_FACE) : ge(r.CULL_FACE);
        let at = me.side === vs;
        Ee && (at = !at),
        Oe(at),
        me.blending === tp && me.transparent === !1 ? Le(Qu) : Le(me.blending, me.blendEquation, me.blendSrc, me.blendDst, me.blendEquationAlpha, me.blendSrcAlpha, me.blendDstAlpha, me.blendColor, me.blendAlpha, me.premultipliedAlpha),
        s.setFunc(me.depthFunc),
        s.setTest(me.depthTest),
        s.setMask(me.depthWrite),
        a.setMask(me.colorWrite);
        const Ct = me.stencilWrite;
        l.setTest(Ct),
        Ct && (l.setMask(me.stencilWriteMask),
        l.setFunc(me.stencilFunc, me.stencilRef, me.stencilFuncMask),
        l.setOp(me.stencilFail, me.stencilZFail, me.stencilZPass)),
        He(me.polygonOffset, me.polygonOffsetFactor, me.polygonOffsetUnits),
        me.alphaToCoverage === !0 ? ge(r.SAMPLE_ALPHA_TO_COVERAGE) : Te(r.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function Oe(me) {
        P !== me && (me ? r.frontFace(r.CW) : r.frontFace(r.CCW),
        P = me)
    }
    function le(me) {
        me !== DP ? (ge(r.CULL_FACE),
        me !== Y && (me === rw ? r.cullFace(r.BACK) : me === UP ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : Te(r.CULL_FACE),
        Y = me
    }
    function Pe(me) {
        me !== V && (H && r.lineWidth(me),
        V = me)
    }
    function He(me, Ee, at) {
        me ? (ge(r.POLYGON_OFFSET_FILL),
        (K !== Ee || Z !== at) && (r.polygonOffset(Ee, at),
        K = Ee,
        Z = at)) : Te(r.POLYGON_OFFSET_FILL)
    }
    function Ve(me) {
        me ? ge(r.SCISSOR_TEST) : Te(r.SCISSOR_TEST)
    }
    function De(me) {
        me === void 0 && (me = r.TEXTURE0 + oe - 1),
        se !== me && (r.activeTexture(me),
        se = me)
    }
    function vt(me, Ee, at) {
        at === void 0 && (se === null ? at = r.TEXTURE0 + oe - 1 : at = se);
        let Ct = B[at];
        Ct === void 0 && (Ct = {
            type: void 0,
            texture: void 0
        },
        B[at] = Ct),
        (Ct.type !== me || Ct.texture !== Ee) && (se !== at && (r.activeTexture(at),
        se = at),
        r.bindTexture(me, Ee || ue[me]),
        Ct.type = me,
        Ct.texture = Ee)
    }
    function J() {
        const me = B[se];
        me !== void 0 && me.type !== void 0 && (r.bindTexture(me.type, null),
        me.type = void 0,
        me.texture = void 0)
    }
    function j() {
        try {
            r.compressedTexImage2D(...arguments)
        } catch (me) {
            console.error("THREE.WebGLState:", me)
        }
    }
    function ve() {
        try {
            r.compressedTexImage3D(...arguments)
        } catch (me) {
            console.error("THREE.WebGLState:", me)
        }
    }
    function Be() {
        try {
            r.texSubImage2D(...arguments)
        } catch (me) {
            console.error("THREE.WebGLState:", me)
        }
    }
    function we() {
        try {
            r.texSubImage3D(...arguments)
        } catch (me) {
            console.error("THREE.WebGLState:", me)
        }
    }
    function Ce() {
        try {
            r.compressedTexSubImage2D(...arguments)
        } catch (me) {
            console.error("THREE.WebGLState:", me)
        }
    }
    function it() {
        try {
            r.compressedTexSubImage3D(...arguments)
        } catch (me) {
            console.error("THREE.WebGLState:", me)
        }
    }
    function lt() {
        try {
            r.texStorage2D(...arguments)
        } catch (me) {
            console.error("THREE.WebGLState:", me)
        }
    }
    function Mt() {
        try {
            r.texStorage3D(...arguments)
        } catch (me) {
            console.error("THREE.WebGLState:", me)
        }
    }
    function pt() {
        try {
            r.texImage2D(...arguments)
        } catch (me) {
            console.error("THREE.WebGLState:", me)
        }
    }
    function je() {
        try {
            r.texImage3D(...arguments)
        } catch (me) {
            console.error("THREE.WebGLState:", me)
        }
    }
    function Ye(me) {
        fe.equals(me) === !1 && (r.scissor(me.x, me.y, me.z, me.w),
        fe.copy(me))
    }
    function ct(me) {
        pe.equals(me) === !1 && (r.viewport(me.x, me.y, me.z, me.w),
        pe.copy(me))
    }
    function _t(me, Ee) {
        let at = f.get(Ee);
        at === void 0 && (at = new WeakMap,
        f.set(Ee, at));
        let Ct = at.get(me);
        Ct === void 0 && (Ct = r.getUniformBlockIndex(Ee, me.name),
        at.set(me, Ct))
    }
    function ut(me, Ee) {
        const Ct = f.get(Ee).get(me);
        u.get(Ee) !== Ct && (r.uniformBlockBinding(Ee, Ct, me.__bindingPointIndex),
        u.set(Ee, Ct))
    }
    function Ut() {
        r.disable(r.BLEND),
        r.disable(r.CULL_FACE),
        r.disable(r.DEPTH_TEST),
        r.disable(r.POLYGON_OFFSET_FILL),
        r.disable(r.SCISSOR_TEST),
        r.disable(r.STENCIL_TEST),
        r.disable(r.SAMPLE_ALPHA_TO_COVERAGE),
        r.blendEquation(r.FUNC_ADD),
        r.blendFunc(r.ONE, r.ZERO),
        r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO),
        r.blendColor(0, 0, 0, 0),
        r.colorMask(!0, !0, !0, !0),
        r.clearColor(0, 0, 0, 0),
        r.depthMask(!0),
        r.depthFunc(r.LESS),
        s.setReversed(!1),
        r.clearDepth(1),
        r.stencilMask(4294967295),
        r.stencilFunc(r.ALWAYS, 0, 4294967295),
        r.stencilOp(r.KEEP, r.KEEP, r.KEEP),
        r.clearStencil(0),
        r.cullFace(r.BACK),
        r.frontFace(r.CCW),
        r.polygonOffset(0, 0),
        r.activeTexture(r.TEXTURE0),
        r.bindFramebuffer(r.FRAMEBUFFER, null),
        r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
        r.bindFramebuffer(r.READ_FRAMEBUFFER, null),
        r.useProgram(null),
        r.lineWidth(1),
        r.scissor(0, 0, r.canvas.width, r.canvas.height),
        r.viewport(0, 0, r.canvas.width, r.canvas.height),
        d = {},
        se = null,
        B = {},
        g = {},
        v = new WeakMap,
        y = [],
        S = null,
        T = !1,
        M = null,
        b = null,
        A = null,
        C = null,
        R = null,
        O = null,
        L = null,
        z = new kt(0,0,0),
        I = 0,
        N = !1,
        P = null,
        Y = null,
        V = null,
        K = null,
        Z = null,
        fe.set(0, 0, r.canvas.width, r.canvas.height),
        pe.set(0, 0, r.canvas.width, r.canvas.height),
        a.reset(),
        s.reset(),
        l.reset()
    }
    return {
        buffers: {
            color: a,
            depth: s,
            stencil: l
        },
        enable: ge,
        disable: Te,
        bindFramebuffer: Ze,
        drawBuffers: ot,
        useProgram: tt,
        setBlending: Le,
        setMaterial: Ne,
        setFlipSided: Oe,
        setCullFace: le,
        setLineWidth: Pe,
        setPolygonOffset: He,
        setScissorTest: Ve,
        activeTexture: De,
        bindTexture: vt,
        unbindTexture: J,
        compressedTexImage2D: j,
        compressedTexImage3D: ve,
        texImage2D: pt,
        texImage3D: je,
        updateUBOMapping: _t,
        uniformBlockBinding: ut,
        texStorage2D: lt,
        texStorage3D: Mt,
        texSubImage2D: Be,
        texSubImage3D: we,
        compressedTexSubImage2D: Ce,
        compressedTexSubImage3D: it,
        scissor: Ye,
        viewport: ct,
        reset: Ut
    }
}
function EQ(r, e, t, n, i, a, s) {
    const l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , u = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , f = new xt
      , d = new WeakMap;
    let g;
    const v = new WeakMap;
    let y = !1;
    try {
        y = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function S(J, j) {
        return y ? new OffscreenCanvas(J,j) : ky("canvas")
    }
    function T(J, j, ve) {
        let Be = 1;
        const we = vt(J);
        if ((we.width > ve || we.height > ve) && (Be = ve / Math.max(we.width, we.height)),
        Be < 1)
            if (typeof HTMLImageElement < "u" && J instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && J instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && J instanceof ImageBitmap || typeof VideoFrame < "u" && J instanceof VideoFrame) {
                const Ce = Math.floor(Be * we.width)
                  , it = Math.floor(Be * we.height);
                g === void 0 && (g = S(Ce, it));
                const lt = j ? S(Ce, it) : g;
                return lt.width = Ce,
                lt.height = it,
                lt.getContext("2d").drawImage(J, 0, 0, Ce, it),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + we.width + "x" + we.height + ") to (" + Ce + "x" + it + ")."),
                lt
            } else
                return "data"in J && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + we.width + "x" + we.height + ")."),
                J;
        return J
    }
    function M(J) {
        return J.generateMipmaps
    }
    function b(J) {
        r.generateMipmap(J)
    }
    function A(J) {
        return J.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : J.isWebGL3DRenderTarget ? r.TEXTURE_3D : J.isWebGLArrayRenderTarget || J.isCompressedArrayTexture ? r.TEXTURE_2D_ARRAY : r.TEXTURE_2D
    }
    function C(J, j, ve, Be, we=!1) {
        if (J !== null) {
            if (r[J] !== void 0)
                return r[J];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + J + "'")
        }
        let Ce = j;
        if (j === r.RED && (ve === r.FLOAT && (Ce = r.R32F),
        ve === r.HALF_FLOAT && (Ce = r.R16F),
        ve === r.UNSIGNED_BYTE && (Ce = r.R8)),
        j === r.RED_INTEGER && (ve === r.UNSIGNED_BYTE && (Ce = r.R8UI),
        ve === r.UNSIGNED_SHORT && (Ce = r.R16UI),
        ve === r.UNSIGNED_INT && (Ce = r.R32UI),
        ve === r.BYTE && (Ce = r.R8I),
        ve === r.SHORT && (Ce = r.R16I),
        ve === r.INT && (Ce = r.R32I)),
        j === r.RG && (ve === r.FLOAT && (Ce = r.RG32F),
        ve === r.HALF_FLOAT && (Ce = r.RG16F),
        ve === r.UNSIGNED_BYTE && (Ce = r.RG8)),
        j === r.RG_INTEGER && (ve === r.UNSIGNED_BYTE && (Ce = r.RG8UI),
        ve === r.UNSIGNED_SHORT && (Ce = r.RG16UI),
        ve === r.UNSIGNED_INT && (Ce = r.RG32UI),
        ve === r.BYTE && (Ce = r.RG8I),
        ve === r.SHORT && (Ce = r.RG16I),
        ve === r.INT && (Ce = r.RG32I)),
        j === r.RGB_INTEGER && (ve === r.UNSIGNED_BYTE && (Ce = r.RGB8UI),
        ve === r.UNSIGNED_SHORT && (Ce = r.RGB16UI),
        ve === r.UNSIGNED_INT && (Ce = r.RGB32UI),
        ve === r.BYTE && (Ce = r.RGB8I),
        ve === r.SHORT && (Ce = r.RGB16I),
        ve === r.INT && (Ce = r.RGB32I)),
        j === r.RGBA_INTEGER && (ve === r.UNSIGNED_BYTE && (Ce = r.RGBA8UI),
        ve === r.UNSIGNED_SHORT && (Ce = r.RGBA16UI),
        ve === r.UNSIGNED_INT && (Ce = r.RGBA32UI),
        ve === r.BYTE && (Ce = r.RGBA8I),
        ve === r.SHORT && (Ce = r.RGBA16I),
        ve === r.INT && (Ce = r.RGBA32I)),
        j === r.RGB && (ve === r.UNSIGNED_INT_5_9_9_9_REV && (Ce = r.RGB9_E5),
        ve === r.UNSIGNED_INT_10F_11F_11F_REV && (Ce = r.R11F_G11F_B10F)),
        j === r.RGBA) {
            const it = we ? Hy : Kn.getTransfer(Be);
            ve === r.FLOAT && (Ce = r.RGBA32F),
            ve === r.HALF_FLOAT && (Ce = r.RGBA16F),
            ve === r.UNSIGNED_BYTE && (Ce = it === yi ? r.SRGB8_ALPHA8 : r.RGBA8),
            ve === r.UNSIGNED_SHORT_4_4_4_4 && (Ce = r.RGBA4),
            ve === r.UNSIGNED_SHORT_5_5_5_1 && (Ce = r.RGB5_A1)
        }
        return (Ce === r.R16F || Ce === r.R32F || Ce === r.RG16F || Ce === r.RG32F || Ce === r.RGBA16F || Ce === r.RGBA32F) && e.get("EXT_color_buffer_float"),
        Ce
    }
    function R(J, j) {
        let ve;
        return J ? j === null || j === rc || j === Eg ? ve = r.DEPTH24_STENCIL8 : j === tr ? ve = r.DEPTH32F_STENCIL8 : j === Tg && (ve = r.DEPTH24_STENCIL8,
        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : j === null || j === rc || j === Eg ? ve = r.DEPTH_COMPONENT24 : j === tr ? ve = r.DEPTH_COMPONENT32F : j === Tg && (ve = r.DEPTH_COMPONENT16),
        ve
    }
    function O(J, j) {
        return M(J) === !0 || J.isFramebufferTexture && J.minFilter !== va && J.minFilter !== fi ? Math.log2(Math.max(j.width, j.height)) + 1 : J.mipmaps !== void 0 && J.mipmaps.length > 0 ? J.mipmaps.length : J.isCompressedTexture && Array.isArray(J.image) ? j.mipmaps.length : 1
    }
    function L(J) {
        const j = J.target;
        j.removeEventListener("dispose", L),
        I(j),
        j.isVideoTexture && d.delete(j)
    }
    function z(J) {
        const j = J.target;
        j.removeEventListener("dispose", z),
        P(j)
    }
    function I(J) {
        const j = n.get(J);
        if (j.__webglInit === void 0)
            return;
        const ve = J.source
          , Be = v.get(ve);
        if (Be) {
            const we = Be[j.__cacheKey];
            we.usedTimes--,
            we.usedTimes === 0 && N(J),
            Object.keys(Be).length === 0 && v.delete(ve)
        }
        n.remove(J)
    }
    function N(J) {
        const j = n.get(J);
        r.deleteTexture(j.__webglTexture);
        const ve = J.source
          , Be = v.get(ve);
        delete Be[j.__cacheKey],
        s.memory.textures--
    }
    function P(J) {
        const j = n.get(J);
        if (J.depthTexture && (J.depthTexture.dispose(),
        n.remove(J.depthTexture)),
        J.isWebGLCubeRenderTarget)
            for (let Be = 0; Be < 6; Be++) {
                if (Array.isArray(j.__webglFramebuffer[Be]))
                    for (let we = 0; we < j.__webglFramebuffer[Be].length; we++)
                        r.deleteFramebuffer(j.__webglFramebuffer[Be][we]);
                else
                    r.deleteFramebuffer(j.__webglFramebuffer[Be]);
                j.__webglDepthbuffer && r.deleteRenderbuffer(j.__webglDepthbuffer[Be])
            }
        else {
            if (Array.isArray(j.__webglFramebuffer))
                for (let Be = 0; Be < j.__webglFramebuffer.length; Be++)
                    r.deleteFramebuffer(j.__webglFramebuffer[Be]);
            else
                r.deleteFramebuffer(j.__webglFramebuffer);
            if (j.__webglDepthbuffer && r.deleteRenderbuffer(j.__webglDepthbuffer),
            j.__webglMultisampledFramebuffer && r.deleteFramebuffer(j.__webglMultisampledFramebuffer),
            j.__webglColorRenderbuffer)
                for (let Be = 0; Be < j.__webglColorRenderbuffer.length; Be++)
                    j.__webglColorRenderbuffer[Be] && r.deleteRenderbuffer(j.__webglColorRenderbuffer[Be]);
            j.__webglDepthRenderbuffer && r.deleteRenderbuffer(j.__webglDepthRenderbuffer)
        }
        const ve = J.textures;
        for (let Be = 0, we = ve.length; Be < we; Be++) {
            const Ce = n.get(ve[Be]);
            Ce.__webglTexture && (r.deleteTexture(Ce.__webglTexture),
            s.memory.textures--),
            n.remove(ve[Be])
        }
        n.remove(J)
    }
    let Y = 0;
    function V() {
        Y = 0
    }
    function K() {
        const J = Y;
        return J >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + J + " texture units while this GPU supports only " + i.maxTextures),
        Y += 1,
        J
    }
    function Z(J) {
        const j = [];
        return j.push(J.wrapS),
        j.push(J.wrapT),
        j.push(J.wrapR || 0),
        j.push(J.magFilter),
        j.push(J.minFilter),
        j.push(J.anisotropy),
        j.push(J.internalFormat),
        j.push(J.format),
        j.push(J.type),
        j.push(J.generateMipmaps),
        j.push(J.premultiplyAlpha),
        j.push(J.flipY),
        j.push(J.unpackAlignment),
        j.push(J.colorSpace),
        j.join()
    }
    function oe(J, j) {
        const ve = n.get(J);
        if (J.isVideoTexture && Ve(J),
        J.isRenderTargetTexture === !1 && J.isExternalTexture !== !0 && J.version > 0 && ve.__version !== J.version) {
            const Be = J.image;
            if (Be === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (Be.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                ue(ve, J, j);
                return
            }
        } else
            J.isExternalTexture && (ve.__webglTexture = J.sourceTexture ? J.sourceTexture : null);
        t.bindTexture(r.TEXTURE_2D, ve.__webglTexture, r.TEXTURE0 + j)
    }
    function H(J, j) {
        const ve = n.get(J);
        if (J.isRenderTargetTexture === !1 && J.version > 0 && ve.__version !== J.version) {
            ue(ve, J, j);
            return
        }
        t.bindTexture(r.TEXTURE_2D_ARRAY, ve.__webglTexture, r.TEXTURE0 + j)
    }
    function q(J, j) {
        const ve = n.get(J);
        if (J.isRenderTargetTexture === !1 && J.version > 0 && ve.__version !== J.version) {
            ue(ve, J, j);
            return
        }
        t.bindTexture(r.TEXTURE_3D, ve.__webglTexture, r.TEXTURE0 + j)
    }
    function Q(J, j) {
        const ve = n.get(J);
        if (J.version > 0 && ve.__version !== J.version) {
            ge(ve, J, j);
            return
        }
        t.bindTexture(r.TEXTURE_CUBE_MAP, ve.__webglTexture, r.TEXTURE0 + j)
    }
    const se = {
        [By]: r.REPEAT,
        [Cr]: r.CLAMP_TO_EDGE,
        [zy]: r.MIRRORED_REPEAT
    }
      , B = {
        [va]: r.NEAREST,
        [KA]: r.NEAREST_MIPMAP_NEAREST,
        [tg]: r.NEAREST_MIPMAP_LINEAR,
        [fi]: r.LINEAR,
        [$v]: r.LINEAR_MIPMAP_NEAREST,
        [Gu]: r.LINEAR_MIPMAP_LINEAR
    }
      , W = {
        [fB]: r.NEVER,
        [vB]: r.ALWAYS,
        [hB]: r.LESS,
        [rC]: r.LEQUAL,
        [dB]: r.EQUAL,
        [gB]: r.GEQUAL,
        [pB]: r.GREATER,
        [mB]: r.NOTEQUAL
    };
    function te(J, j) {
        if (j.type === tr && e.has("OES_texture_float_linear") === !1 && (j.magFilter === fi || j.magFilter === $v || j.magFilter === tg || j.magFilter === Gu || j.minFilter === fi || j.minFilter === $v || j.minFilter === tg || j.minFilter === Gu) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
        r.texParameteri(J, r.TEXTURE_WRAP_S, se[j.wrapS]),
        r.texParameteri(J, r.TEXTURE_WRAP_T, se[j.wrapT]),
        (J === r.TEXTURE_3D || J === r.TEXTURE_2D_ARRAY) && r.texParameteri(J, r.TEXTURE_WRAP_R, se[j.wrapR]),
        r.texParameteri(J, r.TEXTURE_MAG_FILTER, B[j.magFilter]),
        r.texParameteri(J, r.TEXTURE_MIN_FILTER, B[j.minFilter]),
        j.compareFunction && (r.texParameteri(J, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE),
        r.texParameteri(J, r.TEXTURE_COMPARE_FUNC, W[j.compareFunction])),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            if (j.magFilter === va || j.minFilter !== tg && j.minFilter !== Gu || j.type === tr && e.has("OES_texture_float_linear") === !1)
                return;
            if (j.anisotropy > 1 || n.get(j).__currentAnisotropy) {
                const ve = e.get("EXT_texture_filter_anisotropic");
                r.texParameterf(J, ve.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(j.anisotropy, i.getMaxAnisotropy())),
                n.get(j).__currentAnisotropy = j.anisotropy
            }
        }
    }
    function fe(J, j) {
        let ve = !1;
        J.__webglInit === void 0 && (J.__webglInit = !0,
        j.addEventListener("dispose", L));
        const Be = j.source;
        let we = v.get(Be);
        we === void 0 && (we = {},
        v.set(Be, we));
        const Ce = Z(j);
        if (Ce !== J.__cacheKey) {
            we[Ce] === void 0 && (we[Ce] = {
                texture: r.createTexture(),
                usedTimes: 0
            },
            s.memory.textures++,
            ve = !0),
            we[Ce].usedTimes++;
            const it = we[J.__cacheKey];
            it !== void 0 && (we[J.__cacheKey].usedTimes--,
            it.usedTimes === 0 && N(j)),
            J.__cacheKey = Ce,
            J.__webglTexture = we[Ce].texture
        }
        return ve
    }
    function pe(J, j, ve) {
        return Math.floor(Math.floor(J / ve) / j)
    }
    function _e(J, j, ve, Be) {
        const Ce = J.updateRanges;
        if (Ce.length === 0)
            t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, j.width, j.height, ve, Be, j.data);
        else {
            Ce.sort( (je, Ye) => je.start - Ye.start);
            let it = 0;
            for (let je = 1; je < Ce.length; je++) {
                const Ye = Ce[it]
                  , ct = Ce[je]
                  , _t = Ye.start + Ye.count
                  , ut = pe(ct.start, j.width, 4)
                  , Ut = pe(Ye.start, j.width, 4);
                ct.start <= _t + 1 && ut === Ut && pe(ct.start + ct.count - 1, j.width, 4) === ut ? Ye.count = Math.max(Ye.count, ct.start + ct.count - Ye.start) : (++it,
                Ce[it] = ct)
            }
            Ce.length = it + 1;
            const lt = r.getParameter(r.UNPACK_ROW_LENGTH)
              , Mt = r.getParameter(r.UNPACK_SKIP_PIXELS)
              , pt = r.getParameter(r.UNPACK_SKIP_ROWS);
            r.pixelStorei(r.UNPACK_ROW_LENGTH, j.width);
            for (let je = 0, Ye = Ce.length; je < Ye; je++) {
                const ct = Ce[je]
                  , _t = Math.floor(ct.start / 4)
                  , ut = Math.ceil(ct.count / 4)
                  , Ut = _t % j.width
                  , me = Math.floor(_t / j.width)
                  , Ee = ut
                  , at = 1;
                r.pixelStorei(r.UNPACK_SKIP_PIXELS, Ut),
                r.pixelStorei(r.UNPACK_SKIP_ROWS, me),
                t.texSubImage2D(r.TEXTURE_2D, 0, Ut, me, Ee, at, ve, Be, j.data)
            }
            J.clearUpdateRanges(),
            r.pixelStorei(r.UNPACK_ROW_LENGTH, lt),
            r.pixelStorei(r.UNPACK_SKIP_PIXELS, Mt),
            r.pixelStorei(r.UNPACK_SKIP_ROWS, pt)
        }
    }
    function ue(J, j, ve) {
        let Be = r.TEXTURE_2D;
        (j.isDataArrayTexture || j.isCompressedArrayTexture) && (Be = r.TEXTURE_2D_ARRAY),
        j.isData3DTexture && (Be = r.TEXTURE_3D);
        const we = fe(J, j)
          , Ce = j.source;
        t.bindTexture(Be, J.__webglTexture, r.TEXTURE0 + ve);
        const it = n.get(Ce);
        if (Ce.version !== it.__version || we === !0) {
            t.activeTexture(r.TEXTURE0 + ve);
            const lt = Kn.getPrimaries(Kn.workingColorSpace)
              , Mt = j.colorSpace === Xc ? null : Kn.getPrimaries(j.colorSpace)
              , pt = j.colorSpace === Xc || lt === Mt ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, j.flipY),
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, j.premultiplyAlpha),
            r.pixelStorei(r.UNPACK_ALIGNMENT, j.unpackAlignment),
            r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, pt);
            let je = T(j.image, !1, i.maxTextureSize);
            je = De(j, je);
            const Ye = a.convert(j.format, j.colorSpace)
              , ct = a.convert(j.type);
            let _t = C(j.internalFormat, Ye, ct, j.colorSpace, j.isVideoTexture);
            te(Be, j);
            let ut;
            const Ut = j.mipmaps
              , me = j.isVideoTexture !== !0
              , Ee = it.__version === void 0 || we === !0
              , at = Ce.dataReady
              , Ct = O(j, je);
            if (j.isDepthTexture)
                _t = R(j.format === Ag, j.type),
                Ee && (me ? t.texStorage2D(r.TEXTURE_2D, 1, _t, je.width, je.height) : t.texImage2D(r.TEXTURE_2D, 0, _t, je.width, je.height, 0, Ye, ct, null));
            else if (j.isDataTexture)
                if (Ut.length > 0) {
                    me && Ee && t.texStorage2D(r.TEXTURE_2D, Ct, _t, Ut[0].width, Ut[0].height);
                    for (let rt = 0, Ge = Ut.length; rt < Ge; rt++)
                        ut = Ut[rt],
                        me ? at && t.texSubImage2D(r.TEXTURE_2D, rt, 0, 0, ut.width, ut.height, Ye, ct, ut.data) : t.texImage2D(r.TEXTURE_2D, rt, _t, ut.width, ut.height, 0, Ye, ct, ut.data);
                    j.generateMipmaps = !1
                } else
                    me ? (Ee && t.texStorage2D(r.TEXTURE_2D, Ct, _t, je.width, je.height),
                    at && _e(j, je, Ye, ct)) : t.texImage2D(r.TEXTURE_2D, 0, _t, je.width, je.height, 0, Ye, ct, je.data);
            else if (j.isCompressedTexture)
                if (j.isCompressedArrayTexture) {
                    me && Ee && t.texStorage3D(r.TEXTURE_2D_ARRAY, Ct, _t, Ut[0].width, Ut[0].height, je.depth);
                    for (let rt = 0, Ge = Ut.length; rt < Ge; rt++)
                        if (ut = Ut[rt],
                        j.format !== vr)
                            if (Ye !== null)
                                if (me) {
                                    if (at)
                                        if (j.layerUpdates.size > 0) {
                                            const wt = yw(ut.width, ut.height, j.format, j.type);
                                            for (const Ot of j.layerUpdates) {
                                                const Nt = ut.data.subarray(Ot * wt / ut.data.BYTES_PER_ELEMENT, (Ot + 1) * wt / ut.data.BYTES_PER_ELEMENT);
                                                t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, rt, 0, 0, Ot, ut.width, ut.height, 1, Ye, Nt)
                                            }
                                            j.clearLayerUpdates()
                                        } else
                                            t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, rt, 0, 0, 0, ut.width, ut.height, je.depth, Ye, ut.data)
                                } else
                                    t.compressedTexImage3D(r.TEXTURE_2D_ARRAY, rt, _t, ut.width, ut.height, je.depth, 0, ut.data, 0, 0);
                            else
                                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                        else
                            me ? at && t.texSubImage3D(r.TEXTURE_2D_ARRAY, rt, 0, 0, 0, ut.width, ut.height, je.depth, Ye, ct, ut.data) : t.texImage3D(r.TEXTURE_2D_ARRAY, rt, _t, ut.width, ut.height, je.depth, 0, Ye, ct, ut.data)
                } else {
                    me && Ee && t.texStorage2D(r.TEXTURE_2D, Ct, _t, Ut[0].width, Ut[0].height);
                    for (let rt = 0, Ge = Ut.length; rt < Ge; rt++)
                        ut = Ut[rt],
                        j.format !== vr ? Ye !== null ? me ? at && t.compressedTexSubImage2D(r.TEXTURE_2D, rt, 0, 0, ut.width, ut.height, Ye, ut.data) : t.compressedTexImage2D(r.TEXTURE_2D, rt, _t, ut.width, ut.height, 0, ut.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : me ? at && t.texSubImage2D(r.TEXTURE_2D, rt, 0, 0, ut.width, ut.height, Ye, ct, ut.data) : t.texImage2D(r.TEXTURE_2D, rt, _t, ut.width, ut.height, 0, Ye, ct, ut.data)
                }
            else if (j.isDataArrayTexture)
                if (me) {
                    if (Ee && t.texStorage3D(r.TEXTURE_2D_ARRAY, Ct, _t, je.width, je.height, je.depth),
                    at)
                        if (j.layerUpdates.size > 0) {
                            const rt = yw(je.width, je.height, j.format, j.type);
                            for (const Ge of j.layerUpdates) {
                                const wt = je.data.subarray(Ge * rt / je.data.BYTES_PER_ELEMENT, (Ge + 1) * rt / je.data.BYTES_PER_ELEMENT);
                                t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, Ge, je.width, je.height, 1, Ye, ct, wt)
                            }
                            j.clearLayerUpdates()
                        } else
                            t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, je.width, je.height, je.depth, Ye, ct, je.data)
                } else
                    t.texImage3D(r.TEXTURE_2D_ARRAY, 0, _t, je.width, je.height, je.depth, 0, Ye, ct, je.data);
            else if (j.isData3DTexture)
                me ? (Ee && t.texStorage3D(r.TEXTURE_3D, Ct, _t, je.width, je.height, je.depth),
                at && t.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, je.width, je.height, je.depth, Ye, ct, je.data)) : t.texImage3D(r.TEXTURE_3D, 0, _t, je.width, je.height, je.depth, 0, Ye, ct, je.data);
            else if (j.isFramebufferTexture) {
                if (Ee)
                    if (me)
                        t.texStorage2D(r.TEXTURE_2D, Ct, _t, je.width, je.height);
                    else {
                        let rt = je.width
                          , Ge = je.height;
                        for (let wt = 0; wt < Ct; wt++)
                            t.texImage2D(r.TEXTURE_2D, wt, _t, rt, Ge, 0, Ye, ct, null),
                            rt >>= 1,
                            Ge >>= 1
                    }
            } else if (Ut.length > 0) {
                if (me && Ee) {
                    const rt = vt(Ut[0]);
                    t.texStorage2D(r.TEXTURE_2D, Ct, _t, rt.width, rt.height)
                }
                for (let rt = 0, Ge = Ut.length; rt < Ge; rt++)
                    ut = Ut[rt],
                    me ? at && t.texSubImage2D(r.TEXTURE_2D, rt, 0, 0, Ye, ct, ut) : t.texImage2D(r.TEXTURE_2D, rt, _t, Ye, ct, ut);
                j.generateMipmaps = !1
            } else if (me) {
                if (Ee) {
                    const rt = vt(je);
                    t.texStorage2D(r.TEXTURE_2D, Ct, _t, rt.width, rt.height)
                }
                at && t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Ye, ct, je)
            } else
                t.texImage2D(r.TEXTURE_2D, 0, _t, Ye, ct, je);
            M(j) && b(Be),
            it.__version = Ce.version,
            j.onUpdate && j.onUpdate(j)
        }
        J.__version = j.version
    }
    function ge(J, j, ve) {
        if (j.image.length !== 6)
            return;
        const Be = fe(J, j)
          , we = j.source;
        t.bindTexture(r.TEXTURE_CUBE_MAP, J.__webglTexture, r.TEXTURE0 + ve);
        const Ce = n.get(we);
        if (we.version !== Ce.__version || Be === !0) {
            t.activeTexture(r.TEXTURE0 + ve);
            const it = Kn.getPrimaries(Kn.workingColorSpace)
              , lt = j.colorSpace === Xc ? null : Kn.getPrimaries(j.colorSpace)
              , Mt = j.colorSpace === Xc || it === lt ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, j.flipY),
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, j.premultiplyAlpha),
            r.pixelStorei(r.UNPACK_ALIGNMENT, j.unpackAlignment),
            r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, Mt);
            const pt = j.isCompressedTexture || j.image[0].isCompressedTexture
              , je = j.image[0] && j.image[0].isDataTexture
              , Ye = [];
            for (let Ge = 0; Ge < 6; Ge++)
                !pt && !je ? Ye[Ge] = T(j.image[Ge], !0, i.maxCubemapSize) : Ye[Ge] = je ? j.image[Ge].image : j.image[Ge],
                Ye[Ge] = De(j, Ye[Ge]);
            const ct = Ye[0]
              , _t = a.convert(j.format, j.colorSpace)
              , ut = a.convert(j.type)
              , Ut = C(j.internalFormat, _t, ut, j.colorSpace)
              , me = j.isVideoTexture !== !0
              , Ee = Ce.__version === void 0 || Be === !0
              , at = we.dataReady;
            let Ct = O(j, ct);
            te(r.TEXTURE_CUBE_MAP, j);
            let rt;
            if (pt) {
                me && Ee && t.texStorage2D(r.TEXTURE_CUBE_MAP, Ct, Ut, ct.width, ct.height);
                for (let Ge = 0; Ge < 6; Ge++) {
                    rt = Ye[Ge].mipmaps;
                    for (let wt = 0; wt < rt.length; wt++) {
                        const Ot = rt[wt];
                        j.format !== vr ? _t !== null ? me ? at && t.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, wt, 0, 0, Ot.width, Ot.height, _t, Ot.data) : t.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, wt, Ut, Ot.width, Ot.height, 0, Ot.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : me ? at && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, wt, 0, 0, Ot.width, Ot.height, _t, ut, Ot.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, wt, Ut, Ot.width, Ot.height, 0, _t, ut, Ot.data)
                    }
                }
            } else {
                if (rt = j.mipmaps,
                me && Ee) {
                    rt.length > 0 && Ct++;
                    const Ge = vt(Ye[0]);
                    t.texStorage2D(r.TEXTURE_CUBE_MAP, Ct, Ut, Ge.width, Ge.height)
                }
                for (let Ge = 0; Ge < 6; Ge++)
                    if (je) {
                        me ? at && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, 0, 0, 0, Ye[Ge].width, Ye[Ge].height, _t, ut, Ye[Ge].data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, 0, Ut, Ye[Ge].width, Ye[Ge].height, 0, _t, ut, Ye[Ge].data);
                        for (let wt = 0; wt < rt.length; wt++) {
                            const Nt = rt[wt].image[Ge].image;
                            me ? at && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, wt + 1, 0, 0, Nt.width, Nt.height, _t, ut, Nt.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, wt + 1, Ut, Nt.width, Nt.height, 0, _t, ut, Nt.data)
                        }
                    } else {
                        me ? at && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, 0, 0, 0, _t, ut, Ye[Ge]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, 0, Ut, _t, ut, Ye[Ge]);
                        for (let wt = 0; wt < rt.length; wt++) {
                            const Ot = rt[wt];
                            me ? at && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, wt + 1, 0, 0, _t, ut, Ot.image[Ge]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, wt + 1, Ut, _t, ut, Ot.image[Ge])
                        }
                    }
            }
            M(j) && b(r.TEXTURE_CUBE_MAP),
            Ce.__version = we.version,
            j.onUpdate && j.onUpdate(j)
        }
        J.__version = j.version
    }
    function Te(J, j, ve, Be, we, Ce) {
        const it = a.convert(ve.format, ve.colorSpace)
          , lt = a.convert(ve.type)
          , Mt = C(ve.internalFormat, it, lt, ve.colorSpace)
          , pt = n.get(j)
          , je = n.get(ve);
        if (je.__renderTarget = j,
        !pt.__hasExternalTextures) {
            const Ye = Math.max(1, j.width >> Ce)
              , ct = Math.max(1, j.height >> Ce);
            we === r.TEXTURE_3D || we === r.TEXTURE_2D_ARRAY ? t.texImage3D(we, Ce, Mt, Ye, ct, j.depth, 0, it, lt, null) : t.texImage2D(we, Ce, Mt, Ye, ct, 0, it, lt, null)
        }
        t.bindFramebuffer(r.FRAMEBUFFER, J),
        He(j) ? l.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, Be, we, je.__webglTexture, 0, Pe(j)) : (we === r.TEXTURE_2D || we >= r.TEXTURE_CUBE_MAP_POSITIVE_X && we <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, Be, we, je.__webglTexture, Ce),
        t.bindFramebuffer(r.FRAMEBUFFER, null)
    }
    function Ze(J, j, ve) {
        if (r.bindRenderbuffer(r.RENDERBUFFER, J),
        j.depthBuffer) {
            const Be = j.depthTexture
              , we = Be && Be.isDepthTexture ? Be.type : null
              , Ce = R(j.stencilBuffer, we)
              , it = j.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT
              , lt = Pe(j);
            He(j) ? l.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, lt, Ce, j.width, j.height) : ve ? r.renderbufferStorageMultisample(r.RENDERBUFFER, lt, Ce, j.width, j.height) : r.renderbufferStorage(r.RENDERBUFFER, Ce, j.width, j.height),
            r.framebufferRenderbuffer(r.FRAMEBUFFER, it, r.RENDERBUFFER, J)
        } else {
            const Be = j.textures;
            for (let we = 0; we < Be.length; we++) {
                const Ce = Be[we]
                  , it = a.convert(Ce.format, Ce.colorSpace)
                  , lt = a.convert(Ce.type)
                  , Mt = C(Ce.internalFormat, it, lt, Ce.colorSpace)
                  , pt = Pe(j);
                ve && He(j) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, pt, Mt, j.width, j.height) : He(j) ? l.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, pt, Mt, j.width, j.height) : r.renderbufferStorage(r.RENDERBUFFER, Mt, j.width, j.height)
            }
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null)
    }
    function ot(J, j) {
        if (j && j.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(r.FRAMEBUFFER, J),
        !(j.depthTexture && j.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        const Be = n.get(j.depthTexture);
        Be.__renderTarget = j,
        (!Be.__webglTexture || j.depthTexture.image.width !== j.width || j.depthTexture.image.height !== j.height) && (j.depthTexture.image.width = j.width,
        j.depthTexture.image.height = j.height,
        j.depthTexture.needsUpdate = !0),
        oe(j.depthTexture, 0);
        const we = Be.__webglTexture
          , Ce = Pe(j);
        if (j.depthTexture.format === wg)
            He(j) ? l.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, we, 0, Ce) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, we, 0);
        else if (j.depthTexture.format === Ag)
            He(j) ? l.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, we, 0, Ce) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, we, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function tt(J) {
        const j = n.get(J)
          , ve = J.isWebGLCubeRenderTarget === !0;
        if (j.__boundDepthTexture !== J.depthTexture) {
            const Be = J.depthTexture;
            if (j.__depthDisposeCallback && j.__depthDisposeCallback(),
            Be) {
                const we = () => {
                    delete j.__boundDepthTexture,
                    delete j.__depthDisposeCallback,
                    Be.removeEventListener("dispose", we)
                }
                ;
                Be.addEventListener("dispose", we),
                j.__depthDisposeCallback = we
            }
            j.__boundDepthTexture = Be
        }
        if (J.depthTexture && !j.__autoAllocateDepthBuffer) {
            if (ve)
                throw new Error("target.depthTexture not supported in Cube render targets");
            const Be = J.texture.mipmaps;
            Be && Be.length > 0 ? ot(j.__webglFramebuffer[0], J) : ot(j.__webglFramebuffer, J)
        } else if (ve) {
            j.__webglDepthbuffer = [];
            for (let Be = 0; Be < 6; Be++)
                if (t.bindFramebuffer(r.FRAMEBUFFER, j.__webglFramebuffer[Be]),
                j.__webglDepthbuffer[Be] === void 0)
                    j.__webglDepthbuffer[Be] = r.createRenderbuffer(),
                    Ze(j.__webglDepthbuffer[Be], J, !1);
                else {
                    const we = J.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT
                      , Ce = j.__webglDepthbuffer[Be];
                    r.bindRenderbuffer(r.RENDERBUFFER, Ce),
                    r.framebufferRenderbuffer(r.FRAMEBUFFER, we, r.RENDERBUFFER, Ce)
                }
        } else {
            const Be = J.texture.mipmaps;
            if (Be && Be.length > 0 ? t.bindFramebuffer(r.FRAMEBUFFER, j.__webglFramebuffer[0]) : t.bindFramebuffer(r.FRAMEBUFFER, j.__webglFramebuffer),
            j.__webglDepthbuffer === void 0)
                j.__webglDepthbuffer = r.createRenderbuffer(),
                Ze(j.__webglDepthbuffer, J, !1);
            else {
                const we = J.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT
                  , Ce = j.__webglDepthbuffer;
                r.bindRenderbuffer(r.RENDERBUFFER, Ce),
                r.framebufferRenderbuffer(r.FRAMEBUFFER, we, r.RENDERBUFFER, Ce)
            }
        }
        t.bindFramebuffer(r.FRAMEBUFFER, null)
    }
    function $e(J, j, ve) {
        const Be = n.get(J);
        j !== void 0 && Te(Be.__webglFramebuffer, J, J.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0),
        ve !== void 0 && tt(J)
    }
    function re(J) {
        const j = J.texture
          , ve = n.get(J)
          , Be = n.get(j);
        J.addEventListener("dispose", z);
        const we = J.textures
          , Ce = J.isWebGLCubeRenderTarget === !0
          , it = we.length > 1;
        if (it || (Be.__webglTexture === void 0 && (Be.__webglTexture = r.createTexture()),
        Be.__version = j.version,
        s.memory.textures++),
        Ce) {
            ve.__webglFramebuffer = [];
            for (let lt = 0; lt < 6; lt++)
                if (j.mipmaps && j.mipmaps.length > 0) {
                    ve.__webglFramebuffer[lt] = [];
                    for (let Mt = 0; Mt < j.mipmaps.length; Mt++)
                        ve.__webglFramebuffer[lt][Mt] = r.createFramebuffer()
                } else
                    ve.__webglFramebuffer[lt] = r.createFramebuffer()
        } else {
            if (j.mipmaps && j.mipmaps.length > 0) {
                ve.__webglFramebuffer = [];
                for (let lt = 0; lt < j.mipmaps.length; lt++)
                    ve.__webglFramebuffer[lt] = r.createFramebuffer()
            } else
                ve.__webglFramebuffer = r.createFramebuffer();
            if (it)
                for (let lt = 0, Mt = we.length; lt < Mt; lt++) {
                    const pt = n.get(we[lt]);
                    pt.__webglTexture === void 0 && (pt.__webglTexture = r.createTexture(),
                    s.memory.textures++)
                }
            if (J.samples > 0 && He(J) === !1) {
                ve.__webglMultisampledFramebuffer = r.createFramebuffer(),
                ve.__webglColorRenderbuffer = [],
                t.bindFramebuffer(r.FRAMEBUFFER, ve.__webglMultisampledFramebuffer);
                for (let lt = 0; lt < we.length; lt++) {
                    const Mt = we[lt];
                    ve.__webglColorRenderbuffer[lt] = r.createRenderbuffer(),
                    r.bindRenderbuffer(r.RENDERBUFFER, ve.__webglColorRenderbuffer[lt]);
                    const pt = a.convert(Mt.format, Mt.colorSpace)
                      , je = a.convert(Mt.type)
                      , Ye = C(Mt.internalFormat, pt, je, Mt.colorSpace, J.isXRRenderTarget === !0)
                      , ct = Pe(J);
                    r.renderbufferStorageMultisample(r.RENDERBUFFER, ct, Ye, J.width, J.height),
                    r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + lt, r.RENDERBUFFER, ve.__webglColorRenderbuffer[lt])
                }
                r.bindRenderbuffer(r.RENDERBUFFER, null),
                J.depthBuffer && (ve.__webglDepthRenderbuffer = r.createRenderbuffer(),
                Ze(ve.__webglDepthRenderbuffer, J, !0)),
                t.bindFramebuffer(r.FRAMEBUFFER, null)
            }
        }
        if (Ce) {
            t.bindTexture(r.TEXTURE_CUBE_MAP, Be.__webglTexture),
            te(r.TEXTURE_CUBE_MAP, j);
            for (let lt = 0; lt < 6; lt++)
                if (j.mipmaps && j.mipmaps.length > 0)
                    for (let Mt = 0; Mt < j.mipmaps.length; Mt++)
                        Te(ve.__webglFramebuffer[lt][Mt], J, j, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + lt, Mt);
                else
                    Te(ve.__webglFramebuffer[lt], J, j, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + lt, 0);
            M(j) && b(r.TEXTURE_CUBE_MAP),
            t.unbindTexture()
        } else if (it) {
            for (let lt = 0, Mt = we.length; lt < Mt; lt++) {
                const pt = we[lt]
                  , je = n.get(pt);
                let Ye = r.TEXTURE_2D;
                (J.isWebGL3DRenderTarget || J.isWebGLArrayRenderTarget) && (Ye = J.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY),
                t.bindTexture(Ye, je.__webglTexture),
                te(Ye, pt),
                Te(ve.__webglFramebuffer, J, pt, r.COLOR_ATTACHMENT0 + lt, Ye, 0),
                M(pt) && b(Ye)
            }
            t.unbindTexture()
        } else {
            let lt = r.TEXTURE_2D;
            if ((J.isWebGL3DRenderTarget || J.isWebGLArrayRenderTarget) && (lt = J.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY),
            t.bindTexture(lt, Be.__webglTexture),
            te(lt, j),
            j.mipmaps && j.mipmaps.length > 0)
                for (let Mt = 0; Mt < j.mipmaps.length; Mt++)
                    Te(ve.__webglFramebuffer[Mt], J, j, r.COLOR_ATTACHMENT0, lt, Mt);
            else
                Te(ve.__webglFramebuffer, J, j, r.COLOR_ATTACHMENT0, lt, 0);
            M(j) && b(lt),
            t.unbindTexture()
        }
        J.depthBuffer && tt(J)
    }
    function Le(J) {
        const j = J.textures;
        for (let ve = 0, Be = j.length; ve < Be; ve++) {
            const we = j[ve];
            if (M(we)) {
                const Ce = A(J)
                  , it = n.get(we).__webglTexture;
                t.bindTexture(Ce, it),
                b(Ce),
                t.unbindTexture()
            }
        }
    }
    const Ne = []
      , Oe = [];
    function le(J) {
        if (J.samples > 0) {
            if (He(J) === !1) {
                const j = J.textures
                  , ve = J.width
                  , Be = J.height;
                let we = r.COLOR_BUFFER_BIT;
                const Ce = J.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT
                  , it = n.get(J)
                  , lt = j.length > 1;
                if (lt)
                    for (let pt = 0; pt < j.length; pt++)
                        t.bindFramebuffer(r.FRAMEBUFFER, it.__webglMultisampledFramebuffer),
                        r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + pt, r.RENDERBUFFER, null),
                        t.bindFramebuffer(r.FRAMEBUFFER, it.__webglFramebuffer),
                        r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + pt, r.TEXTURE_2D, null, 0);
                t.bindFramebuffer(r.READ_FRAMEBUFFER, it.__webglMultisampledFramebuffer);
                const Mt = J.texture.mipmaps;
                Mt && Mt.length > 0 ? t.bindFramebuffer(r.DRAW_FRAMEBUFFER, it.__webglFramebuffer[0]) : t.bindFramebuffer(r.DRAW_FRAMEBUFFER, it.__webglFramebuffer);
                for (let pt = 0; pt < j.length; pt++) {
                    if (J.resolveDepthBuffer && (J.depthBuffer && (we |= r.DEPTH_BUFFER_BIT),
                    J.stencilBuffer && J.resolveStencilBuffer && (we |= r.STENCIL_BUFFER_BIT)),
                    lt) {
                        r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, it.__webglColorRenderbuffer[pt]);
                        const je = n.get(j[pt]).__webglTexture;
                        r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, je, 0)
                    }
                    r.blitFramebuffer(0, 0, ve, Be, 0, 0, ve, Be, we, r.NEAREST),
                    u === !0 && (Ne.length = 0,
                    Oe.length = 0,
                    Ne.push(r.COLOR_ATTACHMENT0 + pt),
                    J.depthBuffer && J.resolveDepthBuffer === !1 && (Ne.push(Ce),
                    Oe.push(Ce),
                    r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, Oe)),
                    r.invalidateFramebuffer(r.READ_FRAMEBUFFER, Ne))
                }
                if (t.bindFramebuffer(r.READ_FRAMEBUFFER, null),
                t.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
                lt)
                    for (let pt = 0; pt < j.length; pt++) {
                        t.bindFramebuffer(r.FRAMEBUFFER, it.__webglMultisampledFramebuffer),
                        r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + pt, r.RENDERBUFFER, it.__webglColorRenderbuffer[pt]);
                        const je = n.get(j[pt]).__webglTexture;
                        t.bindFramebuffer(r.FRAMEBUFFER, it.__webglFramebuffer),
                        r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + pt, r.TEXTURE_2D, je, 0)
                    }
                t.bindFramebuffer(r.DRAW_FRAMEBUFFER, it.__webglMultisampledFramebuffer)
            } else if (J.depthBuffer && J.resolveDepthBuffer === !1 && u) {
                const j = J.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT;
                r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [j])
            }
        }
    }
    function Pe(J) {
        return Math.min(i.maxSamples, J.samples)
    }
    function He(J) {
        const j = n.get(J);
        return J.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && j.__useRenderToTexture !== !1
    }
    function Ve(J) {
        const j = s.render.frame;
        d.get(J) !== j && (d.set(J, j),
        J.update())
    }
    function De(J, j) {
        const ve = J.colorSpace
          , Be = J.format
          , we = J.type;
        return J.isCompressedTexture === !0 || J.isVideoTexture === !0 || ve !== Jl && ve !== Xc && (Kn.getTransfer(ve) === yi ? (Be !== vr || we !== ys) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", ve)),
        j
    }
    function vt(J) {
        return typeof HTMLImageElement < "u" && J instanceof HTMLImageElement ? (f.width = J.naturalWidth || J.width,
        f.height = J.naturalHeight || J.height) : typeof VideoFrame < "u" && J instanceof VideoFrame ? (f.width = J.displayWidth,
        f.height = J.displayHeight) : (f.width = J.width,
        f.height = J.height),
        f
    }
    this.allocateTextureUnit = K,
    this.resetTextureUnits = V,
    this.setTexture2D = oe,
    this.setTexture2DArray = H,
    this.setTexture3D = q,
    this.setTextureCube = Q,
    this.rebindTextures = $e,
    this.setupRenderTarget = re,
    this.updateRenderTargetMipmap = Le,
    this.updateMultisampleRenderTarget = le,
    this.setupDepthRenderbuffer = tt,
    this.setupFrameBufferTexture = Te,
    this.useMultisampledRTT = He
}
function wz(r, e) {
    function t(n, i=Xc) {
        let a;
        const s = Kn.getTransfer(i);
        if (n === ys)
            return r.UNSIGNED_BYTE;
        if (n === oM)
            return r.UNSIGNED_SHORT_4_4_4_4;
        if (n === lM)
            return r.UNSIGNED_SHORT_5_5_5_1;
        if (n === QA)
            return r.UNSIGNED_INT_5_9_9_9_REV;
        if (n === JA)
            return r.UNSIGNED_INT_10F_11F_11F_REV;
        if (n === aM)
            return r.BYTE;
        if (n === sM)
            return r.SHORT;
        if (n === Tg)
            return r.UNSIGNED_SHORT;
        if (n === f_)
            return r.INT;
        if (n === rc)
            return r.UNSIGNED_INT;
        if (n === tr)
            return r.FLOAT;
        if (n === $r)
            return r.HALF_FLOAT;
        if (n === $A)
            return r.ALPHA;
        if (n === eC)
            return r.RGB;
        if (n === vr)
            return r.RGBA;
        if (n === wg)
            return r.DEPTH_COMPONENT;
        if (n === Ag)
            return r.DEPTH_STENCIL;
        if (n === h_)
            return r.RED;
        if (n === d_)
            return r.RED_INTEGER;
        if (n === tC)
            return r.RG;
        if (n === uM)
            return r.RG_INTEGER;
        if (n === cM)
            return r.RGBA_INTEGER;
        if (n === ey || n === ty || n === ny || n === iy)
            if (s === yi)
                if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                a !== null) {
                    if (n === ey)
                        return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (n === ty)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (n === ny)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (n === iy)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (a = e.get("WEBGL_compressed_texture_s3tc"),
            a !== null) {
                if (n === ey)
                    return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (n === ty)
                    return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (n === ny)
                    return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (n === iy)
                    return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (n === eb || n === tb || n === nb || n === ib)
            if (a = e.get("WEBGL_compressed_texture_pvrtc"),
            a !== null) {
                if (n === eb)
                    return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (n === tb)
                    return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (n === nb)
                    return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (n === ib)
                    return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (n === rb || n === ab || n === sb)
            if (a = e.get("WEBGL_compressed_texture_etc"),
            a !== null) {
                if (n === rb || n === ab)
                    return s === yi ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                if (n === sb)
                    return s === yi ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (n === ob || n === lb || n === ub || n === cb || n === fb || n === hb || n === db || n === pb || n === mb || n === gb || n === vb || n === yb || n === _b || n === xb)
            if (a = e.get("WEBGL_compressed_texture_astc"),
            a !== null) {
                if (n === ob)
                    return s === yi ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (n === lb)
                    return s === yi ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (n === ub)
                    return s === yi ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (n === cb)
                    return s === yi ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (n === fb)
                    return s === yi ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (n === hb)
                    return s === yi ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (n === db)
                    return s === yi ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (n === pb)
                    return s === yi ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (n === mb)
                    return s === yi ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (n === gb)
                    return s === yi ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (n === vb)
                    return s === yi ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (n === yb)
                    return s === yi ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (n === _b)
                    return s === yi ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (n === xb)
                    return s === yi ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (n === Sb || n === bb || n === Mb)
            if (a = e.get("EXT_texture_compression_bptc"),
            a !== null) {
                if (n === Sb)
                    return s === yi ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (n === bb)
                    return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (n === Mb)
                    return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else
                return null;
        if (n === Tb || n === Eb || n === wb || n === Ab)
            if (a = e.get("EXT_texture_compression_rgtc"),
            a !== null) {
                if (n === Tb)
                    return a.COMPRESSED_RED_RGTC1_EXT;
                if (n === Eb)
                    return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (n === wb)
                    return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (n === Ab)
                    return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return n === Eg ? r.UNSIGNED_INT_24_8 : r[n] !== void 0 ? r[n] : null
    }
    return {
        convert: t
    }
}
const wQ = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`
  , AQ = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class CQ {
    constructor() {
        this.texture = null,
        this.mesh = null,
        this.depthNear = 0,
        this.depthFar = 0
    }
    init(e, t) {
        if (this.texture === null) {
            const n = new mC(e.texture);
            (e.depthNear !== t.depthNear || e.depthFar !== t.depthFar) && (this.depthNear = e.depthNear,
            this.depthFar = e.depthFar),
            this.texture = n
        }
    }
    getMesh(e) {
        if (this.texture !== null && this.mesh === null) {
            const t = e.cameras[0].viewport
              , n = new Ks({
                vertexShader: wQ,
                fragmentShader: AQ,
                uniforms: {
                    depthColor: {
                        value: this.texture
                    },
                    depthWidth: {
                        value: t.z
                    },
                    depthHeight: {
                        value: t.w
                    }
                }
            });
            this.mesh = new Ni(new eu(20,20),n)
        }
        return this.mesh
    }
    reset() {
        this.texture = null,
        this.mesh = null
    }
    getDepthTexture() {
        return this.texture
    }
}
class RQ extends sc {
    constructor(e, t) {
        super();
        const n = this;
        let i = null
          , a = 1
          , s = null
          , l = "local-floor"
          , u = 1
          , f = null
          , d = null
          , g = null
          , v = null
          , y = null
          , S = null;
        const T = typeof XRWebGLBinding < "u"
          , M = new CQ
          , b = {}
          , A = t.getContextAttributes();
        let C = null
          , R = null;
        const O = []
          , L = []
          , z = new xt;
        let I = null;
        const N = new Jr;
        N.viewport = new Qn;
        const P = new Jr;
        P.viewport = new Qn;
        const Y = [N, P]
          , V = new gz;
        let K = null
          , Z = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(ue) {
            let ge = O[ue];
            return ge === void 0 && (ge = new xS,
            O[ue] = ge),
            ge.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(ue) {
            let ge = O[ue];
            return ge === void 0 && (ge = new xS,
            O[ue] = ge),
            ge.getGripSpace()
        }
        ,
        this.getHand = function(ue) {
            let ge = O[ue];
            return ge === void 0 && (ge = new xS,
            O[ue] = ge),
            ge.getHandSpace()
        }
        ;
        function oe(ue) {
            const ge = L.indexOf(ue.inputSource);
            if (ge === -1)
                return;
            const Te = O[ge];
            Te !== void 0 && (Te.update(ue.inputSource, ue.frame, f || s),
            Te.dispatchEvent({
                type: ue.type,
                data: ue.inputSource
            }))
        }
        function H() {
            i.removeEventListener("select", oe),
            i.removeEventListener("selectstart", oe),
            i.removeEventListener("selectend", oe),
            i.removeEventListener("squeeze", oe),
            i.removeEventListener("squeezestart", oe),
            i.removeEventListener("squeezeend", oe),
            i.removeEventListener("end", H),
            i.removeEventListener("inputsourceschange", q);
            for (let ue = 0; ue < O.length; ue++) {
                const ge = L[ue];
                ge !== null && (L[ue] = null,
                O[ue].disconnect(ge))
            }
            K = null,
            Z = null,
            M.reset();
            for (const ue in b)
                delete b[ue];
            e.setRenderTarget(C),
            y = null,
            v = null,
            g = null,
            i = null,
            R = null,
            _e.stop(),
            n.isPresenting = !1,
            e.setPixelRatio(I),
            e.setSize(z.width, z.height, !1),
            n.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(ue) {
            a = ue,
            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(ue) {
            l = ue,
            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return f || s
        }
        ,
        this.setReferenceSpace = function(ue) {
            f = ue
        }
        ,
        this.getBaseLayer = function() {
            return v !== null ? v : y
        }
        ,
        this.getBinding = function() {
            return g === null && T && (g = new XRWebGLBinding(i,t)),
            g
        }
        ,
        this.getFrame = function() {
            return S
        }
        ,
        this.getSession = function() {
            return i
        }
        ,
        this.setSession = async function(ue) {
            if (i = ue,
            i !== null) {
                if (C = e.getRenderTarget(),
                i.addEventListener("select", oe),
                i.addEventListener("selectstart", oe),
                i.addEventListener("selectend", oe),
                i.addEventListener("squeeze", oe),
                i.addEventListener("squeezestart", oe),
                i.addEventListener("squeezeend", oe),
                i.addEventListener("end", H),
                i.addEventListener("inputsourceschange", q),
                A.xrCompatible !== !0 && await t.makeXRCompatible(),
                I = e.getPixelRatio(),
                e.getSize(z),
                T && "createProjectionLayer"in XRWebGLBinding.prototype) {
                    let Te = null
                      , Ze = null
                      , ot = null;
                    A.depth && (ot = A.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                    Te = A.stencil ? Ag : wg,
                    Ze = A.stencil ? Eg : rc);
                    const tt = {
                        colorFormat: t.RGBA8,
                        depthFormat: ot,
                        scaleFactor: a
                    };
                    g = this.getBinding(),
                    v = g.createProjectionLayer(tt),
                    i.updateRenderState({
                        layers: [v]
                    }),
                    e.setPixelRatio(1),
                    e.setSize(v.textureWidth, v.textureHeight, !1),
                    R = new sl(v.textureWidth,v.textureHeight,{
                        format: vr,
                        type: ys,
                        depthTexture: new pC(v.textureWidth,v.textureHeight,Ze,void 0,void 0,void 0,void 0,void 0,void 0,Te),
                        stencilBuffer: A.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: A.antialias ? 4 : 0,
                        resolveDepthBuffer: v.ignoreDepthValues === !1,
                        resolveStencilBuffer: v.ignoreDepthValues === !1
                    })
                } else {
                    const Te = {
                        antialias: A.antialias,
                        alpha: !0,
                        depth: A.depth,
                        stencil: A.stencil,
                        framebufferScaleFactor: a
                    };
                    y = new XRWebGLLayer(i,t,Te),
                    i.updateRenderState({
                        baseLayer: y
                    }),
                    e.setPixelRatio(1),
                    e.setSize(y.framebufferWidth, y.framebufferHeight, !1),
                    R = new sl(y.framebufferWidth,y.framebufferHeight,{
                        format: vr,
                        type: ys,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: A.stencil,
                        resolveDepthBuffer: y.ignoreDepthValues === !1,
                        resolveStencilBuffer: y.ignoreDepthValues === !1
                    })
                }
                R.isXRRenderTarget = !0,
                this.setFoveation(u),
                f = null,
                s = await i.requestReferenceSpace(l),
                _e.setContext(i),
                _e.start(),
                n.isPresenting = !0,
                n.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ,
        this.getEnvironmentBlendMode = function() {
            if (i !== null)
                return i.environmentBlendMode
        }
        ,
        this.getDepthTexture = function() {
            return M.getDepthTexture()
        }
        ;
        function q(ue) {
            for (let ge = 0; ge < ue.removed.length; ge++) {
                const Te = ue.removed[ge]
                  , Ze = L.indexOf(Te);
                Ze >= 0 && (L[Ze] = null,
                O[Ze].disconnect(Te))
            }
            for (let ge = 0; ge < ue.added.length; ge++) {
                const Te = ue.added[ge];
                let Ze = L.indexOf(Te);
                if (Ze === -1) {
                    for (let tt = 0; tt < O.length; tt++)
                        if (tt >= L.length) {
                            L.push(Te),
                            Ze = tt;
                            break
                        } else if (L[tt] === null) {
                            L[tt] = Te,
                            Ze = tt;
                            break
                        }
                    if (Ze === -1)
                        break
                }
                const ot = O[Ze];
                ot && ot.connect(Te)
            }
        }
        const Q = new he
          , se = new he;
        function B(ue, ge, Te) {
            Q.setFromMatrixPosition(ge.matrixWorld),
            se.setFromMatrixPosition(Te.matrixWorld);
            const Ze = Q.distanceTo(se)
              , ot = ge.projectionMatrix.elements
              , tt = Te.projectionMatrix.elements
              , $e = ot[14] / (ot[10] - 1)
              , re = ot[14] / (ot[10] + 1)
              , Le = (ot[9] + 1) / ot[5]
              , Ne = (ot[9] - 1) / ot[5]
              , Oe = (ot[8] - 1) / ot[0]
              , le = (tt[8] + 1) / tt[0]
              , Pe = $e * Oe
              , He = $e * le
              , Ve = Ze / (-Oe + le)
              , De = Ve * -Oe;
            if (ge.matrixWorld.decompose(ue.position, ue.quaternion, ue.scale),
            ue.translateX(De),
            ue.translateZ(Ve),
            ue.matrixWorld.compose(ue.position, ue.quaternion, ue.scale),
            ue.matrixWorldInverse.copy(ue.matrixWorld).invert(),
            ot[10] === -1)
                ue.projectionMatrix.copy(ge.projectionMatrix),
                ue.projectionMatrixInverse.copy(ge.projectionMatrixInverse);
            else {
                const vt = $e + Ve
                  , J = re + Ve
                  , j = Pe - De
                  , ve = He + (Ze - De)
                  , Be = Le * re / J * vt
                  , we = Ne * re / J * vt;
                ue.projectionMatrix.makePerspective(j, ve, Be, we, vt, J),
                ue.projectionMatrixInverse.copy(ue.projectionMatrix).invert()
            }
        }
        function W(ue, ge) {
            ge === null ? ue.matrixWorld.copy(ue.matrix) : ue.matrixWorld.multiplyMatrices(ge.matrixWorld, ue.matrix),
            ue.matrixWorldInverse.copy(ue.matrixWorld).invert()
        }
        this.updateCamera = function(ue) {
            if (i === null)
                return;
            let ge = ue.near
              , Te = ue.far;
            M.texture !== null && (M.depthNear > 0 && (ge = M.depthNear),
            M.depthFar > 0 && (Te = M.depthFar)),
            V.near = P.near = N.near = ge,
            V.far = P.far = N.far = Te,
            (K !== V.near || Z !== V.far) && (i.updateRenderState({
                depthNear: V.near,
                depthFar: V.far
            }),
            K = V.near,
            Z = V.far),
            V.layers.mask = ue.layers.mask | 6,
            N.layers.mask = V.layers.mask & 3,
            P.layers.mask = V.layers.mask & 5;
            const Ze = ue.parent
              , ot = V.cameras;
            W(V, Ze);
            for (let tt = 0; tt < ot.length; tt++)
                W(ot[tt], Ze);
            ot.length === 2 ? B(V, N, P) : V.projectionMatrix.copy(N.projectionMatrix),
            te(ue, V, Ze)
        }
        ;
        function te(ue, ge, Te) {
            Te === null ? ue.matrix.copy(ge.matrixWorld) : (ue.matrix.copy(Te.matrixWorld),
            ue.matrix.invert(),
            ue.matrix.multiply(ge.matrixWorld)),
            ue.matrix.decompose(ue.position, ue.quaternion, ue.scale),
            ue.updateMatrixWorld(!0),
            ue.projectionMatrix.copy(ge.projectionMatrix),
            ue.projectionMatrixInverse.copy(ge.projectionMatrixInverse),
            ue.isPerspectiveCamera && (ue.fov = Rg * 2 * Math.atan(1 / ue.projectionMatrix.elements[5]),
            ue.zoom = 1)
        }
        this.getCamera = function() {
            return V
        }
        ,
        this.getFoveation = function() {
            if (!(v === null && y === null))
                return u
        }
        ,
        this.setFoveation = function(ue) {
            u = ue,
            v !== null && (v.fixedFoveation = ue),
            y !== null && y.fixedFoveation !== void 0 && (y.fixedFoveation = ue)
        }
        ,
        this.hasDepthSensing = function() {
            return M.texture !== null
        }
        ,
        this.getDepthSensingMesh = function() {
            return M.getMesh(V)
        }
        ,
        this.getCameraTexture = function(ue) {
            return b[ue]
        }
        ;
        let fe = null;
        function pe(ue, ge) {
            if (d = ge.getViewerPose(f || s),
            S = ge,
            d !== null) {
                const Te = d.views;
                y !== null && (e.setRenderTargetFramebuffer(R, y.framebuffer),
                e.setRenderTarget(R));
                let Ze = !1;
                Te.length !== V.cameras.length && (V.cameras.length = 0,
                Ze = !0);
                for (let re = 0; re < Te.length; re++) {
                    const Le = Te[re];
                    let Ne = null;
                    if (y !== null)
                        Ne = y.getViewport(Le);
                    else {
                        const le = g.getViewSubImage(v, Le);
                        Ne = le.viewport,
                        re === 0 && (e.setRenderTargetTextures(R, le.colorTexture, le.depthStencilTexture),
                        e.setRenderTarget(R))
                    }
                    let Oe = Y[re];
                    Oe === void 0 && (Oe = new Jr,
                    Oe.layers.enable(re),
                    Oe.viewport = new Qn,
                    Y[re] = Oe),
                    Oe.matrix.fromArray(Le.transform.matrix),
                    Oe.matrix.decompose(Oe.position, Oe.quaternion, Oe.scale),
                    Oe.projectionMatrix.fromArray(Le.projectionMatrix),
                    Oe.projectionMatrixInverse.copy(Oe.projectionMatrix).invert(),
                    Oe.viewport.set(Ne.x, Ne.y, Ne.width, Ne.height),
                    re === 0 && (V.matrix.copy(Oe.matrix),
                    V.matrix.decompose(V.position, V.quaternion, V.scale)),
                    Ze === !0 && V.cameras.push(Oe)
                }
                const ot = i.enabledFeatures;
                if (ot && ot.includes("depth-sensing") && i.depthUsage == "gpu-optimized" && T) {
                    g = n.getBinding();
                    const re = g.getDepthInformation(Te[0]);
                    re && re.isValid && re.texture && M.init(re, i.renderState)
                }
                if (ot && ot.includes("camera-access") && T) {
                    e.state.unbindTexture(),
                    g = n.getBinding();
                    for (let re = 0; re < Te.length; re++) {
                        const Le = Te[re].camera;
                        if (Le) {
                            let Ne = b[Le];
                            Ne || (Ne = new mC,
                            b[Le] = Ne);
                            const Oe = g.getCameraImage(Le);
                            Ne.sourceTexture = Oe
                        }
                    }
                }
            }
            for (let Te = 0; Te < O.length; Te++) {
                const Ze = L[Te]
                  , ot = O[Te];
                Ze !== null && ot !== void 0 && ot.update(Ze, ge, f || s)
            }
            fe && fe(ue, ge),
            ge.detectedPlanes && n.dispatchEvent({
                type: "planesdetected",
                data: ge
            }),
            S = null
        }
        const _e = new Sz;
        _e.setAnimationLoop(pe),
        this.setAnimationLoop = function(ue) {
            fe = ue
        }
        ,
        this.dispose = function() {}
    }
}
const Ud = new Co
  , DQ = new vn;
function UQ(r, e) {
    function t(M, b) {
        M.matrixAutoUpdate === !0 && M.updateMatrix(),
        b.value.copy(M.matrix)
    }
    function n(M, b) {
        b.color.getRGB(M.fogColor.value, MB(r)),
        b.isFog ? (M.fogNear.value = b.near,
        M.fogFar.value = b.far) : b.isFogExp2 && (M.fogDensity.value = b.density)
    }
    function i(M, b, A, C, R) {
        b.isMeshBasicMaterial || b.isMeshLambertMaterial ? a(M, b) : b.isMeshToonMaterial ? (a(M, b),
        g(M, b)) : b.isMeshPhongMaterial ? (a(M, b),
        d(M, b)) : b.isMeshStandardMaterial ? (a(M, b),
        v(M, b),
        b.isMeshPhysicalMaterial && y(M, b, R)) : b.isMeshMatcapMaterial ? (a(M, b),
        S(M, b)) : b.isMeshDepthMaterial ? a(M, b) : b.isMeshDistanceMaterial ? (a(M, b),
        T(M, b)) : b.isMeshNormalMaterial ? a(M, b) : b.isLineBasicMaterial ? (s(M, b),
        b.isLineDashedMaterial && l(M, b)) : b.isPointsMaterial ? u(M, b, A, C) : b.isSpriteMaterial ? f(M, b) : b.isShadowMaterial ? (M.color.value.copy(b.color),
        M.opacity.value = b.opacity) : b.isShaderMaterial && (b.uniformsNeedUpdate = !1)
    }
    function a(M, b) {
        M.opacity.value = b.opacity,
        b.color && M.diffuse.value.copy(b.color),
        b.emissive && M.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity),
        b.map && (M.map.value = b.map,
        t(b.map, M.mapTransform)),
        b.alphaMap && (M.alphaMap.value = b.alphaMap,
        t(b.alphaMap, M.alphaMapTransform)),
        b.bumpMap && (M.bumpMap.value = b.bumpMap,
        t(b.bumpMap, M.bumpMapTransform),
        M.bumpScale.value = b.bumpScale,
        b.side === vs && (M.bumpScale.value *= -1)),
        b.normalMap && (M.normalMap.value = b.normalMap,
        t(b.normalMap, M.normalMapTransform),
        M.normalScale.value.copy(b.normalScale),
        b.side === vs && M.normalScale.value.negate()),
        b.displacementMap && (M.displacementMap.value = b.displacementMap,
        t(b.displacementMap, M.displacementMapTransform),
        M.displacementScale.value = b.displacementScale,
        M.displacementBias.value = b.displacementBias),
        b.emissiveMap && (M.emissiveMap.value = b.emissiveMap,
        t(b.emissiveMap, M.emissiveMapTransform)),
        b.specularMap && (M.specularMap.value = b.specularMap,
        t(b.specularMap, M.specularMapTransform)),
        b.alphaTest > 0 && (M.alphaTest.value = b.alphaTest);
        const A = e.get(b)
          , C = A.envMap
          , R = A.envMapRotation;
        C && (M.envMap.value = C,
        Ud.copy(R),
        Ud.x *= -1,
        Ud.y *= -1,
        Ud.z *= -1,
        C.isCubeTexture && C.isRenderTargetTexture === !1 && (Ud.y *= -1,
        Ud.z *= -1),
        M.envMapRotation.value.setFromMatrix4(DQ.makeRotationFromEuler(Ud)),
        M.flipEnvMap.value = C.isCubeTexture && C.isRenderTargetTexture === !1 ? -1 : 1,
        M.reflectivity.value = b.reflectivity,
        M.ior.value = b.ior,
        M.refractionRatio.value = b.refractionRatio),
        b.lightMap && (M.lightMap.value = b.lightMap,
        M.lightMapIntensity.value = b.lightMapIntensity,
        t(b.lightMap, M.lightMapTransform)),
        b.aoMap && (M.aoMap.value = b.aoMap,
        M.aoMapIntensity.value = b.aoMapIntensity,
        t(b.aoMap, M.aoMapTransform))
    }
    function s(M, b) {
        M.diffuse.value.copy(b.color),
        M.opacity.value = b.opacity,
        b.map && (M.map.value = b.map,
        t(b.map, M.mapTransform))
    }
    function l(M, b) {
        M.dashSize.value = b.dashSize,
        M.totalSize.value = b.dashSize + b.gapSize,
        M.scale.value = b.scale
    }
    function u(M, b, A, C) {
        M.diffuse.value.copy(b.color),
        M.opacity.value = b.opacity,
        M.size.value = b.size * A,
        M.scale.value = C * .5,
        b.map && (M.map.value = b.map,
        t(b.map, M.uvTransform)),
        b.alphaMap && (M.alphaMap.value = b.alphaMap,
        t(b.alphaMap, M.alphaMapTransform)),
        b.alphaTest > 0 && (M.alphaTest.value = b.alphaTest)
    }
    function f(M, b) {
        M.diffuse.value.copy(b.color),
        M.opacity.value = b.opacity,
        M.rotation.value = b.rotation,
        b.map && (M.map.value = b.map,
        t(b.map, M.mapTransform)),
        b.alphaMap && (M.alphaMap.value = b.alphaMap,
        t(b.alphaMap, M.alphaMapTransform)),
        b.alphaTest > 0 && (M.alphaTest.value = b.alphaTest)
    }
    function d(M, b) {
        M.specular.value.copy(b.specular),
        M.shininess.value = Math.max(b.shininess, 1e-4)
    }
    function g(M, b) {
        b.gradientMap && (M.gradientMap.value = b.gradientMap)
    }
    function v(M, b) {
        M.metalness.value = b.metalness,
        b.metalnessMap && (M.metalnessMap.value = b.metalnessMap,
        t(b.metalnessMap, M.metalnessMapTransform)),
        M.roughness.value = b.roughness,
        b.roughnessMap && (M.roughnessMap.value = b.roughnessMap,
        t(b.roughnessMap, M.roughnessMapTransform)),
        b.envMap && (M.envMapIntensity.value = b.envMapIntensity)
    }
    function y(M, b, A) {
        M.ior.value = b.ior,
        b.sheen > 0 && (M.sheenColor.value.copy(b.sheenColor).multiplyScalar(b.sheen),
        M.sheenRoughness.value = b.sheenRoughness,
        b.sheenColorMap && (M.sheenColorMap.value = b.sheenColorMap,
        t(b.sheenColorMap, M.sheenColorMapTransform)),
        b.sheenRoughnessMap && (M.sheenRoughnessMap.value = b.sheenRoughnessMap,
        t(b.sheenRoughnessMap, M.sheenRoughnessMapTransform))),
        b.clearcoat > 0 && (M.clearcoat.value = b.clearcoat,
        M.clearcoatRoughness.value = b.clearcoatRoughness,
        b.clearcoatMap && (M.clearcoatMap.value = b.clearcoatMap,
        t(b.clearcoatMap, M.clearcoatMapTransform)),
        b.clearcoatRoughnessMap && (M.clearcoatRoughnessMap.value = b.clearcoatRoughnessMap,
        t(b.clearcoatRoughnessMap, M.clearcoatRoughnessMapTransform)),
        b.clearcoatNormalMap && (M.clearcoatNormalMap.value = b.clearcoatNormalMap,
        t(b.clearcoatNormalMap, M.clearcoatNormalMapTransform),
        M.clearcoatNormalScale.value.copy(b.clearcoatNormalScale),
        b.side === vs && M.clearcoatNormalScale.value.negate())),
        b.dispersion > 0 && (M.dispersion.value = b.dispersion),
        b.iridescence > 0 && (M.iridescence.value = b.iridescence,
        M.iridescenceIOR.value = b.iridescenceIOR,
        M.iridescenceThicknessMinimum.value = b.iridescenceThicknessRange[0],
        M.iridescenceThicknessMaximum.value = b.iridescenceThicknessRange[1],
        b.iridescenceMap && (M.iridescenceMap.value = b.iridescenceMap,
        t(b.iridescenceMap, M.iridescenceMapTransform)),
        b.iridescenceThicknessMap && (M.iridescenceThicknessMap.value = b.iridescenceThicknessMap,
        t(b.iridescenceThicknessMap, M.iridescenceThicknessMapTransform))),
        b.transmission > 0 && (M.transmission.value = b.transmission,
        M.transmissionSamplerMap.value = A.texture,
        M.transmissionSamplerSize.value.set(A.width, A.height),
        b.transmissionMap && (M.transmissionMap.value = b.transmissionMap,
        t(b.transmissionMap, M.transmissionMapTransform)),
        M.thickness.value = b.thickness,
        b.thicknessMap && (M.thicknessMap.value = b.thicknessMap,
        t(b.thicknessMap, M.thicknessMapTransform)),
        M.attenuationDistance.value = b.attenuationDistance,
        M.attenuationColor.value.copy(b.attenuationColor)),
        b.anisotropy > 0 && (M.anisotropyVector.value.set(b.anisotropy * Math.cos(b.anisotropyRotation), b.anisotropy * Math.sin(b.anisotropyRotation)),
        b.anisotropyMap && (M.anisotropyMap.value = b.anisotropyMap,
        t(b.anisotropyMap, M.anisotropyMapTransform))),
        M.specularIntensity.value = b.specularIntensity,
        M.specularColor.value.copy(b.specularColor),
        b.specularColorMap && (M.specularColorMap.value = b.specularColorMap,
        t(b.specularColorMap, M.specularColorMapTransform)),
        b.specularIntensityMap && (M.specularIntensityMap.value = b.specularIntensityMap,
        t(b.specularIntensityMap, M.specularIntensityMapTransform))
    }
    function S(M, b) {
        b.matcap && (M.matcap.value = b.matcap)
    }
    function T(M, b) {
        const A = e.get(b).light;
        M.referencePosition.value.setFromMatrixPosition(A.matrixWorld),
        M.nearDistance.value = A.shadow.camera.near,
        M.farDistance.value = A.shadow.camera.far
    }
    return {
        refreshFogUniforms: n,
        refreshMaterialUniforms: i
    }
}
function OQ(r, e, t, n) {
    let i = {}
      , a = {}
      , s = [];
    const l = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);
    function u(A, C) {
        const R = C.program;
        n.uniformBlockBinding(A, R)
    }
    function f(A, C) {
        let R = i[A.id];
        R === void 0 && (S(A),
        R = d(A),
        i[A.id] = R,
        A.addEventListener("dispose", M));
        const O = C.program;
        n.updateUBOMapping(A, O);
        const L = e.render.frame;
        a[A.id] !== L && (v(A),
        a[A.id] = L)
    }
    function d(A) {
        const C = g();
        A.__bindingPointIndex = C;
        const R = r.createBuffer()
          , O = A.__size
          , L = A.usage;
        return r.bindBuffer(r.UNIFORM_BUFFER, R),
        r.bufferData(r.UNIFORM_BUFFER, O, L),
        r.bindBuffer(r.UNIFORM_BUFFER, null),
        r.bindBufferBase(r.UNIFORM_BUFFER, C, R),
        R
    }
    function g() {
        for (let A = 0; A < l; A++)
            if (s.indexOf(A) === -1)
                return s.push(A),
                A;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function v(A) {
        const C = i[A.id]
          , R = A.uniforms
          , O = A.__cache;
        r.bindBuffer(r.UNIFORM_BUFFER, C);
        for (let L = 0, z = R.length; L < z; L++) {
            const I = Array.isArray(R[L]) ? R[L] : [R[L]];
            for (let N = 0, P = I.length; N < P; N++) {
                const Y = I[N];
                if (y(Y, L, N, O) === !0) {
                    const V = Y.__offset
                      , K = Array.isArray(Y.value) ? Y.value : [Y.value];
                    let Z = 0;
                    for (let oe = 0; oe < K.length; oe++) {
                        const H = K[oe]
                          , q = T(H);
                        typeof H == "number" || typeof H == "boolean" ? (Y.__data[0] = H,
                        r.bufferSubData(r.UNIFORM_BUFFER, V + Z, Y.__data)) : H.isMatrix3 ? (Y.__data[0] = H.elements[0],
                        Y.__data[1] = H.elements[1],
                        Y.__data[2] = H.elements[2],
                        Y.__data[3] = 0,
                        Y.__data[4] = H.elements[3],
                        Y.__data[5] = H.elements[4],
                        Y.__data[6] = H.elements[5],
                        Y.__data[7] = 0,
                        Y.__data[8] = H.elements[6],
                        Y.__data[9] = H.elements[7],
                        Y.__data[10] = H.elements[8],
                        Y.__data[11] = 0) : (H.toArray(Y.__data, Z),
                        Z += q.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    r.bufferSubData(r.UNIFORM_BUFFER, V, Y.__data)
                }
            }
        }
        r.bindBuffer(r.UNIFORM_BUFFER, null)
    }
    function y(A, C, R, O) {
        const L = A.value
          , z = C + "_" + R;
        if (O[z] === void 0)
            return typeof L == "number" || typeof L == "boolean" ? O[z] = L : O[z] = L.clone(),
            !0;
        {
            const I = O[z];
            if (typeof L == "number" || typeof L == "boolean") {
                if (I !== L)
                    return O[z] = L,
                    !0
            } else if (I.equals(L) === !1)
                return I.copy(L),
                !0
        }
        return !1
    }
    function S(A) {
        const C = A.uniforms;
        let R = 0;
        const O = 16;
        for (let z = 0, I = C.length; z < I; z++) {
            const N = Array.isArray(C[z]) ? C[z] : [C[z]];
            for (let P = 0, Y = N.length; P < Y; P++) {
                const V = N[P]
                  , K = Array.isArray(V.value) ? V.value : [V.value];
                for (let Z = 0, oe = K.length; Z < oe; Z++) {
                    const H = K[Z]
                      , q = T(H)
                      , Q = R % O
                      , se = Q % q.boundary
                      , B = Q + se;
                    R += se,
                    B !== 0 && O - B < q.storage && (R += O - B),
                    V.__data = new Float32Array(q.storage / Float32Array.BYTES_PER_ELEMENT),
                    V.__offset = R,
                    R += q.storage
                }
            }
        }
        const L = R % O;
        return L > 0 && (R += O - L),
        A.__size = R,
        A.__cache = {},
        this
    }
    function T(A) {
        const C = {
            boundary: 0,
            storage: 0
        };
        return typeof A == "number" || typeof A == "boolean" ? (C.boundary = 4,
        C.storage = 4) : A.isVector2 ? (C.boundary = 8,
        C.storage = 8) : A.isVector3 || A.isColor ? (C.boundary = 16,
        C.storage = 12) : A.isVector4 ? (C.boundary = 16,
        C.storage = 16) : A.isMatrix3 ? (C.boundary = 48,
        C.storage = 48) : A.isMatrix4 ? (C.boundary = 64,
        C.storage = 64) : A.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", A),
        C
    }
    function M(A) {
        const C = A.target;
        C.removeEventListener("dispose", M);
        const R = s.indexOf(C.__bindingPointIndex);
        s.splice(R, 1),
        r.deleteBuffer(i[C.id]),
        delete i[C.id],
        delete a[C.id]
    }
    function b() {
        for (const A in i)
            r.deleteBuffer(i[A]);
        s = [],
        i = {},
        a = {}
    }
    return {
        bind: u,
        update: f,
        dispose: b
    }
}
class zC {
    constructor(e={}) {
        const {canvas: t=xB(), context: n=null, depth: i=!0, stencil: a=!1, alpha: s=!1, antialias: l=!1, premultipliedAlpha: u=!0, preserveDrawingBuffer: f=!1, powerPreference: d="default", failIfMajorPerformanceCaveat: g=!1, reversedDepthBuffer: v=!1} = e;
        this.isWebGLRenderer = !0;
        let y;
        if (n !== null) {
            if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
                throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            y = n.getContextAttributes().alpha
        } else
            y = s;
        const S = new Uint32Array(4)
          , T = new Int32Array(4);
        let M = null
          , b = null;
        const A = []
          , C = [];
        this.domElement = t,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.toneMapping = Ju,
        this.toneMappingExposure = 1,
        this.transmissionResolutionScale = 1;
        const R = this;
        let O = !1;
        this._outputColorSpace = pa;
        let L = 0
          , z = 0
          , I = null
          , N = -1
          , P = null;
        const Y = new Qn
          , V = new Qn;
        let K = null;
        const Z = new kt(0);
        let oe = 0
          , H = t.width
          , q = t.height
          , Q = 1
          , se = null
          , B = null;
        const W = new Qn(0,0,H,q)
          , te = new Qn(0,0,H,q);
        let fe = !1;
        const pe = new Wg;
        let _e = !1
          , ue = !1;
        const ge = new vn
          , Te = new he
          , Ze = new Qn
          , ot = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        let tt = !1;
        function $e() {
            return I === null ? Q : 1
        }
        let re = n;
        function Le(G, ce) {
            return t.getContext(G, ce)
        }
        try {
            const G = {
                alpha: !0,
                depth: i,
                stencil: a,
                antialias: l,
                premultipliedAlpha: u,
                preserveDrawingBuffer: f,
                powerPreference: d,
                failIfMajorPerformanceCaveat: g
            };
            if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${u_}`),
            t.addEventListener("webglcontextlost", at, !1),
            t.addEventListener("webglcontextrestored", Ct, !1),
            t.addEventListener("webglcontextcreationerror", rt, !1),
            re === null) {
                const ce = "webgl2";
                if (re = Le(ce, G),
                re === null)
                    throw Le(ce) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
        } catch (G) {
            throw console.error("THREE.WebGLRenderer: " + G.message),
            G
        }
        let Ne, Oe, le, Pe, He, Ve, De, vt, J, j, ve, Be, we, Ce, it, lt, Mt, pt, je, Ye, ct, _t, ut, Ut;
        function me() {
            Ne = new XZ(re),
            Ne.init(),
            _t = new wz(re,Ne),
            Oe = new zZ(re,Ne,e,_t),
            le = new TQ(re,Ne),
            Oe.reversedDepthBuffer && v && le.buffers.depth.setReversed(!0),
            Pe = new YZ(re),
            He = new fQ,
            Ve = new EQ(re,Ne,le,He,Oe,_t,Pe),
            De = new FZ(R),
            vt = new GZ(R),
            J = new $W(re),
            ut = new PZ(re,J),
            j = new jZ(re,J,Pe,ut),
            ve = new ZZ(re,j,J,Pe),
            je = new qZ(re,Oe,Ve),
            lt = new IZ(He),
            Be = new cQ(R,De,vt,Ne,Oe,ut,lt),
            we = new UQ(R,He),
            Ce = new dQ,
            it = new _Q(Ne),
            pt = new LZ(R,De,vt,le,ve,y,u),
            Mt = new bQ(R,ve,Oe),
            Ut = new OQ(re,Pe,Oe,le),
            Ye = new BZ(re,Ne,Pe),
            ct = new WZ(re,Ne,Pe),
            Pe.programs = Be.programs,
            R.capabilities = Oe,
            R.extensions = Ne,
            R.properties = He,
            R.renderLists = Ce,
            R.shadowMap = Mt,
            R.state = le,
            R.info = Pe
        }
        me();
        const Ee = new RQ(R,re);
        this.xr = Ee,
        this.getContext = function() {
            return re
        }
        ,
        this.getContextAttributes = function() {
            return re.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const G = Ne.get("WEBGL_lose_context");
            G && G.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const G = Ne.get("WEBGL_lose_context");
            G && G.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return Q
        }
        ,
        this.setPixelRatio = function(G) {
            G !== void 0 && (Q = G,
            this.setSize(H, q, !1))
        }
        ,
        this.getSize = function(G) {
            return G.set(H, q)
        }
        ,
        this.setSize = function(G, ce, ye=!0) {
            if (Ee.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            H = G,
            q = ce,
            t.width = Math.floor(G * Q),
            t.height = Math.floor(ce * Q),
            ye === !0 && (t.style.width = G + "px",
            t.style.height = ce + "px"),
            this.setViewport(0, 0, G, ce)
        }
        ,
        this.getDrawingBufferSize = function(G) {
            return G.set(H * Q, q * Q).floor()
        }
        ,
        this.setDrawingBufferSize = function(G, ce, ye) {
            H = G,
            q = ce,
            Q = ye,
            t.width = Math.floor(G * ye),
            t.height = Math.floor(ce * ye),
            this.setViewport(0, 0, G, ce)
        }
        ,
        this.getCurrentViewport = function(G) {
            return G.copy(Y)
        }
        ,
        this.getViewport = function(G) {
            return G.copy(W)
        }
        ,
        this.setViewport = function(G, ce, ye, xe) {
            G.isVector4 ? W.set(G.x, G.y, G.z, G.w) : W.set(G, ce, ye, xe),
            le.viewport(Y.copy(W).multiplyScalar(Q).round())
        }
        ,
        this.getScissor = function(G) {
            return G.copy(te)
        }
        ,
        this.setScissor = function(G, ce, ye, xe) {
            G.isVector4 ? te.set(G.x, G.y, G.z, G.w) : te.set(G, ce, ye, xe),
            le.scissor(V.copy(te).multiplyScalar(Q).round())
        }
        ,
        this.getScissorTest = function() {
            return fe
        }
        ,
        this.setScissorTest = function(G) {
            le.setScissorTest(fe = G)
        }
        ,
        this.setOpaqueSort = function(G) {
            se = G
        }
        ,
        this.setTransparentSort = function(G) {
            B = G
        }
        ,
        this.getClearColor = function(G) {
            return G.copy(pt.getClearColor())
        }
        ,
        this.setClearColor = function() {
            pt.setClearColor(...arguments)
        }
        ,
        this.getClearAlpha = function() {
            return pt.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            pt.setClearAlpha(...arguments)
        }
        ,
        this.clear = function(G=!0, ce=!0, ye=!0) {
            let xe = 0;
            if (G) {
                let ne = !1;
                if (I !== null) {
                    const nt = I.texture.format;
                    ne = nt === cM || nt === uM || nt === d_
                }
                if (ne) {
                    const nt = I.texture.type
                      , We = nt === ys || nt === rc || nt === Tg || nt === Eg || nt === oM || nt === lM
                      , st = pt.getClearColor()
                      , ft = pt.getClearAlpha()
                      , Tt = st.r
                      , At = st.g
                      , Et = st.b;
                    We ? (S[0] = Tt,
                    S[1] = At,
                    S[2] = Et,
                    S[3] = ft,
                    re.clearBufferuiv(re.COLOR, 0, S)) : (T[0] = Tt,
                    T[1] = At,
                    T[2] = Et,
                    T[3] = ft,
                    re.clearBufferiv(re.COLOR, 0, T))
                } else
                    xe |= re.COLOR_BUFFER_BIT
            }
            ce && (xe |= re.DEPTH_BUFFER_BIT),
            ye && (xe |= re.STENCIL_BUFFER_BIT,
            this.state.buffers.stencil.setMask(4294967295)),
            re.clear(xe)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", at, !1),
            t.removeEventListener("webglcontextrestored", Ct, !1),
            t.removeEventListener("webglcontextcreationerror", rt, !1),
            pt.dispose(),
            Ce.dispose(),
            it.dispose(),
            He.dispose(),
            De.dispose(),
            vt.dispose(),
            ve.dispose(),
            ut.dispose(),
            Ut.dispose(),
            Be.dispose(),
            Ee.dispose(),
            Ee.removeEventListener("sessionstart", Gt),
            Ee.removeEventListener("sessionend", mt),
            Lt.stop()
        }
        ;
        function at(G) {
            G.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            O = !0
        }
        function Ct() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            O = !1;
            const G = Pe.autoReset
              , ce = Mt.enabled
              , ye = Mt.autoUpdate
              , xe = Mt.needsUpdate
              , ne = Mt.type;
            me(),
            Pe.autoReset = G,
            Mt.enabled = ce,
            Mt.autoUpdate = ye,
            Mt.needsUpdate = xe,
            Mt.type = ne
        }
        function rt(G) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", G.statusMessage)
        }
        function Ge(G) {
            const ce = G.target;
            ce.removeEventListener("dispose", Ge),
            wt(ce)
        }
        function wt(G) {
            Ot(G),
            He.remove(G)
        }
        function Ot(G) {
            const ce = He.get(G).programs;
            ce !== void 0 && (ce.forEach(function(ye) {
                Be.releaseProgram(ye)
            }),
            G.isShaderMaterial && Be.releaseShaderCache(G))
        }
        this.renderBufferDirect = function(G, ce, ye, xe, ne, nt) {
            ce === null && (ce = ot);
            const We = ne.isMesh && ne.matrixWorld.determinant() < 0
              , st = $(G, ce, ye, xe, ne);
            le.setMaterial(xe, We);
            let ft = ye.index
              , Tt = 1;
            if (xe.wireframe === !0) {
                if (ft = j.getWireframeAttribute(ye),
                ft === void 0)
                    return;
                Tt = 2
            }
            const At = ye.drawRange
              , Et = ye.attributes.position;
            let Xt = At.start * Tt
              , Jt = (At.start + At.count) * Tt;
            nt !== null && (Xt = Math.max(Xt, nt.start * Tt),
            Jt = Math.min(Jt, (nt.start + nt.count) * Tt)),
            ft !== null ? (Xt = Math.max(Xt, 0),
            Jt = Math.min(Jt, ft.count)) : Et != null && (Xt = Math.max(Xt, 0),
            Jt = Math.min(Jt, Et.count));
            const en = Jt - Xt;
            if (en < 0 || en === 1 / 0)
                return;
            ut.setup(ne, xe, st, ye, ft);
            let Sn, Vt = Ye;
            if (ft !== null && (Sn = J.get(ft),
            Vt = ct,
            Vt.setIndex(Sn)),
            ne.isMesh)
                xe.wireframe === !0 ? (le.setLineWidth(xe.wireframeLinewidth * $e()),
                Vt.setMode(re.LINES)) : Vt.setMode(re.TRIANGLES);
            else if (ne.isLine) {
                let It = xe.linewidth;
                It === void 0 && (It = 1),
                le.setLineWidth(It * $e()),
                ne.isLineSegments ? Vt.setMode(re.LINES) : ne.isLineLoop ? Vt.setMode(re.LINE_LOOP) : Vt.setMode(re.LINE_STRIP)
            } else
                ne.isPoints ? Vt.setMode(re.POINTS) : ne.isSprite && Vt.setMode(re.TRIANGLES);
            if (ne.isBatchedMesh)
                if (ne._multiDrawInstances !== null)
                    Gy("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),
                    Vt.renderMultiDrawInstances(ne._multiDrawStarts, ne._multiDrawCounts, ne._multiDrawCount, ne._multiDrawInstances);
                else if (Ne.get("WEBGL_multi_draw"))
                    Vt.renderMultiDraw(ne._multiDrawStarts, ne._multiDrawCounts, ne._multiDrawCount);
                else {
                    const It = ne._multiDrawStarts
                      , Cn = ne._multiDrawCounts
                      , fn = ne._multiDrawCount
                      , In = ft ? J.get(ft).bytesPerElement : 1
                      , xn = He.get(xe).currentProgram.getUniforms();
                    for (let Bn = 0; Bn < fn; Bn++)
                        xn.setValue(re, "_gl_DrawID", Bn),
                        Vt.render(It[Bn] / In, Cn[Bn])
                }
            else if (ne.isInstancedMesh)
                Vt.renderInstances(Xt, en, ne.count);
            else if (ye.isInstancedBufferGeometry) {
                const It = ye._maxInstanceCount !== void 0 ? ye._maxInstanceCount : 1 / 0
                  , Cn = Math.min(ye.instanceCount, It);
                Vt.renderInstances(Xt, en, Cn)
            } else
                Vt.render(Xt, en)
        }
        ;
        function Nt(G, ce, ye) {
            G.transparent === !0 && G.side === tl && G.forceSinglePass === !1 ? (G.side = vs,
            G.needsUpdate = !0,
            un(G, ce, ye),
            G.side = tf,
            G.needsUpdate = !0,
            un(G, ce, ye),
            G.side = tl) : un(G, ce, ye)
        }
        this.compile = function(G, ce, ye=null) {
            ye === null && (ye = G),
            b = it.get(ye),
            b.init(ce),
            C.push(b),
            ye.traverseVisible(function(ne) {
                ne.isLight && ne.layers.test(ce.layers) && (b.pushLight(ne),
                ne.castShadow && b.pushShadow(ne))
            }),
            G !== ye && G.traverseVisible(function(ne) {
                ne.isLight && ne.layers.test(ce.layers) && (b.pushLight(ne),
                ne.castShadow && b.pushShadow(ne))
            }),
            b.setupLights();
            const xe = new Set;
            return G.traverse(function(ne) {
                if (!(ne.isMesh || ne.isPoints || ne.isLine || ne.isSprite))
                    return;
                const nt = ne.material;
                if (nt)
                    if (Array.isArray(nt))
                        for (let We = 0; We < nt.length; We++) {
                            const st = nt[We];
                            Nt(st, ye, ne),
                            xe.add(st)
                        }
                    else
                        Nt(nt, ye, ne),
                        xe.add(nt)
            }),
            b = C.pop(),
            xe
        }
        ,
        this.compileAsync = function(G, ce, ye=null) {
            const xe = this.compile(G, ce, ye);
            return new Promise(ne => {
                function nt() {
                    if (xe.forEach(function(We) {
                        He.get(We).currentProgram.isReady() && xe.delete(We)
                    }),
                    xe.size === 0) {
                        ne(G);
                        return
                    }
                    setTimeout(nt, 10)
                }
                Ne.get("KHR_parallel_shader_compile") !== null ? nt() : setTimeout(nt, 10)
            }
            )
        }
        ;
        let bt = null;
        function Bt(G) {
            bt && bt(G)
        }
        function Gt() {
            Lt.stop()
        }
        function mt() {
            Lt.start()
        }
        const Lt = new Sz;
        Lt.setAnimationLoop(Bt),
        typeof self < "u" && Lt.setContext(self),
        this.setAnimationLoop = function(G) {
            bt = G,
            Ee.setAnimationLoop(G),
            G === null ? Lt.stop() : Lt.start()
        }
        ,
        Ee.addEventListener("sessionstart", Gt),
        Ee.addEventListener("sessionend", mt),
        this.render = function(G, ce) {
            if (ce !== void 0 && ce.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (O === !0)
                return;
            if (G.matrixWorldAutoUpdate === !0 && G.updateMatrixWorld(),
            ce.parent === null && ce.matrixWorldAutoUpdate === !0 && ce.updateMatrixWorld(),
            Ee.enabled === !0 && Ee.isPresenting === !0 && (Ee.cameraAutoUpdate === !0 && Ee.updateCamera(ce),
            ce = Ee.getCamera()),
            G.isScene === !0 && G.onBeforeRender(R, G, ce, I),
            b = it.get(G, C.length),
            b.init(ce),
            C.push(b),
            ge.multiplyMatrices(ce.projectionMatrix, ce.matrixWorldInverse),
            pe.setFromProjectionMatrix(ge, bo, ce.reversedDepth),
            ue = this.localClippingEnabled,
            _e = lt.init(this.clippingPlanes, ue),
            M = Ce.get(G, A.length),
            M.init(),
            A.push(M),
            Ee.enabled === !0 && Ee.isPresenting === !0) {
                const nt = R.xr.getDepthSensingMesh();
                nt !== null && zt(nt, ce, -1 / 0, R.sortObjects)
            }
            zt(G, ce, 0, R.sortObjects),
            M.finish(),
            R.sortObjects === !0 && M.sort(se, B),
            tt = Ee.enabled === !1 || Ee.isPresenting === !1 || Ee.hasDepthSensing() === !1,
            tt && pt.addToRenderList(M, G),
            this.info.render.frame++,
            _e === !0 && lt.beginShadows();
            const ye = b.state.shadowsArray;
            Mt.render(ye, G, ce),
            _e === !0 && lt.endShadows(),
            this.info.autoReset === !0 && this.info.reset();
            const xe = M.opaque
              , ne = M.transmissive;
            if (b.setupLights(),
            ce.isArrayCamera) {
                const nt = ce.cameras;
                if (ne.length > 0)
                    for (let We = 0, st = nt.length; We < st; We++) {
                        const ft = nt[We];
                        Ln(xe, ne, G, ft)
                    }
                tt && pt.render(G);
                for (let We = 0, st = nt.length; We < st; We++) {
                    const ft = nt[We];
                    Wt(M, G, ft, ft.viewport)
                }
            } else
                ne.length > 0 && Ln(xe, ne, G, ce),
                tt && pt.render(G),
                Wt(M, G, ce);
            I !== null && z === 0 && (Ve.updateMultisampleRenderTarget(I),
            Ve.updateRenderTargetMipmap(I)),
            G.isScene === !0 && G.onAfterRender(R, G, ce),
            ut.resetDefaultState(),
            N = -1,
            P = null,
            C.pop(),
            C.length > 0 ? (b = C[C.length - 1],
            _e === !0 && lt.setGlobalState(R.clippingPlanes, b.state.camera)) : b = null,
            A.pop(),
            A.length > 0 ? M = A[A.length - 1] : M = null
        }
        ;
        function zt(G, ce, ye, xe) {
            if (G.visible === !1)
                return;
            if (G.layers.test(ce.layers)) {
                if (G.isGroup)
                    ye = G.renderOrder;
                else if (G.isLOD)
                    G.autoUpdate === !0 && G.update(ce);
                else if (G.isLight)
                    b.pushLight(G),
                    G.castShadow && b.pushShadow(G);
                else if (G.isSprite) {
                    if (!G.frustumCulled || pe.intersectsSprite(G)) {
                        xe && Ze.setFromMatrixPosition(G.matrixWorld).applyMatrix4(ge);
                        const We = ve.update(G)
                          , st = G.material;
                        st.visible && M.push(G, We, st, ye, Ze.z, null)
                    }
                } else if ((G.isMesh || G.isLine || G.isPoints) && (!G.frustumCulled || pe.intersectsObject(G))) {
                    const We = ve.update(G)
                      , st = G.material;
                    if (xe && (G.boundingSphere !== void 0 ? (G.boundingSphere === null && G.computeBoundingSphere(),
                    Ze.copy(G.boundingSphere.center)) : (We.boundingSphere === null && We.computeBoundingSphere(),
                    Ze.copy(We.boundingSphere.center)),
                    Ze.applyMatrix4(G.matrixWorld).applyMatrix4(ge)),
                    Array.isArray(st)) {
                        const ft = We.groups;
                        for (let Tt = 0, At = ft.length; Tt < At; Tt++) {
                            const Et = ft[Tt]
                              , Xt = st[Et.materialIndex];
                            Xt && Xt.visible && M.push(G, We, Xt, ye, Ze.z, Et)
                        }
                    } else
                        st.visible && M.push(G, We, st, ye, Ze.z, null)
                }
            }
            const nt = G.children;
            for (let We = 0, st = nt.length; We < st; We++)
                zt(nt[We], ce, ye, xe)
        }
        function Wt(G, ce, ye, xe) {
            const ne = G.opaque
              , nt = G.transmissive
              , We = G.transparent;
            b.setupLightsView(ye),
            _e === !0 && lt.setGlobalState(R.clippingPlanes, ye),
            xe && le.viewport(Y.copy(xe)),
            ne.length > 0 && qt(ne, ce, ye),
            nt.length > 0 && qt(nt, ce, ye),
            We.length > 0 && qt(We, ce, ye),
            le.buffers.depth.setTest(!0),
            le.buffers.depth.setMask(!0),
            le.buffers.color.setMask(!0),
            le.setPolygonOffset(!1)
        }
        function Ln(G, ce, ye, xe) {
            if ((ye.isScene === !0 ? ye.overrideMaterial : null) !== null)
                return;
            b.state.transmissionRenderTarget[xe.id] === void 0 && (b.state.transmissionRenderTarget[xe.id] = new sl(1,1,{
                generateMipmaps: !0,
                type: Ne.has("EXT_color_buffer_half_float") || Ne.has("EXT_color_buffer_float") ? $r : ys,
                minFilter: Gu,
                samples: 4,
                stencilBuffer: a,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: Kn.workingColorSpace
            }));
            const nt = b.state.transmissionRenderTarget[xe.id]
              , We = xe.viewport || Y;
            nt.setSize(We.z * R.transmissionResolutionScale, We.w * R.transmissionResolutionScale);
            const st = R.getRenderTarget()
              , ft = R.getActiveCubeFace()
              , Tt = R.getActiveMipmapLevel();
            R.setRenderTarget(nt),
            R.getClearColor(Z),
            oe = R.getClearAlpha(),
            oe < 1 && R.setClearColor(16777215, .5),
            R.clear(),
            tt && pt.render(ye);
            const At = R.toneMapping;
            R.toneMapping = Ju;
            const Et = xe.viewport;
            if (xe.viewport !== void 0 && (xe.viewport = void 0),
            b.setupLightsView(xe),
            _e === !0 && lt.setGlobalState(R.clippingPlanes, xe),
            qt(G, ye, xe),
            Ve.updateMultisampleRenderTarget(nt),
            Ve.updateRenderTargetMipmap(nt),
            Ne.has("WEBGL_multisampled_render_to_texture") === !1) {
                let Xt = !1;
                for (let Jt = 0, en = ce.length; Jt < en; Jt++) {
                    const Sn = ce[Jt]
                      , Vt = Sn.object
                      , It = Sn.geometry
                      , Cn = Sn.material
                      , fn = Sn.group;
                    if (Cn.side === tl && Vt.layers.test(xe.layers)) {
                        const In = Cn.side;
                        Cn.side = vs,
                        Cn.needsUpdate = !0,
                        Pt(Vt, ye, xe, It, Cn, fn),
                        Cn.side = In,
                        Cn.needsUpdate = !0,
                        Xt = !0
                    }
                }
                Xt === !0 && (Ve.updateMultisampleRenderTarget(nt),
                Ve.updateRenderTargetMipmap(nt))
            }
            R.setRenderTarget(st, ft, Tt),
            R.setClearColor(Z, oe),
            Et !== void 0 && (xe.viewport = Et),
            R.toneMapping = At
        }
        function qt(G, ce, ye) {
            const xe = ce.isScene === !0 ? ce.overrideMaterial : null;
            for (let ne = 0, nt = G.length; ne < nt; ne++) {
                const We = G[ne]
                  , st = We.object
                  , ft = We.geometry
                  , Tt = We.group;
                let At = We.material;
                At.allowOverride === !0 && xe !== null && (At = xe),
                st.layers.test(ye.layers) && Pt(st, ce, ye, ft, At, Tt)
            }
        }
        function Pt(G, ce, ye, xe, ne, nt) {
            G.onBeforeRender(R, ce, ye, xe, ne, nt),
            G.modelViewMatrix.multiplyMatrices(ye.matrixWorldInverse, G.matrixWorld),
            G.normalMatrix.getNormalMatrix(G.modelViewMatrix),
            ne.onBeforeRender(R, ce, ye, xe, G, nt),
            ne.transparent === !0 && ne.side === tl && ne.forceSinglePass === !1 ? (ne.side = vs,
            ne.needsUpdate = !0,
            R.renderBufferDirect(ye, ce, xe, ne, G, nt),
            ne.side = tf,
            ne.needsUpdate = !0,
            R.renderBufferDirect(ye, ce, xe, ne, G, nt),
            ne.side = tl) : R.renderBufferDirect(ye, ce, xe, ne, G, nt),
            G.onAfterRender(R, ce, ye, xe, ne, nt)
        }
        function un(G, ce, ye) {
            ce.isScene !== !0 && (ce = ot);
            const xe = He.get(G)
              , ne = b.state.lights
              , nt = b.state.shadowsArray
              , We = ne.state.version
              , st = Be.getParameters(G, ne.state, nt, ce, ye)
              , ft = Be.getProgramCacheKey(st);
            let Tt = xe.programs;
            xe.environment = G.isMeshStandardMaterial ? ce.environment : null,
            xe.fog = ce.fog,
            xe.envMap = (G.isMeshStandardMaterial ? vt : De).get(G.envMap || xe.environment),
            xe.envMapRotation = xe.environment !== null && G.envMap === null ? ce.environmentRotation : G.envMapRotation,
            Tt === void 0 && (G.addEventListener("dispose", Ge),
            Tt = new Map,
            xe.programs = Tt);
            let At = Tt.get(ft);
            if (At !== void 0) {
                if (xe.currentProgram === At && xe.lightsStateVersion === We)
                    return k(G, st),
                    At
            } else
                st.uniforms = Be.getUniforms(G),
                G.onBeforeCompile(st, R),
                At = Be.acquireProgram(st, ft),
                Tt.set(ft, At),
                xe.uniforms = st.uniforms;
            const Et = xe.uniforms;
            return (!G.isShaderMaterial && !G.isRawShaderMaterial || G.clipping === !0) && (Et.clippingPlanes = lt.uniform),
            k(G, st),
            xe.needsLights = Ue(G),
            xe.lightsStateVersion = We,
            xe.needsLights && (Et.ambientLightColor.value = ne.state.ambient,
            Et.lightProbe.value = ne.state.probe,
            Et.directionalLights.value = ne.state.directional,
            Et.directionalLightShadows.value = ne.state.directionalShadow,
            Et.spotLights.value = ne.state.spot,
            Et.spotLightShadows.value = ne.state.spotShadow,
            Et.rectAreaLights.value = ne.state.rectArea,
            Et.ltc_1.value = ne.state.rectAreaLTC1,
            Et.ltc_2.value = ne.state.rectAreaLTC2,
            Et.pointLights.value = ne.state.point,
            Et.pointLightShadows.value = ne.state.pointShadow,
            Et.hemisphereLights.value = ne.state.hemi,
            Et.directionalShadowMap.value = ne.state.directionalShadowMap,
            Et.directionalShadowMatrix.value = ne.state.directionalShadowMatrix,
            Et.spotShadowMap.value = ne.state.spotShadowMap,
            Et.spotLightMatrix.value = ne.state.spotLightMatrix,
            Et.spotLightMap.value = ne.state.spotLightMap,
            Et.pointShadowMap.value = ne.state.pointShadowMap,
            Et.pointShadowMatrix.value = ne.state.pointShadowMatrix),
            xe.currentProgram = At,
            xe.uniformsList = null,
            At
        }
        function $t(G) {
            if (G.uniformsList === null) {
                const ce = G.currentProgram.getUniforms();
                G.uniformsList = SS.seqWithValue(ce.seq, G.uniforms)
            }
            return G.uniformsList
        }
        function k(G, ce) {
            const ye = He.get(G);
            ye.outputColorSpace = ce.outputColorSpace,
            ye.batching = ce.batching,
            ye.batchingColor = ce.batchingColor,
            ye.instancing = ce.instancing,
            ye.instancingColor = ce.instancingColor,
            ye.instancingMorph = ce.instancingMorph,
            ye.skinning = ce.skinning,
            ye.morphTargets = ce.morphTargets,
            ye.morphNormals = ce.morphNormals,
            ye.morphColors = ce.morphColors,
            ye.morphTargetsCount = ce.morphTargetsCount,
            ye.numClippingPlanes = ce.numClippingPlanes,
            ye.numIntersection = ce.numClipIntersection,
            ye.vertexAlphas = ce.vertexAlphas,
            ye.vertexTangents = ce.vertexTangents,
            ye.toneMapping = ce.toneMapping
        }
        function $(G, ce, ye, xe, ne) {
            ce.isScene !== !0 && (ce = ot),
            Ve.resetTextureUnits();
            const nt = ce.fog
              , We = xe.isMeshStandardMaterial ? ce.environment : null
              , st = I === null ? R.outputColorSpace : I.isXRRenderTarget === !0 ? I.texture.colorSpace : Jl
              , ft = (xe.isMeshStandardMaterial ? vt : De).get(xe.envMap || We)
              , Tt = xe.vertexColors === !0 && !!ye.attributes.color && ye.attributes.color.itemSize === 4
              , At = !!ye.attributes.tangent && (!!xe.normalMap || xe.anisotropy > 0)
              , Et = !!ye.morphAttributes.position
              , Xt = !!ye.morphAttributes.normal
              , Jt = !!ye.morphAttributes.color;
            let en = Ju;
            xe.toneMapped && (I === null || I.isXRRenderTarget === !0) && (en = R.toneMapping);
            const Sn = ye.morphAttributes.position || ye.morphAttributes.normal || ye.morphAttributes.color
              , Vt = Sn !== void 0 ? Sn.length : 0
              , It = He.get(xe)
              , Cn = b.state.lights;
            if (_e === !0 && (ue === !0 || G !== P)) {
                const bn = G === P && xe.id === N;
                lt.setState(xe, G, bn)
            }
            let fn = !1;
            xe.version === It.__version ? (It.needsLights && It.lightsStateVersion !== Cn.state.version || It.outputColorSpace !== st || ne.isBatchedMesh && It.batching === !1 || !ne.isBatchedMesh && It.batching === !0 || ne.isBatchedMesh && It.batchingColor === !0 && ne.colorTexture === null || ne.isBatchedMesh && It.batchingColor === !1 && ne.colorTexture !== null || ne.isInstancedMesh && It.instancing === !1 || !ne.isInstancedMesh && It.instancing === !0 || ne.isSkinnedMesh && It.skinning === !1 || !ne.isSkinnedMesh && It.skinning === !0 || ne.isInstancedMesh && It.instancingColor === !0 && ne.instanceColor === null || ne.isInstancedMesh && It.instancingColor === !1 && ne.instanceColor !== null || ne.isInstancedMesh && It.instancingMorph === !0 && ne.morphTexture === null || ne.isInstancedMesh && It.instancingMorph === !1 && ne.morphTexture !== null || It.envMap !== ft || xe.fog === !0 && It.fog !== nt || It.numClippingPlanes !== void 0 && (It.numClippingPlanes !== lt.numPlanes || It.numIntersection !== lt.numIntersection) || It.vertexAlphas !== Tt || It.vertexTangents !== At || It.morphTargets !== Et || It.morphNormals !== Xt || It.morphColors !== Jt || It.toneMapping !== en || It.morphTargetsCount !== Vt) && (fn = !0) : (fn = !0,
            It.__version = xe.version);
            let In = It.currentProgram;
            fn === !0 && (In = un(xe, ce, ne));
            let xn = !1
              , Bn = !1
              , hn = !1;
            const Yt = In.getUniforms()
              , ti = It.uniforms;
            if (le.useProgram(In.program) && (xn = !0,
            Bn = !0,
            hn = !0),
            xe.id !== N && (N = xe.id,
            Bn = !0),
            xn || P !== G) {
                le.buffers.depth.getReversed() && G.reversedDepth !== !0 && (G._reversedDepth = !0,
                G.updateProjectionMatrix()),
                Yt.setValue(re, "projectionMatrix", G.projectionMatrix),
                Yt.setValue(re, "viewMatrix", G.matrixWorldInverse);
                const ui = Yt.map.cameraPosition;
                ui !== void 0 && ui.setValue(re, Te.setFromMatrixPosition(G.matrixWorld)),
                Oe.logarithmicDepthBuffer && Yt.setValue(re, "logDepthBufFC", 2 / (Math.log(G.far + 1) / Math.LN2)),
                (xe.isMeshPhongMaterial || xe.isMeshToonMaterial || xe.isMeshLambertMaterial || xe.isMeshBasicMaterial || xe.isMeshStandardMaterial || xe.isShaderMaterial) && Yt.setValue(re, "isOrthographic", G.isOrthographicCamera === !0),
                P !== G && (P = G,
                Bn = !0,
                hn = !0)
            }
            if (ne.isSkinnedMesh) {
                Yt.setOptional(re, ne, "bindMatrix"),
                Yt.setOptional(re, ne, "bindMatrixInverse");
                const bn = ne.skeleton;
                bn && (bn.boneTexture === null && bn.computeBoneTexture(),
                Yt.setValue(re, "boneTexture", bn.boneTexture, Ve))
            }
            ne.isBatchedMesh && (Yt.setOptional(re, ne, "batchingTexture"),
            Yt.setValue(re, "batchingTexture", ne._matricesTexture, Ve),
            Yt.setOptional(re, ne, "batchingIdTexture"),
            Yt.setValue(re, "batchingIdTexture", ne._indirectTexture, Ve),
            Yt.setOptional(re, ne, "batchingColorTexture"),
            ne._colorsTexture !== null && Yt.setValue(re, "batchingColorTexture", ne._colorsTexture, Ve));
            const ri = ye.morphAttributes;
            if ((ri.position !== void 0 || ri.normal !== void 0 || ri.color !== void 0) && je.update(ne, ye, In),
            (Bn || It.receiveShadow !== ne.receiveShadow) && (It.receiveShadow = ne.receiveShadow,
            Yt.setValue(re, "receiveShadow", ne.receiveShadow)),
            xe.isMeshGouraudMaterial && xe.envMap !== null && (ti.envMap.value = ft,
            ti.flipEnvMap.value = ft.isCubeTexture && ft.isRenderTargetTexture === !1 ? -1 : 1),
            xe.isMeshStandardMaterial && xe.envMap === null && ce.environment !== null && (ti.envMapIntensity.value = ce.environmentIntensity),
            Bn && (Yt.setValue(re, "toneMappingExposure", R.toneMappingExposure),
            It.needsLights && Se(ti, hn),
            nt && xe.fog === !0 && we.refreshFogUniforms(ti, nt),
            we.refreshMaterialUniforms(ti, xe, Q, q, b.state.transmissionRenderTarget[G.id]),
            SS.upload(re, $t(It), ti, Ve)),
            xe.isShaderMaterial && xe.uniformsNeedUpdate === !0 && (SS.upload(re, $t(It), ti, Ve),
            xe.uniformsNeedUpdate = !1),
            xe.isSpriteMaterial && Yt.setValue(re, "center", ne.center),
            Yt.setValue(re, "modelViewMatrix", ne.modelViewMatrix),
            Yt.setValue(re, "normalMatrix", ne.normalMatrix),
            Yt.setValue(re, "modelMatrix", ne.matrixWorld),
            xe.isShaderMaterial || xe.isRawShaderMaterial) {
                const bn = xe.uniformsGroups;
                for (let ui = 0, Ss = bn.length; ui < Ss; ui++) {
                    const Di = bn[ui];
                    Ut.update(Di, In),
                    Ut.bind(Di, In)
                }
            }
            return In
        }
        function Se(G, ce) {
            G.ambientLightColor.needsUpdate = ce,
            G.lightProbe.needsUpdate = ce,
            G.directionalLights.needsUpdate = ce,
            G.directionalLightShadows.needsUpdate = ce,
            G.pointLights.needsUpdate = ce,
            G.pointLightShadows.needsUpdate = ce,
            G.spotLights.needsUpdate = ce,
            G.spotLightShadows.needsUpdate = ce,
            G.rectAreaLights.needsUpdate = ce,
            G.hemisphereLights.needsUpdate = ce
        }
        function Ue(G) {
            return G.isMeshLambertMaterial || G.isMeshToonMaterial || G.isMeshPhongMaterial || G.isMeshStandardMaterial || G.isShadowMaterial || G.isShaderMaterial && G.lights === !0
        }
        this.getActiveCubeFace = function() {
            return L
        }
        ,
        this.getActiveMipmapLevel = function() {
            return z
        }
        ,
        this.getRenderTarget = function() {
            return I
        }
        ,
        this.setRenderTargetTextures = function(G, ce, ye) {
            const xe = He.get(G);
            xe.__autoAllocateDepthBuffer = G.resolveDepthBuffer === !1,
            xe.__autoAllocateDepthBuffer === !1 && (xe.__useRenderToTexture = !1),
            He.get(G.texture).__webglTexture = ce,
            He.get(G.depthTexture).__webglTexture = xe.__autoAllocateDepthBuffer ? void 0 : ye,
            xe.__hasExternalTextures = !0
        }
        ,
        this.setRenderTargetFramebuffer = function(G, ce) {
            const ye = He.get(G);
            ye.__webglFramebuffer = ce,
            ye.__useDefaultFramebuffer = ce === void 0
        }
        ;
        const Fe = re.createFramebuffer();
        this.setRenderTarget = function(G, ce=0, ye=0) {
            I = G,
            L = ce,
            z = ye;
            let xe = !0
              , ne = null
              , nt = !1
              , We = !1;
            if (G) {
                const ft = He.get(G);
                if (ft.__useDefaultFramebuffer !== void 0)
                    le.bindFramebuffer(re.FRAMEBUFFER, null),
                    xe = !1;
                else if (ft.__webglFramebuffer === void 0)
                    Ve.setupRenderTarget(G);
                else if (ft.__hasExternalTextures)
                    Ve.rebindTextures(G, He.get(G.texture).__webglTexture, He.get(G.depthTexture).__webglTexture);
                else if (G.depthBuffer) {
                    const Et = G.depthTexture;
                    if (ft.__boundDepthTexture !== Et) {
                        if (Et !== null && He.has(Et) && (G.width !== Et.image.width || G.height !== Et.image.height))
                            throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                        Ve.setupDepthRenderbuffer(G)
                    }
                }
                const Tt = G.texture;
                (Tt.isData3DTexture || Tt.isDataArrayTexture || Tt.isCompressedArrayTexture) && (We = !0);
                const At = He.get(G).__webglFramebuffer;
                G.isWebGLCubeRenderTarget ? (Array.isArray(At[ce]) ? ne = At[ce][ye] : ne = At[ce],
                nt = !0) : G.samples > 0 && Ve.useMultisampledRTT(G) === !1 ? ne = He.get(G).__webglMultisampledFramebuffer : Array.isArray(At) ? ne = At[ye] : ne = At,
                Y.copy(G.viewport),
                V.copy(G.scissor),
                K = G.scissorTest
            } else
                Y.copy(W).multiplyScalar(Q).floor(),
                V.copy(te).multiplyScalar(Q).floor(),
                K = fe;
            if (ye !== 0 && (ne = Fe),
            le.bindFramebuffer(re.FRAMEBUFFER, ne) && xe && le.drawBuffers(G, ne),
            le.viewport(Y),
            le.scissor(V),
            le.setScissorTest(K),
            nt) {
                const ft = He.get(G.texture);
                re.framebufferTexture2D(re.FRAMEBUFFER, re.COLOR_ATTACHMENT0, re.TEXTURE_CUBE_MAP_POSITIVE_X + ce, ft.__webglTexture, ye)
            } else if (We) {
                const ft = ce;
                for (let Tt = 0; Tt < G.textures.length; Tt++) {
                    const At = He.get(G.textures[Tt]);
                    re.framebufferTextureLayer(re.FRAMEBUFFER, re.COLOR_ATTACHMENT0 + Tt, At.__webglTexture, ye, ft)
                }
            } else if (G !== null && ye !== 0) {
                const ft = He.get(G.texture);
                re.framebufferTexture2D(re.FRAMEBUFFER, re.COLOR_ATTACHMENT0, re.TEXTURE_2D, ft.__webglTexture, ye)
            }
            N = -1
        }
        ,
        this.readRenderTargetPixels = function(G, ce, ye, xe, ne, nt, We, st=0) {
            if (!(G && G.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let ft = He.get(G).__webglFramebuffer;
            if (G.isWebGLCubeRenderTarget && We !== void 0 && (ft = ft[We]),
            ft) {
                le.bindFramebuffer(re.FRAMEBUFFER, ft);
                try {
                    const Tt = G.textures[st]
                      , At = Tt.format
                      , Et = Tt.type;
                    if (!Oe.textureFormatReadable(At)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    if (!Oe.textureTypeReadable(Et)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    ce >= 0 && ce <= G.width - xe && ye >= 0 && ye <= G.height - ne && (G.textures.length > 1 && re.readBuffer(re.COLOR_ATTACHMENT0 + st),
                    re.readPixels(ce, ye, xe, ne, _t.convert(At), _t.convert(Et), nt))
                } finally {
                    const Tt = I !== null ? He.get(I).__webglFramebuffer : null;
                    le.bindFramebuffer(re.FRAMEBUFFER, Tt)
                }
            }
        }
        ,
        this.readRenderTargetPixelsAsync = async function(G, ce, ye, xe, ne, nt, We, st=0) {
            if (!(G && G.isWebGLRenderTarget))
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let ft = He.get(G).__webglFramebuffer;
            if (G.isWebGLCubeRenderTarget && We !== void 0 && (ft = ft[We]),
            ft)
                if (ce >= 0 && ce <= G.width - xe && ye >= 0 && ye <= G.height - ne) {
                    le.bindFramebuffer(re.FRAMEBUFFER, ft);
                    const Tt = G.textures[st]
                      , At = Tt.format
                      , Et = Tt.type;
                    if (!Oe.textureFormatReadable(At))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!Oe.textureTypeReadable(Et))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    const Xt = re.createBuffer();
                    re.bindBuffer(re.PIXEL_PACK_BUFFER, Xt),
                    re.bufferData(re.PIXEL_PACK_BUFFER, nt.byteLength, re.STREAM_READ),
                    G.textures.length > 1 && re.readBuffer(re.COLOR_ATTACHMENT0 + st),
                    re.readPixels(ce, ye, xe, ne, _t.convert(At), _t.convert(Et), 0);
                    const Jt = I !== null ? He.get(I).__webglFramebuffer : null;
                    le.bindFramebuffer(re.FRAMEBUFFER, Jt);
                    const en = re.fenceSync(re.SYNC_GPU_COMMANDS_COMPLETE, 0);
                    return re.flush(),
                    await _X(re, en, 4),
                    re.bindBuffer(re.PIXEL_PACK_BUFFER, Xt),
                    re.getBufferSubData(re.PIXEL_PACK_BUFFER, 0, nt),
                    re.deleteBuffer(Xt),
                    re.deleteSync(en),
                    nt
                } else
                    throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
        }
        ,
        this.copyFramebufferToTexture = function(G, ce=null, ye=0) {
            const xe = Math.pow(2, -ye)
              , ne = Math.floor(G.image.width * xe)
              , nt = Math.floor(G.image.height * xe)
              , We = ce !== null ? ce.x : 0
              , st = ce !== null ? ce.y : 0;
            Ve.setTexture2D(G, 0),
            re.copyTexSubImage2D(re.TEXTURE_2D, ye, 0, 0, We, st, ne, nt),
            le.unbindTexture()
        }
        ;
        const Ke = re.createFramebuffer()
          , yt = re.createFramebuffer();
        this.copyTextureToTexture = function(G, ce, ye=null, xe=null, ne=0, nt=null) {
            nt === null && (ne !== 0 ? (Gy("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),
            nt = ne,
            ne = 0) : nt = 0);
            let We, st, ft, Tt, At, Et, Xt, Jt, en;
            const Sn = G.isCompressedTexture ? G.mipmaps[nt] : G.image;
            if (ye !== null)
                We = ye.max.x - ye.min.x,
                st = ye.max.y - ye.min.y,
                ft = ye.isBox3 ? ye.max.z - ye.min.z : 1,
                Tt = ye.min.x,
                At = ye.min.y,
                Et = ye.isBox3 ? ye.min.z : 0;
            else {
                const ri = Math.pow(2, -ne);
                We = Math.floor(Sn.width * ri),
                st = Math.floor(Sn.height * ri),
                G.isDataArrayTexture ? ft = Sn.depth : G.isData3DTexture ? ft = Math.floor(Sn.depth * ri) : ft = 1,
                Tt = 0,
                At = 0,
                Et = 0
            }
            xe !== null ? (Xt = xe.x,
            Jt = xe.y,
            en = xe.z) : (Xt = 0,
            Jt = 0,
            en = 0);
            const Vt = _t.convert(ce.format)
              , It = _t.convert(ce.type);
            let Cn;
            ce.isData3DTexture ? (Ve.setTexture3D(ce, 0),
            Cn = re.TEXTURE_3D) : ce.isDataArrayTexture || ce.isCompressedArrayTexture ? (Ve.setTexture2DArray(ce, 0),
            Cn = re.TEXTURE_2D_ARRAY) : (Ve.setTexture2D(ce, 0),
            Cn = re.TEXTURE_2D),
            re.pixelStorei(re.UNPACK_FLIP_Y_WEBGL, ce.flipY),
            re.pixelStorei(re.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ce.premultiplyAlpha),
            re.pixelStorei(re.UNPACK_ALIGNMENT, ce.unpackAlignment);
            const fn = re.getParameter(re.UNPACK_ROW_LENGTH)
              , In = re.getParameter(re.UNPACK_IMAGE_HEIGHT)
              , xn = re.getParameter(re.UNPACK_SKIP_PIXELS)
              , Bn = re.getParameter(re.UNPACK_SKIP_ROWS)
              , hn = re.getParameter(re.UNPACK_SKIP_IMAGES);
            re.pixelStorei(re.UNPACK_ROW_LENGTH, Sn.width),
            re.pixelStorei(re.UNPACK_IMAGE_HEIGHT, Sn.height),
            re.pixelStorei(re.UNPACK_SKIP_PIXELS, Tt),
            re.pixelStorei(re.UNPACK_SKIP_ROWS, At),
            re.pixelStorei(re.UNPACK_SKIP_IMAGES, Et);
            const Yt = G.isDataArrayTexture || G.isData3DTexture
              , ti = ce.isDataArrayTexture || ce.isData3DTexture;
            if (G.isDepthTexture) {
                const ri = He.get(G)
                  , bn = He.get(ce)
                  , ui = He.get(ri.__renderTarget)
                  , Ss = He.get(bn.__renderTarget);
                le.bindFramebuffer(re.READ_FRAMEBUFFER, ui.__webglFramebuffer),
                le.bindFramebuffer(re.DRAW_FRAMEBUFFER, Ss.__webglFramebuffer);
                for (let Di = 0; Di < ft; Di++)
                    Yt && (re.framebufferTextureLayer(re.READ_FRAMEBUFFER, re.COLOR_ATTACHMENT0, He.get(G).__webglTexture, ne, Et + Di),
                    re.framebufferTextureLayer(re.DRAW_FRAMEBUFFER, re.COLOR_ATTACHMENT0, He.get(ce).__webglTexture, nt, en + Di)),
                    re.blitFramebuffer(Tt, At, We, st, Xt, Jt, We, st, re.DEPTH_BUFFER_BIT, re.NEAREST);
                le.bindFramebuffer(re.READ_FRAMEBUFFER, null),
                le.bindFramebuffer(re.DRAW_FRAMEBUFFER, null)
            } else if (ne !== 0 || G.isRenderTargetTexture || He.has(G)) {
                const ri = He.get(G)
                  , bn = He.get(ce);
                le.bindFramebuffer(re.READ_FRAMEBUFFER, Ke),
                le.bindFramebuffer(re.DRAW_FRAMEBUFFER, yt);
                for (let ui = 0; ui < ft; ui++)
                    Yt ? re.framebufferTextureLayer(re.READ_FRAMEBUFFER, re.COLOR_ATTACHMENT0, ri.__webglTexture, ne, Et + ui) : re.framebufferTexture2D(re.READ_FRAMEBUFFER, re.COLOR_ATTACHMENT0, re.TEXTURE_2D, ri.__webglTexture, ne),
                    ti ? re.framebufferTextureLayer(re.DRAW_FRAMEBUFFER, re.COLOR_ATTACHMENT0, bn.__webglTexture, nt, en + ui) : re.framebufferTexture2D(re.DRAW_FRAMEBUFFER, re.COLOR_ATTACHMENT0, re.TEXTURE_2D, bn.__webglTexture, nt),
                    ne !== 0 ? re.blitFramebuffer(Tt, At, We, st, Xt, Jt, We, st, re.COLOR_BUFFER_BIT, re.NEAREST) : ti ? re.copyTexSubImage3D(Cn, nt, Xt, Jt, en + ui, Tt, At, We, st) : re.copyTexSubImage2D(Cn, nt, Xt, Jt, Tt, At, We, st);
                le.bindFramebuffer(re.READ_FRAMEBUFFER, null),
                le.bindFramebuffer(re.DRAW_FRAMEBUFFER, null)
            } else
                ti ? G.isDataTexture || G.isData3DTexture ? re.texSubImage3D(Cn, nt, Xt, Jt, en, We, st, ft, Vt, It, Sn.data) : ce.isCompressedArrayTexture ? re.compressedTexSubImage3D(Cn, nt, Xt, Jt, en, We, st, ft, Vt, Sn.data) : re.texSubImage3D(Cn, nt, Xt, Jt, en, We, st, ft, Vt, It, Sn) : G.isDataTexture ? re.texSubImage2D(re.TEXTURE_2D, nt, Xt, Jt, We, st, Vt, It, Sn.data) : G.isCompressedTexture ? re.compressedTexSubImage2D(re.TEXTURE_2D, nt, Xt, Jt, Sn.width, Sn.height, Vt, Sn.data) : re.texSubImage2D(re.TEXTURE_2D, nt, Xt, Jt, We, st, Vt, It, Sn);
            re.pixelStorei(re.UNPACK_ROW_LENGTH, fn),
            re.pixelStorei(re.UNPACK_IMAGE_HEIGHT, In),
            re.pixelStorei(re.UNPACK_SKIP_PIXELS, xn),
            re.pixelStorei(re.UNPACK_SKIP_ROWS, Bn),
            re.pixelStorei(re.UNPACK_SKIP_IMAGES, hn),
            nt === 0 && ce.generateMipmaps && re.generateMipmap(Cn),
            le.unbindTexture()
        }
        ,
        this.initRenderTarget = function(G) {
            He.get(G).__webglFramebuffer === void 0 && Ve.setupRenderTarget(G)
        }
        ,
        this.initTexture = function(G) {
            G.isCubeTexture ? Ve.setTextureCube(G, 0) : G.isData3DTexture ? Ve.setTexture3D(G, 0) : G.isDataArrayTexture || G.isCompressedArrayTexture ? Ve.setTexture2DArray(G, 0) : Ve.setTexture2D(G, 0),
            le.unbindTexture()
        }
        ,
        this.resetState = function() {
            L = 0,
            z = 0,
            I = null,
            le.reset(),
            ut.reset()
        }
        ,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    get coordinateSystem() {
        return bo
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorSpace = Kn._getDrawingBufferColorSpace(e),
        t.unpackColorSpace = Kn._getUnpackColorSpace()
    }
}
const NQ = Object.freeze(Object.defineProperty({
    __proto__: null,
    ACESFilmicToneMapping: ZA,
    AddEquation: rh,
    AddOperation: JP,
    AdditiveAnimationBlendMode: nC,
    AdditiveBlending: aw,
    AgXToneMapping: iB,
    AlphaFormat: $A,
    AlwaysCompare: vB,
    AlwaysDepth: qS,
    AlwaysStencilFunc: cw,
    AmbientLight: fz,
    AnimationAction: _z,
    AnimationClip: Zy,
    AnimationLoader: jj,
    AnimationMixer: yW,
    AnimationObjectGroup: gW,
    AnimationUtils: Vj,
    ArcCurve: PB,
    ArrayCamera: gz,
    ArrowHelper: XW,
    AttachedBindMode: lw,
    Audio: vz,
    AudioAnalyser: sW,
    AudioContext: RC,
    AudioListener: iW,
    AudioLoader: eW,
    AxesHelper: jW,
    BackSide: vs,
    BasicDepthPacking: uB,
    BasicShadowMap: OP,
    BatchedMesh: DB,
    Bone: hC,
    BooleanKeyframeTrack: _p,
    Box2: CW,
    Box3: ea,
    Box3Helper: kW,
    BoxGeometry: yp,
    BoxHelper: VW,
    BufferAttribute: xi,
    BufferGeometry: Nn,
    BufferGeometryLoader: mz,
    ByteType: aM,
    Cache: Xu,
    Camera: pM,
    CameraHelper: HW,
    CanvasTexture: cj,
    CapsuleGeometry: SM,
    CatmullRomCurve3: BB,
    CineonToneMapping: tB,
    CircleGeometry: bM,
    ClampToEdgeWrapping: Cr,
    Clock: DC,
    Color: kt,
    ColorKeyframeTrack: EC,
    ColorManagement: Kn,
    CompressedArrayTexture: lj,
    CompressedCubeTexture: uj,
    CompressedTexture: xM,
    CompressedTextureLoader: Wj,
    ConeGeometry: v_,
    ConstantAlphaFactor: ZP,
    ConstantColorFactor: YP,
    Controls: YW,
    CubeCamera: TB,
    CubeReflectionMapping: ic,
    CubeRefractionMapping: _h,
    CubeTexture: p_,
    CubeTextureLoader: sz,
    CubeUVReflectionMapping: Xg,
    CubicBezierCurve: vC,
    CubicBezierCurve3: zB,
    CubicInterpolant: nz,
    CullFaceBack: rw,
    CullFaceFront: UP,
    CullFaceFrontBack: x9,
    CullFaceNone: DP,
    Curve: $l,
    CurvePath: FB,
    CustomBlending: NP,
    CustomToneMapping: nB,
    CylinderGeometry: g_,
    Cylindrical: AW,
    Data3DTexture: dM,
    DataArrayTexture: hM,
    DataTexture: Kl,
    DataTextureLoader: wC,
    DataUtils: jd,
    DecrementStencilOp: N9,
    DecrementWrapStencilOp: P9,
    DefaultLoadingManager: az,
    DepthFormat: wg,
    DepthStencilFormat: Ag,
    DepthTexture: pC,
    DetachedBindMode: aB,
    DirectionalLight: cz,
    DirectionalLightHelper: FW,
    DiscreteInterpolant: iz,
    DodecahedronGeometry: MM,
    DoubleSide: tl,
    DstAlphaFactor: kP,
    DstColorFactor: XP,
    DynamicCopyUsage: K9,
    DynamicDrawUsage: X9,
    DynamicReadUsage: Y9,
    EdgesGeometry: LB,
    EllipseCurve: TM,
    EqualCompare: dB,
    EqualDepth: KS,
    EqualStencilFunc: F9,
    EquirectangularReflectionMapping: Mg,
    EquirectangularRefractionMapping: Py,
    Euler: Co,
    EventDispatcher: sc,
    ExternalTexture: mC,
    ExtrudeGeometry: EM,
    FileLoader: Eo,
    Float16BufferAttribute: HX,
    Float32BufferAttribute: Qt,
    FloatType: tr,
    Fog: gM,
    FogExp2: mM,
    FramebufferTexture: oj,
    FrontSide: tf,
    Frustum: Wg,
    FrustumArray: _M,
    GLBufferAttribute: MW,
    GLSL1: J9,
    GLSL3: fw,
    GreaterCompare: pB,
    GreaterDepth: JS,
    GreaterEqualCompare: gB,
    GreaterEqualDepth: QS,
    GreaterEqualStencilFunc: G9,
    GreaterStencilFunc: V9,
    GridHelper: zW,
    Group: ig,
    HalfFloatType: $r,
    HemisphereLight: oz,
    HemisphereLightHelper: BW,
    IcosahedronGeometry: y_,
    ImageBitmapLoader: $j,
    ImageLoader: Ky,
    ImageUtils: SB,
    IncrementStencilOp: O9,
    IncrementWrapStencilOp: L9,
    InstancedBufferAttribute: fp,
    InstancedBufferGeometry: CC,
    InstancedInterleavedBuffer: bW,
    InstancedMesh: RB,
    Int16BufferAttribute: IX,
    Int32BufferAttribute: FX,
    Int8BufferAttribute: PX,
    IntType: f_,
    InterleavedBuffer: vM,
    InterleavedBufferAttribute: cp,
    Interpolant: S_,
    InterpolateDiscrete: Iy,
    InterpolateLinear: Cb,
    InterpolateSmooth: _S,
    InterpolationSamplingMode: tX,
    InterpolationSamplingType: eX,
    InvertStencilOp: B9,
    KeepStencilOp: Pd,
    KeyframeTrack: ol,
    LOD: AB,
    LatheGeometry: wM,
    Layers: Dg,
    LessCompare: hB,
    LessDepth: ZS,
    LessEqualCompare: rC,
    LessEqualDepth: up,
    LessEqualStencilFunc: H9,
    LessStencilFunc: I9,
    Light: Ah,
    LightProbe: pz,
    Line: xh,
    Line3: UW,
    LineBasicMaterial: _s,
    LineCurve: yC,
    LineCurve3: IB,
    LineDashedMaterial: $B,
    LineLoop: UB,
    LineSegments: lc,
    LinearFilter: fi,
    LinearInterpolant: TC,
    LinearMipMapLinearFilter: uw,
    LinearMipMapNearestFilter: M9,
    LinearMipmapLinearFilter: Gu,
    LinearMipmapNearestFilter: $v,
    LinearSRGBColorSpace: Jl,
    LinearToneMapping: $P,
    LinearTransfer: Hy,
    Loader: xs,
    LoaderUtils: gw,
    LoadingManager: PM,
    LoopOnce: sB,
    LoopPingPong: lB,
    LoopRepeat: oB,
    MOUSE: y9,
    Material: Va,
    MaterialLoader: BM,
    MathUtils: yB,
    Matrix2: PC,
    Matrix3: An,
    Matrix4: vn,
    MaxEquation: zP,
    Mesh: Ni,
    MeshBasicMaterial: oc,
    MeshDepthMaterial: NM,
    MeshDistanceMaterial: LM,
    MeshLambertMaterial: QB,
    MeshMatcapMaterial: JB,
    MeshNormalMaterial: KB,
    MeshPhongMaterial: qB,
    MeshPhysicalMaterial: YB,
    MeshStandardMaterial: bC,
    MeshToonMaterial: ZB,
    MinEquation: BP,
    MirroredRepeatWrapping: zy,
    MixOperation: QP,
    MultiplyBlending: ow,
    MultiplyOperation: c_,
    NearestFilter: va,
    NearestMipMapLinearFilter: b9,
    NearestMipMapNearestFilter: S9,
    NearestMipmapLinearFilter: tg,
    NearestMipmapNearestFilter: KA,
    NeutralToneMapping: rB,
    NeverCompare: fB,
    NeverDepth: YS,
    NeverStencilFunc: z9,
    NoBlending: Qu,
    NoColorSpace: Xc,
    NoToneMapping: Ju,
    NormalAnimationBlendMode: fM,
    NormalBlending: tp,
    NotEqualCompare: mB,
    NotEqualDepth: $S,
    NotEqualStencilFunc: k9,
    NumberKeyframeTrack: Yy,
    Object3D: ii,
    ObjectLoader: Qj,
    ObjectSpaceNormalMap: cB,
    OctahedronGeometry: __,
    OneFactor: FP,
    OneMinusConstantAlphaFactor: KP,
    OneMinusConstantColorFactor: qP,
    OneMinusDstAlphaFactor: GP,
    OneMinusDstColorFactor: jP,
    OneMinusSrcAlphaFactor: WS,
    OneMinusSrcColorFactor: VP,
    OrthographicCamera: Yg,
    PCFShadowMap: rM,
    PCFSoftShadowMap: Jv,
    PMREMGenerator: _w,
    Path: Ob,
    PerspectiveCamera: Jr,
    Plane: nh,
    PlaneGeometry: eu,
    PlaneHelper: GW,
    PointLight: uz,
    PointLightHelper: LW,
    Points: OB,
    PointsMaterial: dC,
    PolarGridHelper: IW,
    PolyhedronGeometry: wh,
    PositionalAudio: aW,
    PropertyBinding: ni,
    PropertyMixer: yz,
    QuadraticBezierCurve: _C,
    QuadraticBezierCurve3: xC,
    Quaternion: qs,
    QuaternionKeyframeTrack: b_,
    QuaternionLinearInterpolant: rz,
    RED_GREEN_RGTC2_Format: wb,
    RED_RGTC1_Format: Tb,
    REVISION: u_,
    RGBADepthPacking: iC,
    RGBAFormat: vr,
    RGBAIntegerFormat: cM,
    RGBA_ASTC_10x10_Format: yb,
    RGBA_ASTC_10x5_Format: mb,
    RGBA_ASTC_10x6_Format: gb,
    RGBA_ASTC_10x8_Format: vb,
    RGBA_ASTC_12x10_Format: _b,
    RGBA_ASTC_12x12_Format: xb,
    RGBA_ASTC_4x4_Format: ob,
    RGBA_ASTC_5x4_Format: lb,
    RGBA_ASTC_5x5_Format: ub,
    RGBA_ASTC_6x5_Format: cb,
    RGBA_ASTC_6x6_Format: fb,
    RGBA_ASTC_8x5_Format: hb,
    RGBA_ASTC_8x6_Format: db,
    RGBA_ASTC_8x8_Format: pb,
    RGBA_BPTC_Format: Sb,
    RGBA_ETC2_EAC_Format: sb,
    RGBA_PVRTC_2BPPV1_Format: ib,
    RGBA_PVRTC_4BPPV1_Format: nb,
    RGBA_S3TC_DXT1_Format: ty,
    RGBA_S3TC_DXT3_Format: ny,
    RGBA_S3TC_DXT5_Format: iy,
    RGBDepthPacking: C9,
    RGBFormat: eC,
    RGBIntegerFormat: T9,
    RGB_BPTC_SIGNED_Format: bb,
    RGB_BPTC_UNSIGNED_Format: Mb,
    RGB_ETC1_Format: rb,
    RGB_ETC2_Format: ab,
    RGB_PVRTC_2BPPV1_Format: tb,
    RGB_PVRTC_4BPPV1_Format: eb,
    RGB_S3TC_DXT1_Format: ey,
    RGDepthPacking: R9,
    RGFormat: tC,
    RGIntegerFormat: uM,
    RawShaderMaterial: WB,
    Ray: jg,
    Raycaster: LC,
    RectAreaLight: hz,
    RedFormat: h_,
    RedIntegerFormat: d_,
    ReinhardToneMapping: eB,
    RenderTarget: sC,
    RenderTarget3D: _W,
    RepeatWrapping: By,
    ReplaceStencilOp: U9,
    ReverseSubtractEquation: PP,
    RingGeometry: AM,
    SIGNED_RED_GREEN_RGTC2_Format: Ab,
    SIGNED_RED_RGTC1_Format: Eb,
    SRGBColorSpace: pa,
    SRGBTransfer: yi,
    Scene: m_,
    ShaderChunk: Un,
    ShaderLib: Yl,
    ShaderMaterial: Ks,
    ShadowMaterial: jB,
    Shape: ip,
    ShapeGeometry: CM,
    ShapePath: WW,
    ShapeUtils: Zl,
    ShortType: sM,
    Skeleton: yM,
    SkeletonHelper: NW,
    SkinnedMesh: CB,
    Source: lh,
    Sphere: ta,
    SphereGeometry: x_,
    Spherical: wW,
    SphericalHarmonics3: dz,
    SplineCurve: SC,
    SpotLight: lz,
    SpotLightHelper: OW,
    Sprite: wB,
    SpriteMaterial: fC,
    SrcAlphaFactor: jS,
    SrcAlphaSaturateFactor: WP,
    SrcColorFactor: HP,
    StaticCopyUsage: Z9,
    StaticDrawUsage: Vy,
    StaticReadUsage: W9,
    StereoCamera: tW,
    StreamCopyUsage: Q9,
    StreamDrawUsage: j9,
    StreamReadUsage: q9,
    StringKeyframeTrack: xp,
    SubtractEquation: LP,
    SubtractiveBlending: sw,
    TOUCH: _9,
    TangentSpaceNormalMap: Eh,
    TetrahedronGeometry: RM,
    Texture: _i,
    TextureLoader: Yj,
    TextureUtils: JW,
    Timer: TW,
    TimestampQuery: $9,
    TorusGeometry: DM,
    TorusKnotGeometry: UM,
    Triangle: Vs,
    TriangleFanDrawMode: A9,
    TriangleStripDrawMode: w9,
    TrianglesDrawMode: E9,
    TubeGeometry: OM,
    UVMapping: yh,
    Uint16BufferAttribute: oC,
    Uint32BufferAttribute: lC,
    Uint8BufferAttribute: BX,
    Uint8ClampedBufferAttribute: zX,
    Uniform: NC,
    UniformsGroup: SW,
    UniformsLib: Ht,
    UniformsUtils: uC,
    UnsignedByteType: ys,
    UnsignedInt101111Type: JA,
    UnsignedInt248Type: Eg,
    UnsignedInt5999Type: QA,
    UnsignedIntType: rc,
    UnsignedShort4444Type: oM,
    UnsignedShort5551Type: lM,
    UnsignedShortType: Tg,
    VSMShadowMap: Wl,
    Vector2: xt,
    Vector3: he,
    Vector4: Qn,
    VectorKeyframeTrack: qy,
    VideoFrameTexture: sj,
    VideoTexture: NB,
    WebGL3DRenderTarget: TX,
    WebGLArrayRenderTarget: MX,
    WebGLCoordinateSystem: bo,
    WebGLCubeRenderTarget: cC,
    WebGLRenderTarget: sl,
    WebGLRenderer: zC,
    WebGLUtils: wz,
    WebGPUCoordinateSystem: Cg,
    WebXRController: xS,
    WireframeGeometry: XB,
    WrapAroundEnding: Fy,
    ZeroCurvatureEnding: Gd,
    ZeroFactor: IP,
    ZeroSlopeEnding: Xd,
    ZeroStencilOp: D9,
    createCanvasElement: xB
}, Symbol.toStringTag, {
    value: "Module"
}));
var GT = {
    exports: {}
}
  , XT = {}
  , jT = {
    exports: {}
}
  , WT = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wO;
function LQ() {
    if (wO)
        return WT;
    wO = 1;
    var r = zg();
    function e(g, v) {
        return g === v && (g !== 0 || 1 / g === 1 / v) || g !== g && v !== v
    }
    var t = typeof Object.is == "function" ? Object.is : e
      , n = r.useState
      , i = r.useEffect
      , a = r.useLayoutEffect
      , s = r.useDebugValue;
    function l(g, v) {
        var y = v()
          , S = n({
            inst: {
                value: y,
                getSnapshot: v
            }
        })
          , T = S[0].inst
          , M = S[1];
        return a(function() {
            T.value = y,
            T.getSnapshot = v,
            u(T) && M({
                inst: T
            })
        }, [g, y, v]),
        i(function() {
            return u(T) && M({
                inst: T
            }),
            g(function() {
                u(T) && M({
                    inst: T
                })
            })
        }, [g]),
        s(y),
        y
    }
    function u(g) {
        var v = g.getSnapshot;
        g = g.value;
        try {
            var y = v();
            return !t(g, y)
        } catch {
            return !0
        }
    }
    function f(g, v) {
        return v()
    }
    var d = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? f : l;
    return WT.useSyncExternalStore = r.useSyncExternalStore !== void 0 ? r.useSyncExternalStore : d,
    WT
}
var AO;
function PQ() {
    return AO || (AO = 1,
    jT.exports = LQ()),
    jT.exports
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var CO;
function BQ() {
    if (CO)
        return XT;
    CO = 1;
    var r = zg()
      , e = PQ();
    function t(f, d) {
        return f === d && (f !== 0 || 1 / f === 1 / d) || f !== f && d !== d
    }
    var n = typeof Object.is == "function" ? Object.is : t
      , i = e.useSyncExternalStore
      , a = r.useRef
      , s = r.useEffect
      , l = r.useMemo
      , u = r.useDebugValue;
    return XT.useSyncExternalStoreWithSelector = function(f, d, g, v, y) {
        var S = a(null);
        if (S.current === null) {
            var T = {
                hasValue: !1,
                value: null
            };
            S.current = T
        } else
            T = S.current;
        S = l(function() {
            function b(L) {
                if (!A) {
                    if (A = !0,
                    C = L,
                    L = v(L),
                    y !== void 0 && T.hasValue) {
                        var z = T.value;
                        if (y(z, L))
                            return R = z
                    }
                    return R = L
                }
                if (z = R,
                n(C, L))
                    return z;
                var I = v(L);
                return y !== void 0 && y(z, I) ? (C = L,
                z) : (C = L,
                R = I)
            }
            var A = !1, C, R, O = g === void 0 ? null : g;
            return [function() {
                return b(d())
            }
            , O === null ? void 0 : function() {
                return b(O())
            }
            ]
        }, [d, g, v, y]);
        var M = i(f, S[0], S[1]);
        return s(function() {
            T.hasValue = !0,
            T.value = M
        }, [M]),
        u(M),
        M
    }
    ,
    XT
}
var RO;
function zQ() {
    return RO || (RO = 1,
    GT.exports = BQ()),
    GT.exports
}
var IQ = zQ();
const FQ = jb(IQ)
  , DO = r => {
    let e;
    const t = new Set
      , n = (f, d) => {
        const g = typeof f == "function" ? f(e) : f;
        if (!Object.is(g, e)) {
            const v = e;
            e = d ?? (typeof g != "object" || g === null) ? g : Object.assign({}, e, g),
            t.forEach(y => y(e, v))
        }
    }
      , i = () => e
      , l = {
        setState: n,
        getState: i,
        getInitialState: () => u,
        subscribe: f => (t.add(f),
        () => t.delete(f))
    }
      , u = e = r(n, i, l);
    return l
}
  , HQ = r => r ? DO(r) : DO
  , {useSyncExternalStoreWithSelector: VQ} = FQ
  , kQ = r => r;
function GQ(r, e=kQ, t) {
    const n = VQ(r.subscribe, r.getState, r.getInitialState, e, t);
    return ln.useDebugValue(n),
    n
}
const UO = (r, e) => {
    const t = HQ(r)
      , n = (i, a=e) => GQ(t, i, a);
    return Object.assign(n, t),
    n
}
  , Az = (r, e) => r ? UO(r, e) : UO
  , XQ = r => typeof r == "object" && typeof r.then == "function"
  , Yd = [];
function Cz(r, e, t= (n, i) => n === i) {
    if (r === e)
        return !0;
    if (!r || !e)
        return !1;
    const n = r.length;
    if (e.length !== n)
        return !1;
    for (let i = 0; i < n; i++)
        if (!t(r[i], e[i]))
            return !1;
    return !0
}
function Rz(r, e=null, t=!1, n={}) {
    e === null && (e = [r]);
    for (const a of Yd)
        if (Cz(e, a.keys, a.equal)) {
            if (t)
                return;
            if (Object.prototype.hasOwnProperty.call(a, "error"))
                throw a.error;
            if (Object.prototype.hasOwnProperty.call(a, "response"))
                return n.lifespan && n.lifespan > 0 && (a.timeout && clearTimeout(a.timeout),
                a.timeout = setTimeout(a.remove, n.lifespan)),
                a.response;
            if (!t)
                throw a.promise
        }
    const i = {
        keys: e,
        equal: n.equal,
        remove: () => {
            const a = Yd.indexOf(i);
            a !== -1 && Yd.splice(a, 1)
        }
        ,
        promise: (XQ(r) ? r : r(...e)).then(a => {
            i.response = a,
            n.lifespan && n.lifespan > 0 && (i.timeout = setTimeout(i.remove, n.lifespan))
        }
        ).catch(a => i.error = a)
    };
    if (Yd.push(i),
    !t)
        throw i.promise
}
const Dz = (r, e, t) => Rz(r, e, !1, t)
  , jQ = (r, e, t) => void Rz(r, e, !0, t)
  , WQ = r => {
    if (r === void 0 || r.length === 0)
        Yd.splice(0, Yd.length);
    else {
        const e = Yd.find(t => Cz(r, t.keys, t.equal));
        e && e.remove()
    }
}
;
var YT = {
    exports: {}
}
  , qT = {
    exports: {}
}
  , ZT = {
    exports: {}
}
  , KT = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var OO;
function YQ() {
    return OO || (OO = 1,
    function(r) {
        function e(H, q) {
            var Q = H.length;
            H.push(q);
            e: for (; 0 < Q; ) {
                var se = Q - 1 >>> 1
                  , B = H[se];
                if (0 < i(B, q))
                    H[se] = q,
                    H[Q] = B,
                    Q = se;
                else
                    break e
            }
        }
        function t(H) {
            return H.length === 0 ? null : H[0]
        }
        function n(H) {
            if (H.length === 0)
                return null;
            var q = H[0]
              , Q = H.pop();
            if (Q !== q) {
                H[0] = Q;
                e: for (var se = 0, B = H.length, W = B >>> 1; se < W; ) {
                    var te = 2 * (se + 1) - 1
                      , fe = H[te]
                      , pe = te + 1
                      , _e = H[pe];
                    if (0 > i(fe, Q))
                        pe < B && 0 > i(_e, fe) ? (H[se] = _e,
                        H[pe] = Q,
                        se = pe) : (H[se] = fe,
                        H[te] = Q,
                        se = te);
                    else if (pe < B && 0 > i(_e, Q))
                        H[se] = _e,
                        H[pe] = Q,
                        se = pe;
                    else
                        break e
                }
            }
            return q
        }
        function i(H, q) {
            var Q = H.sortIndex - q.sortIndex;
            return Q !== 0 ? Q : H.id - q.id
        }
        if (r.unstable_now = void 0,
        typeof performance == "object" && typeof performance.now == "function") {
            var a = performance;
            r.unstable_now = function() {
                return a.now()
            }
        } else {
            var s = Date
              , l = s.now();
            r.unstable_now = function() {
                return s.now() - l
            }
        }
        var u = []
          , f = []
          , d = 1
          , g = null
          , v = 3
          , y = !1
          , S = !1
          , T = !1
          , M = typeof setTimeout == "function" ? setTimeout : null
          , b = typeof clearTimeout == "function" ? clearTimeout : null
          , A = typeof setImmediate < "u" ? setImmediate : null;
        function C(H) {
            for (var q = t(f); q !== null; ) {
                if (q.callback === null)
                    n(f);
                else if (q.startTime <= H)
                    n(f),
                    q.sortIndex = q.expirationTime,
                    e(u, q);
                else
                    break;
                q = t(f)
            }
        }
        function R(H) {
            if (T = !1,
            C(H),
            !S)
                if (t(u) !== null)
                    S = !0,
                    Z();
                else {
                    var q = t(f);
                    q !== null && oe(R, q.startTime - H)
                }
        }
        var O = !1
          , L = -1
          , z = 5
          , I = -1;
        function N() {
            return !(r.unstable_now() - I < z)
        }
        function P() {
            if (O) {
                var H = r.unstable_now();
                I = H;
                var q = !0;
                try {
                    e: {
                        S = !1,
                        T && (T = !1,
                        b(L),
                        L = -1),
                        y = !0;
                        var Q = v;
                        try {
                            t: {
                                for (C(H),
                                g = t(u); g !== null && !(g.expirationTime > H && N()); ) {
                                    var se = g.callback;
                                    if (typeof se == "function") {
                                        g.callback = null,
                                        v = g.priorityLevel;
                                        var B = se(g.expirationTime <= H);
                                        if (H = r.unstable_now(),
                                        typeof B == "function") {
                                            g.callback = B,
                                            C(H),
                                            q = !0;
                                            break t
                                        }
                                        g === t(u) && n(u),
                                        C(H)
                                    } else
                                        n(u);
                                    g = t(u)
                                }
                                if (g !== null)
                                    q = !0;
                                else {
                                    var W = t(f);
                                    W !== null && oe(R, W.startTime - H),
                                    q = !1
                                }
                            }
                            break e
                        } finally {
                            g = null,
                            v = Q,
                            y = !1
                        }
                        q = void 0
                    }
                } finally {
                    q ? Y() : O = !1
                }
            }
        }
        var Y;
        if (typeof A == "function")
            Y = function() {
                A(P)
            }
            ;
        else if (typeof MessageChannel < "u") {
            var V = new MessageChannel
              , K = V.port2;
            V.port1.onmessage = P,
            Y = function() {
                K.postMessage(null)
            }
        } else
            Y = function() {
                M(P, 0)
            }
            ;
        function Z() {
            O || (O = !0,
            Y())
        }
        function oe(H, q) {
            L = M(function() {
                H(r.unstable_now())
            }, q)
        }
        r.unstable_IdlePriority = 5,
        r.unstable_ImmediatePriority = 1,
        r.unstable_LowPriority = 4,
        r.unstable_NormalPriority = 3,
        r.unstable_Profiling = null,
        r.unstable_UserBlockingPriority = 2,
        r.unstable_cancelCallback = function(H) {
            H.callback = null
        }
        ,
        r.unstable_continueExecution = function() {
            S || y || (S = !0,
            Z())
        }
        ,
        r.unstable_forceFrameRate = function(H) {
            0 > H || 125 < H ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : z = 0 < H ? Math.floor(1e3 / H) : 5
        }
        ,
        r.unstable_getCurrentPriorityLevel = function() {
            return v
        }
        ,
        r.unstable_getFirstCallbackNode = function() {
            return t(u)
        }
        ,
        r.unstable_next = function(H) {
            switch (v) {
            case 1:
            case 2:
            case 3:
                var q = 3;
                break;
            default:
                q = v
            }
            var Q = v;
            v = q;
            try {
                return H()
            } finally {
                v = Q
            }
        }
        ,
        r.unstable_pauseExecution = function() {}
        ,
        r.unstable_requestPaint = function() {}
        ,
        r.unstable_runWithPriority = function(H, q) {
            switch (H) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                H = 3
            }
            var Q = v;
            v = H;
            try {
                return q()
            } finally {
                v = Q
            }
        }
        ,
        r.unstable_scheduleCallback = function(H, q, Q) {
            var se = r.unstable_now();
            switch (typeof Q == "object" && Q !== null ? (Q = Q.delay,
            Q = typeof Q == "number" && 0 < Q ? se + Q : se) : Q = se,
            H) {
            case 1:
                var B = -1;
                break;
            case 2:
                B = 250;
                break;
            case 5:
                B = 1073741823;
                break;
            case 4:
                B = 1e4;
                break;
            default:
                B = 5e3
            }
            return B = Q + B,
            H = {
                id: d++,
                callback: q,
                priorityLevel: H,
                startTime: Q,
                expirationTime: B,
                sortIndex: -1
            },
            Q > se ? (H.sortIndex = Q,
            e(f, H),
            t(u) === null && H === t(f) && (T ? (b(L),
            L = -1) : T = !0,
            oe(R, Q - se))) : (H.sortIndex = B,
            e(u, H),
            S || y || (S = !0,
            Z())),
            H
        }
        ,
        r.unstable_shouldYield = N,
        r.unstable_wrapCallback = function(H) {
            var q = v;
            return function() {
                var Q = v;
                v = q;
                try {
                    return H.apply(this, arguments)
                } finally {
                    v = Q
                }
            }
        }
    }(KT)),
    KT
}
var NO;
function qQ() {
    return NO || (NO = 1,
    ZT.exports = YQ()),
    ZT.exports
}
/**
 * @license React
 * react-reconciler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var LO;
function ZQ() {
    return LO || (LO = 1,
    function(r) {
        r.exports = function(e) {
            function t(h, p, x, w) {
                return new x0(h,p,x,w)
            }
            function n() {}
            function i(h) {
                var p = "https://react.dev/errors/" + h;
                if (1 < arguments.length) {
                    p += "?args[]=" + encodeURIComponent(arguments[1]);
                    for (var x = 2; x < arguments.length; x++)
                        p += "&args[]=" + encodeURIComponent(arguments[x])
                }
                return "Minified React error #" + h + "; visit " + p + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
            }
            function a(h) {
                return h === null || typeof h != "object" ? null : (h = Cl && h[Cl] || h["@@iterator"],
                typeof h == "function" ? h : null)
            }
            function s(h) {
                if (h == null)
                    return null;
                if (typeof h == "function")
                    return h.$$typeof === T0 ? null : h.displayName || h.name || null;
                if (typeof h == "string")
                    return h;
                switch (h) {
                case vu:
                    return "Fragment";
                case Cs:
                    return "Portal";
                case Fp:
                    return "Profiler";
                case Qh:
                    return "StrictMode";
                case Hp:
                    return "Suspense";
                case yf:
                    return "SuspenseList"
                }
                if (typeof h == "object")
                    switch (h.$$typeof) {
                    case to:
                        return (h.displayName || "Context") + ".Provider";
                    case b0:
                        return (h._context.displayName || "Context") + ".Consumer";
                    case $h:
                        var p = h.render;
                        return h = h.displayName,
                        h || (h = p.displayName || p.name || "",
                        h = h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef"),
                        h;
                    case Vp:
                        return p = h.displayName || null,
                        p !== null ? p : s(h.type) || "Memo";
                    case Rs:
                        p = h._payload,
                        h = h._init;
                        try {
                            return s(h(p))
                        } catch {}
                    }
                return null
            }
            function l(h) {
                if (Lo === void 0)
                    try {
                        throw Error()
                    } catch (x) {
                        var p = x.stack.trim().match(/\n( *(at )?)/);
                        Lo = p && p[1] || "",
                        Rl = -1 < x.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : ""
                    }
                return `
` + Lo + h + Rl
            }
            function u(h, p) {
                if (!h || gc)
                    return "";
                gc = !0;
                var x = Error.prepareStackTrace;
                Error.prepareStackTrace = void 0;
                try {
                    var w = {
                        DetermineComponentFrameRoot: function() {
                            try {
                                if (p) {
                                    var Ft = function() {
                                        throw Error()
                                    };
                                    if (Object.defineProperty(Ft.prototype, "props", {
                                        set: function() {
                                            throw Error()
                                        }
                                    }),
                                    typeof Reflect == "object" && Reflect.construct) {
                                        try {
                                            Reflect.construct(Ft, [])
                                        } catch (Tn) {
                                            var jt = Tn
                                        }
                                        Reflect.construct(h, [], Ft)
                                    } else {
                                        try {
                                            Ft.call()
                                        } catch (Tn) {
                                            jt = Tn
                                        }
                                        h.call(Ft.prototype)
                                    }
                                } else {
                                    try {
                                        throw Error()
                                    } catch (Tn) {
                                        jt = Tn
                                    }
                                    (Ft = h()) && typeof Ft.catch == "function" && Ft.catch(function() {})
                                }
                            } catch (Tn) {
                                if (Tn && jt && typeof Tn.stack == "string")
                                    return [Tn.stack, jt.stack]
                            }
                            return [null, null]
                        }
                    };
                    w.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
                    var U = Object.getOwnPropertyDescriptor(w.DetermineComponentFrameRoot, "name");
                    U && U.configurable && Object.defineProperty(w.DetermineComponentFrameRoot, "name", {
                        value: "DetermineComponentFrameRoot"
                    });
                    var F = w.DetermineComponentFrameRoot()
                      , ie = F[0]
                      , Me = F[1];
                    if (ie && Me) {
                        var Ie = ie.split(`
`)
                          , ht = Me.split(`
`);
                        for (U = w = 0; w < Ie.length && !Ie[w].includes("DetermineComponentFrameRoot"); )
                            w++;
                        for (; U < ht.length && !ht[U].includes("DetermineComponentFrameRoot"); )
                            U++;
                        if (w === Ie.length || U === ht.length)
                            for (w = Ie.length - 1,
                            U = ht.length - 1; 1 <= w && 0 <= U && Ie[w] !== ht[U]; )
                                U--;
                        for (; 1 <= w && 0 <= U; w--,
                        U--)
                            if (Ie[w] !== ht[U]) {
                                if (w !== 1 || U !== 1)
                                    do
                                        if (w--,
                                        U--,
                                        0 > U || Ie[w] !== ht[U]) {
                                            var Dt = `
` + Ie[w].replace(" at new ", " at ");
                                            return h.displayName && Dt.includes("<anonymous>") && (Dt = Dt.replace("<anonymous>", h.displayName)),
                                            Dt
                                        }
                                    while (1 <= w && 0 <= U);
                                break
                            }
                    }
                } finally {
                    gc = !1,
                    Error.prepareStackTrace = x
                }
                return (x = h ? h.displayName || h.name : "") ? l(x) : ""
            }
            function f(h) {
                switch (h.tag) {
                case 26:
                case 27:
                case 5:
                    return l(h.type);
                case 16:
                    return l("Lazy");
                case 13:
                    return l("Suspense");
                case 19:
                    return l("SuspenseList");
                case 0:
                case 15:
                    return h = u(h.type, !1),
                    h;
                case 11:
                    return h = u(h.type.render, !1),
                    h;
                case 1:
                    return h = u(h.type, !0),
                    h;
                default:
                    return ""
                }
            }
            function d(h) {
                try {
                    var p = "";
                    do
                        p += f(h),
                        h = h.return;
                    while (h);
                    return p
                } catch (x) {
                    return `
Error generating stack: ` + x.message + `
` + x.stack
                }
            }
            function g(h) {
                var p = h
                  , x = h;
                if (h.alternate)
                    for (; p.return; )
                        p = p.return;
                else {
                    h = p;
                    do
                        p = h,
                        (p.flags & 4098) !== 0 && (x = p.return),
                        h = p.return;
                    while (h)
                }
                return p.tag === 3 ? x : null
            }
            function v(h) {
                if (g(h) !== h)
                    throw Error(i(188))
            }
            function y(h) {
                var p = h.alternate;
                if (!p) {
                    if (p = g(h),
                    p === null)
                        throw Error(i(188));
                    return p !== h ? null : h
                }
                for (var x = h, w = p; ; ) {
                    var U = x.return;
                    if (U === null)
                        break;
                    var F = U.alternate;
                    if (F === null) {
                        if (w = U.return,
                        w !== null) {
                            x = w;
                            continue
                        }
                        break
                    }
                    if (U.child === F.child) {
                        for (F = U.child; F; ) {
                            if (F === x)
                                return v(U),
                                h;
                            if (F === w)
                                return v(U),
                                p;
                            F = F.sibling
                        }
                        throw Error(i(188))
                    }
                    if (x.return !== w.return)
                        x = U,
                        w = F;
                    else {
                        for (var ie = !1, Me = U.child; Me; ) {
                            if (Me === x) {
                                ie = !0,
                                x = U,
                                w = F;
                                break
                            }
                            if (Me === w) {
                                ie = !0,
                                w = U,
                                x = F;
                                break
                            }
                            Me = Me.sibling
                        }
                        if (!ie) {
                            for (Me = F.child; Me; ) {
                                if (Me === x) {
                                    ie = !0,
                                    x = F,
                                    w = U;
                                    break
                                }
                                if (Me === w) {
                                    ie = !0,
                                    w = F,
                                    x = U;
                                    break
                                }
                                Me = Me.sibling
                            }
                            if (!ie)
                                throw Error(i(189))
                        }
                    }
                    if (x.alternate !== w)
                        throw Error(i(190))
                }
                if (x.tag !== 3)
                    throw Error(i(188));
                return x.stateNode.current === x ? h : p
            }
            function S(h) {
                var p = h.tag;
                if (p === 5 || p === 26 || p === 27 || p === 6)
                    return h;
                for (h = h.child; h !== null; ) {
                    if (p = S(h),
                    p !== null)
                        return p;
                    h = h.sibling
                }
                return null
            }
            function T(h) {
                var p = h.tag;
                if (p === 5 || p === 26 || p === 27 || p === 6)
                    return h;
                for (h = h.child; h !== null; ) {
                    if (h.tag !== 4 && (p = T(h),
                    p !== null))
                        return p;
                    h = h.sibling
                }
                return null
            }
            function M(h) {
                return {
                    current: h
                }
            }
            function b(h) {
                0 > Nl || (h.current = qi[Nl],
                qi[Nl] = null,
                Nl--)
            }
            function A(h, p) {
                Nl++,
                qi[Nl] = h.current,
                h.current = p
            }
            function C(h) {
                return h >>>= 0,
                h === 0 ? 32 : 31 - (M1(h) / T1 | 0) | 0
            }
            function R(h) {
                var p = h & 42;
                if (p !== 0)
                    return p;
                switch (h & -h) {
                case 1:
                    return 1;
                case 2:
                    return 2;
                case 4:
                    return 4;
                case 8:
                    return 8;
                case 16:
                    return 16;
                case 32:
                    return 32;
                case 64:
                    return 64;
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                    return h & 4194176;
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                    return h & 62914560;
                case 67108864:
                    return 67108864;
                case 134217728:
                    return 134217728;
                case 268435456:
                    return 268435456;
                case 536870912:
                    return 536870912;
                case 1073741824:
                    return 0;
                default:
                    return h
                }
            }
            function O(h, p) {
                var x = h.pendingLanes;
                if (x === 0)
                    return 0;
                var w = 0
                  , U = h.suspendedLanes
                  , F = h.pingedLanes
                  , ie = h.warmLanes;
                h = h.finishedLanes !== 0;
                var Me = x & 134217727;
                return Me !== 0 ? (x = Me & ~U,
                x !== 0 ? w = R(x) : (F &= Me,
                F !== 0 ? w = R(F) : h || (ie = Me & ~ie,
                ie !== 0 && (w = R(ie))))) : (Me = x & ~U,
                Me !== 0 ? w = R(Me) : F !== 0 ? w = R(F) : h || (ie = x & ~ie,
                ie !== 0 && (w = R(ie)))),
                w === 0 ? 0 : p !== 0 && p !== w && (p & U) === 0 && (U = w & -w,
                ie = p & -p,
                U >= ie || U === 32 && (ie & 4194176) !== 0) ? p : w
            }
            function L(h, p) {
                return (h.pendingLanes & ~(h.suspendedLanes & ~h.pingedLanes) & p) === 0
            }
            function z(h, p) {
                switch (h) {
                case 1:
                case 2:
                case 4:
                case 8:
                    return p + 250;
                case 16:
                case 32:
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                    return p + 5e3;
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                    return -1;
                case 67108864:
                case 134217728:
                case 268435456:
                case 536870912:
                case 1073741824:
                    return -1;
                default:
                    return -1
                }
            }
            function I() {
                var h = Bo;
                return Bo <<= 1,
                (Bo & 4194176) === 0 && (Bo = 128),
                h
            }
            function N() {
                var h = _c;
                return _c <<= 1,
                (_c & 62914560) === 0 && (_c = 4194304),
                h
            }
            function P(h) {
                for (var p = [], x = 0; 31 > x; x++)
                    p.push(h);
                return p
            }
            function Y(h, p) {
                h.pendingLanes |= p,
                p !== 268435456 && (h.suspendedLanes = 0,
                h.pingedLanes = 0,
                h.warmLanes = 0)
            }
            function V(h, p, x, w, U, F) {
                var ie = h.pendingLanes;
                h.pendingLanes = x,
                h.suspendedLanes = 0,
                h.pingedLanes = 0,
                h.warmLanes = 0,
                h.expiredLanes &= x,
                h.entangledLanes &= x,
                h.errorRecoveryDisabledLanes &= x,
                h.shellSuspendCounter = 0;
                var Me = h.entanglements
                  , Ie = h.expirationTimes
                  , ht = h.hiddenUpdates;
                for (x = ie & ~x; 0 < x; ) {
                    var Dt = 31 - ua(x)
                      , Ft = 1 << Dt;
                    Me[Dt] = 0,
                    Ie[Dt] = -1;
                    var jt = ht[Dt];
                    if (jt !== null)
                        for (ht[Dt] = null,
                        Dt = 0; Dt < jt.length; Dt++) {
                            var Tn = jt[Dt];
                            Tn !== null && (Tn.lane &= -536870913)
                        }
                    x &= ~Ft
                }
                w !== 0 && K(h, w, 0),
                F !== 0 && U === 0 && h.tag !== 0 && (h.suspendedLanes |= F & ~(ie & ~p))
            }
            function K(h, p, x) {
                h.pendingLanes |= p,
                h.suspendedLanes &= ~p;
                var w = 31 - ua(p);
                h.entangledLanes |= p,
                h.entanglements[w] = h.entanglements[w] | 1073741824 | x & 4194218
            }
            function Z(h, p) {
                var x = h.entangledLanes |= p;
                for (h = h.entanglements; x; ) {
                    var w = 31 - ua(x)
                      , U = 1 << w;
                    U & p | h[w] & p && (h[w] |= p),
                    x &= ~U
                }
            }
            function oe(h) {
                return h &= -h,
                2 < h ? 8 < h ? (h & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
            }
            function H(h) {
                if (Aa && typeof Aa.onCommitFiberRoot == "function")
                    try {
                        Aa.onCommitFiberRoot(Zi, h, void 0, (h.current.flags & 128) === 128)
                    } catch {}
            }
            function q(h) {
                if (typeof A1 == "function" && Sr(h),
                Aa && typeof Aa.setStrictMode == "function")
                    try {
                        Aa.setStrictMode(Zi, h)
                    } catch {}
            }
            function Q(h, p) {
                return h === p && (h !== 0 || 1 / h === 1 / p) || h !== h && p !== p
            }
            function se(h, p) {
                if (typeof h == "object" && h !== null) {
                    var x = G0.get(h);
                    return x !== void 0 ? x : (p = {
                        value: h,
                        source: p,
                        stack: d(p)
                    },
                    G0.set(h, p),
                    p)
                }
                return {
                    value: h,
                    source: p,
                    stack: d(p)
                }
            }
            function B(h, p) {
                xc[Sc++] = Af,
                xc[Sc++] = bc,
                bc = h,
                Af = p
            }
            function W(h, p, x) {
                qa[Za++] = ro,
                qa[Za++] = ao,
                qa[Za++] = Tu,
                Tu = h;
                var w = ro;
                h = ao;
                var U = 32 - ua(w) - 1;
                w &= ~(1 << U),
                x += 1;
                var F = 32 - ua(p) + U;
                if (30 < F) {
                    var ie = U - U % 5;
                    F = (w & (1 << ie) - 1).toString(32),
                    w >>= ie,
                    U -= ie,
                    ro = 1 << 32 - ua(p) + U | x << U | w,
                    ao = F + h
                } else
                    ro = 1 << F | x << U | w,
                    ao = h
            }
            function te(h) {
                h.return !== null && (B(h, 1),
                W(h, 1, 0))
            }
            function fe(h) {
                for (; h === bc; )
                    bc = xc[--Sc],
                    xc[Sc] = null,
                    Af = xc[--Sc],
                    xc[Sc] = null;
                for (; h === Tu; )
                    Tu = qa[--Za],
                    qa[Za] = null,
                    ao = qa[--Za],
                    qa[Za] = null,
                    ro = qa[--Za],
                    qa[Za] = null
            }
            function pe(h, p) {
                A(zo, p),
                A(Cf, h),
                A(fr, null),
                h = k_(p),
                b(fr),
                A(fr, h)
            }
            function _e() {
                b(fr),
                b(Cf),
                b(zo)
            }
            function ue(h) {
                h.memoizedState !== null && A(Mc, h);
                var p = fr.current
                  , x = bf(p, h.type);
                p !== x && (A(Cf, h),
                A(fr, x))
            }
            function ge(h) {
                Cf.current === h && (b(fr),
                b(Cf)),
                Mc.current === h && (b(Mc),
                oa ? no._currentValue = _u : no._currentValue2 = _u)
            }
            function Te(h) {
                var p = Error(i(418, ""));
                throw re(se(p, h)),
                ld
            }
            function Ze(h, p) {
                if (!Lr)
                    throw Error(i(175));
                d1(h.stateNode, h.type, h.memoizedProps, p, h) || Te(h)
            }
            function ot(h) {
                for (Pr = h.return; Pr; )
                    switch (Pr.tag) {
                    case 3:
                    case 27:
                        br = !0;
                        return;
                    case 5:
                    case 13:
                        br = !1;
                        return;
                    default:
                        Pr = Pr.return
                    }
            }
            function tt(h) {
                if (!Lr || h !== Pr)
                    return !1;
                if (!Yn)
                    return ot(h),
                    Yn = !0,
                    !1;
                var p = !1;
                if (pi ? h.tag !== 3 && h.tag !== 27 && (h.tag !== 5 || Kp(h.type) && !wn(h.type, h.memoizedProps)) && (p = !0) : h.tag !== 3 && (h.tag !== 5 || Kp(h.type) && !wn(h.type, h.memoizedProps)) && (p = !0),
                p && Br && Te(h),
                ot(h),
                h.tag === 13) {
                    if (!Lr)
                        throw Error(i(316));
                    if (h = h.memoizedState,
                    h = h !== null ? h.dehydrated : null,
                    !h)
                        throw Error(i(317));
                    Br = m1(h)
                } else
                    Br = Pr ? F0(h.stateNode) : null;
                return !0
            }
            function $e() {
                Lr && (Br = Pr = null,
                Yn = !1)
            }
            function re(h) {
                Os === null ? Os = [h] : Os.push(h)
            }
            function Le() {
                for (var h = Tc, p = so = Tc = 0; p < h; ) {
                    var x = Ns[p];
                    Ns[p++] = null;
                    var w = Ns[p];
                    Ns[p++] = null;
                    var U = Ns[p];
                    Ns[p++] = null;
                    var F = Ns[p];
                    if (Ns[p++] = null,
                    w !== null && U !== null) {
                        var ie = w.pending;
                        ie === null ? U.next = U : (U.next = ie.next,
                        ie.next = U),
                        w.pending = U
                    }
                    F !== 0 && Pe(x, U, F)
                }
            }
            function Ne(h, p, x, w) {
                Ns[Tc++] = h,
                Ns[Tc++] = p,
                Ns[Tc++] = x,
                Ns[Tc++] = w,
                so |= w,
                h.lanes |= w,
                h = h.alternate,
                h !== null && (h.lanes |= w)
            }
            function Oe(h, p, x, w) {
                return Ne(h, p, x, w),
                He(h)
            }
            function le(h, p) {
                return Ne(h, null, null, p),
                He(h)
            }
            function Pe(h, p, x) {
                h.lanes |= x;
                var w = h.alternate;
                w !== null && (w.lanes |= x);
                for (var U = !1, F = h.return; F !== null; )
                    F.childLanes |= x,
                    w = F.alternate,
                    w !== null && (w.childLanes |= x),
                    F.tag === 22 && (h = F.stateNode,
                    h === null || h._visibility & 1 || (U = !0)),
                    h = F,
                    F = F.return;
                U && p !== null && h.tag === 3 && (F = h.stateNode,
                U = 31 - ua(x),
                F = F.hiddenUpdates,
                h = F[U],
                h === null ? F[U] = [p] : h.push(p),
                p.lane = x | 536870912)
            }
            function He(h) {
                if (50 < zf)
                    throw zf = 0,
                    fm = null,
                    Error(i(185));
                for (var p = h.return; p !== null; )
                    h = p,
                    p = h.return;
                return h.tag === 3 ? h.stateNode : null
            }
            function Ve(h) {
                h !== Ll && h.next === null && (Ll === null ? ud = Ll = h : Ll = Ll.next = h),
                Si = !0,
                Ec || (Ec = !0,
                Be(vt))
            }
            function De(h, p) {
                if (!X0 && Si) {
                    X0 = !0;
                    do
                        for (var x = !1, w = ud; w !== null; ) {
                            if (h !== 0) {
                                var U = w.pendingLanes;
                                if (U === 0)
                                    var F = 0;
                                else {
                                    var ie = w.suspendedLanes
                                      , Me = w.pingedLanes;
                                    F = (1 << 31 - ua(42 | h) + 1) - 1,
                                    F &= U & ~(ie & ~Me),
                                    F = F & 201326677 ? F & 201326677 | 1 : F ? F | 2 : 0
                                }
                                F !== 0 && (x = !0,
                                ve(w, F))
                            } else
                                F = Vn,
                                F = O(w, w === oi ? F : 0),
                                (F & 3) === 0 || L(w, F) || (x = !0,
                                ve(w, F));
                            w = w.next
                        }
                    while (x);
                    X0 = !1
                }
            }
            function vt() {
                Si = Ec = !1;
                var h = 0;
                Rf !== 0 && (W_() && (h = Rf),
                Rf = 0);
                for (var p = Us(), x = null, w = ud; w !== null; ) {
                    var U = w.next
                      , F = J(w, p);
                    F === 0 ? (w.next = null,
                    x === null ? ud = U : x.next = U,
                    U === null && (Ll = x)) : (x = w,
                    (h !== 0 || (F & 3) !== 0) && (Si = !0)),
                    w = U
                }
                De(h)
            }
            function J(h, p) {
                for (var x = h.suspendedLanes, w = h.pingedLanes, U = h.expirationTimes, F = h.pendingLanes & -62914561; 0 < F; ) {
                    var ie = 31 - ua(F)
                      , Me = 1 << ie
                      , Ie = U[ie];
                    Ie === -1 ? ((Me & x) === 0 || (Me & w) !== 0) && (U[ie] = z(Me, p)) : Ie <= p && (h.expiredLanes |= Me),
                    F &= ~Me
                }
                if (p = oi,
                x = Vn,
                x = O(h, h === p ? x : 0),
                w = h.callbackNode,
                x === 0 || h === p && hi === 2 || h.cancelPendingCommit !== null)
                    return w !== null && w !== null && em(w),
                    h.callbackNode = null,
                    h.callbackPriority = 0;
                if ((x & 3) === 0 || L(h, x)) {
                    if (p = x & -x,
                    p === h.callbackPriority)
                        return p;
                    switch (w !== null && em(w),
                    oe(x)) {
                    case 2:
                    case 8:
                        x = w1;
                        break;
                    case 32:
                        x = im;
                        break;
                    case 268435456:
                        x = JM;
                        break;
                    default:
                        x = im
                    }
                    return w = j.bind(null, h),
                    x = od(x, w),
                    h.callbackPriority = p,
                    h.callbackNode = x,
                    p
                }
                return w !== null && w !== null && em(w),
                h.callbackPriority = 2,
                h.callbackNode = null,
                2
            }
            function j(h, p) {
                var x = h.callbackNode;
                if (eo() && h.callbackNode !== x)
                    return null;
                var w = Vn;
                return w = O(h, h === oi ? w : 0),
                w === 0 ? null : (hu(h, w, p),
                J(h, Us()),
                h.callbackNode != null && h.callbackNode === x ? j.bind(null, h) : null)
            }
            function ve(h, p) {
                if (eo())
                    return null;
                hu(h, p, !0)
            }
            function Be(h) {
                R0 ? Ol(function() {
                    (Zn & 6) !== 0 ? od(nm, h) : h()
                }) : od(nm, h)
            }
            function we() {
                return Rf === 0 && (Rf = I()),
                Rf
            }
            function Ce(h, p) {
                if (Df === null) {
                    var x = Df = [];
                    wc = 0,
                    Ka = we(),
                    Ac = {
                        status: "pending",
                        value: void 0,
                        then: function(w) {
                            x.push(w)
                        }
                    }
                }
                return wc++,
                p.then(it, it),
                p
            }
            function it() {
                if (--wc === 0 && Df !== null) {
                    Ac !== null && (Ac.status = "fulfilled");
                    var h = Df;
                    Df = null,
                    Ka = 0,
                    Ac = null;
                    for (var p = 0; p < h.length; p++)
                        (0,
                        h[p])()
                }
            }
            function lt(h, p) {
                var x = []
                  , w = {
                    status: "pending",
                    value: null,
                    reason: null,
                    then: function(U) {
                        x.push(U)
                    }
                };
                return h.then(function() {
                    w.status = "fulfilled",
                    w.value = p;
                    for (var U = 0; U < x.length; U++)
                        (0,
                        x[U])(p)
                }, function(U) {
                    for (w.status = "rejected",
                    w.reason = U,
                    U = 0; U < x.length; U++)
                        (0,
                        x[U])(void 0)
                }),
                w
            }
            function Mt(h) {
                h.updateQueue = {
                    baseState: h.memoizedState,
                    firstBaseUpdate: null,
                    lastBaseUpdate: null,
                    shared: {
                        pending: null,
                        lanes: 0,
                        hiddenCallbacks: null
                    },
                    callbacks: null
                }
            }
            function pt(h, p) {
                h = h.updateQueue,
                p.updateQueue === h && (p.updateQueue = {
                    baseState: h.baseState,
                    firstBaseUpdate: h.firstBaseUpdate,
                    lastBaseUpdate: h.lastBaseUpdate,
                    shared: h.shared,
                    callbacks: null
                })
            }
            function je(h) {
                return {
                    lane: h,
                    tag: 0,
                    payload: null,
                    callback: null,
                    next: null
                }
            }
            function Ye(h, p, x) {
                var w = h.updateQueue;
                if (w === null)
                    return null;
                if (w = w.shared,
                (Zn & 2) !== 0) {
                    var U = w.pending;
                    return U === null ? p.next = p : (p.next = U.next,
                    U.next = p),
                    w.pending = p,
                    p = He(h),
                    Pe(h, null, x),
                    p
                }
                return Ne(h, w, p, x),
                He(h)
            }
            function ct(h, p, x) {
                if (p = p.updateQueue,
                p !== null && (p = p.shared,
                (x & 4194176) !== 0)) {
                    var w = p.lanes;
                    w &= h.pendingLanes,
                    x |= w,
                    p.lanes = x,
                    Z(h, x)
                }
            }
            function _t(h, p) {
                var x = h.updateQueue
                  , w = h.alternate;
                if (w !== null && (w = w.updateQueue,
                x === w)) {
                    var U = null
                      , F = null;
                    if (x = x.firstBaseUpdate,
                    x !== null) {
                        do {
                            var ie = {
                                lane: x.lane,
                                tag: x.tag,
                                payload: x.payload,
                                callback: null,
                                next: null
                            };
                            F === null ? U = F = ie : F = F.next = ie,
                            x = x.next
                        } while (x !== null);
                        F === null ? U = F = p : F = F.next = p
                    } else
                        U = F = p;
                    x = {
                        baseState: w.baseState,
                        firstBaseUpdate: U,
                        lastBaseUpdate: F,
                        shared: w.shared,
                        callbacks: w.callbacks
                    },
                    h.updateQueue = x;
                    return
                }
                h = x.lastBaseUpdate,
                h === null ? x.firstBaseUpdate = p : h.next = p,
                x.lastBaseUpdate = p
            }
            function ut() {
                if (Cc) {
                    var h = Ac;
                    if (h !== null)
                        throw h
                }
            }
            function Ut(h, p, x, w) {
                Cc = !1;
                var U = h.updateQueue;
                Pl = !1;
                var F = U.firstBaseUpdate
                  , ie = U.lastBaseUpdate
                  , Me = U.shared.pending;
                if (Me !== null) {
                    U.shared.pending = null;
                    var Ie = Me
                      , ht = Ie.next;
                    Ie.next = null,
                    ie === null ? F = ht : ie.next = ht,
                    ie = Ie;
                    var Dt = h.alternate;
                    Dt !== null && (Dt = Dt.updateQueue,
                    Me = Dt.lastBaseUpdate,
                    Me !== ie && (Me === null ? Dt.firstBaseUpdate = ht : Me.next = ht,
                    Dt.lastBaseUpdate = Ie))
                }
                if (F !== null) {
                    var Ft = U.baseState;
                    ie = 0,
                    Dt = ht = Ie = null,
                    Me = F;
                    do {
                        var jt = Me.lane & -536870913
                          , Tn = jt !== Me.lane;
                        if (Tn ? (Vn & jt) === jt : (w & jt) === jt) {
                            jt !== 0 && jt === Ka && (Cc = !0),
                            Dt !== null && (Dt = Dt.next = {
                                lane: 0,
                                tag: Me.tag,
                                payload: Me.payload,
                                callback: null,
                                next: null
                            });
                            e: {
                                var rs = h
                                  , Nu = Me;
                                jt = p;
                                var Lu = x;
                                switch (Nu.tag) {
                                case 1:
                                    if (rs = Nu.payload,
                                    typeof rs == "function") {
                                        Ft = rs.call(Lu, Ft, jt);
                                        break e
                                    }
                                    Ft = rs;
                                    break e;
                                case 3:
                                    rs.flags = rs.flags & -65537 | 128;
                                case 0:
                                    if (rs = Nu.payload,
                                    jt = typeof rs == "function" ? rs.call(Lu, Ft, jt) : rs,
                                    jt == null)
                                        break e;
                                    Ft = Ip({}, Ft, jt);
                                    break e;
                                case 2:
                                    Pl = !0
                                }
                            }
                            jt = Me.callback,
                            jt !== null && (h.flags |= 64,
                            Tn && (h.flags |= 8192),
                            Tn = U.callbacks,
                            Tn === null ? U.callbacks = [jt] : Tn.push(jt))
                        } else
                            Tn = {
                                lane: jt,
                                tag: Me.tag,
                                payload: Me.payload,
                                callback: Me.callback,
                                next: null
                            },
                            Dt === null ? (ht = Dt = Tn,
                            Ie = Ft) : Dt = Dt.next = Tn,
                            ie |= jt;
                        if (Me = Me.next,
                        Me === null) {
                            if (Me = U.shared.pending,
                            Me === null)
                                break;
                            Tn = Me,
                            Me = Tn.next,
                            Tn.next = null,
                            U.lastBaseUpdate = Tn,
                            U.shared.pending = null
                        }
                    } while (!0);
                    Dt === null && (Ie = Ft),
                    U.baseState = Ie,
                    U.firstBaseUpdate = ht,
                    U.lastBaseUpdate = Dt,
                    F === null && (U.shared.lanes = 0),
                    ns |= ie,
                    h.lanes = ie,
                    h.memoizedState = Ft
                }
            }
            function me(h, p) {
                if (typeof h != "function")
                    throw Error(i(191, h));
                h.call(p)
            }
            function Ee(h, p) {
                var x = h.callbacks;
                if (x !== null)
                    for (h.callbacks = null,
                    h = 0; h < x.length; h++)
                        me(x[h], p)
            }
            function at(h, p) {
                if (Ca(h, p))
                    return !0;
                if (typeof h != "object" || h === null || typeof p != "object" || p === null)
                    return !1;
                var x = Object.keys(h)
                  , w = Object.keys(p);
                if (x.length !== w.length)
                    return !1;
                for (w = 0; w < x.length; w++) {
                    var U = x[w];
                    if (!Io.call(p, U) || !Ca(h[U], p[U]))
                        return !1
                }
                return !0
            }
            function Ct(h) {
                return h = h.status,
                h === "fulfilled" || h === "rejected"
            }
            function rt() {}
            function Ge(h, p, x) {
                switch (x = h[x],
                x === void 0 ? h.push(p) : x !== p && (p.then(rt, rt),
                p = x),
                p.status) {
                case "fulfilled":
                    return p.value;
                case "rejected":
                    throw h = p.reason,
                    h === Uf ? Error(i(483)) : h;
                default:
                    if (typeof p.status == "string")
                        p.then(rt, rt);
                    else {
                        if (h = oi,
                        h !== null && 100 < h.shellSuspendCounter)
                            throw Error(i(482));
                        h = p,
                        h.status = "pending",
                        h.then(function(w) {
                            if (p.status === "pending") {
                                var U = p;
                                U.status = "fulfilled",
                                U.value = w
                            }
                        }, function(w) {
                            if (p.status === "pending") {
                                var U = p;
                                U.status = "rejected",
                                U.reason = w
                            }
                        })
                    }
                    switch (p.status) {
                    case "fulfilled":
                        return p.value;
                    case "rejected":
                        throw h = p.reason,
                        h === Uf ? Error(i(483)) : h
                    }
                    throw Eu = p,
                    Uf
                }
            }
            function wt() {
                if (Eu === null)
                    throw Error(i(459));
                var h = Eu;
                return Eu = null,
                h
            }
            function Ot(h) {
                var p = Au;
                return Au += 1,
                wu === null && (wu = []),
                Ge(wu, h, p)
            }
            function Nt(h, p) {
                p = p.props.ref,
                h.ref = p !== void 0 ? p : null
            }
            function bt(h, p) {
                throw p.$$typeof === jM ? Error(i(525)) : (h = Object.prototype.toString.call(p),
                Error(i(31, h === "[object Object]" ? "object with keys {" + Object.keys(p).join(", ") + "}" : h)))
            }
            function Bt(h) {
                var p = h._init;
                return p(h._payload)
            }
            function Gt(h) {
                function p(qe, Ae) {
                    if (h) {
                        var et = qe.deletions;
                        et === null ? (qe.deletions = [Ae],
                        qe.flags |= 16) : et.push(Ae)
                    }
                }
                function x(qe, Ae) {
                    if (!h)
                        return null;
                    for (; Ae !== null; )
                        p(qe, Ae),
                        Ae = Ae.sibling;
                    return null
                }
                function w(qe) {
                    for (var Ae = new Map; qe !== null; )
                        qe.key !== null ? Ae.set(qe.key, qe) : Ae.set(qe.index, qe),
                        qe = qe.sibling;
                    return Ae
                }
                function U(qe, Ae) {
                    return qe = As(qe, Ae),
                    qe.index = 0,
                    qe.sibling = null,
                    qe
                }
                function F(qe, Ae, et) {
                    return qe.index = et,
                    h ? (et = qe.alternate,
                    et !== null ? (et = et.index,
                    et < Ae ? (qe.flags |= 33554434,
                    Ae) : et) : (qe.flags |= 33554434,
                    Ae)) : (qe.flags |= 1048576,
                    Ae)
                }
                function ie(qe) {
                    return h && qe.alternate === null && (qe.flags |= 33554434),
                    qe
                }
                function Me(qe, Ae, et, Rt) {
                    return Ae === null || Ae.tag !== 6 ? (Ae = Bp(et, qe.mode, Rt),
                    Ae.return = qe,
                    Ae) : (Ae = U(Ae, et),
                    Ae.return = qe,
                    Ae)
                }
                function Ie(qe, Ae, et, Rt) {
                    var tn = et.type;
                    return tn === vu ? Dt(qe, Ae, et.props.children, Rt, et.key) : Ae !== null && (Ae.elementType === tn || typeof tn == "object" && tn !== null && tn.$$typeof === Rs && Bt(tn) === Ae.type) ? (Ae = U(Ae, et.props),
                    Nt(Ae, et),
                    Ae.return = qe,
                    Ae) : (Ae = No(et.type, et.key, et.props, null, qe.mode, Rt),
                    Nt(Ae, et),
                    Ae.return = qe,
                    Ae)
                }
                function ht(qe, Ae, et, Rt) {
                    return Ae === null || Ae.tag !== 4 || Ae.stateNode.containerInfo !== et.containerInfo || Ae.stateNode.implementation !== et.implementation ? (Ae = S0(et, qe.mode, Rt),
                    Ae.return = qe,
                    Ae) : (Ae = U(Ae, et.children || []),
                    Ae.return = qe,
                    Ae)
                }
                function Dt(qe, Ae, et, Rt, tn) {
                    return Ae === null || Ae.tag !== 7 ? (Ae = Ii(et, qe.mode, Rt, tn),
                    Ae.return = qe,
                    Ae) : (Ae = U(Ae, et),
                    Ae.return = qe,
                    Ae)
                }
                function Ft(qe, Ae, et) {
                    if (typeof Ae == "string" && Ae !== "" || typeof Ae == "number" || typeof Ae == "bigint")
                        return Ae = Bp("" + Ae, qe.mode, et),
                        Ae.return = qe,
                        Ae;
                    if (typeof Ae == "object" && Ae !== null) {
                        switch (Ae.$$typeof) {
                        case Kh:
                            return et = No(Ae.type, Ae.key, Ae.props, null, qe.mode, et),
                            Nt(et, Ae),
                            et.return = qe,
                            et;
                        case Cs:
                            return Ae = S0(Ae, qe.mode, et),
                            Ae.return = qe,
                            Ae;
                        case Rs:
                            var Rt = Ae._init;
                            return Ae = Rt(Ae._payload),
                            Ft(qe, Ae, et)
                        }
                        if (_f(Ae) || a(Ae))
                            return Ae = Ii(Ae, qe.mode, et, null),
                            Ae.return = qe,
                            Ae;
                        if (typeof Ae.then == "function")
                            return Ft(qe, Ot(Ae), et);
                        if (Ae.$$typeof === to)
                            return Ft(qe, Ph(qe, Ae), et);
                        bt(qe, Ae)
                    }
                    return null
                }
                function jt(qe, Ae, et, Rt) {
                    var tn = Ae !== null ? Ae.key : null;
                    if (typeof et == "string" && et !== "" || typeof et == "number" || typeof et == "bigint")
                        return tn !== null ? null : Me(qe, Ae, "" + et, Rt);
                    if (typeof et == "object" && et !== null) {
                        switch (et.$$typeof) {
                        case Kh:
                            return et.key === tn ? Ie(qe, Ae, et, Rt) : null;
                        case Cs:
                            return et.key === tn ? ht(qe, Ae, et, Rt) : null;
                        case Rs:
                            return tn = et._init,
                            et = tn(et._payload),
                            jt(qe, Ae, et, Rt)
                        }
                        if (_f(et) || a(et))
                            return tn !== null ? null : Dt(qe, Ae, et, Rt, null);
                        if (typeof et.then == "function")
                            return jt(qe, Ae, Ot(et), Rt);
                        if (et.$$typeof === to)
                            return jt(qe, Ae, Ph(qe, et), Rt);
                        bt(qe, et)
                    }
                    return null
                }
                function Tn(qe, Ae, et, Rt, tn) {
                    if (typeof Rt == "string" && Rt !== "" || typeof Rt == "number" || typeof Rt == "bigint")
                        return qe = qe.get(et) || null,
                        Me(Ae, qe, "" + Rt, tn);
                    if (typeof Rt == "object" && Rt !== null) {
                        switch (Rt.$$typeof) {
                        case Kh:
                            return qe = qe.get(Rt.key === null ? et : Rt.key) || null,
                            Ie(Ae, qe, Rt, tn);
                        case Cs:
                            return qe = qe.get(Rt.key === null ? et : Rt.key) || null,
                            ht(Ae, qe, Rt, tn);
                        case Rs:
                            var Ci = Rt._init;
                            return Rt = Ci(Rt._payload),
                            Tn(qe, Ae, et, Rt, tn)
                        }
                        if (_f(Rt) || a(Rt))
                            return qe = qe.get(et) || null,
                            Dt(Ae, qe, Rt, tn, null);
                        if (typeof Rt.then == "function")
                            return Tn(qe, Ae, et, Ot(Rt), tn);
                        if (Rt.$$typeof === to)
                            return Tn(qe, Ae, et, Ph(Ae, Rt), tn);
                        bt(Ae, Rt)
                    }
                    return null
                }
                function rs(qe, Ae, et, Rt) {
                    for (var tn = null, Ci = null, mn = Ae, ei = Ae = 0, Ki = null; mn !== null && ei < et.length; ei++) {
                        mn.index > ei ? (Ki = mn,
                        mn = null) : Ki = mn.sibling;
                        var Fn = jt(qe, mn, et[ei], Rt);
                        if (Fn === null) {
                            mn === null && (mn = Ki);
                            break
                        }
                        h && mn && Fn.alternate === null && p(qe, mn),
                        Ae = F(Fn, Ae, ei),
                        Ci === null ? tn = Fn : Ci.sibling = Fn,
                        Ci = Fn,
                        mn = Ki
                    }
                    if (ei === et.length)
                        return x(qe, mn),
                        Yn && B(qe, ei),
                        tn;
                    if (mn === null) {
                        for (; ei < et.length; ei++)
                            mn = Ft(qe, et[ei], Rt),
                            mn !== null && (Ae = F(mn, Ae, ei),
                            Ci === null ? tn = mn : Ci.sibling = mn,
                            Ci = mn);
                        return Yn && B(qe, ei),
                        tn
                    }
                    for (mn = w(mn); ei < et.length; ei++)
                        Ki = Tn(mn, qe, ei, et[ei], Rt),
                        Ki !== null && (h && Ki.alternate !== null && mn.delete(Ki.key === null ? ei : Ki.key),
                        Ae = F(Ki, Ae, ei),
                        Ci === null ? tn = Ki : Ci.sibling = Ki,
                        Ci = Ki);
                    return h && mn.forEach(function(Wo) {
                        return p(qe, Wo)
                    }),
                    Yn && B(qe, ei),
                    tn
                }
                function Nu(qe, Ae, et, Rt) {
                    if (et == null)
                        throw Error(i(151));
                    for (var tn = null, Ci = null, mn = Ae, ei = Ae = 0, Ki = null, Fn = et.next(); mn !== null && !Fn.done; ei++,
                    Fn = et.next()) {
                        mn.index > ei ? (Ki = mn,
                        mn = null) : Ki = mn.sibling;
                        var Wo = jt(qe, mn, Fn.value, Rt);
                        if (Wo === null) {
                            mn === null && (mn = Ki);
                            break
                        }
                        h && mn && Wo.alternate === null && p(qe, mn),
                        Ae = F(Wo, Ae, ei),
                        Ci === null ? tn = Wo : Ci.sibling = Wo,
                        Ci = Wo,
                        mn = Ki
                    }
                    if (Fn.done)
                        return x(qe, mn),
                        Yn && B(qe, ei),
                        tn;
                    if (mn === null) {
                        for (; !Fn.done; ei++,
                        Fn = et.next())
                            Fn = Ft(qe, Fn.value, Rt),
                            Fn !== null && (Ae = F(Fn, Ae, ei),
                            Ci === null ? tn = Fn : Ci.sibling = Fn,
                            Ci = Fn);
                        return Yn && B(qe, ei),
                        tn
                    }
                    for (mn = w(mn); !Fn.done; ei++,
                    Fn = et.next())
                        Fn = Tn(mn, qe, ei, Fn.value, Rt),
                        Fn !== null && (h && Fn.alternate !== null && mn.delete(Fn.key === null ? ei : Fn.key),
                        Ae = F(Fn, Ae, ei),
                        Ci === null ? tn = Fn : Ci.sibling = Fn,
                        Ci = Fn);
                    return h && mn.forEach(function(hm) {
                        return p(qe, hm)
                    }),
                    Yn && B(qe, ei),
                    tn
                }
                function Lu(qe, Ae, et, Rt) {
                    if (typeof et == "object" && et !== null && et.type === vu && et.key === null && (et = et.props.children),
                    typeof et == "object" && et !== null) {
                        switch (et.$$typeof) {
                        case Kh:
                            e: {
                                for (var tn = et.key; Ae !== null; ) {
                                    if (Ae.key === tn) {
                                        if (tn = et.type,
                                        tn === vu) {
                                            if (Ae.tag === 7) {
                                                x(qe, Ae.sibling),
                                                Rt = U(Ae, et.props.children),
                                                Rt.return = qe,
                                                qe = Rt;
                                                break e
                                            }
                                        } else if (Ae.elementType === tn || typeof tn == "object" && tn !== null && tn.$$typeof === Rs && Bt(tn) === Ae.type) {
                                            x(qe, Ae.sibling),
                                            Rt = U(Ae, et.props),
                                            Nt(Rt, et),
                                            Rt.return = qe,
                                            qe = Rt;
                                            break e
                                        }
                                        x(qe, Ae);
                                        break
                                    } else
                                        p(qe, Ae);
                                    Ae = Ae.sibling
                                }
                                et.type === vu ? (Rt = Ii(et.props.children, qe.mode, Rt, et.key),
                                Rt.return = qe,
                                qe = Rt) : (Rt = No(et.type, et.key, et.props, null, qe.mode, Rt),
                                Nt(Rt, et),
                                Rt.return = qe,
                                qe = Rt)
                            }
                            return ie(qe);
                        case Cs:
                            e: {
                                for (tn = et.key; Ae !== null; ) {
                                    if (Ae.key === tn)
                                        if (Ae.tag === 4 && Ae.stateNode.containerInfo === et.containerInfo && Ae.stateNode.implementation === et.implementation) {
                                            x(qe, Ae.sibling),
                                            Rt = U(Ae, et.children || []),
                                            Rt.return = qe,
                                            qe = Rt;
                                            break e
                                        } else {
                                            x(qe, Ae);
                                            break
                                        }
                                    else
                                        p(qe, Ae);
                                    Ae = Ae.sibling
                                }
                                Rt = S0(et, qe.mode, Rt),
                                Rt.return = qe,
                                qe = Rt
                            }
                            return ie(qe);
                        case Rs:
                            return tn = et._init,
                            et = tn(et._payload),
                            Lu(qe, Ae, et, Rt)
                        }
                        if (_f(et))
                            return rs(qe, Ae, et, Rt);
                        if (a(et)) {
                            if (tn = a(et),
                            typeof tn != "function")
                                throw Error(i(150));
                            return et = tn.call(et),
                            Nu(qe, Ae, et, Rt)
                        }
                        if (typeof et.then == "function")
                            return Lu(qe, Ae, Ot(et), Rt);
                        if (et.$$typeof === to)
                            return Lu(qe, Ae, Ph(qe, et), Rt);
                        bt(qe, et)
                    }
                    return typeof et == "string" && et !== "" || typeof et == "number" || typeof et == "bigint" ? (et = "" + et,
                    Ae !== null && Ae.tag === 6 ? (x(qe, Ae.sibling),
                    Rt = U(Ae, et),
                    Rt.return = qe,
                    qe = Rt) : (x(qe, Ae),
                    Rt = Bp(et, qe.mode, Rt),
                    Rt.return = qe,
                    qe = Rt),
                    ie(qe)) : x(qe, Ae)
                }
                return function(qe, Ae, et, Rt) {
                    try {
                        Au = 0;
                        var tn = Lu(qe, Ae, et, Rt);
                        return wu = null,
                        tn
                    } catch (mn) {
                        if (mn === Uf)
                            throw mn;
                        var Ci = t(29, mn, null, qe.mode);
                        return Ci.lanes = Rt,
                        Ci.return = qe,
                        Ci
                    } finally {}
                }
            }
            function mt(h, p) {
                h = Wr,
                A(Of, h),
                A(bi, p),
                Wr = h | p.baseLanes
            }
            function Lt() {
                A(Of, Wr),
                A(bi, bi.current)
            }
            function zt() {
                Wr = Of.current,
                b(bi),
                b(Of)
            }
            function Wt(h) {
                var p = h.alternate;
                A(hr, hr.current & 1),
                A(Qa, h),
                mi === null && (p === null || bi.current !== null || p.memoizedState !== null) && (mi = h)
            }
            function Ln(h) {
                if (h.tag === 22) {
                    if (A(hr, hr.current),
                    A(Qa, h),
                    mi === null) {
                        var p = h.alternate;
                        p !== null && p.memoizedState !== null && (mi = h)
                    }
                } else
                    qt()
            }
            function qt() {
                A(hr, hr.current),
                A(Qa, Qa.current)
            }
            function Pt(h) {
                b(Qa),
                mi === h && (mi = null),
                b(hr)
            }
            function un(h) {
                for (var p = h; p !== null; ) {
                    if (p.tag === 13) {
                        var x = p.memoizedState;
                        if (x !== null && (x = x.dehydrated,
                        x === null || Yp(x) || qp(x)))
                            return p
                    } else if (p.tag === 19 && p.memoizedProps.revealOrder !== void 0) {
                        if ((p.flags & 128) !== 0)
                            return p
                    } else if (p.child !== null) {
                        p.child.return = p,
                        p = p.child;
                        continue
                    }
                    if (p === h)
                        break;
                    for (; p.sibling === null; ) {
                        if (p.return === null || p.return === h)
                            return null;
                        p = p.return
                    }
                    p.sibling.return = p.return,
                    p = p.sibling
                }
                return null
            }
            function $t() {
                throw Error(i(321))
            }
            function k(h, p) {
                if (p === null)
                    return !1;
                for (var x = 0; x < p.length && x < h.length; x++)
                    if (!Ca(h[x], p[x]))
                        return !1;
                return !0
            }
            function $(h, p, x, w, U, F) {
                return Bl = F,
                Dn = p,
                p.memoizedState = null,
                p.updateQueue = null,
                p.lanes = 0,
                pn.H = h === null || h.memoizedState === null ? Du : ca,
                Ru = !1,
                F = x(w, U),
                Ru = !1,
                Rc && (F = Ue(p, x, w, U)),
                Se(h),
                F
            }
            function Se(h) {
                pn.H = Fi;
                var p = sn !== null && sn.next !== null;
                if (Bl = 0,
                qn = sn = Dn = null,
                Ls = !1,
                Dc = 0,
                Mr = null,
                p)
                    throw Error(i(300));
                h === null || gi || (h = h.dependencies,
                h !== null && Lh(h) && (gi = !0))
            }
            function Ue(h, p, x, w) {
                Dn = h;
                var U = 0;
                do {
                    if (Rc && (Mr = null),
                    Dc = 0,
                    Rc = !1,
                    25 <= U)
                        throw Error(i(301));
                    if (U += 1,
                    qn = sn = null,
                    h.updateQueue != null) {
                        var F = h.updateQueue;
                        F.lastEffect = null,
                        F.events = null,
                        F.stores = null,
                        F.memoCache != null && (F.memoCache.index = 0)
                    }
                    pn.H = Ja,
                    F = p(x, w)
                } while (Rc);
                return F
            }
            function Fe() {
                var h = pn.H
                  , p = h.useState()[0];
                return p = typeof p.then == "function" ? xe(p) : p,
                h = h.useState()[0],
                (sn !== null ? sn.memoizedState : null) !== h && (Dn.flags |= 1024),
                p
            }
            function Ke() {
                var h = rm !== 0;
                return rm = 0,
                h
            }
            function yt(h, p, x) {
                p.updateQueue = h.updateQueue,
                p.flags &= -2053,
                h.lanes &= ~x
            }
            function G(h) {
                if (Ls) {
                    for (h = h.memoizedState; h !== null; ) {
                        var p = h.queue;
                        p !== null && (p.pending = null),
                        h = h.next
                    }
                    Ls = !1
                }
                Bl = 0,
                qn = sn = Dn = null,
                Rc = !1,
                Dc = rm = 0,
                Mr = null
            }
            function ce() {
                var h = {
                    memoizedState: null,
                    baseState: null,
                    baseQueue: null,
                    queue: null,
                    next: null
                };
                return qn === null ? Dn.memoizedState = qn = h : qn = qn.next = h,
                qn
            }
            function ye() {
                if (sn === null) {
                    var h = Dn.alternate;
                    h = h !== null ? h.memoizedState : null
                } else
                    h = sn.next;
                var p = qn === null ? Dn.memoizedState : qn.next;
                if (p !== null)
                    qn = p,
                    sn = h;
                else {
                    if (h === null)
                        throw Dn.alternate === null ? Error(i(467)) : Error(i(310));
                    sn = h,
                    h = {
                        memoizedState: sn.memoizedState,
                        baseState: sn.baseState,
                        baseQueue: sn.baseQueue,
                        queue: sn.queue,
                        next: null
                    },
                    qn === null ? Dn.memoizedState = qn = h : qn = qn.next = h
                }
                return qn
            }
            function xe(h) {
                var p = Dc;
                return Dc += 1,
                Mr === null && (Mr = []),
                h = Ge(Mr, h, p),
                p = Dn,
                (qn === null ? p.memoizedState : qn.next) === null && (p = p.alternate,
                pn.H = p === null || p.memoizedState === null ? Du : ca),
                h
            }
            function ne(h) {
                if (h !== null && typeof h == "object") {
                    if (typeof h.then == "function")
                        return xe(h);
                    if (h.$$typeof === to)
                        return Dr(h)
                }
                throw Error(i(438, String(h)))
            }
            function nt(h) {
                var p = null
                  , x = Dn.updateQueue;
                if (x !== null && (p = x.memoCache),
                p == null) {
                    var w = Dn.alternate;
                    w !== null && (w = w.updateQueue,
                    w !== null && (w = w.memoCache,
                    w != null && (p = {
                        data: w.data.map(function(U) {
                            return U.slice()
                        }),
                        index: 0
                    })))
                }
                if (p == null && (p = {
                    data: [],
                    index: 0
                }),
                x === null && (x = am(),
                Dn.updateQueue = x),
                x.memoCache = p,
                x = p.data[p.index],
                x === void 0)
                    for (x = p.data[p.index] = Array(h),
                    w = 0; w < h; w++)
                        x[w] = V_;
                return p.index++,
                x
            }
            function We(h, p) {
                return typeof p == "function" ? p(h) : p
            }
            function st(h) {
                var p = ye();
                return ft(p, sn, h)
            }
            function ft(h, p, x) {
                var w = h.queue;
                if (w === null)
                    throw Error(i(311));
                w.lastRenderedReducer = x;
                var U = h.baseQueue
                  , F = w.pending;
                if (F !== null) {
                    if (U !== null) {
                        var ie = U.next;
                        U.next = F.next,
                        F.next = ie
                    }
                    p.baseQueue = U = F,
                    w.pending = null
                }
                if (F = h.baseState,
                U === null)
                    h.memoizedState = F;
                else {
                    p = U.next;
                    var Me = ie = null
                      , Ie = null
                      , ht = p
                      , Dt = !1;
                    do {
                        var Ft = ht.lane & -536870913;
                        if (Ft !== ht.lane ? (Vn & Ft) === Ft : (Bl & Ft) === Ft) {
                            var jt = ht.revertLane;
                            if (jt === 0)
                                Ie !== null && (Ie = Ie.next = {
                                    lane: 0,
                                    revertLane: 0,
                                    action: ht.action,
                                    hasEagerState: ht.hasEagerState,
                                    eagerState: ht.eagerState,
                                    next: null
                                }),
                                Ft === Ka && (Dt = !0);
                            else if ((Bl & jt) === jt) {
                                ht = ht.next,
                                jt === Ka && (Dt = !0);
                                continue
                            } else
                                Ft = {
                                    lane: 0,
                                    revertLane: ht.revertLane,
                                    action: ht.action,
                                    hasEagerState: ht.hasEagerState,
                                    eagerState: ht.eagerState,
                                    next: null
                                },
                                Ie === null ? (Me = Ie = Ft,
                                ie = F) : Ie = Ie.next = Ft,
                                Dn.lanes |= jt,
                                ns |= jt;
                            Ft = ht.action,
                            Ru && x(F, Ft),
                            F = ht.hasEagerState ? ht.eagerState : x(F, Ft)
                        } else
                            jt = {
                                lane: Ft,
                                revertLane: ht.revertLane,
                                action: ht.action,
                                hasEagerState: ht.hasEagerState,
                                eagerState: ht.eagerState,
                                next: null
                            },
                            Ie === null ? (Me = Ie = jt,
                            ie = F) : Ie = Ie.next = jt,
                            Dn.lanes |= Ft,
                            ns |= Ft;
                        ht = ht.next
                    } while (ht !== null && ht !== p);
                    if (Ie === null ? ie = F : Ie.next = Me,
                    !Ca(F, h.memoizedState) && (gi = !0,
                    Dt && (x = Ac,
                    x !== null)))
                        throw x;
                    h.memoizedState = F,
                    h.baseState = ie,
                    h.baseQueue = Ie,
                    w.lastRenderedState = F
                }
                return U === null && (w.lanes = 0),
                [h.memoizedState, w.dispatch]
            }
            function Tt(h) {
                var p = ye()
                  , x = p.queue;
                if (x === null)
                    throw Error(i(311));
                x.lastRenderedReducer = h;
                var w = x.dispatch
                  , U = x.pending
                  , F = p.memoizedState;
                if (U !== null) {
                    x.pending = null;
                    var ie = U = U.next;
                    do
                        F = h(F, ie.action),
                        ie = ie.next;
                    while (ie !== U);
                    Ca(F, p.memoizedState) || (gi = !0),
                    p.memoizedState = F,
                    p.baseQueue === null && (p.baseState = F),
                    x.lastRenderedState = F
                }
                return [F, w]
            }
            function At(h, p, x) {
                var w = Dn
                  , U = ye()
                  , F = Yn;
                if (F) {
                    if (x === void 0)
                        throw Error(i(407));
                    x = x()
                } else
                    x = p();
                var ie = !Ca((sn || U).memoizedState, x);
                if (ie && (U.memoizedState = x,
                gi = !0),
                U = U.queue,
                ll(Jt.bind(null, w, U, h), [h]),
                U.getSnapshot !== p || ie || qn !== null && qn.memoizedState.tag & 1) {
                    if (w.flags |= 2048,
                    Di(9, Xt.bind(null, w, U, x, p), {
                        destroy: void 0
                    }, null),
                    oi === null)
                        throw Error(i(349));
                    F || (Bl & 60) !== 0 || Et(w, p, x)
                }
                return x
            }
            function Et(h, p, x) {
                h.flags |= 16384,
                h = {
                    getSnapshot: p,
                    value: x
                },
                p = Dn.updateQueue,
                p === null ? (p = am(),
                Dn.updateQueue = p,
                p.stores = [h]) : (x = p.stores,
                x === null ? p.stores = [h] : x.push(h))
            }
            function Xt(h, p, x, w) {
                p.value = x,
                p.getSnapshot = w,
                en(p) && Sn(h)
            }
            function Jt(h, p, x) {
                return x(function() {
                    en(p) && Sn(h)
                })
            }
            function en(h) {
                var p = h.getSnapshot;
                h = h.value;
                try {
                    var x = p();
                    return !Ca(h, x)
                } catch {
                    return !0
                }
            }
            function Sn(h) {
                var p = le(h, 2);
                p !== null && xr(p, h, 2)
            }
            function Vt(h) {
                var p = ce();
                if (typeof h == "function") {
                    var x = h;
                    if (h = x(),
                    Ru) {
                        q(!0);
                        try {
                            x()
                        } finally {
                            q(!1)
                        }
                    }
                }
                return p.memoizedState = p.baseState = h,
                p.queue = {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: We,
                    lastRenderedState: h
                },
                p
            }
            function It(h, p, x, w) {
                return h.baseState = x,
                ft(h, sn, typeof w == "function" ? w : We)
            }
            function Cn(h, p, x, w, U) {
                if (ru(h))
                    throw Error(i(485));
                if (h = p.action,
                h !== null) {
                    var F = {
                        payload: U,
                        action: h,
                        next: null,
                        isTransition: !0,
                        status: "pending",
                        value: null,
                        reason: null,
                        listeners: [],
                        then: function(ie) {
                            F.listeners.push(ie)
                        }
                    };
                    pn.T !== null ? x(!0) : F.isTransition = !1,
                    w(F),
                    x = p.pending,
                    x === null ? (F.next = p.pending = F,
                    fn(p, F)) : (F.next = x.next,
                    p.pending = x.next = F)
                }
            }
            function fn(h, p) {
                var x = p.action
                  , w = p.payload
                  , U = h.state;
                if (p.isTransition) {
                    var F = pn.T
                      , ie = {};
                    pn.T = ie;
                    try {
                        var Me = x(U, w)
                          , Ie = pn.S;
                        Ie !== null && Ie(ie, Me),
                        In(h, p, Me)
                    } catch (ht) {
                        Bn(h, p, ht)
                    } finally {
                        pn.T = F
                    }
                } else
                    try {
                        F = x(U, w),
                        In(h, p, F)
                    } catch (ht) {
                        Bn(h, p, ht)
                    }
            }
            function In(h, p, x) {
                x !== null && typeof x == "object" && typeof x.then == "function" ? x.then(function(w) {
                    xn(h, p, w)
                }, function(w) {
                    return Bn(h, p, w)
                }) : xn(h, p, x)
            }
            function xn(h, p, x) {
                p.status = "fulfilled",
                p.value = x,
                hn(p),
                h.state = x,
                p = h.pending,
                p !== null && (x = p.next,
                x === p ? h.pending = null : (x = x.next,
                p.next = x,
                fn(h, x)))
            }
            function Bn(h, p, x) {
                var w = h.pending;
                if (h.pending = null,
                w !== null) {
                    w = w.next;
                    do
                        p.status = "rejected",
                        p.reason = x,
                        hn(p),
                        p = p.next;
                    while (p !== w)
                }
                h.action = null
            }
            function hn(h) {
                h = h.listeners;
                for (var p = 0; p < h.length; p++)
                    (0,
                    h[p])()
            }
            function Yt(h, p) {
                return p
            }
            function ti(h, p) {
                if (Yn) {
                    var x = oi.formState;
                    if (x !== null) {
                        e: {
                            var w = Dn;
                            if (Yn) {
                                if (Br) {
                                    var U = I0(Br, br);
                                    if (U) {
                                        Br = F0(U),
                                        w = u1(U);
                                        break e
                                    }
                                }
                                Te(w)
                            }
                            w = !1
                        }
                        w && (p = x[0])
                    }
                }
                x = ce(),
                x.memoizedState = x.baseState = p,
                w = {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: Yt,
                    lastRenderedState: p
                },
                x.queue = w,
                x = af.bind(null, Dn, w),
                w.dispatch = x,
                w = Vt(!1);
                var F = pl.bind(null, Dn, !1, w.queue);
                return w = ce(),
                U = {
                    state: p,
                    dispatch: null,
                    action: h,
                    pending: null
                },
                w.queue = U,
                x = Cn.bind(null, Dn, U, F, x),
                U.dispatch = x,
                w.memoizedState = h,
                [p, x, !1]
            }
            function ri(h) {
                var p = ye();
                return bn(p, sn, h)
            }
            function bn(h, p, x) {
                p = ft(h, p, Yt)[0],
                h = st(We)[0],
                p = typeof p == "object" && p !== null && typeof p.then == "function" ? xe(p) : p;
                var w = ye()
                  , U = w.queue
                  , F = U.dispatch;
                return x !== w.memoizedState && (Dn.flags |= 2048,
                Di(9, ui.bind(null, U, x), {
                    destroy: void 0
                }, null)),
                [p, F, h]
            }
            function ui(h, p) {
                h.action = p
            }
            function Ss(h) {
                var p = ye()
                  , x = sn;
                if (x !== null)
                    return bn(p, x, h);
                ye(),
                p = p.memoizedState,
                x = ye();
                var w = x.queue.dispatch;
                return x.memoizedState = h,
                [p, w, !1]
            }
            function Di(h, p, x, w) {
                return h = {
                    tag: h,
                    create: p,
                    inst: x,
                    deps: w,
                    next: null
                },
                p = Dn.updateQueue,
                p === null && (p = am(),
                Dn.updateQueue = p),
                x = p.lastEffect,
                x === null ? p.lastEffect = h.next = h : (w = x.next,
                x.next = h,
                h.next = w,
                p.lastEffect = h),
                h
            }
            function rf() {
                return ye().memoizedState
            }
            function tu(h, p, x, w) {
                var U = ce();
                Dn.flags |= h,
                U.memoizedState = Di(1 | p, x, {
                    destroy: void 0
                }, w === void 0 ? null : w)
            }
            function nu(h, p, x, w) {
                var U = ye();
                w = w === void 0 ? null : w;
                var F = U.memoizedState.inst;
                sn !== null && w !== null && k(w, sn.memoizedState.deps) ? U.memoizedState = Di(p, x, F, w) : (Dn.flags |= h,
                U.memoizedState = Di(1 | p, x, F, w))
            }
            function iu(h, p) {
                tu(8390656, 8, h, p)
            }
            function ll(h, p) {
                nu(2048, 8, h, p)
            }
            function Ch(h, p) {
                return nu(4, 2, h, p)
            }
            function Ro(h, p) {
                return nu(4, 4, h, p)
            }
            function Qs(h, p) {
                if (typeof p == "function") {
                    h = h();
                    var x = p(h);
                    return function() {
                        typeof x == "function" ? x() : p(null)
                    }
                }
                if (p != null)
                    return h = h(),
                    p.current = h,
                    function() {
                        p.current = null
                    }
            }
            function Js(h, p, x) {
                x = x != null ? x.concat([h]) : null,
                nu(4, 4, Qs.bind(null, p, h), x)
            }
            function ya() {}
            function Do(h, p) {
                var x = ye();
                p = p === void 0 ? null : p;
                var w = x.memoizedState;
                return p !== null && k(p, w[1]) ? w[0] : (x.memoizedState = [h, p],
                h)
            }
            function ul(h, p) {
                var x = ye();
                p = p === void 0 ? null : p;
                var w = x.memoizedState;
                if (p !== null && k(p, w[1]))
                    return w[0];
                if (w = h(),
                Ru) {
                    q(!0);
                    try {
                        h()
                    } finally {
                        q(!1)
                    }
                }
                return x.memoizedState = [w, p],
                w
            }
            function cl(h, p, x) {
                return x === void 0 || (Bl & 1073741824) !== 0 ? h.memoizedState = p : (h.memoizedState = x,
                h = m0(),
                Dn.lanes |= h,
                ns |= h,
                x)
            }
            function uc(h, p, x, w) {
                return Ca(x, p) ? x : bi.current !== null ? (h = cl(h, x, w),
                Ca(h, p) || (gi = !0),
                h) : (Bl & 42) === 0 ? (gi = !0,
                h.memoizedState = x) : (h = m0(),
                Dn.lanes |= h,
                ns |= h,
                p)
            }
            function fl(h, p, x, w, U) {
                var F = Ul();
                Xr(F !== 0 && 8 > F ? F : 8);
                var ie = pn.T
                  , Me = {};
                pn.T = Me,
                pl(h, !1, p, x);
                try {
                    var Ie = U()
                      , ht = pn.S;
                    if (ht !== null && ht(Me, Ie),
                    Ie !== null && typeof Ie == "object" && typeof Ie.then == "function") {
                        var Dt = lt(Ie, w);
                        bs(h, p, Dt, Wi(h))
                    } else
                        bs(h, p, w, Wi(h))
                } catch (Ft) {
                    bs(h, p, {
                        then: function() {},
                        status: "rejected",
                        reason: Ft
                    }, Wi())
                } finally {
                    Xr(F),
                    pn.T = ie
                }
            }
            function ia(h) {
                var p = h.memoizedState;
                if (p !== null)
                    return p;
                p = {
                    memoizedState: _u,
                    baseState: _u,
                    baseQueue: null,
                    queue: {
                        pending: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: We,
                        lastRenderedState: _u
                    },
                    next: null
                };
                var x = {};
                return p.next = {
                    memoizedState: x,
                    baseState: x,
                    baseQueue: null,
                    queue: {
                        pending: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: We,
                        lastRenderedState: x
                    },
                    next: null
                },
                h.memoizedState = p,
                h = h.alternate,
                h !== null && (h.memoizedState = p),
                p
            }
            function hl() {
                return Dr(no)
            }
            function dl() {
                return ye().memoizedState
            }
            function Xi() {
                return ye().memoizedState
            }
            function cc(h) {
                for (var p = h.return; p !== null; ) {
                    switch (p.tag) {
                    case 24:
                    case 3:
                        var x = Wi();
                        h = je(x);
                        var w = Ye(p, h, x);
                        w !== null && (xr(w, p, x),
                        ct(w, p, x)),
                        p = {
                            cache: ou()
                        },
                        h.payload = p;
                        return
                    }
                    p = p.return
                }
            }
            function fc(h, p, x) {
                var w = Wi();
                x = {
                    lane: w,
                    revertLane: 0,
                    action: x,
                    hasEagerState: !1,
                    eagerState: null,
                    next: null
                },
                ru(h) ? ji(p, x) : (x = Oe(h, p, x, w),
                x !== null && (xr(x, h, w),
                _a(x, p, w)))
            }
            function af(h, p, x) {
                var w = Wi();
                bs(h, p, x, w)
            }
            function bs(h, p, x, w) {
                var U = {
                    lane: w,
                    revertLane: 0,
                    action: x,
                    hasEagerState: !1,
                    eagerState: null,
                    next: null
                };
                if (ru(h))
                    ji(p, U);
                else {
                    var F = h.alternate;
                    if (h.lanes === 0 && (F === null || F.lanes === 0) && (F = p.lastRenderedReducer,
                    F !== null))
                        try {
                            var ie = p.lastRenderedState
                              , Me = F(ie, x);
                            if (U.hasEagerState = !0,
                            U.eagerState = Me,
                            Ca(Me, ie))
                                return Ne(h, p, U, 0),
                                oi === null && Le(),
                                !1
                        } catch {} finally {}
                    if (x = Oe(h, p, U, w),
                    x !== null)
                        return xr(x, h, w),
                        _a(x, p, w),
                        !0
                }
                return !1
            }
            function pl(h, p, x, w) {
                if (w = {
                    lane: 2,
                    revertLane: we(),
                    action: w,
                    hasEagerState: !1,
                    eagerState: null,
                    next: null
                },
                ru(h)) {
                    if (p)
                        throw Error(i(479))
                } else
                    p = Oe(h, x, w, 2),
                    p !== null && xr(p, h, 2)
            }
            function ru(h) {
                var p = h.alternate;
                return h === Dn || p !== null && p === Dn
            }
            function ji(h, p) {
                Rc = Ls = !0;
                var x = h.pending;
                x === null ? p.next = p : (p.next = x.next,
                x.next = p),
                h.pending = p
            }
            function _a(h, p, x) {
                if ((x & 4194176) !== 0) {
                    var w = p.lanes;
                    w &= h.pendingLanes,
                    x |= w,
                    p.lanes = x,
                    Z(h, x)
                }
            }
            function ra(h, p, x, w) {
                p = h.memoizedState,
                x = x(w, p),
                x = x == null ? p : Ip({}, p, x),
                h.memoizedState = x,
                h.lanes === 0 && (h.updateQueue.baseState = x)
            }
            function ml(h, p, x, w, U, F, ie) {
                return h = h.stateNode,
                typeof h.shouldComponentUpdate == "function" ? h.shouldComponentUpdate(w, F, ie) : p.prototype && p.prototype.isPureReactComponent ? !at(x, w) || !at(U, F) : !0
            }
            function sf(h, p, x, w) {
                h = p.state,
                typeof p.componentWillReceiveProps == "function" && p.componentWillReceiveProps(x, w),
                typeof p.UNSAFE_componentWillReceiveProps == "function" && p.UNSAFE_componentWillReceiveProps(x, w),
                p.state !== h && Ho.enqueueReplaceState(p, p.state, null)
            }
            function ka(h, p) {
                var x = p;
                if ("ref"in p) {
                    x = {};
                    for (var w in p)
                        w !== "ref" && (x[w] = p[w])
                }
                if (h = h.defaultProps) {
                    x === p && (x = Ip({}, x));
                    for (var U in h)
                        x[U] === void 0 && (x[U] = h[U])
                }
                return x
            }
            function Ms(h, p) {
                try {
                    var x = h.onUncaughtError;
                    x(p.value, {
                        componentStack: p.stack
                    })
                } catch (w) {
                    setTimeout(function() {
                        throw w
                    })
                }
            }
            function gl(h, p, x) {
                try {
                    var w = h.onCaughtError;
                    w(x.value, {
                        componentStack: x.stack,
                        errorBoundary: p.tag === 1 ? p.stateNode : null
                    })
                } catch (U) {
                    setTimeout(function() {
                        throw U
                    })
                }
            }
            function Ts(h, p, x) {
                return x = je(x),
                x.tag = 3,
                x.payload = {
                    element: null
                },
                x.callback = function() {
                    Ms(h, p)
                }
                ,
                x
            }
            function hc(h) {
                return h = je(h),
                h.tag = 3,
                h
            }
            function kr(h, p, x, w) {
                var U = x.type.getDerivedStateFromError;
                if (typeof U == "function") {
                    var F = w.value;
                    h.payload = function() {
                        return U(F)
                    }
                    ,
                    h.callback = function() {
                        gl(p, x, w)
                    }
                }
                var ie = x.stateNode;
                ie !== null && typeof ie.componentDidCatch == "function" && (h.callback = function() {
                    gl(p, x, w),
                    typeof U != "function" && (Uu === null ? Uu = new Set([this]) : Uu.add(this));
                    var Me = w.stack;
                    this.componentDidCatch(w.value, {
                        componentStack: Me !== null ? Me : ""
                    })
                }
                )
            }
            function Qg(h, p, x, w, U) {
                if (x.flags |= 32768,
                w !== null && typeof w == "object" && typeof w.then == "function") {
                    if (p = x.alternate,
                    p !== null && Nh(p, x, U, !0),
                    x = Qa.current,
                    x !== null) {
                        switch (x.tag) {
                        case 13:
                            return mi === null ? El() : x.alternate === null && vi === 0 && (vi = 3),
                            x.flags &= -257,
                            x.flags |= 65536,
                            x.lanes = U,
                            w === fd ? x.flags |= 16384 : (p = x.updateQueue,
                            p === null ? x.updateQueue = new Set([w]) : p.add(w),
                            mc(h, w, U)),
                            !1;
                        case 22:
                            return x.flags |= 65536,
                            w === fd ? x.flags |= 16384 : (p = x.updateQueue,
                            p === null ? (p = {
                                transitions: null,
                                markerInstances: null,
                                retryQueue: new Set([w])
                            },
                            x.updateQueue = p) : (x = p.retryQueue,
                            x === null ? p.retryQueue = new Set([w]) : x.add(w)),
                            mc(h, w, U)),
                            !1
                        }
                        throw Error(i(435, x.tag))
                    }
                    return mc(h, w, U),
                    El(),
                    !1
                }
                if (Yn)
                    return p = Qa.current,
                    p !== null ? ((p.flags & 65536) === 0 && (p.flags |= 256),
                    p.flags |= 65536,
                    p.lanes = U,
                    w !== ld && (h = Error(i(422), {
                        cause: w
                    }),
                    re(se(h, x)))) : (w !== ld && (p = Error(i(423), {
                        cause: w
                    }),
                    re(se(p, x))),
                    h = h.current.alternate,
                    h.flags |= 65536,
                    U &= -U,
                    h.lanes |= U,
                    w = se(w, x),
                    U = Ts(h.stateNode, w, U),
                    _t(h, U),
                    vi !== 4 && (vi = 2)),
                    !1;
                var F = Error(i(520), {
                    cause: w
                });
                if (F = se(F, x),
                Oc === null ? Oc = [F] : Oc.push(F),
                vi !== 4 && (vi = 2),
                p === null)
                    return !0;
                w = se(w, x),
                x = p;
                do {
                    switch (x.tag) {
                    case 3:
                        return x.flags |= 65536,
                        h = U & -U,
                        x.lanes |= h,
                        h = Ts(x.stateNode, w, h),
                        _t(x, h),
                        !1;
                    case 1:
                        if (p = x.type,
                        F = x.stateNode,
                        (x.flags & 128) === 0 && (typeof p.getDerivedStateFromError == "function" || F !== null && typeof F.componentDidCatch == "function" && (Uu === null || !Uu.has(F))))
                            return x.flags |= 65536,
                            U &= -U,
                            x.lanes |= U,
                            U = hc(U),
                            kr(U, h, x, w),
                            _t(x, U),
                            !1
                    }
                    x = x.return
                } while (x !== null);
                return !1
            }
            function zi(h, p, x, w) {
                p.child = h === null ? Fo(p, null, x, w) : Cu(p, h.child, x, w)
            }
            function vl(h, p, x, w, U) {
                x = x.render;
                var F = p.ref;
                if ("ref"in w) {
                    var ie = {};
                    for (var Me in w)
                        Me !== "ref" && (ie[Me] = w[Me])
                } else
                    ie = w;
                return su(p),
                w = $(h, p, x, ie, F, U),
                Me = Ke(),
                h !== null && !gi ? (yt(h, p, U),
                yl(h, p, U)) : (Yn && Me && te(p),
                p.flags |= 1,
                zi(h, p, w, U),
                p.child)
            }
            function Rh(h, p, x, w, U) {
                if (h === null) {
                    var F = x.type;
                    return typeof F == "function" && !Wh(F) && F.defaultProps === void 0 && x.compare === null ? (p.tag = 15,
                    p.type = F,
                    Sp(h, p, F, w, U)) : (h = No(x.type, null, w, p, p.mode, U),
                    h.ref = p.ref,
                    h.return = p,
                    p.child = h)
                }
                if (F = h.child,
                !n0(h, U)) {
                    var ie = F.memoizedProps;
                    if (x = x.compare,
                    x = x !== null ? x : at,
                    x(ie, w) && h.ref === p.ref)
                        return yl(h, p, U)
                }
                return p.flags |= 1,
                h = As(F, w),
                h.ref = p.ref,
                h.return = p,
                p.child = h
            }
            function Sp(h, p, x, w, U) {
                if (h !== null) {
                    var F = h.memoizedProps;
                    if (at(F, w) && h.ref === p.ref)
                        if (gi = !1,
                        p.pendingProps = w = F,
                        n0(h, U))
                            (h.flags & 131072) !== 0 && (gi = !0);
                        else
                            return p.lanes = h.lanes,
                            yl(h, p, U)
                }
                return Ga(h, p, x, w, U)
            }
            function Rr(h, p, x) {
                var w = p.pendingProps
                  , U = w.children
                  , F = (p.stateNode._pendingVisibility & 2) !== 0
                  , ie = h !== null ? h.memoizedState : null;
                if (ir(h, p),
                w.mode === "hidden" || F) {
                    if ((p.flags & 128) !== 0) {
                        if (w = ie !== null ? ie.baseLanes | x : x,
                        h !== null) {
                            for (U = p.child = h.child,
                            F = 0; U !== null; )
                                F = F | U.lanes | U.childLanes,
                                U = U.sibling;
                            p.childLanes = F & ~w
                        } else
                            p.childLanes = 0,
                            p.child = null;
                        return xa(h, p, w, x)
                    }
                    if ((x & 536870912) !== 0)
                        p.memoizedState = {
                            baseLanes: 0,
                            cachePool: null
                        },
                        h !== null && Mp(p, ie !== null ? ie.cachePool : null),
                        ie !== null ? mt(p, ie) : Lt(),
                        Ln(p);
                    else
                        return p.lanes = p.childLanes = 536870912,
                        xa(h, p, ie !== null ? ie.baseLanes | x : x, x)
                } else
                    ie !== null ? (Mp(p, ie.cachePool),
                    mt(p, ie),
                    qt(),
                    p.memoizedState = null) : (h !== null && Mp(p, null),
                    Lt(),
                    qt());
                return zi(h, p, U, x),
                p.child
            }
            function xa(h, p, x, w) {
                var U = r0();
                return U = U === null ? null : {
                    parent: oa ? Mi._currentValue : Mi._currentValue2,
                    pool: U
                },
                p.memoizedState = {
                    baseLanes: x,
                    cachePool: U
                },
                h !== null && Mp(p, null),
                Lt(),
                Ln(p),
                h !== null && Nh(h, p, w, !0),
                null
            }
            function ir(h, p) {
                var x = p.ref;
                if (x === null)
                    h !== null && h.ref !== null && (p.flags |= 2097664);
                else {
                    if (typeof x != "function" && typeof x != "object")
                        throw Error(i(284));
                    (h === null || h.ref !== x) && (p.flags |= 2097664)
                }
            }
            function Ga(h, p, x, w, U) {
                return su(p),
                x = $(h, p, x, w, void 0, U),
                w = Ke(),
                h !== null && !gi ? (yt(h, p, U),
                yl(h, p, U)) : (Yn && w && te(p),
                p.flags |= 1,
                zi(h, p, x, U),
                p.child)
            }
            function Dh(h, p, x, w, U, F) {
                return su(p),
                p.updateQueue = null,
                x = Ue(p, w, x, U),
                Se(h),
                w = Ke(),
                h !== null && !gi ? (yt(h, p, F),
                yl(h, p, F)) : (Yn && w && te(p),
                p.flags |= 1,
                zi(h, p, x, F),
                p.child)
            }
            function A_(h, p, x, w, U) {
                if (su(p),
                p.stateNode === null) {
                    var F = Mu
                      , ie = x.contextType;
                    typeof ie == "object" && ie !== null && (F = Dr(ie)),
                    F = new x(w,F),
                    p.memoizedState = F.state !== null && F.state !== void 0 ? F.state : null,
                    F.updater = Ho,
                    p.stateNode = F,
                    F._reactInternals = p,
                    F = p.stateNode,
                    F.props = w,
                    F.state = p.memoizedState,
                    F.refs = {},
                    Mt(p),
                    ie = x.contextType,
                    F.context = typeof ie == "object" && ie !== null ? Dr(ie) : Mu,
                    F.state = p.memoizedState,
                    ie = x.getDerivedStateFromProps,
                    typeof ie == "function" && (ra(p, x, ie, w),
                    F.state = p.memoizedState),
                    typeof x.getDerivedStateFromProps == "function" || typeof F.getSnapshotBeforeUpdate == "function" || typeof F.UNSAFE_componentWillMount != "function" && typeof F.componentWillMount != "function" || (ie = F.state,
                    typeof F.componentWillMount == "function" && F.componentWillMount(),
                    typeof F.UNSAFE_componentWillMount == "function" && F.UNSAFE_componentWillMount(),
                    ie !== F.state && Ho.enqueueReplaceState(F, F.state, null),
                    Ut(p, w, F, U),
                    ut(),
                    F.state = p.memoizedState),
                    typeof F.componentDidMount == "function" && (p.flags |= 4194308),
                    w = !0
                } else if (h === null) {
                    F = p.stateNode;
                    var Me = p.memoizedProps
                      , Ie = ka(x, Me);
                    F.props = Ie;
                    var ht = F.context
                      , Dt = x.contextType;
                    ie = Mu,
                    typeof Dt == "object" && Dt !== null && (ie = Dr(Dt));
                    var Ft = x.getDerivedStateFromProps;
                    Dt = typeof Ft == "function" || typeof F.getSnapshotBeforeUpdate == "function",
                    Me = p.pendingProps !== Me,
                    Dt || typeof F.UNSAFE_componentWillReceiveProps != "function" && typeof F.componentWillReceiveProps != "function" || (Me || ht !== ie) && sf(p, F, w, ie),
                    Pl = !1;
                    var jt = p.memoizedState;
                    F.state = jt,
                    Ut(p, w, F, U),
                    ut(),
                    ht = p.memoizedState,
                    Me || jt !== ht || Pl ? (typeof Ft == "function" && (ra(p, x, Ft, w),
                    ht = p.memoizedState),
                    (Ie = Pl || ml(p, x, Ie, w, jt, ht, ie)) ? (Dt || typeof F.UNSAFE_componentWillMount != "function" && typeof F.componentWillMount != "function" || (typeof F.componentWillMount == "function" && F.componentWillMount(),
                    typeof F.UNSAFE_componentWillMount == "function" && F.UNSAFE_componentWillMount()),
                    typeof F.componentDidMount == "function" && (p.flags |= 4194308)) : (typeof F.componentDidMount == "function" && (p.flags |= 4194308),
                    p.memoizedProps = w,
                    p.memoizedState = ht),
                    F.props = w,
                    F.state = ht,
                    F.context = ie,
                    w = Ie) : (typeof F.componentDidMount == "function" && (p.flags |= 4194308),
                    w = !1)
                } else {
                    F = p.stateNode,
                    pt(h, p),
                    ie = p.memoizedProps,
                    Dt = ka(x, ie),
                    F.props = Dt,
                    Ft = p.pendingProps,
                    jt = F.context,
                    ht = x.contextType,
                    Ie = Mu,
                    typeof ht == "object" && ht !== null && (Ie = Dr(ht)),
                    Me = x.getDerivedStateFromProps,
                    (ht = typeof Me == "function" || typeof F.getSnapshotBeforeUpdate == "function") || typeof F.UNSAFE_componentWillReceiveProps != "function" && typeof F.componentWillReceiveProps != "function" || (ie !== Ft || jt !== Ie) && sf(p, F, w, Ie),
                    Pl = !1,
                    jt = p.memoizedState,
                    F.state = jt,
                    Ut(p, w, F, U),
                    ut();
                    var Tn = p.memoizedState;
                    ie !== Ft || jt !== Tn || Pl || h !== null && h.dependencies !== null && Lh(h.dependencies) ? (typeof Me == "function" && (ra(p, x, Me, w),
                    Tn = p.memoizedState),
                    (Dt = Pl || ml(p, x, Dt, w, jt, Tn, Ie) || h !== null && h.dependencies !== null && Lh(h.dependencies)) ? (ht || typeof F.UNSAFE_componentWillUpdate != "function" && typeof F.componentWillUpdate != "function" || (typeof F.componentWillUpdate == "function" && F.componentWillUpdate(w, Tn, Ie),
                    typeof F.UNSAFE_componentWillUpdate == "function" && F.UNSAFE_componentWillUpdate(w, Tn, Ie)),
                    typeof F.componentDidUpdate == "function" && (p.flags |= 4),
                    typeof F.getSnapshotBeforeUpdate == "function" && (p.flags |= 1024)) : (typeof F.componentDidUpdate != "function" || ie === h.memoizedProps && jt === h.memoizedState || (p.flags |= 4),
                    typeof F.getSnapshotBeforeUpdate != "function" || ie === h.memoizedProps && jt === h.memoizedState || (p.flags |= 1024),
                    p.memoizedProps = w,
                    p.memoizedState = Tn),
                    F.props = w,
                    F.state = Tn,
                    F.context = Ie,
                    w = Dt) : (typeof F.componentDidUpdate != "function" || ie === h.memoizedProps && jt === h.memoizedState || (p.flags |= 4),
                    typeof F.getSnapshotBeforeUpdate != "function" || ie === h.memoizedProps && jt === h.memoizedState || (p.flags |= 1024),
                    w = !1)
                }
                return F = w,
                ir(h, p),
                w = (p.flags & 128) !== 0,
                F || w ? (F = p.stateNode,
                x = w && typeof x.getDerivedStateFromError != "function" ? null : F.render(),
                p.flags |= 1,
                h !== null && w ? (p.child = Cu(p, h.child, null, U),
                p.child = Cu(p, null, x, U)) : zi(h, p, x, U),
                p.memoizedState = F.state,
                h = p.child) : h = yl(h, p, U),
                h
            }
            function C_(h, p, x, w) {
                return $e(),
                p.flags |= 256,
                zi(h, p, x, w),
                p.child
            }
            function Jg(h) {
                return {
                    baseLanes: h,
                    cachePool: a0()
                }
            }
            function Uh(h, p, x) {
                return h = h !== null ? h.childLanes & ~x : 0,
                p && (h |= is),
                h
            }
            function R_(h, p, x) {
                var w = p.pendingProps, U = !1, F = (p.flags & 128) !== 0, ie;
                if ((ie = F) || (ie = h !== null && h.memoizedState === null ? !1 : (hr.current & 2) !== 0),
                ie && (U = !0,
                p.flags &= -129),
                ie = (p.flags & 32) !== 0,
                p.flags &= -33,
                h === null) {
                    if (Yn) {
                        if (U ? Wt(p) : qt(),
                        Yn) {
                            var Me = Br, Ie;
                            (Ie = Me) && (Me = h1(Me, br),
                            Me !== null ? (p.memoizedState = {
                                dehydrated: Me,
                                treeContext: Tu !== null ? {
                                    id: ro,
                                    overflow: ao
                                } : null,
                                retryLane: 536870912
                            },
                            Ie = t(18, null, null, 0),
                            Ie.stateNode = Me,
                            Ie.return = p,
                            p.child = Ie,
                            Pr = p,
                            Br = null,
                            Ie = !0) : Ie = !1),
                            Ie || Te(p)
                        }
                        if (Me = p.memoizedState,
                        Me !== null && (Me = Me.dehydrated,
                        Me !== null))
                            return qp(Me) ? p.lanes = 16 : p.lanes = 536870912,
                            null;
                        Pt(p)
                    }
                    return Me = w.children,
                    w = w.fallback,
                    U ? (qt(),
                    U = p.mode,
                    Me = e0({
                        mode: "hidden",
                        children: Me
                    }, U),
                    w = Ii(w, U, x, null),
                    Me.return = p,
                    w.return = p,
                    Me.sibling = w,
                    p.child = Me,
                    U = p.child,
                    U.memoizedState = Jg(x),
                    U.childLanes = Uh(h, ie, x),
                    p.memoizedState = lm,
                    w) : (Wt(p),
                    $g(p, Me))
                }
                if (Ie = h.memoizedState,
                Ie !== null && (Me = Ie.dehydrated,
                Me !== null)) {
                    if (F)
                        p.flags & 256 ? (Wt(p),
                        p.flags &= -257,
                        p = bp(h, p, x)) : p.memoizedState !== null ? (qt(),
                        p.child = h.child,
                        p.flags |= 128,
                        p = null) : (qt(),
                        U = w.fallback,
                        Me = p.mode,
                        w = e0({
                            mode: "visible",
                            children: w.children
                        }, Me),
                        U = Ii(U, Me, x, null),
                        U.flags |= 2,
                        w.return = p,
                        U.return = p,
                        w.sibling = U,
                        p.child = w,
                        Cu(p, h.child, null, x),
                        w = p.child,
                        w.memoizedState = Jg(x),
                        w.childLanes = Uh(h, ie, x),
                        p.memoizedState = lm,
                        p = U);
                    else if (Wt(p),
                    qp(Me))
                        ie = o1(Me).digest,
                        w = Error(i(419)),
                        w.stack = "",
                        w.digest = ie,
                        re({
                            value: w,
                            source: null,
                            stack: null
                        }),
                        p = bp(h, p, x);
                    else if (gi || Nh(h, p, x, !1),
                    ie = (x & h.childLanes) !== 0,
                    gi || ie) {
                        if (ie = oi,
                        ie !== null) {
                            if (w = x & -x,
                            (w & 42) !== 0)
                                w = 1;
                            else
                                switch (w) {
                                case 2:
                                    w = 1;
                                    break;
                                case 8:
                                    w = 4;
                                    break;
                                case 32:
                                    w = 16;
                                    break;
                                case 128:
                                case 256:
                                case 512:
                                case 1024:
                                case 2048:
                                case 4096:
                                case 8192:
                                case 16384:
                                case 32768:
                                case 65536:
                                case 131072:
                                case 262144:
                                case 524288:
                                case 1048576:
                                case 2097152:
                                case 4194304:
                                case 8388608:
                                case 16777216:
                                case 33554432:
                                    w = 64;
                                    break;
                                case 268435456:
                                    w = 134217728;
                                    break;
                                default:
                                    w = 0
                                }
                            if (w = (w & (ie.suspendedLanes | x)) !== 0 ? 0 : w,
                            w !== 0 && w !== Ie.retryLane)
                                throw Ie.retryLane = w,
                                le(h, w),
                                xr(ie, h, w),
                                om
                        }
                        Yp(Me) || El(),
                        p = bp(h, p, x)
                    } else
                        Yp(Me) ? (p.flags |= 128,
                        p.child = h.child,
                        p = wl.bind(null, h),
                        l1(Me, p),
                        p = null) : (h = Ie.treeContext,
                        Lr && (Br = f1(Me),
                        Pr = p,
                        Yn = !0,
                        Os = null,
                        br = !1,
                        h !== null && (qa[Za++] = ro,
                        qa[Za++] = ao,
                        qa[Za++] = Tu,
                        ro = h.id,
                        ao = h.overflow,
                        Tu = p)),
                        p = $g(p, w.children),
                        p.flags |= 4096);
                    return p
                }
                return U ? (qt(),
                U = w.fallback,
                Me = p.mode,
                Ie = h.child,
                F = Ie.sibling,
                w = As(Ie, {
                    mode: "hidden",
                    children: w.children
                }),
                w.subtreeFlags = Ie.subtreeFlags & 31457280,
                F !== null ? U = As(F, U) : (U = Ii(U, Me, x, null),
                U.flags |= 2),
                U.return = p,
                w.return = p,
                w.sibling = U,
                p.child = w,
                w = U,
                U = p.child,
                Me = h.child.memoizedState,
                Me === null ? Me = Jg(x) : (Ie = Me.cachePool,
                Ie !== null ? (F = oa ? Mi._currentValue : Mi._currentValue2,
                Ie = Ie.parent !== F ? {
                    parent: F,
                    pool: F
                } : Ie) : Ie = a0(),
                Me = {
                    baseLanes: Me.baseLanes | x,
                    cachePool: Ie
                }),
                U.memoizedState = Me,
                U.childLanes = Uh(h, ie, x),
                p.memoizedState = lm,
                w) : (Wt(p),
                x = h.child,
                h = x.sibling,
                x = As(x, {
                    mode: "visible",
                    children: w.children
                }),
                x.return = p,
                x.sibling = null,
                h !== null && (ie = p.deletions,
                ie === null ? (p.deletions = [h],
                p.flags |= 16) : ie.push(h)),
                p.child = x,
                p.memoizedState = null,
                x)
            }
            function $g(h, p) {
                return p = e0({
                    mode: "visible",
                    children: p
                }, h.mode),
                p.return = h,
                h.child = p
            }
            function e0(h, p) {
                return qh(h, p, 0, null)
            }
            function bp(h, p, x) {
                return Cu(p, h.child, null, x),
                h = $g(p, p.pendingProps.children),
                h.flags |= 2,
                p.memoizedState = null,
                h
            }
            function D_(h, p, x) {
                h.lanes |= p;
                var w = h.alternate;
                w !== null && (w.lanes |= p),
                Oh(h.return, p, x)
            }
            function t0(h, p, x, w, U) {
                var F = h.memoizedState;
                F === null ? h.memoizedState = {
                    isBackwards: p,
                    rendering: null,
                    renderingStartTime: 0,
                    last: w,
                    tail: x,
                    tailMode: U
                } : (F.isBackwards = p,
                F.rendering = null,
                F.renderingStartTime = 0,
                F.last = w,
                F.tail = x,
                F.tailMode = U)
            }
            function U_(h, p, x) {
                var w = p.pendingProps
                  , U = w.revealOrder
                  , F = w.tail;
                if (zi(h, p, w.children, x),
                w = hr.current,
                (w & 2) !== 0)
                    w = w & 1 | 2,
                    p.flags |= 128;
                else {
                    if (h !== null && (h.flags & 128) !== 0)
                        e: for (h = p.child; h !== null; ) {
                            if (h.tag === 13)
                                h.memoizedState !== null && D_(h, x, p);
                            else if (h.tag === 19)
                                D_(h, x, p);
                            else if (h.child !== null) {
                                h.child.return = h,
                                h = h.child;
                                continue
                            }
                            if (h === p)
                                break e;
                            for (; h.sibling === null; ) {
                                if (h.return === null || h.return === p)
                                    break e;
                                h = h.return
                            }
                            h.sibling.return = h.return,
                            h = h.sibling
                        }
                    w &= 1
                }
                switch (A(hr, w),
                U) {
                case "forwards":
                    for (x = p.child,
                    U = null; x !== null; )
                        h = x.alternate,
                        h !== null && un(h) === null && (U = x),
                        x = x.sibling;
                    x = U,
                    x === null ? (U = p.child,
                    p.child = null) : (U = x.sibling,
                    x.sibling = null),
                    t0(p, !1, U, x, F);
                    break;
                case "backwards":
                    for (x = null,
                    U = p.child,
                    p.child = null; U !== null; ) {
                        if (h = U.alternate,
                        h !== null && un(h) === null) {
                            p.child = U;
                            break
                        }
                        h = U.sibling,
                        U.sibling = x,
                        x = U,
                        U = h
                    }
                    t0(p, !0, x, null, F);
                    break;
                case "together":
                    t0(p, !1, null, null, void 0);
                    break;
                default:
                    p.memoizedState = null
                }
                return p.child
            }
            function yl(h, p, x) {
                if (h !== null && (p.dependencies = h.dependencies),
                ns |= p.lanes,
                (x & p.childLanes) === 0)
                    if (h !== null) {
                        if (Nh(h, p, x, !1),
                        (x & p.childLanes) === 0)
                            return null
                    } else
                        return null;
                if (h !== null && p.child !== h.child)
                    throw Error(i(153));
                if (p.child !== null) {
                    for (h = p.child,
                    x = As(h, h.pendingProps),
                    p.child = x,
                    x.return = p; h.sibling !== null; )
                        h = h.sibling,
                        x = x.sibling = As(h, h.pendingProps),
                        x.return = p;
                    x.sibling = null
                }
                return p.child
            }
            function n0(h, p) {
                return (h.lanes & p) !== 0 ? !0 : (h = h.dependencies,
                !!(h !== null && Lh(h)))
            }
            function kM(h, p, x) {
                switch (p.tag) {
                case 3:
                    pe(p, p.stateNode.containerInfo),
                    au(p, Mi, h.memoizedState.cache),
                    $e();
                    break;
                case 27:
                case 5:
                    ue(p);
                    break;
                case 4:
                    pe(p, p.stateNode.containerInfo);
                    break;
                case 10:
                    au(p, p.type, p.memoizedProps.value);
                    break;
                case 13:
                    var w = p.memoizedState;
                    if (w !== null)
                        return w.dehydrated !== null ? (Wt(p),
                        p.flags |= 128,
                        null) : (x & p.child.childLanes) !== 0 ? R_(h, p, x) : (Wt(p),
                        h = yl(h, p, x),
                        h !== null ? h.sibling : null);
                    Wt(p);
                    break;
                case 19:
                    var U = (h.flags & 128) !== 0;
                    if (w = (x & p.childLanes) !== 0,
                    w || (Nh(h, p, x, !1),
                    w = (x & p.childLanes) !== 0),
                    U) {
                        if (w)
                            return U_(h, p, x);
                        p.flags |= 128
                    }
                    if (U = p.memoizedState,
                    U !== null && (U.rendering = null,
                    U.tail = null,
                    U.lastEffect = null),
                    A(hr, hr.current),
                    w)
                        break;
                    return null;
                case 22:
                case 23:
                    return p.lanes = 0,
                    Rr(h, p, x);
                case 24:
                    au(p, Mi, h.memoizedState.cache)
                }
                return yl(h, p, x)
            }
            function O_(h, p, x) {
                if (h !== null)
                    if (h.memoizedProps !== p.pendingProps)
                        gi = !0;
                    else {
                        if (!n0(h, x) && (p.flags & 128) === 0)
                            return gi = !1,
                            kM(h, p, x);
                        gi = (h.flags & 131072) !== 0
                    }
                else
                    gi = !1,
                    Yn && (p.flags & 1048576) !== 0 && W(p, Af, p.index);
                switch (p.lanes = 0,
                p.tag) {
                case 16:
                    e: {
                        h = p.pendingProps;
                        var w = p.elementType
                          , U = w._init;
                        if (w = U(w._payload),
                        p.type = w,
                        typeof w == "function")
                            Wh(w) ? (h = ka(w, h),
                            p.tag = 1,
                            p = A_(null, p, w, h, x)) : (p.tag = 0,
                            p = Ga(null, p, w, h, x));
                        else {
                            if (w != null) {
                                if (U = w.$$typeof,
                                U === $h) {
                                    p.tag = 11,
                                    p = vl(null, p, w, h, x);
                                    break e
                                } else if (U === Vp) {
                                    p.tag = 14,
                                    p = Rh(null, p, w, h, x);
                                    break e
                                }
                            }
                            throw p = s(w) || w,
                            Error(i(306, p, ""))
                        }
                    }
                    return p;
                case 0:
                    return Ga(h, p, p.type, p.pendingProps, x);
                case 1:
                    return w = p.type,
                    U = ka(w, p.pendingProps),
                    A_(h, p, w, U, x);
                case 3:
                    e: {
                        if (pe(p, p.stateNode.containerInfo),
                        h === null)
                            throw Error(i(387));
                        var F = p.pendingProps;
                        U = p.memoizedState,
                        w = U.element,
                        pt(h, p),
                        Ut(p, F, null, x);
                        var ie = p.memoizedState;
                        if (F = ie.cache,
                        au(p, Mi, F),
                        F !== U.cache && dc(p, [Mi], x, !0),
                        ut(),
                        F = ie.element,
                        Lr && U.isDehydrated)
                            if (U = {
                                element: F,
                                isDehydrated: !1,
                                cache: ie.cache
                            },
                            p.updateQueue.baseState = U,
                            p.memoizedState = U,
                            p.flags & 256) {
                                p = C_(h, p, F, x);
                                break e
                            } else if (F !== w) {
                                w = se(Error(i(424)), p),
                                re(w),
                                p = C_(h, p, F, x);
                                break e
                            } else
                                for (Lr && (Br = c1(p.stateNode.containerInfo),
                                Pr = p,
                                Yn = !0,
                                Os = null,
                                br = !0),
                                x = Fo(p, null, F, x),
                                p.child = x; x; )
                                    x.flags = x.flags & -3 | 4096,
                                    x = x.sibling;
                        else {
                            if ($e(),
                            F === w) {
                                p = yl(h, p, x);
                                break e
                            }
                            zi(h, p, F, x)
                        }
                        p = p.child
                    }
                    return p;
                case 26:
                    if (Ya)
                        return ir(h, p),
                        h === null ? (x = k0(p.type, null, p.pendingProps, null)) ? p.memoizedState = x : Yn || (p.stateNode = $p(p.type, p.pendingProps, zo.current, p)) : p.memoizedState = k0(p.type, h.memoizedProps, p.pendingProps, h.memoizedState),
                        null;
                case 27:
                    if (pi)
                        return ue(p),
                        h === null && pi && Yn && (w = p.stateNode = io(p.type, p.pendingProps, zo.current, fr.current, !1),
                        Pr = p,
                        br = !0,
                        Br = Zp(w)),
                        w = p.pendingProps.children,
                        h !== null || Yn ? zi(h, p, w, x) : p.child = Cu(p, null, w, x),
                        ir(h, p),
                        p.child;
                case 5:
                    return h === null && Yn && (Qp(p.type, p.pendingProps, fr.current),
                    (U = w = Br) && (w = ZM(w, p.type, p.pendingProps, br),
                    w !== null ? (p.stateNode = w,
                    Pr = p,
                    Br = Zp(w),
                    br = !1,
                    U = !0) : U = !1),
                    U || Te(p)),
                    ue(p),
                    U = p.type,
                    F = p.pendingProps,
                    ie = h !== null ? h.memoizedProps : null,
                    w = F.children,
                    wn(U, F) ? w = null : ie !== null && wn(U, ie) && (p.flags |= 32),
                    p.memoizedState !== null && (U = $(h, p, Fe, null, null, x),
                    oa ? no._currentValue = U : no._currentValue2 = U),
                    ir(h, p),
                    zi(h, p, w, x),
                    p.child;
                case 6:
                    return h === null && Yn && (v1(p.pendingProps, fr.current),
                    (h = x = Br) && (x = H0(x, p.pendingProps, br),
                    x !== null ? (p.stateNode = x,
                    Pr = p,
                    Br = null,
                    h = !0) : h = !1),
                    h || Te(p)),
                    null;
                case 13:
                    return R_(h, p, x);
                case 4:
                    return pe(p, p.stateNode.containerInfo),
                    w = p.pendingProps,
                    h === null ? p.child = Cu(p, null, w, x) : zi(h, p, w, x),
                    p.child;
                case 11:
                    return vl(h, p, p.type, p.pendingProps, x);
                case 7:
                    return zi(h, p, p.pendingProps, x),
                    p.child;
                case 8:
                    return zi(h, p, p.pendingProps.children, x),
                    p.child;
                case 12:
                    return zi(h, p, p.pendingProps.children, x),
                    p.child;
                case 10:
                    return w = p.pendingProps,
                    au(p, p.type, w.value),
                    zi(h, p, w.children, x),
                    p.child;
                case 9:
                    return U = p.type._context,
                    w = p.pendingProps.children,
                    su(p),
                    U = Dr(U),
                    w = w(U),
                    p.flags |= 1,
                    zi(h, p, w, x),
                    p.child;
                case 14:
                    return Rh(h, p, p.type, p.pendingProps, x);
                case 15:
                    return Sp(h, p, p.type, p.pendingProps, x);
                case 19:
                    return U_(h, p, x);
                case 22:
                    return Rr(h, p, x);
                case 24:
                    return su(p),
                    w = Dr(Mi),
                    h === null ? (U = r0(),
                    U === null && (U = oi,
                    F = ou(),
                    U.pooledCache = F,
                    F.refCount++,
                    F !== null && (U.pooledCacheLanes |= x),
                    U = F),
                    p.memoizedState = {
                        parent: w,
                        cache: U
                    },
                    Mt(p),
                    au(p, Mi, U)) : ((h.lanes & x) !== 0 && (pt(h, p),
                    Ut(p, null, null, x),
                    ut()),
                    U = h.memoizedState,
                    F = p.memoizedState,
                    U.parent !== w ? (U = {
                        parent: w,
                        cache: w
                    },
                    p.memoizedState = U,
                    p.lanes === 0 && (p.memoizedState = p.updateQueue.baseState = U),
                    au(p, Mi, w)) : (w = F.cache,
                    au(p, Mi, w),
                    w !== U.cache && dc(p, [Mi], x, !0))),
                    zi(h, p, p.pendingProps.children, x),
                    p.child;
                case 29:
                    throw p.pendingProps
                }
                throw Error(i(156, p.tag))
            }
            function au(h, p, x) {
                oa ? (A(zl, p._currentValue),
                p._currentValue = x) : (A(zl, p._currentValue2),
                p._currentValue2 = x)
            }
            function _l(h) {
                var p = zl.current;
                oa ? h._currentValue = p : h._currentValue2 = p,
                b(zl)
            }
            function Oh(h, p, x) {
                for (; h !== null; ) {
                    var w = h.alternate;
                    if ((h.childLanes & p) !== p ? (h.childLanes |= p,
                    w !== null && (w.childLanes |= p)) : w !== null && (w.childLanes & p) !== p && (w.childLanes |= p),
                    h === x)
                        break;
                    h = h.return
                }
            }
            function dc(h, p, x, w) {
                var U = h.child;
                for (U !== null && (U.return = h); U !== null; ) {
                    var F = U.dependencies;
                    if (F !== null) {
                        var ie = U.child;
                        F = F.firstContext;
                        e: for (; F !== null; ) {
                            var Me = F;
                            F = U;
                            for (var Ie = 0; Ie < p.length; Ie++)
                                if (Me.context === p[Ie]) {
                                    F.lanes |= x,
                                    Me = F.alternate,
                                    Me !== null && (Me.lanes |= x),
                                    Oh(F.return, x, h),
                                    w || (ie = null);
                                    break e
                                }
                            F = Me.next
                        }
                    } else if (U.tag === 18) {
                        if (ie = U.return,
                        ie === null)
                            throw Error(i(341));
                        ie.lanes |= x,
                        F = ie.alternate,
                        F !== null && (F.lanes |= x),
                        Oh(ie, x, h),
                        ie = null
                    } else
                        ie = U.child;
                    if (ie !== null)
                        ie.return = U;
                    else
                        for (ie = U; ie !== null; ) {
                            if (ie === h) {
                                ie = null;
                                break
                            }
                            if (U = ie.sibling,
                            U !== null) {
                                U.return = ie.return,
                                ie = U;
                                break
                            }
                            ie = ie.return
                        }
                    U = ie
                }
            }
            function Nh(h, p, x, w) {
                h = null;
                for (var U = p, F = !1; U !== null; ) {
                    if (!F) {
                        if ((U.flags & 524288) !== 0)
                            F = !0;
                        else if ((U.flags & 262144) !== 0)
                            break
                    }
                    if (U.tag === 10) {
                        var ie = U.alternate;
                        if (ie === null)
                            throw Error(i(387));
                        if (ie = ie.memoizedProps,
                        ie !== null) {
                            var Me = U.type;
                            Ca(U.pendingProps.value, ie.value) || (h !== null ? h.push(Me) : h = [Me])
                        }
                    } else if (U === Mc.current) {
                        if (ie = U.alternate,
                        ie === null)
                            throw Error(i(387));
                        ie.memoizedState.memoizedState !== U.memoizedState.memoizedState && (h !== null ? h.push(no) : h = [no])
                    }
                    U = U.return
                }
                h !== null && dc(p, h, x, w),
                p.flags |= 262144
            }
            function Lh(h) {
                for (h = h.firstContext; h !== null; ) {
                    var p = h.context;
                    if (!Ca(oa ? p._currentValue : p._currentValue2, h.memoizedValue))
                        return !0;
                    h = h.next
                }
                return !1
            }
            function su(h) {
                lo = h,
                $a = null,
                h = h.dependencies,
                h !== null && (h.firstContext = null)
            }
            function Dr(h) {
                return i0(lo, h)
            }
            function Ph(h, p) {
                return lo === null && su(h),
                i0(h, p)
            }
            function i0(h, p) {
                var x = oa ? p._currentValue : p._currentValue2;
                if (p = {
                    context: p,
                    memoizedValue: x,
                    next: null
                },
                $a === null) {
                    if (h === null)
                        throw Error(i(308));
                    $a = p,
                    h.dependencies = {
                        lanes: 0,
                        firstContext: p
                    },
                    h.flags |= 524288
                } else
                    $a = $a.next = p;
                return x
            }
            function ou() {
                return {
                    controller: new Nf,
                    data: new Map,
                    refCount: 0
                }
            }
            function Bh(h) {
                h.refCount--,
                h.refCount === 0 && C1(R1, function() {
                    h.controller.abort()
                })
            }
            function r0() {
                var h = Vo.current;
                return h !== null ? h : oi.pooledCache
            }
            function Mp(h, p) {
                p === null ? A(Vo, Vo.current) : A(Vo, p.pool)
            }
            function a0() {
                var h = r0();
                return h === null ? null : {
                    parent: oa ? Mi._currentValue : Mi._currentValue2,
                    pool: h
                }
            }
            function Sa(h) {
                h.flags |= 4
            }
            function of(h, p) {
                if (h !== null && h.child === p.child)
                    return !1;
                if ((p.flags & 16) !== 0)
                    return !0;
                for (h = p.child; h !== null; ) {
                    if ((h.flags & 13878) !== 0 || (h.subtreeFlags & 13878) !== 0)
                        return !0;
                    h = h.sibling
                }
                return !1
            }
            function pc(h, p, x, w) {
                if (cr)
                    for (x = p.child; x !== null; ) {
                        if (x.tag === 5 || x.tag === 6)
                            td(h, x.stateNode);
                        else if (!(x.tag === 4 || pi && x.tag === 27) && x.child !== null) {
                            x.child.return = x,
                            x = x.child;
                            continue
                        }
                        if (x === p)
                            break;
                        for (; x.sibling === null; ) {
                            if (x.return === null || x.return === p)
                                return;
                            x = x.return
                        }
                        x.sibling.return = x.return,
                        x = x.sibling
                    }
                else if (Ds)
                    for (var U = p.child; U !== null; ) {
                        if (U.tag === 5) {
                            var F = U.stateNode;
                            x && w && (F = B0(F, U.type, U.memoizedProps)),
                            td(h, F)
                        } else if (U.tag === 6)
                            F = U.stateNode,
                            x && w && (F = z0(F, U.memoizedProps)),
                            td(h, F);
                        else if (U.tag !== 4) {
                            if (U.tag === 22 && U.memoizedState !== null)
                                F = U.child,
                                F !== null && (F.return = U),
                                pc(h, U, !0, !0);
                            else if (U.child !== null) {
                                U.child.return = U,
                                U = U.child;
                                continue
                            }
                        }
                        if (U === p)
                            break;
                        for (; U.sibling === null; ) {
                            if (U.return === null || U.return === p)
                                return;
                            U = U.return
                        }
                        U.sibling.return = U.return,
                        U = U.sibling
                    }
            }
            function N_(h, p, x, w) {
                if (Ds)
                    for (var U = p.child; U !== null; ) {
                        if (U.tag === 5) {
                            var F = U.stateNode;
                            x && w && (F = B0(F, U.type, U.memoizedProps)),
                            P0(h, F)
                        } else if (U.tag === 6)
                            F = U.stateNode,
                            x && w && (F = z0(F, U.memoizedProps)),
                            P0(h, F);
                        else if (U.tag !== 4) {
                            if (U.tag === 22 && U.memoizedState !== null)
                                F = U.child,
                                F !== null && (F.return = U),
                                N_(h, U, !(U.memoizedProps !== null && U.memoizedProps.mode === "manual"), !0);
                            else if (U.child !== null) {
                                U.child.return = U,
                                U = U.child;
                                continue
                            }
                        }
                        if (U === p)
                            break;
                        for (; U.sibling === null; ) {
                            if (U.return === null || U.return === p)
                                return;
                            U = U.return
                        }
                        U.sibling.return = U.return,
                        U = U.sibling
                    }
            }
            function zh(h, p) {
                if (Ds && of(h, p)) {
                    h = p.stateNode;
                    var x = h.containerInfo
                      , w = nd();
                    N_(w, p, !1, !1),
                    h.pendingChildren = w,
                    Sa(p),
                    Wp(x, w)
                }
            }
            function Tp(h, p, x, w) {
                if (cr)
                    h.memoizedProps !== w && Sa(p);
                else if (Ds) {
                    var U = h.stateNode
                      , F = h.memoizedProps;
                    if ((h = of(h, p)) || F !== w) {
                        var ie = fr.current;
                        F = Tf(U, x, F, w, !h, null),
                        F === U ? p.stateNode = U : (Dl(F, x, w, ie) && Sa(p),
                        p.stateNode = F,
                        h ? pc(F, p, !1, !1) : Sa(p))
                    } else
                        p.stateNode = U
                }
            }
            function Ep(h, p, x) {
                if (A0(p, x)) {
                    if (h.flags |= 16777216,
                    !Xp(p, x))
                        if (du())
                            h.flags |= 8192;
                        else
                            throw Eu = fd,
                            cd
                } else
                    h.flags &= -16777217
            }
            function wp(h, p) {
                if (x1(p)) {
                    if (h.flags |= 16777216,
                    !yc(p))
                        if (du())
                            h.flags |= 8192;
                        else
                            throw Eu = fd,
                            cd
                } else
                    h.flags &= -16777217
            }
            function lf(h, p) {
                p !== null && (h.flags |= 4),
                h.flags & 16384 && (p = h.tag !== 22 ? N() : 536870912,
                h.lanes |= p,
                Xo |= p)
            }
            function uf(h, p) {
                if (!Yn)
                    switch (h.tailMode) {
                    case "hidden":
                        p = h.tail;
                        for (var x = null; p !== null; )
                            p.alternate !== null && (x = p),
                            p = p.sibling;
                        x === null ? h.tail = null : x.sibling = null;
                        break;
                    case "collapsed":
                        x = h.tail;
                        for (var w = null; x !== null; )
                            x.alternate !== null && (w = x),
                            x = x.sibling;
                        w === null ? p || h.tail === null ? h.tail = null : h.tail.sibling = null : w.sibling = null
                    }
            }
            function Ui(h) {
                var p = h.alternate !== null && h.alternate.child === h.child
                  , x = 0
                  , w = 0;
                if (p)
                    for (var U = h.child; U !== null; )
                        x |= U.lanes | U.childLanes,
                        w |= U.subtreeFlags & 31457280,
                        w |= U.flags & 31457280,
                        U.return = h,
                        U = U.sibling;
                else
                    for (U = h.child; U !== null; )
                        x |= U.lanes | U.childLanes,
                        w |= U.subtreeFlags,
                        w |= U.flags,
                        U.return = h,
                        U = U.sibling;
                return h.subtreeFlags |= w,
                h.childLanes = x,
                p
            }
            function L_(h, p, x) {
                var w = p.pendingProps;
                switch (fe(p),
                p.tag) {
                case 16:
                case 15:
                case 0:
                case 11:
                case 7:
                case 8:
                case 12:
                case 9:
                case 14:
                    return Ui(p),
                    null;
                case 1:
                    return Ui(p),
                    null;
                case 3:
                    return x = p.stateNode,
                    w = null,
                    h !== null && (w = h.memoizedState.cache),
                    p.memoizedState.cache !== w && (p.flags |= 2048),
                    _l(Mi),
                    _e(),
                    x.pendingContext && (x.context = x.pendingContext,
                    x.pendingContext = null),
                    (h === null || h.child === null) && (tt(p) ? Sa(p) : h === null || h.memoizedState.isDehydrated && (p.flags & 256) === 0 || (p.flags |= 1024,
                    Os !== null && (Xh(Os),
                    Os = null))),
                    zh(h, p),
                    Ui(p),
                    null;
                case 26:
                    if (Ya) {
                        x = p.type;
                        var U = p.memoizedState;
                        return h === null ? (Sa(p),
                        U !== null ? (Ui(p),
                        wp(p, U)) : (Ui(p),
                        Ep(p, x, w))) : U ? U !== h.memoizedState ? (Sa(p),
                        Ui(p),
                        wp(p, U)) : (Ui(p),
                        p.flags &= -16777217) : (cr ? h.memoizedProps !== w && Sa(p) : Tp(h, p, x, w),
                        Ui(p),
                        Ep(p, x, w)),
                        null
                    }
                case 27:
                    if (pi) {
                        if (ge(p),
                        x = zo.current,
                        U = p.type,
                        h !== null && p.stateNode != null)
                            cr ? h.memoizedProps !== w && Sa(p) : Tp(h, p, U, w);
                        else {
                            if (!w) {
                                if (p.stateNode === null)
                                    throw Error(i(166));
                                return Ui(p),
                                null
                            }
                            h = fr.current,
                            tt(p) ? Ze(p, h) : (h = io(U, w, x, h, !0),
                            p.stateNode = h,
                            Sa(p))
                        }
                        return Ui(p),
                        null
                    }
                case 5:
                    if (ge(p),
                    x = p.type,
                    h !== null && p.stateNode != null)
                        Tp(h, p, x, w);
                    else {
                        if (!w) {
                            if (p.stateNode === null)
                                throw Error(i(166));
                            return Ui(p),
                            null
                        }
                        h = fr.current,
                        tt(p) ? Ze(p, h) : (U = w0(x, w, zo.current, h, p),
                        pc(U, p, !1, !1),
                        p.stateNode = U,
                        Dl(U, x, w, h) && Sa(p))
                    }
                    return Ui(p),
                    Ep(p, p.type, p.pendingProps),
                    null;
                case 6:
                    if (h && p.stateNode != null)
                        x = h.memoizedProps,
                        cr ? x !== w && Sa(p) : Ds && (x !== w ? (p.stateNode = ci(w, zo.current, fr.current, p),
                        Sa(p)) : p.stateNode = h.stateNode);
                    else {
                        if (typeof w != "string" && p.stateNode === null)
                            throw Error(i(166));
                        if (h = zo.current,
                        x = fr.current,
                        tt(p)) {
                            if (!Lr)
                                throw Error(i(176));
                            if (h = p.stateNode,
                            x = p.memoizedProps,
                            w = null,
                            U = Pr,
                            U !== null)
                                switch (U.tag) {
                                case 27:
                                case 5:
                                    w = U.memoizedProps
                                }
                            V0(h, x, p, w) || Te(p)
                        } else
                            p.stateNode = ci(w, h, x, p)
                    }
                    return Ui(p),
                    null;
                case 13:
                    if (w = p.memoizedState,
                    h === null || h.memoizedState !== null && h.memoizedState.dehydrated !== null) {
                        if (U = tt(p),
                        w !== null && w.dehydrated !== null) {
                            if (h === null) {
                                if (!U)
                                    throw Error(i(318));
                                if (!Lr)
                                    throw Error(i(344));
                                if (U = p.memoizedState,
                                U = U !== null ? U.dehydrated : null,
                                !U)
                                    throw Error(i(317));
                                p1(U, p)
                            } else
                                $e(),
                                (p.flags & 128) === 0 && (p.memoizedState = null),
                                p.flags |= 4;
                            Ui(p),
                            U = !1
                        } else
                            Os !== null && (Xh(Os),
                            Os = null),
                            U = !0;
                        if (!U)
                            return p.flags & 256 ? (Pt(p),
                            p) : (Pt(p),
                            null)
                    }
                    if (Pt(p),
                    (p.flags & 128) !== 0)
                        return p.lanes = x,
                        p;
                    if (x = w !== null,
                    h = h !== null && h.memoizedState !== null,
                    x) {
                        w = p.child,
                        U = null,
                        w.alternate !== null && w.alternate.memoizedState !== null && w.alternate.memoizedState.cachePool !== null && (U = w.alternate.memoizedState.cachePool.pool);
                        var F = null;
                        w.memoizedState !== null && w.memoizedState.cachePool !== null && (F = w.memoizedState.cachePool.pool),
                        F !== U && (w.flags |= 2048)
                    }
                    return x !== h && x && (p.child.flags |= 8192),
                    lf(p, p.updateQueue),
                    Ui(p),
                    null;
                case 4:
                    return _e(),
                    zh(h, p),
                    h === null && Yi(p.stateNode.containerInfo),
                    Ui(p),
                    null;
                case 10:
                    return _l(p.type),
                    Ui(p),
                    null;
                case 19:
                    if (b(hr),
                    U = p.memoizedState,
                    U === null)
                        return Ui(p),
                        null;
                    if (w = (p.flags & 128) !== 0,
                    F = U.rendering,
                    F === null)
                        if (w)
                            uf(U, !1);
                        else {
                            if (vi !== 0 || h !== null && (h.flags & 128) !== 0)
                                for (h = p.child; h !== null; ) {
                                    if (F = un(h),
                                    F !== null) {
                                        for (p.flags |= 128,
                                        uf(U, !1),
                                        h = F.updateQueue,
                                        p.updateQueue = h,
                                        lf(p, h),
                                        p.subtreeFlags = 0,
                                        h = x,
                                        x = p.child; x !== null; )
                                            Yh(x, h),
                                            x = x.sibling;
                                        return A(hr, hr.current & 1 | 2),
                                        p.child
                                    }
                                    h = h.sibling
                                }
                            U.tail !== null && Us() > Bf && (p.flags |= 128,
                            w = !0,
                            uf(U, !1),
                            p.lanes = 4194304)
                        }
                    else {
                        if (!w)
                            if (h = un(F),
                            h !== null) {
                                if (p.flags |= 128,
                                w = !0,
                                h = h.updateQueue,
                                p.updateQueue = h,
                                lf(p, h),
                                uf(U, !0),
                                U.tail === null && U.tailMode === "hidden" && !F.alternate && !Yn)
                                    return Ui(p),
                                    null
                            } else
                                2 * Us() - U.renderingStartTime > Bf && x !== 536870912 && (p.flags |= 128,
                                w = !0,
                                uf(U, !1),
                                p.lanes = 4194304);
                        U.isBackwards ? (F.sibling = p.child,
                        p.child = F) : (h = U.last,
                        h !== null ? h.sibling = F : p.child = F,
                        U.last = F)
                    }
                    return U.tail !== null ? (p = U.tail,
                    U.rendering = p,
                    U.tail = p.sibling,
                    U.renderingStartTime = Us(),
                    p.sibling = null,
                    h = hr.current,
                    A(hr, w ? h & 1 | 2 : h & 1),
                    p) : (Ui(p),
                    null);
                case 22:
                case 23:
                    return Pt(p),
                    zt(),
                    w = p.memoizedState !== null,
                    h !== null ? h.memoizedState !== null !== w && (p.flags |= 8192) : w && (p.flags |= 8192),
                    w ? (x & 536870912) !== 0 && (p.flags & 128) === 0 && (Ui(p),
                    p.subtreeFlags & 6 && (p.flags |= 8192)) : Ui(p),
                    x = p.updateQueue,
                    x !== null && lf(p, x.retryQueue),
                    x = null,
                    h !== null && h.memoizedState !== null && h.memoizedState.cachePool !== null && (x = h.memoizedState.cachePool.pool),
                    w = null,
                    p.memoizedState !== null && p.memoizedState.cachePool !== null && (w = p.memoizedState.cachePool.pool),
                    w !== x && (p.flags |= 2048),
                    h !== null && b(Vo),
                    null;
                case 24:
                    return x = null,
                    h !== null && (x = h.memoizedState.cache),
                    p.memoizedState.cache !== x && (p.flags |= 2048),
                    _l(Mi),
                    Ui(p),
                    null;
                case 25:
                    return null
                }
                throw Error(i(156, p.tag))
            }
            function GM(h, p) {
                switch (fe(p),
                p.tag) {
                case 1:
                    return h = p.flags,
                    h & 65536 ? (p.flags = h & -65537 | 128,
                    p) : null;
                case 3:
                    return _l(Mi),
                    _e(),
                    h = p.flags,
                    (h & 65536) !== 0 && (h & 128) === 0 ? (p.flags = h & -65537 | 128,
                    p) : null;
                case 26:
                case 27:
                case 5:
                    return ge(p),
                    null;
                case 13:
                    if (Pt(p),
                    h = p.memoizedState,
                    h !== null && h.dehydrated !== null) {
                        if (p.alternate === null)
                            throw Error(i(340));
                        $e()
                    }
                    return h = p.flags,
                    h & 65536 ? (p.flags = h & -65537 | 128,
                    p) : null;
                case 19:
                    return b(hr),
                    null;
                case 4:
                    return _e(),
                    null;
                case 10:
                    return _l(p.type),
                    null;
                case 22:
                case 23:
                    return Pt(p),
                    zt(),
                    h !== null && b(Vo),
                    h = p.flags,
                    h & 65536 ? (p.flags = h & -65537 | 128,
                    p) : null;
                case 24:
                    return _l(Mi),
                    null;
                case 25:
                    return null;
                default:
                    return null
                }
            }
            function P_(h, p) {
                switch (fe(p),
                p.tag) {
                case 3:
                    _l(Mi),
                    _e();
                    break;
                case 26:
                case 27:
                case 5:
                    ge(p);
                    break;
                case 4:
                    _e();
                    break;
                case 13:
                    Pt(p);
                    break;
                case 19:
                    b(hr);
                    break;
                case 10:
                    _l(p.type);
                    break;
                case 22:
                case 23:
                    Pt(p),
                    zt(),
                    h !== null && b(Vo);
                    break;
                case 24:
                    _l(Mi)
                }
            }
            function Ih(h, p) {
                try {
                    var x = p.updateQueue
                      , w = x !== null ? x.lastEffect : null;
                    if (w !== null) {
                        var U = w.next;
                        x = U;
                        do {
                            if ((x.tag & h) === h) {
                                w = void 0;
                                var F = x.create
                                  , ie = x.inst;
                                w = F(),
                                ie.destroy = w
                            }
                            x = x.next
                        } while (x !== U)
                    }
                } catch (Me) {
                    ai(p, p.return, Me)
                }
            }
            function lu(h, p, x) {
                try {
                    var w = p.updateQueue
                      , U = w !== null ? w.lastEffect : null;
                    if (U !== null) {
                        var F = U.next;
                        w = F;
                        do {
                            if ((w.tag & h) === h) {
                                var ie = w.inst
                                  , Me = ie.destroy;
                                if (Me !== void 0) {
                                    ie.destroy = void 0,
                                    U = p;
                                    var Ie = x;
                                    try {
                                        Me()
                                    } catch (ht) {
                                        ai(U, Ie, ht)
                                    }
                                }
                            }
                            w = w.next
                        } while (w !== F)
                    }
                } catch (ht) {
                    ai(p, p.return, ht)
                }
            }
            function B_(h) {
                var p = h.updateQueue;
                if (p !== null) {
                    var x = h.stateNode;
                    try {
                        Ee(p, x)
                    } catch (w) {
                        ai(h, h.return, w)
                    }
                }
            }
            function ba(h, p, x) {
                x.props = ka(h.type, h.memoizedProps),
                x.state = h.memoizedState;
                try {
                    x.componentWillUnmount()
                } catch (w) {
                    ai(h, p, w)
                }
            }
            function $s(h, p) {
                try {
                    var x = h.ref;
                    if (x !== null) {
                        var w = h.stateNode;
                        switch (h.tag) {
                        case 26:
                        case 27:
                        case 5:
                            var U = Sf(w);
                            break;
                        default:
                            U = w
                        }
                        typeof x == "function" ? h.refCleanup = x(U) : x.current = U
                    }
                } catch (F) {
                    ai(h, p, F)
                }
            }
            function Ma(h, p) {
                var x = h.ref
                  , w = h.refCleanup;
                if (x !== null)
                    if (typeof w == "function")
                        try {
                            w()
                        } catch (U) {
                            ai(h, p, U)
                        } finally {
                            h.refCleanup = null,
                            h = h.alternate,
                            h != null && (h.refCleanup = null)
                        }
                    else if (typeof x == "function")
                        try {
                            x(null)
                        } catch (U) {
                            ai(h, p, U)
                        }
                    else
                        x.current = null
            }
            function s0(h) {
                var p = h.type
                  , x = h.memoizedProps
                  , w = h.stateNode;
                try {
                    YM(w, p, x, h)
                } catch (U) {
                    ai(h, h.return, U)
                }
            }
            function o0(h, p, x) {
                try {
                    $_(h.stateNode, h.type, x, p, h)
                } catch (w) {
                    ai(h, h.return, w)
                }
            }
            function l0(h) {
                return h.tag === 5 || h.tag === 3 || (Ya ? h.tag === 26 : !1) || (pi ? h.tag === 27 : !1) || h.tag === 4
            }
            function Fh(h) {
                e: for (; ; ) {
                    for (; h.sibling === null; ) {
                        if (h.return === null || l0(h.return))
                            return null;
                        h = h.return
                    }
                    for (h.sibling.return = h.return,
                    h = h.sibling; h.tag !== 5 && h.tag !== 6 && (!pi || h.tag !== 27) && h.tag !== 18; ) {
                        if (h.flags & 2 || h.child === null || h.tag === 4)
                            continue e;
                        h.child.return = h,
                        h = h.child
                    }
                    if (!(h.flags & 2))
                        return h.stateNode
                }
            }
            function u0(h, p, x) {
                var w = h.tag;
                if (w === 5 || w === 6)
                    h = h.stateNode,
                    p ? t1(x, h, p) : O0(x, h);
                else if (!(w === 4 || pi && w === 27) && (h = h.child,
                h !== null))
                    for (u0(h, p, x),
                    h = h.sibling; h !== null; )
                        u0(h, p, x),
                        h = h.sibling
            }
            function xl(h, p, x) {
                var w = h.tag;
                if (w === 5 || w === 6)
                    h = h.stateNode,
                    p ? e1(x, h, p) : Q_(x, h);
                else if (!(w === 4 || pi && w === 27) && (h = h.child,
                h !== null))
                    for (xl(h, p, x),
                    h = h.sibling; h !== null; )
                        xl(h, p, x),
                        h = h.sibling
            }
            function Ap(h, p, x) {
                h = h.containerInfo;
                try {
                    Ef(h, x)
                } catch (w) {
                    ai(p, p.return, w)
                }
            }
            function Hh(h, p) {
                for (kp(h.containerInfo),
                Mn = p; Mn !== null; )
                    if (h = Mn,
                    p = h.child,
                    (h.subtreeFlags & 1028) !== 0 && p !== null)
                        p.return = h,
                        Mn = p;
                    else
                        for (; Mn !== null; ) {
                            h = Mn;
                            var x = h.alternate;
                            switch (p = h.flags,
                            h.tag) {
                            case 0:
                                break;
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if ((p & 1024) !== 0 && x !== null) {
                                    p = void 0;
                                    var w = h
                                      , U = x.memoizedProps;
                                    x = x.memoizedState;
                                    var F = w.stateNode;
                                    try {
                                        var ie = ka(w.type, U, w.elementType === w.type);
                                        p = F.getSnapshotBeforeUpdate(ie, x),
                                        F.__reactInternalSnapshotBeforeUpdate = p
                                    } catch (Me) {
                                        ai(w, w.return, Me)
                                    }
                                }
                                break;
                            case 3:
                                (p & 1024) !== 0 && cr && s1(h.stateNode.containerInfo);
                                break;
                            case 5:
                            case 26:
                            case 27:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                if ((p & 1024) !== 0)
                                    throw Error(i(163))
                            }
                            if (p = h.sibling,
                            p !== null) {
                                p.return = h.return,
                                Mn = p;
                                break
                            }
                            Mn = h.return
                        }
                return ie = zn,
                zn = !1,
                ie
            }
            function Cp(h, p, x) {
                var w = x.flags;
                switch (x.tag) {
                case 0:
                case 11:
                case 15:
                    bl(h, x),
                    w & 4 && Ih(5, x);
                    break;
                case 1:
                    if (bl(h, x),
                    w & 4)
                        if (h = x.stateNode,
                        p === null)
                            try {
                                h.componentDidMount()
                            } catch (Me) {
                                ai(x, x.return, Me)
                            }
                        else {
                            var U = ka(x.type, p.memoizedProps);
                            p = p.memoizedState;
                            try {
                                h.componentDidUpdate(U, p, h.__reactInternalSnapshotBeforeUpdate)
                            } catch (Me) {
                                ai(x, x.return, Me)
                            }
                        }
                    w & 64 && B_(x),
                    w & 512 && $s(x, x.return);
                    break;
                case 3:
                    if (bl(h, x),
                    w & 64 && (w = x.updateQueue,
                    w !== null)) {
                        if (h = null,
                        x.child !== null)
                            switch (x.child.tag) {
                            case 27:
                            case 5:
                                h = Sf(x.child.stateNode);
                                break;
                            case 1:
                                h = x.child.stateNode
                            }
                        try {
                            Ee(w, h)
                        } catch (Me) {
                            ai(x, x.return, Me)
                        }
                    }
                    break;
                case 26:
                    if (Ya) {
                        bl(h, x),
                        w & 512 && $s(x, x.return);
                        break
                    }
                case 27:
                case 5:
                    bl(h, x),
                    p === null && w & 4 && s0(x),
                    w & 512 && $s(x, x.return);
                    break;
                case 12:
                    bl(h, x);
                    break;
                case 13:
                    bl(h, x),
                    w & 4 && Rp(h, x);
                    break;
                case 22:
                    if (U = x.memoizedState !== null || ko,
                    !U) {
                        p = p !== null && p.memoizedState !== null || Hi;
                        var F = ko
                          , ie = Hi;
                        ko = U,
                        (Hi = p) && !ie ? Ml(h, x, (x.subtreeFlags & 8772) !== 0) : bl(h, x),
                        ko = F,
                        Hi = ie
                    }
                    w & 512 && (x.memoizedProps.mode === "manual" ? $s(x, x.return) : Ma(x, x.return));
                    break;
                default:
                    bl(h, x)
                }
            }
            function c0(h) {
                var p = h.alternate;
                p !== null && (h.alternate = null,
                c0(p)),
                h.child = null,
                h.deletions = null,
                h.sibling = null,
                h.tag === 5 && (p = h.stateNode,
                p !== null && WM(p)),
                h.stateNode = null,
                h.return = null,
                h.dependencies = null,
                h.memoizedProps = null,
                h.memoizedState = null,
                h.pendingProps = null,
                h.stateNode = null,
                h.updateQueue = null
            }
            function Ur(h, p, x) {
                for (x = x.child; x !== null; )
                    uu(h, p, x),
                    x = x.sibling
            }
            function uu(h, p, x) {
                if (Aa && typeof Aa.onCommitFiberUnmount == "function")
                    try {
                        Aa.onCommitFiberUnmount(Zi, x)
                    } catch {}
                switch (x.tag) {
                case 26:
                    if (Ya) {
                        Hi || Ma(x, p),
                        Ur(h, p, x),
                        x.memoizedState ? vc(x.memoizedState) : x.stateNode && wf(x.stateNode);
                        break
                    }
                case 27:
                    if (pi) {
                        Hi || Ma(x, p);
                        var w = an
                          , U = Rn;
                        an = x.stateNode,
                        Ur(h, p, x),
                        bu(x.stateNode),
                        an = w,
                        Rn = U;
                        break
                    }
                case 5:
                    Hi || Ma(x, p);
                case 6:
                    if (cr) {
                        if (w = an,
                        U = Rn,
                        an = null,
                        Ur(h, p, x),
                        an = w,
                        Rn = U,
                        an !== null)
                            if (Rn)
                                try {
                                    n1(an, x.stateNode)
                                } catch (F) {
                                    ai(x, p, F)
                                }
                            else
                                try {
                                    N0(an, x.stateNode)
                                } catch (F) {
                                    ai(x, p, F)
                                }
                    } else
                        Ur(h, p, x);
                    break;
                case 18:
                    cr && an !== null && (Rn ? id(an, x.stateNode) : g1(an, x.stateNode));
                    break;
                case 4:
                    cr ? (w = an,
                    U = Rn,
                    an = x.stateNode.containerInfo,
                    Rn = !0,
                    Ur(h, p, x),
                    an = w,
                    Rn = U) : (Ds && Ap(x.stateNode, x, nd()),
                    Ur(h, p, x));
                    break;
                case 0:
                case 11:
                case 14:
                case 15:
                    Hi || lu(2, x, p),
                    Hi || lu(4, x, p),
                    Ur(h, p, x);
                    break;
                case 1:
                    Hi || (Ma(x, p),
                    w = x.stateNode,
                    typeof w.componentWillUnmount == "function" && ba(x, p, w)),
                    Ur(h, p, x);
                    break;
                case 21:
                    Ur(h, p, x);
                    break;
                case 22:
                    Hi || Ma(x, p),
                    Hi = (w = Hi) || x.memoizedState !== null,
                    Ur(h, p, x),
                    Hi = w;
                    break;
                default:
                    Ur(h, p, x)
                }
            }
            function Rp(h, p) {
                if (Lr && p.memoizedState === null && (h = p.alternate,
                h !== null && (h = h.memoizedState,
                h !== null && (h = h.dehydrated,
                h !== null))))
                    try {
                        QM(h)
                    } catch (x) {
                        ai(p, p.return, x)
                    }
            }
            function z_(h) {
                switch (h.tag) {
                case 13:
                case 19:
                    var p = h.stateNode;
                    return p === null && (p = h.stateNode = new si),
                    p;
                case 22:
                    return h = h.stateNode,
                    p = h._retryCache,
                    p === null && (p = h._retryCache = new si),
                    p;
                default:
                    throw Error(i(435, h.tag))
                }
            }
            function Sl(h, p) {
                var x = z_(h);
                p.forEach(function(w) {
                    var U = gu.bind(null, h, w);
                    x.has(w) || (x.add(w),
                    w.then(U, U))
                })
            }
            function aa(h, p) {
                var x = p.deletions;
                if (x !== null)
                    for (var w = 0; w < x.length; w++) {
                        var U = x[w]
                          , F = h
                          , ie = p;
                        if (cr) {
                            var Me = ie;
                            e: for (; Me !== null; ) {
                                switch (Me.tag) {
                                case 27:
                                case 5:
                                    an = Me.stateNode,
                                    Rn = !1;
                                    break e;
                                case 3:
                                    an = Me.stateNode.containerInfo,
                                    Rn = !0;
                                    break e;
                                case 4:
                                    an = Me.stateNode.containerInfo,
                                    Rn = !0;
                                    break e
                                }
                                Me = Me.return
                            }
                            if (an === null)
                                throw Error(i(160));
                            uu(F, ie, U),
                            an = null,
                            Rn = !1
                        } else
                            uu(F, ie, U);
                        F = U.alternate,
                        F !== null && (F.return = null),
                        U.return = null
                    }
                if (p.subtreeFlags & 13878)
                    for (p = p.child; p !== null; )
                        f0(p, h),
                        p = p.sibling
            }
            function f0(h, p) {
                var x = h.alternate
                  , w = h.flags;
                switch (h.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                    aa(p, h),
                    Ta(h),
                    w & 4 && (lu(3, h, h.return),
                    Ih(3, h),
                    lu(5, h, h.return));
                    break;
                case 1:
                    aa(p, h),
                    Ta(h),
                    w & 512 && (Hi || x === null || Ma(x, x.return)),
                    w & 64 && ko && (h = h.updateQueue,
                    h !== null && (w = h.callbacks,
                    w !== null && (x = h.shared.hiddenCallbacks,
                    h.shared.hiddenCallbacks = x === null ? w : x.concat(w))));
                    break;
                case 26:
                    if (Ya) {
                        var U = Pi;
                        aa(p, h),
                        Ta(h),
                        w & 512 && (Hi || x === null || Ma(x, x.return)),
                        w & 4 && (w = x !== null ? x.memoizedState : null,
                        p = h.memoizedState,
                        x === null ? p === null ? h.stateNode === null ? h.stateNode = ad(U, h.type, h.memoizedProps, h) : sd(U, h.type, h.stateNode) : h.stateNode = y1(U, p, h.memoizedProps) : w !== p ? (w === null ? x.stateNode !== null && wf(x.stateNode) : vc(w),
                        p === null ? sd(U, h.type, h.stateNode) : y1(U, p, h.memoizedProps)) : p === null && h.stateNode !== null && o0(h, h.memoizedProps, x.memoizedProps));
                        break
                    }
                case 27:
                    if (pi && w & 4 && h.alternate === null) {
                        U = h.stateNode;
                        var F = h.memoizedProps;
                        try {
                            Su(U),
                            b1(h.type, F, U, h)
                        } catch (Dt) {
                            ai(h, h.return, Dt)
                        }
                    }
                case 5:
                    if (aa(p, h),
                    Ta(h),
                    w & 512 && (Hi || x === null || Ma(x, x.return)),
                    cr) {
                        if (h.flags & 32) {
                            p = h.stateNode;
                            try {
                                L0(p)
                            } catch (Dt) {
                                ai(h, h.return, Dt)
                            }
                        }
                        w & 4 && h.stateNode != null && (p = h.memoizedProps,
                        o0(h, p, x !== null ? x.memoizedProps : p)),
                        w & 1024 && (W0 = !0)
                    }
                    break;
                case 6:
                    if (aa(p, h),
                    Ta(h),
                    w & 4 && cr) {
                        if (h.stateNode === null)
                            throw Error(i(162));
                        w = h.memoizedProps,
                        x = x !== null ? x.memoizedProps : w,
                        p = h.stateNode;
                        try {
                            J_(p, x, w)
                        } catch (Dt) {
                            ai(h, h.return, Dt)
                        }
                    }
                    break;
                case 3:
                    if (Ya ? (_1(),
                    U = Pi,
                    Pi = Jp(p.containerInfo),
                    aa(p, h),
                    Pi = U) : aa(p, h),
                    Ta(h),
                    w & 4) {
                        if (cr && Lr && x !== null && x.memoizedState.isDehydrated)
                            try {
                                KM(p.containerInfo)
                            } catch (Dt) {
                                ai(h, h.return, Dt)
                            }
                        if (Ds) {
                            w = p.containerInfo,
                            x = p.pendingChildren;
                            try {
                                Ef(w, x)
                            } catch (Dt) {
                                ai(h, h.return, Dt)
                            }
                        }
                    }
                    W0 && (W0 = !1,
                    I_(h));
                    break;
                case 4:
                    Ya ? (x = Pi,
                    Pi = Jp(h.stateNode.containerInfo),
                    aa(p, h),
                    Ta(h),
                    Pi = x) : (aa(p, h),
                    Ta(h)),
                    w & 4 && Ds && Ap(h.stateNode, h, h.stateNode.pendingChildren);
                    break;
                case 12:
                    aa(p, h),
                    Ta(h);
                    break;
                case 13:
                    aa(p, h),
                    Ta(h),
                    h.child.flags & 8192 && h.memoizedState !== null != (x !== null && x.memoizedState !== null) && (fa = Us()),
                    w & 4 && (w = h.updateQueue,
                    w !== null && (h.updateQueue = null,
                    Sl(h, w)));
                    break;
                case 22:
                    w & 512 && (Hi || x === null || Ma(x, x.return)),
                    U = h.memoizedState !== null;
                    var ie = x !== null && x.memoizedState !== null
                      , Me = ko
                      , Ie = Hi;
                    if (ko = Me || U,
                    Hi = Ie || ie,
                    aa(p, h),
                    Hi = Ie,
                    ko = Me,
                    Ta(h),
                    p = h.stateNode,
                    p._current = h,
                    p._visibility &= -3,
                    p._visibility |= p._pendingVisibility & 2,
                    w & 8192 && (p._visibility = U ? p._visibility & -2 : p._visibility | 1,
                    U && (p = ko || Hi,
                    x === null || ie || p || cf(h)),
                    cr && (h.memoizedProps === null || h.memoizedProps.mode !== "manual"))) {
                        e: if (x = null,
                        cr)
                            for (p = h; ; ) {
                                if (p.tag === 5 || Ya && p.tag === 26 || pi && p.tag === 27) {
                                    if (x === null) {
                                        ie = x = p;
                                        try {
                                            F = ie.stateNode,
                                            U ? i1(F) : a1(ie.stateNode, ie.memoizedProps)
                                        } catch (Dt) {
                                            ai(ie, ie.return, Dt)
                                        }
                                    }
                                } else if (p.tag === 6) {
                                    if (x === null) {
                                        ie = p;
                                        try {
                                            var ht = ie.stateNode;
                                            U ? r1(ht) : qM(ht, ie.memoizedProps)
                                        } catch (Dt) {
                                            ai(ie, ie.return, Dt)
                                        }
                                    }
                                } else if ((p.tag !== 22 && p.tag !== 23 || p.memoizedState === null || p === h) && p.child !== null) {
                                    p.child.return = p,
                                    p = p.child;
                                    continue
                                }
                                if (p === h)
                                    break e;
                                for (; p.sibling === null; ) {
                                    if (p.return === null || p.return === h)
                                        break e;
                                    x === p && (x = null),
                                    p = p.return
                                }
                                x === p && (x = null),
                                p.sibling.return = p.return,
                                p = p.sibling
                            }
                    }
                    w & 4 && (w = h.updateQueue,
                    w !== null && (x = w.retryQueue,
                    x !== null && (w.retryQueue = null,
                    Sl(h, x))));
                    break;
                case 19:
                    aa(p, h),
                    Ta(h),
                    w & 4 && (w = h.updateQueue,
                    w !== null && (h.updateQueue = null,
                    Sl(h, w)));
                    break;
                case 21:
                    break;
                default:
                    aa(p, h),
                    Ta(h)
                }
            }
            function Ta(h) {
                var p = h.flags;
                if (p & 2) {
                    try {
                        if (cr && (!pi || h.tag !== 27)) {
                            e: {
                                for (var x = h.return; x !== null; ) {
                                    if (l0(x)) {
                                        var w = x;
                                        break e
                                    }
                                    x = x.return
                                }
                                throw Error(i(160))
                            }
                            switch (w.tag) {
                            case 27:
                                if (pi) {
                                    var U = w.stateNode
                                      , F = Fh(h);
                                    xl(h, F, U);
                                    break
                                }
                            case 5:
                                var ie = w.stateNode;
                                w.flags & 32 && (L0(ie),
                                w.flags &= -33);
                                var Me = Fh(h);
                                xl(h, Me, ie);
                                break;
                            case 3:
                            case 4:
                                var Ie = w.stateNode.containerInfo
                                  , ht = Fh(h);
                                u0(h, ht, Ie);
                                break;
                            default:
                                throw Error(i(161))
                            }
                        }
                    } catch (Dt) {
                        ai(h, h.return, Dt)
                    }
                    h.flags &= -3
                }
                p & 4096 && (h.flags &= -4097)
            }
            function I_(h) {
                if (h.subtreeFlags & 1024)
                    for (h = h.child; h !== null; ) {
                        var p = h;
                        I_(p),
                        p.tag === 5 && p.flags & 1024 && jp(p.stateNode),
                        h = h.sibling
                    }
            }
            function bl(h, p) {
                if (p.subtreeFlags & 8772)
                    for (p = p.child; p !== null; )
                        Cp(h, p.alternate, p),
                        p = p.sibling
            }
            function cf(h) {
                for (h = h.child; h !== null; ) {
                    var p = h;
                    switch (p.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                        lu(4, p, p.return),
                        cf(p);
                        break;
                    case 1:
                        Ma(p, p.return);
                        var x = p.stateNode;
                        typeof x.componentWillUnmount == "function" && ba(p, p.return, x),
                        cf(p);
                        break;
                    case 26:
                    case 27:
                    case 5:
                        Ma(p, p.return),
                        cf(p);
                        break;
                    case 22:
                        Ma(p, p.return),
                        p.memoizedState === null && cf(p);
                        break;
                    default:
                        cf(p)
                    }
                    h = h.sibling
                }
            }
            function Ml(h, p, x) {
                for (x = x && (p.subtreeFlags & 8772) !== 0,
                p = p.child; p !== null; ) {
                    var w = p.alternate
                      , U = h
                      , F = p
                      , ie = F.flags;
                    switch (F.tag) {
                    case 0:
                    case 11:
                    case 15:
                        Ml(U, F, x),
                        Ih(4, F);
                        break;
                    case 1:
                        if (Ml(U, F, x),
                        w = F,
                        U = w.stateNode,
                        typeof U.componentDidMount == "function")
                            try {
                                U.componentDidMount()
                            } catch (ht) {
                                ai(w, w.return, ht)
                            }
                        if (w = F,
                        U = w.updateQueue,
                        U !== null) {
                            var Me = w.stateNode;
                            try {
                                var Ie = U.shared.hiddenCallbacks;
                                if (Ie !== null)
                                    for (U.shared.hiddenCallbacks = null,
                                    U = 0; U < Ie.length; U++)
                                        me(Ie[U], Me)
                            } catch (ht) {
                                ai(w, w.return, ht)
                            }
                        }
                        x && ie & 64 && B_(F),
                        $s(F, F.return);
                        break;
                    case 26:
                    case 27:
                    case 5:
                        Ml(U, F, x),
                        x && w === null && ie & 4 && s0(F),
                        $s(F, F.return);
                        break;
                    case 12:
                        Ml(U, F, x);
                        break;
                    case 13:
                        Ml(U, F, x),
                        x && ie & 4 && Rp(U, F);
                        break;
                    case 22:
                        F.memoizedState === null && Ml(U, F, x),
                        $s(F, F.return);
                        break;
                    default:
                        Ml(U, F, x)
                    }
                    p = p.sibling
                }
            }
            function Dp(h, p) {
                var x = null;
                h !== null && h.memoizedState !== null && h.memoizedState.cachePool !== null && (x = h.memoizedState.cachePool.pool),
                h = null,
                p.memoizedState !== null && p.memoizedState.cachePool !== null && (h = p.memoizedState.cachePool.pool),
                h !== x && (h != null && h.refCount++,
                x != null && Bh(x))
            }
            function Vh(h, p) {
                h = null,
                p.alternate !== null && (h = p.alternate.memoizedState.cache),
                p = p.memoizedState.cache,
                p !== h && (p.refCount++,
                h != null && Bh(h))
            }
            function _r(h, p, x, w) {
                if (p.subtreeFlags & 10256)
                    for (p = p.child; p !== null; )
                        h0(h, p, x, w),
                        p = p.sibling
            }
            function h0(h, p, x, w) {
                var U = p.flags;
                switch (p.tag) {
                case 0:
                case 11:
                case 15:
                    _r(h, p, x, w),
                    U & 2048 && Ih(9, p);
                    break;
                case 3:
                    _r(h, p, x, w),
                    U & 2048 && (h = null,
                    p.alternate !== null && (h = p.alternate.memoizedState.cache),
                    p = p.memoizedState.cache,
                    p !== h && (p.refCount++,
                    h != null && Bh(h)));
                    break;
                case 12:
                    if (U & 2048) {
                        _r(h, p, x, w),
                        h = p.stateNode;
                        try {
                            var F = p.memoizedProps
                              , ie = F.id
                              , Me = F.onPostCommit;
                            typeof Me == "function" && Me(ie, p.alternate === null ? "mount" : "update", h.passiveEffectDuration, -0)
                        } catch (Ie) {
                            ai(p, p.return, Ie)
                        }
                    } else
                        _r(h, p, x, w);
                    break;
                case 23:
                    break;
                case 22:
                    F = p.stateNode,
                    p.memoizedState !== null ? F._visibility & 4 ? _r(h, p, x, w) : Gr(h, p) : F._visibility & 4 ? _r(h, p, x, w) : (F._visibility |= 4,
                    Or(h, p, x, w, (p.subtreeFlags & 10256) !== 0)),
                    U & 2048 && Dp(p.alternate, p);
                    break;
                case 24:
                    _r(h, p, x, w),
                    U & 2048 && Vh(p.alternate, p);
                    break;
                default:
                    _r(h, p, x, w)
                }
            }
            function Or(h, p, x, w, U) {
                for (U = U && (p.subtreeFlags & 10256) !== 0,
                p = p.child; p !== null; ) {
                    var F = h
                      , ie = p
                      , Me = x
                      , Ie = w
                      , ht = ie.flags;
                    switch (ie.tag) {
                    case 0:
                    case 11:
                    case 15:
                        Or(F, ie, Me, Ie, U),
                        Ih(8, ie);
                        break;
                    case 23:
                        break;
                    case 22:
                        var Dt = ie.stateNode;
                        ie.memoizedState !== null ? Dt._visibility & 4 ? Or(F, ie, Me, Ie, U) : Gr(F, ie) : (Dt._visibility |= 4,
                        Or(F, ie, Me, Ie, U)),
                        U && ht & 2048 && Dp(ie.alternate, ie);
                        break;
                    case 24:
                        Or(F, ie, Me, Ie, U),
                        U && ht & 2048 && Vh(ie.alternate, ie);
                        break;
                    default:
                        Or(F, ie, Me, Ie, U)
                    }
                    p = p.sibling
                }
            }
            function Gr(h, p) {
                if (p.subtreeFlags & 10256)
                    for (p = p.child; p !== null; ) {
                        var x = h
                          , w = p
                          , U = w.flags;
                        switch (w.tag) {
                        case 22:
                            Gr(x, w),
                            U & 2048 && Dp(w.alternate, w);
                            break;
                        case 24:
                            Gr(x, w),
                            U & 2048 && Vh(w.alternate, w);
                            break;
                        default:
                            Gr(x, w)
                        }
                        p = p.sibling
                    }
            }
            function Es(h) {
                if (h.subtreeFlags & es)
                    for (h = h.child; h !== null; )
                        Up(h),
                        h = h.sibling
            }
            function Up(h) {
                switch (h.tag) {
                case 26:
                    Es(h),
                    h.flags & es && (h.memoizedState !== null ? S1(Pi, h.memoizedState, h.memoizedProps) : la(h.type, h.memoizedProps));
                    break;
                case 5:
                    Es(h),
                    h.flags & es && la(h.type, h.memoizedProps);
                    break;
                case 3:
                case 4:
                    if (Ya) {
                        var p = Pi;
                        Pi = Jp(h.stateNode.containerInfo),
                        Es(h),
                        Pi = p
                    } else
                        Es(h);
                    break;
                case 22:
                    h.memoizedState === null && (p = h.alternate,
                    p !== null && p.memoizedState !== null ? (p = es,
                    es = 16777216,
                    Es(h),
                    es = p) : Es(h));
                    break;
                default:
                    Es(h)
                }
            }
            function kh(h) {
                var p = h.alternate;
                if (p !== null && (h = p.child,
                h !== null)) {
                    p.child = null;
                    do
                        p = h.sibling,
                        h.sibling = null,
                        h = p;
                    while (h !== null)
                }
            }
            function cu(h) {
                var p = h.deletions;
                if ((h.flags & 16) !== 0) {
                    if (p !== null)
                        for (var x = 0; x < p.length; x++) {
                            var w = p[x];
                            Mn = w,
                            d0(w, h)
                        }
                    kh(h)
                }
                if (h.subtreeFlags & 10256)
                    for (h = h.child; h !== null; )
                        Op(h),
                        h = h.sibling
            }
            function Op(h) {
                switch (h.tag) {
                case 0:
                case 11:
                case 15:
                    cu(h),
                    h.flags & 2048 && lu(9, h, h.return);
                    break;
                case 3:
                    cu(h);
                    break;
                case 12:
                    cu(h);
                    break;
                case 22:
                    var p = h.stateNode;
                    h.memoizedState !== null && p._visibility & 4 && (h.return === null || h.return.tag !== 13) ? (p._visibility &= -5,
                    Tl(h)) : cu(h);
                    break;
                default:
                    cu(h)
                }
            }
            function Tl(h) {
                var p = h.deletions;
                if ((h.flags & 16) !== 0) {
                    if (p !== null)
                        for (var x = 0; x < p.length; x++) {
                            var w = p[x];
                            Mn = w,
                            d0(w, h)
                        }
                    kh(h)
                }
                for (h = h.child; h !== null; ) {
                    switch (p = h,
                    p.tag) {
                    case 0:
                    case 11:
                    case 15:
                        lu(8, p, p.return),
                        Tl(p);
                        break;
                    case 22:
                        x = p.stateNode,
                        x._visibility & 4 && (x._visibility &= -5,
                        Tl(p));
                        break;
                    default:
                        Tl(p)
                    }
                    h = h.sibling
                }
            }
            function d0(h, p) {
                for (; Mn !== null; ) {
                    var x = Mn;
                    switch (x.tag) {
                    case 0:
                    case 11:
                    case 15:
                        lu(8, x, p);
                        break;
                    case 23:
                    case 22:
                        if (x.memoizedState !== null && x.memoizedState.cachePool !== null) {
                            var w = x.memoizedState.cachePool.pool;
                            w != null && w.refCount++
                        }
                        break;
                    case 24:
                        Bh(x.memoizedState.cache)
                    }
                    if (w = x.child,
                    w !== null)
                        w.return = x,
                        Mn = w;
                    else
                        e: for (x = h; Mn !== null; ) {
                            w = Mn;
                            var U = w.sibling
                              , F = w.return;
                            if (c0(w),
                            w === x) {
                                Mn = null;
                                break e
                            }
                            if (U !== null) {
                                U.return = F,
                                Mn = U;
                                break e
                            }
                            Mn = F
                        }
                }
            }
            function ff(h) {
                var p = X_(h);
                if (p != null) {
                    if (typeof p.memoizedProps["data-testname"] != "string")
                        throw Error(i(364));
                    return p
                }
                if (h = D0(h),
                h === null)
                    throw Error(i(362));
                return h.stateNode.current
            }
            function fu(h, p) {
                var x = h.tag;
                switch (p.$$typeof) {
                case Pf:
                    if (h.type === p.value)
                        return !0;
                    break;
                case Ps:
                    e: {
                        for (p = p.value,
                        h = [h, 0],
                        x = 0; x < h.length; ) {
                            var w = h[x++]
                              , U = w.tag
                              , F = h[x++]
                              , ie = p[F];
                            if (U !== 5 && U !== 26 && U !== 27 || !Mf(w)) {
                                for (; ie != null && fu(w, ie); )
                                    F++,
                                    ie = p[F];
                                if (F === p.length) {
                                    p = !0;
                                    break e
                                } else
                                    for (w = w.child; w !== null; )
                                        h.push(w, F),
                                        w = w.sibling
                            }
                        }
                        p = !1
                    }
                    return p;
                case Ai:
                    if ((x === 5 || x === 26 || x === 27) && q_(h.stateNode, p.value))
                        return !0;
                    break;
                case Go:
                    if ((x === 5 || x === 6 || x === 26 || x === 27) && (h = Y_(h),
                    h !== null && 0 <= h.indexOf(p.value)))
                        return !0;
                    break;
                case uo:
                    if ((x === 5 || x === 26 || x === 27) && (h = h.memoizedProps["data-testname"],
                    typeof h == "string" && h.toLowerCase() === p.value.toLowerCase()))
                        return !0;
                    break;
                default:
                    throw Error(i(365))
                }
                return !1
            }
            function p0(h) {
                switch (h.$$typeof) {
                case Pf:
                    return "<" + (s(h.value) || "Unknown") + ">";
                case Ps:
                    return ":has(" + (p0(h) || "") + ")";
                case Ai:
                    return '[role="' + h.value + '"]';
                case Go:
                    return '"' + h.value + '"';
                case uo:
                    return '[data-testname="' + h.value + '"]';
                default:
                    throw Error(i(365))
                }
            }
            function Ea(h, p) {
                var x = [];
                h = [h, 0];
                for (var w = 0; w < h.length; ) {
                    var U = h[w++]
                      , F = U.tag
                      , ie = h[w++]
                      , Me = p[ie];
                    if (F !== 5 && F !== 26 && F !== 27 || !Mf(U)) {
                        for (; Me != null && fu(U, Me); )
                            ie++,
                            Me = p[ie];
                        if (ie === p.length)
                            x.push(U);
                        else
                            for (U = U.child; U !== null; )
                                h.push(U, ie),
                                U = U.sibling
                    }
                }
                return x
            }
            function Gh(h, p) {
                if (!xu)
                    throw Error(i(363));
                h = ff(h),
                h = Ea(h, p),
                p = [],
                h = Array.from(h);
                for (var x = 0; x < h.length; ) {
                    var w = h[x++]
                      , U = w.tag;
                    if (U === 5 || U === 26 || U === 27)
                        Mf(w) || p.push(w.stateNode);
                    else
                        for (w = w.child; w !== null; )
                            h.push(w),
                            w = w.sibling
                }
                return p
            }
            function Wi() {
                if ((Zn & 2) !== 0 && Vn !== 0)
                    return Vn & -Vn;
                if (pn.T !== null) {
                    var h = Ka;
                    return h !== 0 ? h : we()
                }
                return j_()
            }
            function m0() {
                is === 0 && (is = (Vn & 536870912) === 0 || Yn ? I() : 536870912);
                var h = Qa.current;
                return h !== null && (h.flags |= 32),
                is
            }
            function xr(h, p, x) {
                (h === oi && hi === 2 || h.cancelPendingCommit !== null) && (Nr(h, 0),
                wa(h, Vn, is, !1)),
                Y(h, x),
                ((Zn & 2) === 0 || h !== oi) && (h === oi && ((Zn & 2) === 0 && (Il |= x),
                vi === 4 && wa(h, Vn, is, !1)),
                Ve(h))
            }
            function hu(h, p, x) {
                if ((Zn & 6) !== 0)
                    throw Error(i(327));
                var w = !x && (p & 60) === 0 && (p & h.expiredLanes) === 0 || L(h, p)
                  , U = w ? v0(h, p) : Lp(h, p, !0)
                  , F = w;
                do {
                    if (U === 0) {
                        ts && !w && wa(h, p, 0, !1);
                        break
                    } else if (U === 6)
                        wa(h, p, 0, !zs);
                    else {
                        if (x = h.current.alternate,
                        F && !hf(x)) {
                            U = Lp(h, p, !1),
                            F = !1;
                            continue
                        }
                        if (U === 2) {
                            if (F = p,
                            h.errorRecoveryDisabledLanes & F)
                                var ie = 0;
                            else
                                ie = h.pendingLanes & -536870913,
                                ie = ie !== 0 ? ie : ie & 536870912 ? 536870912 : 0;
                            if (ie !== 0) {
                                p = ie;
                                e: {
                                    var Me = h;
                                    U = Oc;
                                    var Ie = Lr && Me.current.memoizedState.isDehydrated;
                                    if (Ie && (Nr(Me, ie).flags |= 256),
                                    ie = Lp(Me, ie, !1),
                                    ie !== 2) {
                                        if (dr && !Ie) {
                                            Me.errorRecoveryDisabledLanes |= F,
                                            Il |= F,
                                            U = 4;
                                            break e
                                        }
                                        F = Vi,
                                        Vi = U,
                                        F !== null && Xh(F)
                                    }
                                    U = ie
                                }
                                if (F = !1,
                                U !== 2)
                                    continue
                            }
                        }
                        if (U === 1) {
                            Nr(h, 0),
                            wa(h, p, 0, !0);
                            break
                        }
                        e: {
                            switch (w = h,
                            U) {
                            case 0:
                            case 1:
                                throw Error(i(345));
                            case 4:
                                if ((p & 4194176) === p) {
                                    wa(w, p, is, !zs);
                                    break e
                                }
                                break;
                            case 2:
                                Vi = null;
                                break;
                            case 3:
                            case 5:
                                break;
                            default:
                                throw Error(i(329))
                            }
                            if (w.finishedWork = x,
                            w.finishedLanes = p,
                            (p & 62914560) === p && (F = fa + 300 - Us(),
                            10 < F)) {
                                if (wa(w, p, is, !zs),
                                O(w, 0) !== 0)
                                    break e;
                                w.timeoutHandle = ar(Np.bind(null, w, x, Vi, dd, um, p, is, Il, Xo, zs, 2, -0, 0), F);
                                break e
                            }
                            Np(w, x, Vi, dd, um, p, is, Il, Xo, zs, 0, -0, 0)
                        }
                    }
                    break
                } while (!0);
                Ve(h)
            }
            function Xh(h) {
                Vi === null ? Vi = h : Vi.push.apply(Vi, h)
            }
            function Np(h, p, x, w, U, F, ie, Me, Ie, ht, Dt, Ft, jt) {
                var Tn = p.subtreeFlags;
                if ((Tn & 8192 || (Tn & 16785408) === 16785408) && (C0(),
                Up(p),
                p = sr(),
                p !== null)) {
                    h.cancelPendingCommit = p(pu.bind(null, h, x, w, U, ie, Me, Ie, 1, Ft, jt)),
                    wa(h, F, ie, !ht);
                    return
                }
                pu(h, x, w, U, ie, Me, Ie, Dt, Ft, jt)
            }
            function hf(h) {
                for (var p = h; ; ) {
                    var x = p.tag;
                    if ((x === 0 || x === 11 || x === 15) && p.flags & 16384 && (x = p.updateQueue,
                    x !== null && (x = x.stores,
                    x !== null)))
                        for (var w = 0; w < x.length; w++) {
                            var U = x[w]
                              , F = U.getSnapshot;
                            U = U.value;
                            try {
                                if (!Ca(F(), U))
                                    return !1
                            } catch {
                                return !1
                            }
                        }
                    if (x = p.child,
                    p.subtreeFlags & 16384 && x !== null)
                        x.return = p,
                        p = x;
                    else {
                        if (p === h)
                            break;
                        for (; p.sibling === null; ) {
                            if (p.return === null || p.return === h)
                                return !0;
                            p = p.return
                        }
                        p.sibling.return = p.return,
                        p = p.sibling
                    }
                }
                return !0
            }
            function wa(h, p, x, w) {
                p &= ~hd,
                p &= ~Il,
                h.suspendedLanes |= p,
                h.pingedLanes &= ~p,
                w && (h.warmLanes |= p),
                w = h.expirationTimes;
                for (var U = p; 0 < U; ) {
                    var F = 31 - ua(U)
                      , ie = 1 << F;
                    w[F] = -1,
                    U &= ~ie
                }
                x !== 0 && K(h, x, p)
            }
            function jh() {
                return (Zn & 6) === 0 ? (De(0),
                !1) : !0
            }
            function df() {
                if (on !== null) {
                    if (hi === 0)
                        var h = on.return;
                    else
                        h = on,
                        $a = lo = null,
                        G(h),
                        wu = null,
                        Au = 0,
                        h = on;
                    for (; h !== null; )
                        P_(h.alternate, h),
                        h = h.return;
                    on = null
                }
            }
            function Nr(h, p) {
                h.finishedWork = null,
                h.finishedLanes = 0;
                var x = h.timeoutHandle;
                x !== yu && (h.timeoutHandle = yu,
                Gp(x)),
                x = h.cancelPendingCommit,
                x !== null && (h.cancelPendingCommit = null,
                x()),
                df(),
                oi = h,
                on = x = As(h.current, null),
                Vn = p,
                hi = 0,
                jr = null,
                zs = !1,
                ts = L(h, p),
                dr = !1,
                Xo = is = hd = Il = ns = vi = 0,
                Vi = Oc = null,
                um = !1,
                (p & 8) !== 0 && (p |= p & 32);
                var w = h.entangledLanes;
                if (w !== 0)
                    for (h = h.entanglements,
                    w &= p; 0 < w; ) {
                        var U = 31 - ua(w)
                          , F = 1 << U;
                        p |= h[U],
                        w &= ~F
                    }
                return Wr = p,
                Le(),
                x
            }
            function Xa(h, p) {
                Dn = null,
                pn.H = Fi,
                p === Uf ? (p = wt(),
                hi = 3) : p === cd ? (p = wt(),
                hi = 4) : hi = p === om ? 8 : p !== null && typeof p == "object" && typeof p.then == "function" ? 6 : 1,
                jr = p,
                on === null && (vi = 1,
                Ms(h, se(p, h.current)))
            }
            function du() {
                var h = Qa.current;
                return h === null ? !0 : (Vn & 4194176) === Vn ? mi === null : (Vn & 62914560) === Vn || (Vn & 536870912) !== 0 ? h === mi : !1
            }
            function Uo() {
                var h = pn.H;
                return pn.H = Fi,
                h === null ? Fi : h
            }
            function Oo() {
                var h = pn.A;
                return pn.A = Lf,
                h
            }
            function El() {
                vi = 4,
                zs || (Vn & 4194176) !== Vn && Qa.current !== null || (ts = !0),
                (ns & 134217727) === 0 && (Il & 134217727) === 0 || oi === null || wa(oi, Vn, is, !1)
            }
            function Lp(h, p, x) {
                var w = Zn;
                Zn |= 2;
                var U = Uo()
                  , F = Oo();
                (oi !== h || Vn !== p) && (dd = null,
                Nr(h, p)),
                p = !1;
                var ie = vi;
                e: do
                    try {
                        if (hi !== 0 && on !== null) {
                            var Me = on
                              , Ie = jr;
                            switch (hi) {
                            case 8:
                                df(),
                                ie = 6;
                                break e;
                            case 3:
                            case 2:
                            case 6:
                                Qa.current === null && (p = !0);
                                var ht = hi;
                                if (hi = 0,
                                jr = null,
                                ws(h, Me, Ie, ht),
                                x && ts) {
                                    ie = 0;
                                    break e
                                }
                                break;
                            default:
                                ht = hi,
                                hi = 0,
                                jr = null,
                                ws(h, Me, Ie, ht)
                            }
                        }
                        g0(),
                        ie = vi;
                        break
                    } catch (Dt) {
                        Xa(h, Dt)
                    }
                while (!0);
                return p && h.shellSuspendCounter++,
                $a = lo = null,
                Zn = w,
                pn.H = U,
                pn.A = F,
                on === null && (oi = null,
                Vn = 0,
                Le()),
                ie
            }
            function g0() {
                for (; on !== null; )
                    Li(on)
            }
            function v0(h, p) {
                var x = Zn;
                Zn |= 2;
                var w = Uo()
                  , U = Oo();
                oi !== h || Vn !== p ? (dd = null,
                Bf = Us() + 500,
                Nr(h, p)) : ts = L(h, p);
                e: do
                    try {
                        if (hi !== 0 && on !== null) {
                            p = on;
                            var F = jr;
                            t: switch (hi) {
                            case 1:
                                hi = 0,
                                jr = null,
                                ws(h, p, F, 1);
                                break;
                            case 2:
                                if (Ct(F)) {
                                    hi = 0,
                                    jr = null,
                                    $n(p);
                                    break
                                }
                                p = function() {
                                    hi === 2 && oi === h && (hi = 7),
                                    Ve(h)
                                }
                                ,
                                F.then(p, p);
                                break e;
                            case 3:
                                hi = 7;
                                break e;
                            case 4:
                                hi = 5;
                                break e;
                            case 7:
                                Ct(F) ? (hi = 0,
                                jr = null,
                                $n(p)) : (hi = 0,
                                jr = null,
                                ws(h, p, F, 7));
                                break;
                            case 5:
                                var ie = null;
                                switch (on.tag) {
                                case 26:
                                    ie = on.memoizedState;
                                case 5:
                                case 27:
                                    var Me = on
                                      , Ie = Me.type
                                      , ht = Me.pendingProps;
                                    if (ie ? yc(ie) : Xp(Ie, ht)) {
                                        hi = 0,
                                        jr = null;
                                        var Dt = Me.sibling;
                                        if (Dt !== null)
                                            on = Dt;
                                        else {
                                            var Ft = Me.return;
                                            Ft !== null ? (on = Ft,
                                            ja(Ft)) : on = null
                                        }
                                        break t
                                    }
                                }
                                hi = 0,
                                jr = null,
                                ws(h, p, F, 5);
                                break;
                            case 6:
                                hi = 0,
                                jr = null,
                                ws(h, p, F, 6);
                                break;
                            case 8:
                                df(),
                                vi = 6;
                                break e;
                            default:
                                throw Error(i(462))
                            }
                        }
                        sa();
                        break
                    } catch (jt) {
                        Xa(h, jt)
                    }
                while (!0);
                return $a = lo = null,
                pn.H = w,
                pn.A = U,
                Zn = x,
                on !== null ? 0 : (oi = null,
                Vn = 0,
                Le(),
                vi)
            }
            function sa() {
                for (; on !== null && !E1(); )
                    Li(on)
            }
            function Li(h) {
                var p = O_(h.alternate, h, Wr);
                h.memoizedProps = h.pendingProps,
                p === null ? ja(h) : on = p
            }
            function $n(h) {
                var p = h
                  , x = p.alternate;
                switch (p.tag) {
                case 15:
                case 0:
                    p = Dh(x, p, p.pendingProps, p.type, void 0, Vn);
                    break;
                case 11:
                    p = Dh(x, p, p.pendingProps, p.type.render, p.ref, Vn);
                    break;
                case 5:
                    G(p);
                default:
                    P_(x, p),
                    p = on = Yh(p, Wr),
                    p = O_(x, p, Wr)
                }
                h.memoizedProps = h.pendingProps,
                p === null ? ja(h) : on = p
            }
            function ws(h, p, x, w) {
                $a = lo = null,
                G(p),
                wu = null,
                Au = 0;
                var U = p.return;
                try {
                    if (Qg(h, U, p, x, Vn)) {
                        vi = 1,
                        Ms(h, se(x, h.current)),
                        on = null;
                        return
                    }
                } catch (F) {
                    if (U !== null)
                        throw on = U,
                        F;
                    vi = 1,
                    Ms(h, se(x, h.current)),
                    on = null;
                    return
                }
                p.flags & 32768 ? (Yn || w === 1 ? h = !0 : ts || (Vn & 536870912) !== 0 ? h = !1 : (zs = h = !0,
                (w === 2 || w === 3 || w === 6) && (w = Qa.current,
                w !== null && w.tag === 13 && (w.flags |= 16384))),
                Pp(p, h)) : ja(p)
            }
            function ja(h) {
                var p = h;
                do {
                    if ((p.flags & 32768) !== 0) {
                        Pp(p, zs);
                        return
                    }
                    h = p.return;
                    var x = L_(p.alternate, p, Wr);
                    if (x !== null) {
                        on = x;
                        return
                    }
                    if (p = p.sibling,
                    p !== null) {
                        on = p;
                        return
                    }
                    on = p = h
                } while (p !== null);
                vi === 0 && (vi = 5)
            }
            function Pp(h, p) {
                do {
                    var x = GM(h.alternate, h);
                    if (x !== null) {
                        x.flags &= 32767,
                        on = x;
                        return
                    }
                    if (x = h.return,
                    x !== null && (x.flags |= 32768,
                    x.subtreeFlags = 0,
                    x.deletions = null),
                    !p && (h = h.sibling,
                    h !== null)) {
                        on = h;
                        return
                    }
                    on = h = x
                } while (h !== null);
                vi = 6,
                on = null
            }
            function pu(h, p, x, w, U, F, ie, Me, Ie, ht) {
                var Dt = pn.T
                  , Ft = Ul();
                try {
                    Xr(2),
                    pn.T = null,
                    F_(h, p, x, w, Ft, U, F, ie, Me, Ie, ht)
                } finally {
                    pn.T = Dt,
                    Xr(Ft)
                }
            }
            function F_(h, p, x, w, U, F, ie, Me) {
                do
                    eo();
                while (jo !== null);
                if ((Zn & 6) !== 0)
                    throw Error(i(327));
                var Ie = h.finishedWork;
                if (w = h.finishedLanes,
                Ie === null)
                    return null;
                if (h.finishedWork = null,
                h.finishedLanes = 0,
                Ie === h.current)
                    throw Error(i(177));
                h.callbackNode = null,
                h.callbackPriority = 0,
                h.cancelPendingCommit = null;
                var ht = Ie.lanes | Ie.childLanes;
                if (ht |= so,
                V(h, w, ht, F, ie, Me),
                h === oi && (on = oi = null,
                Vn = 0),
                (Ie.subtreeFlags & 10256) === 0 && (Ie.flags & 10256) === 0 || co || (co = !0,
                Ou = ht,
                cm = x,
                Al(im, function() {
                    return eo(),
                    null
                })),
                x = (Ie.flags & 15990) !== 0,
                (Ie.subtreeFlags & 15990) !== 0 || x ? (x = pn.T,
                pn.T = null,
                F = Ul(),
                Xr(2),
                ie = Zn,
                Zn |= 4,
                Hh(h, Ie),
                f0(Ie, h),
                G_(h.containerInfo),
                h.current = Ie,
                Cp(h, Ie.alternate, Ie),
                tm(),
                Zn = ie,
                Xr(F),
                pn.T = x) : h.current = Ie,
                co ? (co = !1,
                jo = h,
                Nc = w) : y0(h, ht),
                ht = h.pendingLanes,
                ht === 0 && (Uu = null),
                H(Ie.stateNode),
                Ve(h),
                p !== null)
                    for (U = h.onRecoverableError,
                    Ie = 0; Ie < p.length; Ie++)
                        ht = p[Ie],
                        U(ht.value, {
                            componentStack: ht.stack
                        });
                return (Nc & 3) !== 0 && eo(),
                ht = h.pendingLanes,
                (w & 4194218) !== 0 && (ht & 42) !== 0 ? h === fm ? zf++ : (zf = 0,
                fm = h) : zf = 0,
                De(0),
                null
            }
            function y0(h, p) {
                (h.pooledCacheLanes &= p) === 0 && (p = h.pooledCache,
                p != null && (h.pooledCache = null,
                Bh(p)))
            }
            function eo() {
                if (jo !== null) {
                    var h = jo
                      , p = Ou;
                    Ou = 0;
                    var x = oe(Nc)
                      , w = 32 > x ? 32 : x;
                    x = pn.T;
                    var U = Ul();
                    try {
                        if (Xr(w),
                        pn.T = null,
                        jo === null)
                            var F = !1;
                        else {
                            w = cm,
                            cm = null;
                            var ie = jo
                              , Me = Nc;
                            if (jo = null,
                            Nc = 0,
                            (Zn & 6) !== 0)
                                throw Error(i(331));
                            var Ie = Zn;
                            if (Zn |= 4,
                            Op(ie.current),
                            h0(ie, ie.current, Me, w),
                            Zn = Ie,
                            De(0, !1),
                            Aa && typeof Aa.onPostCommitFiberRoot == "function")
                                try {
                                    Aa.onPostCommitFiberRoot(Zi, ie)
                                } catch {}
                            F = !0
                        }
                        return F
                    } finally {
                        Xr(U),
                        pn.T = x,
                        y0(h, p)
                    }
                }
                return !1
            }
            function pf(h, p, x) {
                p = se(x, p),
                p = Ts(h.stateNode, p, 2),
                h = Ye(h, p, 2),
                h !== null && (Y(h, 2),
                Ve(h))
            }
            function ai(h, p, x) {
                if (h.tag === 3)
                    pf(h, h, x);
                else
                    for (; p !== null; ) {
                        if (p.tag === 3) {
                            pf(p, h, x);
                            break
                        } else if (p.tag === 1) {
                            var w = p.stateNode;
                            if (typeof p.type.getDerivedStateFromError == "function" || typeof w.componentDidCatch == "function" && (Uu === null || !Uu.has(w))) {
                                h = se(x, h),
                                x = hc(2),
                                w = Ye(p, x, 2),
                                w !== null && (kr(x, w, p, h),
                                Y(w, 2),
                                Ve(w));
                                break
                            }
                        }
                        p = p.return
                    }
            }
            function mc(h, p, x) {
                var w = h.pingCache;
                if (w === null) {
                    w = h.pingCache = new Bs;
                    var U = new Set;
                    w.set(p, U)
                } else
                    U = w.get(p),
                    U === void 0 && (U = new Set,
                    w.set(p, U));
                U.has(x) || (dr = !0,
                U.add(x),
                h = _0.bind(null, h, p, x),
                p.then(h, h))
            }
            function _0(h, p, x) {
                var w = h.pingCache;
                w !== null && w.delete(p),
                h.pingedLanes |= h.suspendedLanes & x,
                h.warmLanes &= ~x,
                oi === h && (Vn & x) === x && (vi === 4 || vi === 3 && (Vn & 62914560) === Vn && 300 > Us() - fa ? (Zn & 2) === 0 && Nr(h, 0) : hd |= x,
                Xo === Vn && (Xo = 0)),
                Ve(h)
            }
            function mu(h, p) {
                p === 0 && (p = N()),
                h = le(h, p),
                h !== null && (Y(h, p),
                Ve(h))
            }
            function wl(h) {
                var p = h.memoizedState
                  , x = 0;
                p !== null && (x = p.retryLane),
                mu(h, x)
            }
            function gu(h, p) {
                var x = 0;
                switch (h.tag) {
                case 13:
                    var w = h.stateNode
                      , U = h.memoizedState;
                    U !== null && (x = U.retryLane);
                    break;
                case 19:
                    w = h.stateNode;
                    break;
                case 22:
                    w = h.stateNode._retryCache;
                    break;
                default:
                    throw Error(i(314))
                }
                w !== null && w.delete(p),
                mu(h, x)
            }
            function Al(h, p) {
                return od(h, p)
            }
            function x0(h, p, x, w) {
                this.tag = h,
                this.key = x,
                this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
                this.index = 0,
                this.refCleanup = this.ref = null,
                this.pendingProps = p,
                this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
                this.mode = w,
                this.subtreeFlags = this.flags = 0,
                this.deletions = null,
                this.childLanes = this.lanes = 0,
                this.alternate = null
            }
            function Wh(h) {
                return h = h.prototype,
                !(!h || !h.isReactComponent)
            }
            function As(h, p) {
                var x = h.alternate;
                return x === null ? (x = t(h.tag, p, h.key, h.mode),
                x.elementType = h.elementType,
                x.type = h.type,
                x.stateNode = h.stateNode,
                x.alternate = h,
                h.alternate = x) : (x.pendingProps = p,
                x.type = h.type,
                x.flags = 0,
                x.subtreeFlags = 0,
                x.deletions = null),
                x.flags = h.flags & 31457280,
                x.childLanes = h.childLanes,
                x.lanes = h.lanes,
                x.child = h.child,
                x.memoizedProps = h.memoizedProps,
                x.memoizedState = h.memoizedState,
                x.updateQueue = h.updateQueue,
                p = h.dependencies,
                x.dependencies = p === null ? null : {
                    lanes: p.lanes,
                    firstContext: p.firstContext
                },
                x.sibling = h.sibling,
                x.index = h.index,
                x.ref = h.ref,
                x.refCleanup = h.refCleanup,
                x
            }
            function Yh(h, p) {
                h.flags &= 31457282;
                var x = h.alternate;
                return x === null ? (h.childLanes = 0,
                h.lanes = p,
                h.child = null,
                h.subtreeFlags = 0,
                h.memoizedProps = null,
                h.memoizedState = null,
                h.updateQueue = null,
                h.dependencies = null,
                h.stateNode = null) : (h.childLanes = x.childLanes,
                h.lanes = x.lanes,
                h.child = x.child,
                h.subtreeFlags = 0,
                h.deletions = null,
                h.memoizedProps = x.memoizedProps,
                h.memoizedState = x.memoizedState,
                h.updateQueue = x.updateQueue,
                h.type = x.type,
                p = x.dependencies,
                h.dependencies = p === null ? null : {
                    lanes: p.lanes,
                    firstContext: p.firstContext
                }),
                h
            }
            function No(h, p, x, w, U, F) {
                var ie = 0;
                if (w = h,
                typeof h == "function")
                    Wh(h) && (ie = 1);
                else if (typeof h == "string")
                    ie = Ya && pi ? rd(h, x, fr.current) ? 26 : Po(h) ? 27 : 5 : Ya ? rd(h, x, fr.current) ? 26 : 5 : pi && Po(h) ? 27 : 5;
                else
                    e: switch (h) {
                    case vu:
                        return Ii(x.children, U, F, p);
                    case Qh:
                        ie = 8,
                        U |= 24;
                        break;
                    case Fp:
                        return h = t(12, x, p, U | 2),
                        h.elementType = Fp,
                        h.lanes = F,
                        h;
                    case Hp:
                        return h = t(13, x, p, U),
                        h.elementType = Hp,
                        h.lanes = F,
                        h;
                    case yf:
                        return h = t(19, x, p, U),
                        h.elementType = yf,
                        h.lanes = F,
                        h;
                    case M0:
                        return qh(x, U, F, p);
                    default:
                        if (typeof h == "object" && h !== null)
                            switch (h.$$typeof) {
                            case Jh:
                            case to:
                                ie = 10;
                                break e;
                            case b0:
                                ie = 9;
                                break e;
                            case $h:
                                ie = 11;
                                break e;
                            case Vp:
                                ie = 14;
                                break e;
                            case Rs:
                                ie = 16,
                                w = null;
                                break e
                            }
                        ie = 29,
                        x = Error(i(130, h === null ? "null" : typeof h, "")),
                        w = null
                    }
                return p = t(ie, x, p, U),
                p.elementType = h,
                p.type = w,
                p.lanes = F,
                p
            }
            function Ii(h, p, x, w) {
                return h = t(7, h, w, p),
                h.lanes = x,
                h
            }
            function qh(h, p, x, w) {
                h = t(22, h, w, p),
                h.elementType = M0,
                h.lanes = x;
                var U = {
                    _visibility: 1,
                    _pendingVisibility: 1,
                    _pendingMarkers: null,
                    _retryCache: null,
                    _transitions: null,
                    _current: null,
                    detach: function() {
                        var F = U._current;
                        if (F === null)
                            throw Error(i(456));
                        if ((U._pendingVisibility & 2) === 0) {
                            var ie = le(F, 2);
                            ie !== null && (U._pendingVisibility |= 2,
                            xr(ie, F, 2))
                        }
                    },
                    attach: function() {
                        var F = U._current;
                        if (F === null)
                            throw Error(i(456));
                        if ((U._pendingVisibility & 2) !== 0) {
                            var ie = le(F, 2);
                            ie !== null && (U._pendingVisibility &= -3,
                            xr(ie, F, 2))
                        }
                    }
                };
                return h.stateNode = U,
                h
            }
            function Bp(h, p, x) {
                return h = t(6, h, null, p),
                h.lanes = x,
                h
            }
            function S0(h, p, x) {
                return p = t(4, h.children !== null ? h.children : [], h.key, p),
                p.lanes = x,
                p.stateNode = {
                    containerInfo: h.containerInfo,
                    pendingChildren: null,
                    implementation: h.implementation
                },
                p
            }
            function XM(h, p, x, w, U, F, ie, Me) {
                this.tag = 1,
                this.containerInfo = h,
                this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
                this.timeoutHandle = yu,
                this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
                this.callbackPriority = 0,
                this.expirationTimes = P(-1),
                this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
                this.entanglements = P(0),
                this.hiddenUpdates = P(null),
                this.identifierPrefix = w,
                this.onUncaughtError = U,
                this.onCaughtError = F,
                this.onRecoverableError = ie,
                this.pooledCache = null,
                this.pooledCacheLanes = 0,
                this.formState = Me,
                this.incompleteTransitions = new Map
            }
            function H_(h, p, x, w, U, F, ie, Me, Ie, ht, Dt, Ft) {
                return h = new XM(h,p,x,ie,Me,Ie,ht,Ft),
                p = 1,
                F === !0 && (p |= 24),
                F = t(3, null, null, p),
                h.current = F,
                F.stateNode = h,
                p = ou(),
                p.refCount++,
                h.pooledCache = p,
                p.refCount++,
                F.memoizedState = {
                    element: w,
                    isDehydrated: x,
                    cache: p
                },
                Mt(F),
                h
            }
            function rr(h) {
                return h ? (h = Mu,
                h) : Mu
            }
            function zp(h) {
                var p = h._reactInternals;
                if (p === void 0)
                    throw typeof h.render == "function" ? Error(i(188)) : (h = Object.keys(h).join(","),
                    Error(i(268, h)));
                return h = y(p),
                h = h !== null ? S(h) : null,
                h === null ? null : Sf(h.stateNode)
            }
            function mf(h, p, x, w, U, F) {
                U = rr(U),
                w.context === null ? w.context = U : w.pendingContext = U,
                w = je(p),
                w.payload = {
                    element: x
                },
                F = F === void 0 ? null : F,
                F !== null && (w.callback = F),
                x = Ye(h, w, p),
                x !== null && (xr(x, h, p),
                ct(x, h, p))
            }
            function gf(h, p) {
                if (h = h.memoizedState,
                h !== null && h.dehydrated !== null) {
                    var x = h.retryLane;
                    h.retryLane = x !== 0 && x < p ? x : p
                }
            }
            function Zh(h, p) {
                gf(h, p),
                (h = h.alternate) && gf(h, p)
            }
            var En = {}, vf = zg(), Wa = qQ(), Ip = Object.assign, jM = Symbol.for("react.element"), Kh = Symbol.for("react.transitional.element"), Cs = Symbol.for("react.portal"), vu = Symbol.for("react.fragment"), Qh = Symbol.for("react.strict_mode"), Fp = Symbol.for("react.profiler"), Jh = Symbol.for("react.provider"), b0 = Symbol.for("react.consumer"), to = Symbol.for("react.context"), $h = Symbol.for("react.forward_ref"), Hp = Symbol.for("react.suspense"), yf = Symbol.for("react.suspense_list"), Vp = Symbol.for("react.memo"), Rs = Symbol.for("react.lazy"), M0 = Symbol.for("react.offscreen"), V_ = Symbol.for("react.memo_cache_sentinel"), Cl = Symbol.iterator, T0 = Symbol.for("react.client.reference"), pn = vf.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Lo, Rl, gc = !1, _f = Array.isArray, E0 = e.rendererVersion, ed = e.rendererPackageName, xf = e.extraDevToolsConfig, Sf = e.getPublicInstance, k_ = e.getRootHostContext, bf = e.getChildHostContext, kp = e.prepareForCommit, G_ = e.resetAfterCommit, w0 = e.createInstance, td = e.appendInitialChild, Dl = e.finalizeInitialChildren, wn = e.shouldSetTextContent, ci = e.createTextInstance, ar = e.scheduleTimeout, Gp = e.cancelTimeout, yu = e.noTimeout, oa = e.isPrimaryRenderer;
            e.warnsIfNotActing;
            var cr = e.supportsMutation
              , Ds = e.supportsPersistence
              , Lr = e.supportsHydration
              , X_ = e.getInstanceFromNode;
            e.beforeActiveInstanceBlur,
            e.afterActiveInstanceBlur;
            var Yi = e.preparePortalMount;
            e.prepareScopeUpdate,
            e.getInstanceFromScope;
            var Xr = e.setCurrentUpdatePriority
              , Ul = e.getCurrentUpdatePriority
              , j_ = e.resolveUpdatePriority;
            e.resolveEventType,
            e.resolveEventTimeStamp;
            var W_ = e.shouldAttemptEagerTransition
              , WM = e.detachDeletedInstance;
            e.requestPostPaintCallback;
            var A0 = e.maySuspendCommit
              , Xp = e.preloadInstance
              , C0 = e.startSuspendingCommit
              , la = e.suspendInstance
              , sr = e.waitForCommitToBeReady
              , _u = e.NotPendingTransition
              , no = e.HostTransitionContext
              , jp = e.resetFormInstance;
            e.bindToConsole;
            var R0 = e.supportsMicrotasks
              , Ol = e.scheduleMicrotask
              , xu = e.supportsTestSelectors
              , D0 = e.findFiberRoot
              , U0 = e.getBoundingRect
              , Y_ = e.getTextContent
              , Mf = e.isHiddenSubtree
              , q_ = e.matchAccessibilityRole
              , Z_ = e.setFocusIfFocusable
              , K_ = e.setupIntersectionObserver
              , Q_ = e.appendChild
              , O0 = e.appendChildToContainer
              , J_ = e.commitTextUpdate
              , YM = e.commitMount
              , $_ = e.commitUpdate
              , e1 = e.insertBefore
              , t1 = e.insertInContainerBefore
              , N0 = e.removeChild
              , n1 = e.removeChildFromContainer
              , L0 = e.resetTextContent
              , i1 = e.hideInstance
              , r1 = e.hideTextInstance
              , a1 = e.unhideInstance
              , qM = e.unhideTextInstance
              , s1 = e.clearContainer
              , Tf = e.cloneInstance
              , nd = e.createContainerChildSet
              , P0 = e.appendChildToContainerChildSet
              , Wp = e.finalizeContainerChildren
              , Ef = e.replaceContainerChildren
              , B0 = e.cloneHiddenInstance
              , z0 = e.cloneHiddenTextInstance
              , Yp = e.isSuspenseInstancePending
              , qp = e.isSuspenseInstanceFallback
              , o1 = e.getSuspenseInstanceFallbackErrorDetails
              , l1 = e.registerSuspenseInstanceRetry
              , I0 = e.canHydrateFormStateMarker
              , u1 = e.isFormStateMarkerMatching
              , F0 = e.getNextHydratableSibling
              , Zp = e.getFirstHydratableChild
              , c1 = e.getFirstHydratableChildWithinContainer
              , f1 = e.getFirstHydratableChildWithinSuspenseInstance
              , ZM = e.canHydrateInstance
              , H0 = e.canHydrateTextInstance
              , h1 = e.canHydrateSuspenseInstance
              , d1 = e.hydrateInstance
              , V0 = e.hydrateTextInstance
              , p1 = e.hydrateSuspenseInstance
              , m1 = e.getNextHydratableInstanceAfterSuspenseInstance
              , KM = e.commitHydratedContainer
              , QM = e.commitHydratedSuspenseInstance
              , g1 = e.clearSuspenseBoundary
              , id = e.clearSuspenseBoundaryFromContainer
              , Kp = e.shouldDeleteUnhydratedTailInstances;
            e.diffHydratedPropsForDevWarnings,
            e.diffHydratedTextForDevWarnings,
            e.describeHydratableInstanceForDevWarnings;
            var Qp = e.validateHydratableInstance
              , v1 = e.validateHydratableTextInstance
              , Ya = e.supportsResources
              , rd = e.isHostHoistableType
              , Jp = e.getHoistableRoot
              , k0 = e.getResource
              , y1 = e.acquireResource
              , vc = e.releaseResource
              , ad = e.hydrateHoistable
              , sd = e.mountHoistable
              , wf = e.unmountHoistable
              , $p = e.createHoistableInstance
              , _1 = e.prepareToCommitHoistables
              , x1 = e.mayResourceSuspendCommit
              , yc = e.preloadResource
              , S1 = e.suspendResource
              , pi = e.supportsSingletons
              , io = e.resolveSingletonInstance
              , Su = e.clearSingleton
              , b1 = e.acquireSingletonInstance
              , bu = e.releaseSingletonInstance
              , Po = e.isHostSingletonType
              , qi = []
              , Nl = -1
              , Mu = {}
              , ua = Math.clz32 ? Math.clz32 : C
              , M1 = Math.log
              , T1 = Math.LN2
              , Bo = 128
              , _c = 4194304
              , od = Wa.unstable_scheduleCallback
              , em = Wa.unstable_cancelCallback
              , E1 = Wa.unstable_shouldYield
              , tm = Wa.unstable_requestPaint
              , Us = Wa.unstable_now
              , nm = Wa.unstable_ImmediatePriority
              , w1 = Wa.unstable_UserBlockingPriority
              , im = Wa.unstable_NormalPriority
              , JM = Wa.unstable_IdlePriority
              , A1 = Wa.log
              , Sr = Wa.unstable_setDisableYieldValue
              , Zi = null
              , Aa = null
              , Ca = typeof Object.is == "function" ? Object.is : Q
              , G0 = new WeakMap
              , xc = []
              , Sc = 0
              , bc = null
              , Af = 0
              , qa = []
              , Za = 0
              , Tu = null
              , ro = 1
              , ao = ""
              , fr = M(null)
              , Cf = M(null)
              , zo = M(null)
              , Mc = M(null)
              , Pr = null
              , Br = null
              , Yn = !1
              , Os = null
              , br = !1
              , ld = Error(i(519))
              , Ns = []
              , Tc = 0
              , so = 0
              , ud = null
              , Ll = null
              , Ec = !1
              , Si = !1
              , X0 = !1
              , Rf = 0
              , Df = null
              , wc = 0
              , Ka = 0
              , Ac = null
              , Pl = !1
              , Cc = !1
              , Io = Object.prototype.hasOwnProperty
              , Uf = Error(i(460))
              , cd = Error(i(474))
              , fd = {
                then: function() {}
            }
              , Eu = null
              , wu = null
              , Au = 0
              , Cu = Gt(!0)
              , Fo = Gt(!1)
              , bi = M(null)
              , Of = M(0)
              , Qa = M(null)
              , mi = null
              , hr = M(0)
              , Bl = 0
              , Dn = null
              , sn = null
              , qn = null
              , Ls = !1
              , Rc = !1
              , Ru = !1
              , rm = 0
              , Dc = 0
              , Mr = null
              , oo = 0
              , am = function() {
                return {
                    lastEffect: null,
                    events: null,
                    stores: null,
                    memoCache: null
                }
            }
              , Fi = {
                readContext: Dr,
                use: ne,
                useCallback: $t,
                useContext: $t,
                useEffect: $t,
                useImperativeHandle: $t,
                useLayoutEffect: $t,
                useInsertionEffect: $t,
                useMemo: $t,
                useReducer: $t,
                useRef: $t,
                useState: $t,
                useDebugValue: $t,
                useDeferredValue: $t,
                useTransition: $t,
                useSyncExternalStore: $t,
                useId: $t
            };
            Fi.useCacheRefresh = $t,
            Fi.useMemoCache = $t,
            Fi.useHostTransitionStatus = $t,
            Fi.useFormState = $t,
            Fi.useActionState = $t,
            Fi.useOptimistic = $t;
            var Du = {
                readContext: Dr,
                use: ne,
                useCallback: function(h, p) {
                    return ce().memoizedState = [h, p === void 0 ? null : p],
                    h
                },
                useContext: Dr,
                useEffect: iu,
                useImperativeHandle: function(h, p, x) {
                    x = x != null ? x.concat([h]) : null,
                    tu(4194308, 4, Qs.bind(null, p, h), x)
                },
                useLayoutEffect: function(h, p) {
                    return tu(4194308, 4, h, p)
                },
                useInsertionEffect: function(h, p) {
                    tu(4, 2, h, p)
                },
                useMemo: function(h, p) {
                    var x = ce();
                    p = p === void 0 ? null : p;
                    var w = h();
                    if (Ru) {
                        q(!0);
                        try {
                            h()
                        } finally {
                            q(!1)
                        }
                    }
                    return x.memoizedState = [w, p],
                    w
                },
                useReducer: function(h, p, x) {
                    var w = ce();
                    if (x !== void 0) {
                        var U = x(p);
                        if (Ru) {
                            q(!0);
                            try {
                                x(p)
                            } finally {
                                q(!1)
                            }
                        }
                    } else
                        U = p;
                    return w.memoizedState = w.baseState = U,
                    h = {
                        pending: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: h,
                        lastRenderedState: U
                    },
                    w.queue = h,
                    h = h.dispatch = fc.bind(null, Dn, h),
                    [w.memoizedState, h]
                },
                useRef: function(h) {
                    var p = ce();
                    return h = {
                        current: h
                    },
                    p.memoizedState = h
                },
                useState: function(h) {
                    h = Vt(h);
                    var p = h.queue
                      , x = af.bind(null, Dn, p);
                    return p.dispatch = x,
                    [h.memoizedState, x]
                },
                useDebugValue: ya,
                useDeferredValue: function(h, p) {
                    var x = ce();
                    return cl(x, h, p)
                },
                useTransition: function() {
                    var h = Vt(!1);
                    return h = fl.bind(null, Dn, h.queue, !0, !1),
                    ce().memoizedState = h,
                    [!1, h]
                },
                useSyncExternalStore: function(h, p, x) {
                    var w = Dn
                      , U = ce();
                    if (Yn) {
                        if (x === void 0)
                            throw Error(i(407));
                        x = x()
                    } else {
                        if (x = p(),
                        oi === null)
                            throw Error(i(349));
                        (Vn & 60) !== 0 || Et(w, p, x)
                    }
                    U.memoizedState = x;
                    var F = {
                        value: x,
                        getSnapshot: p
                    };
                    return U.queue = F,
                    iu(Jt.bind(null, w, F, h), [h]),
                    w.flags |= 2048,
                    Di(9, Xt.bind(null, w, F, x, p), {
                        destroy: void 0
                    }, null),
                    x
                },
                useId: function() {
                    var h = ce()
                      , p = oi.identifierPrefix;
                    if (Yn) {
                        var x = ao
                          , w = ro;
                        x = (w & ~(1 << 32 - ua(w) - 1)).toString(32) + x,
                        p = ":" + p + "R" + x,
                        x = rm++,
                        0 < x && (p += "H" + x.toString(32)),
                        p += ":"
                    } else
                        x = oo++,
                        p = ":" + p + "r" + x.toString(32) + ":";
                    return h.memoizedState = p
                },
                useCacheRefresh: function() {
                    return ce().memoizedState = cc.bind(null, Dn)
                }
            };
            Du.useMemoCache = nt,
            Du.useHostTransitionStatus = hl,
            Du.useFormState = ti,
            Du.useActionState = ti,
            Du.useOptimistic = function(h) {
                var p = ce();
                p.memoizedState = p.baseState = h;
                var x = {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: null,
                    lastRenderedState: null
                };
                return p.queue = x,
                p = pl.bind(null, Dn, !0, x),
                x.dispatch = p,
                [h, p]
            }
            ;
            var ca = {
                readContext: Dr,
                use: ne,
                useCallback: Do,
                useContext: Dr,
                useEffect: ll,
                useImperativeHandle: Js,
                useInsertionEffect: Ch,
                useLayoutEffect: Ro,
                useMemo: ul,
                useReducer: st,
                useRef: rf,
                useState: function() {
                    return st(We)
                },
                useDebugValue: ya,
                useDeferredValue: function(h, p) {
                    var x = ye();
                    return uc(x, sn.memoizedState, h, p)
                },
                useTransition: function() {
                    var h = st(We)[0]
                      , p = ye().memoizedState;
                    return [typeof h == "boolean" ? h : xe(h), p]
                },
                useSyncExternalStore: At,
                useId: dl
            };
            ca.useCacheRefresh = Xi,
            ca.useMemoCache = nt,
            ca.useHostTransitionStatus = hl,
            ca.useFormState = ri,
            ca.useActionState = ri,
            ca.useOptimistic = function(h, p) {
                var x = ye();
                return It(x, sn, h, p)
            }
            ;
            var Ja = {
                readContext: Dr,
                use: ne,
                useCallback: Do,
                useContext: Dr,
                useEffect: ll,
                useImperativeHandle: Js,
                useInsertionEffect: Ch,
                useLayoutEffect: Ro,
                useMemo: ul,
                useReducer: Tt,
                useRef: rf,
                useState: function() {
                    return Tt(We)
                },
                useDebugValue: ya,
                useDeferredValue: function(h, p) {
                    var x = ye();
                    return sn === null ? cl(x, h, p) : uc(x, sn.memoizedState, h, p)
                },
                useTransition: function() {
                    var h = Tt(We)[0]
                      , p = ye().memoizedState;
                    return [typeof h == "boolean" ? h : xe(h), p]
                },
                useSyncExternalStore: At,
                useId: dl
            };
            Ja.useCacheRefresh = Xi,
            Ja.useMemoCache = nt,
            Ja.useHostTransitionStatus = hl,
            Ja.useFormState = Ss,
            Ja.useActionState = Ss,
            Ja.useOptimistic = function(h, p) {
                var x = ye();
                return sn !== null ? It(x, sn, h, p) : (x.baseState = h,
                [h, x.queue.dispatch])
            }
            ;
            var Ho = {
                isMounted: function(h) {
                    return (h = h._reactInternals) ? g(h) === h : !1
                },
                enqueueSetState: function(h, p, x) {
                    h = h._reactInternals;
                    var w = Wi()
                      , U = je(w);
                    U.payload = p,
                    x != null && (U.callback = x),
                    p = Ye(h, U, w),
                    p !== null && (xr(p, h, w),
                    ct(p, h, w))
                },
                enqueueReplaceState: function(h, p, x) {
                    h = h._reactInternals;
                    var w = Wi()
                      , U = je(w);
                    U.tag = 1,
                    U.payload = p,
                    x != null && (U.callback = x),
                    p = Ye(h, U, w),
                    p !== null && (xr(p, h, w),
                    ct(p, h, w))
                },
                enqueueForceUpdate: function(h, p) {
                    h = h._reactInternals;
                    var x = Wi()
                      , w = je(x);
                    w.tag = 2,
                    p != null && (w.callback = p),
                    p = Ye(h, w, x),
                    p !== null && (xr(p, h, x),
                    ct(p, h, x))
                }
            }
              , sm = typeof reportError == "function" ? reportError : function(h) {
                if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                    var p = new window.ErrorEvent("error",{
                        bubbles: !0,
                        cancelable: !0,
                        message: typeof h == "object" && h !== null && typeof h.message == "string" ? String(h.message) : String(h),
                        error: h
                    });
                    if (!window.dispatchEvent(p))
                        return
                } else if (typeof process == "object" && typeof process.emit == "function") {
                    process.emit("uncaughtException", h);
                    return
                }
                console.error(h)
            }
              , om = Error(i(461))
              , gi = !1
              , lm = {
                dehydrated: null,
                treeContext: null,
                retryLane: 0
            }
              , zl = M(null)
              , lo = null
              , $a = null
              , Nf = typeof AbortController < "u" ? AbortController : function() {
                var h = []
                  , p = this.signal = {
                    aborted: !1,
                    addEventListener: function(x, w) {
                        h.push(w)
                    }
                };
                this.abort = function() {
                    p.aborted = !0,
                    h.forEach(function(x) {
                        return x()
                    })
                }
            }
              , C1 = Wa.unstable_scheduleCallback
              , R1 = Wa.unstable_NormalPriority
              , Mi = {
                $$typeof: to,
                Consumer: null,
                Provider: null,
                _currentValue: null,
                _currentValue2: null,
                _threadCount: 0
            }
              , j0 = pn.S;
            pn.S = function(h, p) {
                typeof p == "object" && p !== null && typeof p.then == "function" && Ce(h, p),
                j0 !== null && j0(h, p)
            }
            ;
            var Vo = M(null)
              , ko = !1
              , Hi = !1
              , W0 = !1
              , si = typeof WeakSet == "function" ? WeakSet : Set
              , Mn = null
              , zn = !1
              , an = null
              , Rn = !1
              , Pi = null
              , es = 8192
              , Lf = {
                getCacheForType: function(h) {
                    var p = Dr(Mi)
                      , x = p.data.get(h);
                    return x === void 0 && (x = h(),
                    p.data.set(h, x)),
                    x
                }
            }
              , Pf = 0
              , Ps = 1
              , Ai = 2
              , uo = 3
              , Go = 4;
            if (typeof Symbol == "function" && Symbol.for) {
                var Uc = Symbol.for;
                Pf = Uc("selector.component"),
                Ps = Uc("selector.has_pseudo_class"),
                Ai = Uc("selector.role"),
                uo = Uc("selector.test_id"),
                Go = Uc("selector.text")
            }
            var Bs = typeof WeakMap == "function" ? WeakMap : Map
              , Zn = 0
              , oi = null
              , on = null
              , Vn = 0
              , hi = 0
              , jr = null
              , zs = !1
              , ts = !1
              , dr = !1
              , Wr = 0
              , vi = 0
              , ns = 0
              , Il = 0
              , hd = 0
              , is = 0
              , Xo = 0
              , Oc = null
              , Vi = null
              , um = !1
              , fa = 0
              , Bf = 1 / 0
              , dd = null
              , Uu = null
              , co = !1
              , jo = null
              , Nc = 0
              , Ou = 0
              , cm = null
              , zf = 0
              , fm = null;
            return En.attemptContinuousHydration = function(h) {
                if (h.tag === 13) {
                    var p = le(h, 67108864);
                    p !== null && xr(p, h, 67108864),
                    Zh(h, 67108864)
                }
            }
            ,
            En.attemptHydrationAtCurrentPriority = function(h) {
                if (h.tag === 13) {
                    var p = Wi()
                      , x = le(h, p);
                    x !== null && xr(x, h, p),
                    Zh(h, p)
                }
            }
            ,
            En.attemptSynchronousHydration = function(h) {
                switch (h.tag) {
                case 3:
                    if (h = h.stateNode,
                    h.current.memoizedState.isDehydrated) {
                        var p = R(h.pendingLanes);
                        if (p !== 0) {
                            for (h.pendingLanes |= 2,
                            h.entangledLanes |= 2; p; ) {
                                var x = 1 << 31 - ua(p);
                                h.entanglements[1] |= x,
                                p &= ~x
                            }
                            Ve(h),
                            (Zn & 6) === 0 && (Bf = Us() + 500,
                            De(0))
                        }
                    }
                    break;
                case 13:
                    p = le(h, 2),
                    p !== null && xr(p, h, 2),
                    jh(),
                    Zh(h, 2)
                }
            }
            ,
            En.batchedUpdates = function(h, p) {
                return h(p)
            }
            ,
            En.createComponentSelector = function(h) {
                return {
                    $$typeof: Pf,
                    value: h
                }
            }
            ,
            En.createContainer = function(h, p, x, w, U, F, ie, Me, Ie, ht) {
                return H_(h, p, !1, null, x, w, F, ie, Me, Ie, ht, null)
            }
            ,
            En.createHasPseudoClassSelector = function(h) {
                return {
                    $$typeof: Ps,
                    value: h
                }
            }
            ,
            En.createHydrationContainer = function(h, p, x, w, U, F, ie, Me, Ie, ht, Dt, Ft, jt) {
                return h = H_(x, w, !0, h, U, F, Me, Ie, ht, Dt, Ft, jt),
                h.context = rr(null),
                x = h.current,
                w = Wi(),
                U = je(w),
                U.callback = p ?? null,
                Ye(x, U, w),
                h.current.lanes = w,
                Y(h, w),
                Ve(h),
                h
            }
            ,
            En.createPortal = function(h, p, x) {
                var w = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
                return {
                    $$typeof: Cs,
                    key: w == null ? null : "" + w,
                    children: h,
                    containerInfo: p,
                    implementation: x
                }
            }
            ,
            En.createRoleSelector = function(h) {
                return {
                    $$typeof: Ai,
                    value: h
                }
            }
            ,
            En.createTestNameSelector = function(h) {
                return {
                    $$typeof: uo,
                    value: h
                }
            }
            ,
            En.createTextSelector = function(h) {
                return {
                    $$typeof: Go,
                    value: h
                }
            }
            ,
            En.defaultOnCaughtError = function(h) {
                console.error(h)
            }
            ,
            En.defaultOnRecoverableError = function(h) {
                sm(h)
            }
            ,
            En.defaultOnUncaughtError = function(h) {
                sm(h)
            }
            ,
            En.deferredUpdates = function(h) {
                var p = pn.T
                  , x = Ul();
                try {
                    return Xr(32),
                    pn.T = null,
                    h()
                } finally {
                    Xr(x),
                    pn.T = p
                }
            }
            ,
            En.discreteUpdates = function(h, p, x, w, U) {
                var F = pn.T
                  , ie = Ul();
                try {
                    return Xr(2),
                    pn.T = null,
                    h(p, x, w, U)
                } finally {
                    Xr(ie),
                    pn.T = F,
                    Zn === 0 && (Bf = Us() + 500)
                }
            }
            ,
            En.findAllNodes = Gh,
            En.findBoundingRects = function(h, p) {
                if (!xu)
                    throw Error(i(363));
                p = Gh(h, p),
                h = [];
                for (var x = 0; x < p.length; x++)
                    h.push(U0(p[x]));
                for (p = h.length - 1; 0 < p; p--) {
                    x = h[p];
                    for (var w = x.x, U = w + x.width, F = x.y, ie = F + x.height, Me = p - 1; 0 <= Me; Me--)
                        if (p !== Me) {
                            var Ie = h[Me]
                              , ht = Ie.x
                              , Dt = ht + Ie.width
                              , Ft = Ie.y
                              , jt = Ft + Ie.height;
                            if (w >= ht && F >= Ft && U <= Dt && ie <= jt) {
                                h.splice(p, 1);
                                break
                            } else if (w !== ht || x.width !== Ie.width || jt < F || Ft > ie) {
                                if (!(F !== Ft || x.height !== Ie.height || Dt < w || ht > U)) {
                                    ht > w && (Ie.width += ht - w,
                                    Ie.x = w),
                                    Dt < U && (Ie.width = U - ht),
                                    h.splice(p, 1);
                                    break
                                }
                            } else {
                                Ft > F && (Ie.height += Ft - F,
                                Ie.y = F),
                                jt < ie && (Ie.height = ie - Ft),
                                h.splice(p, 1);
                                break
                            }
                        }
                }
                return h
            }
            ,
            En.findHostInstance = zp,
            En.findHostInstanceWithNoPortals = function(h) {
                return h = y(h),
                h = h !== null ? T(h) : null,
                h === null ? null : Sf(h.stateNode)
            }
            ,
            En.findHostInstanceWithWarning = function(h) {
                return zp(h)
            }
            ,
            En.flushPassiveEffects = eo,
            En.flushSyncFromReconciler = function(h) {
                var p = Zn;
                Zn |= 1;
                var x = pn.T
                  , w = Ul();
                try {
                    if (Xr(2),
                    pn.T = null,
                    h)
                        return h()
                } finally {
                    Xr(w),
                    pn.T = x,
                    Zn = p,
                    (Zn & 6) === 0 && De(0)
                }
            }
            ,
            En.flushSyncWork = jh,
            En.focusWithin = function(h, p) {
                if (!xu)
                    throw Error(i(363));
                for (h = ff(h),
                p = Ea(h, p),
                p = Array.from(p),
                h = 0; h < p.length; ) {
                    var x = p[h++]
                      , w = x.tag;
                    if (!Mf(x)) {
                        if ((w === 5 || w === 26 || w === 27) && Z_(x.stateNode))
                            return !0;
                        for (x = x.child; x !== null; )
                            p.push(x),
                            x = x.sibling
                    }
                }
                return !1
            }
            ,
            En.getFindAllNodesFailureDescription = function(h, p) {
                if (!xu)
                    throw Error(i(363));
                var x = 0
                  , w = [];
                h = [ff(h), 0];
                for (var U = 0; U < h.length; ) {
                    var F = h[U++]
                      , ie = F.tag
                      , Me = h[U++]
                      , Ie = p[Me];
                    if ((ie !== 5 && ie !== 26 && ie !== 27 || !Mf(F)) && (fu(F, Ie) && (w.push(p0(Ie)),
                    Me++,
                    Me > x && (x = Me)),
                    Me < p.length))
                        for (F = F.child; F !== null; )
                            h.push(F, Me),
                            F = F.sibling
                }
                if (x < p.length) {
                    for (h = []; x < p.length; x++)
                        h.push(p0(p[x]));
                    return `findAllNodes was able to match part of the selector:
  ` + (w.join(" > ") + `

No matching component was found for:
  `) + h.join(" > ")
                }
                return null
            }
            ,
            En.getPublicRootInstance = function(h) {
                if (h = h.current,
                !h.child)
                    return null;
                switch (h.child.tag) {
                case 27:
                case 5:
                    return Sf(h.child.stateNode);
                default:
                    return h.child.stateNode
                }
            }
            ,
            En.injectIntoDevTools = function() {
                var h = {
                    bundleType: 0,
                    version: E0,
                    rendererPackageName: ed,
                    currentDispatcherRef: pn,
                    findFiberByHostInstance: X_,
                    reconcilerVersion: "19.0.0"
                };
                if (xf !== null && (h.rendererConfig = xf),
                typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
                    h = !1;
                else {
                    var p = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                    if (p.isDisabled || !p.supportsFiber)
                        h = !0;
                    else {
                        try {
                            Zi = p.inject(h),
                            Aa = p
                        } catch {}
                        h = !!p.checkDCE
                    }
                }
                return h
            }
            ,
            En.isAlreadyRendering = function() {
                return !1
            }
            ,
            En.observeVisibleRects = function(h, p, x, w) {
                if (!xu)
                    throw Error(i(363));
                h = Gh(h, p);
                var U = K_(h, x, w).disconnect;
                return {
                    disconnect: function() {
                        U()
                    }
                }
            }
            ,
            En.shouldError = function() {
                return null
            }
            ,
            En.shouldSuspend = function() {
                return !1
            }
            ,
            En.startHostTransition = function(h, p, x, w) {
                if (h.tag !== 5)
                    throw Error(i(476));
                var U = ia(h).queue;
                fl(h, U, p, _u, x === null ? n : function() {
                    var F = ia(h).next.queue;
                    return bs(h, F, {}, Wi()),
                    x(w)
                }
                )
            }
            ,
            En.updateContainer = function(h, p, x, w) {
                var U = p.current
                  , F = Wi();
                return mf(U, F, h, p, x, w),
                F
            }
            ,
            En.updateContainerSync = function(h, p, x, w) {
                return p.tag === 0 && eo(),
                mf(p.current, 2, h, p, x, w),
                2
            }
            ,
            En
        }
        ,
        r.exports.default = r.exports,
        Object.defineProperty(r.exports, "__esModule", {
            value: !0
        })
    }(qT)),
    qT.exports
}
var PO;
function KQ() {
    return PO || (PO = 1,
    YT.exports = ZQ()),
    YT.exports
}
var QQ = KQ();
const JQ = jb(QQ);
var QT = {
    exports: {}
}
  , JT = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var BO;
function $Q() {
    return BO || (BO = 1,
    function(r) {
        function e(H, q) {
            var Q = H.length;
            H.push(q);
            e: for (; 0 < Q; ) {
                var se = Q - 1 >>> 1
                  , B = H[se];
                if (0 < i(B, q))
                    H[se] = q,
                    H[Q] = B,
                    Q = se;
                else
                    break e
            }
        }
        function t(H) {
            return H.length === 0 ? null : H[0]
        }
        function n(H) {
            if (H.length === 0)
                return null;
            var q = H[0]
              , Q = H.pop();
            if (Q !== q) {
                H[0] = Q;
                e: for (var se = 0, B = H.length, W = B >>> 1; se < W; ) {
                    var te = 2 * (se + 1) - 1
                      , fe = H[te]
                      , pe = te + 1
                      , _e = H[pe];
                    if (0 > i(fe, Q))
                        pe < B && 0 > i(_e, fe) ? (H[se] = _e,
                        H[pe] = Q,
                        se = pe) : (H[se] = fe,
                        H[te] = Q,
                        se = te);
                    else if (pe < B && 0 > i(_e, Q))
                        H[se] = _e,
                        H[pe] = Q,
                        se = pe;
                    else
                        break e
                }
            }
            return q
        }
        function i(H, q) {
            var Q = H.sortIndex - q.sortIndex;
            return Q !== 0 ? Q : H.id - q.id
        }
        if (r.unstable_now = void 0,
        typeof performance == "object" && typeof performance.now == "function") {
            var a = performance;
            r.unstable_now = function() {
                return a.now()
            }
        } else {
            var s = Date
              , l = s.now();
            r.unstable_now = function() {
                return s.now() - l
            }
        }
        var u = []
          , f = []
          , d = 1
          , g = null
          , v = 3
          , y = !1
          , S = !1
          , T = !1
          , M = typeof setTimeout == "function" ? setTimeout : null
          , b = typeof clearTimeout == "function" ? clearTimeout : null
          , A = typeof setImmediate < "u" ? setImmediate : null;
        function C(H) {
            for (var q = t(f); q !== null; ) {
                if (q.callback === null)
                    n(f);
                else if (q.startTime <= H)
                    n(f),
                    q.sortIndex = q.expirationTime,
                    e(u, q);
                else
                    break;
                q = t(f)
            }
        }
        function R(H) {
            if (T = !1,
            C(H),
            !S)
                if (t(u) !== null)
                    S = !0,
                    Z();
                else {
                    var q = t(f);
                    q !== null && oe(R, q.startTime - H)
                }
        }
        var O = !1
          , L = -1
          , z = 5
          , I = -1;
        function N() {
            return !(r.unstable_now() - I < z)
        }
        function P() {
            if (O) {
                var H = r.unstable_now();
                I = H;
                var q = !0;
                try {
                    e: {
                        S = !1,
                        T && (T = !1,
                        b(L),
                        L = -1),
                        y = !0;
                        var Q = v;
                        try {
                            t: {
                                for (C(H),
                                g = t(u); g !== null && !(g.expirationTime > H && N()); ) {
                                    var se = g.callback;
                                    if (typeof se == "function") {
                                        g.callback = null,
                                        v = g.priorityLevel;
                                        var B = se(g.expirationTime <= H);
                                        if (H = r.unstable_now(),
                                        typeof B == "function") {
                                            g.callback = B,
                                            C(H),
                                            q = !0;
                                            break t
                                        }
                                        g === t(u) && n(u),
                                        C(H)
                                    } else
                                        n(u);
                                    g = t(u)
                                }
                                if (g !== null)
                                    q = !0;
                                else {
                                    var W = t(f);
                                    W !== null && oe(R, W.startTime - H),
                                    q = !1
                                }
                            }
                            break e
                        } finally {
                            g = null,
                            v = Q,
                            y = !1
                        }
                        q = void 0
                    }
                } finally {
                    q ? Y() : O = !1
                }
            }
        }
        var Y;
        if (typeof A == "function")
            Y = function() {
                A(P)
            }
            ;
        else if (typeof MessageChannel < "u") {
            var V = new MessageChannel
              , K = V.port2;
            V.port1.onmessage = P,
            Y = function() {
                K.postMessage(null)
            }
        } else
            Y = function() {
                M(P, 0)
            }
            ;
        function Z() {
            O || (O = !0,
            Y())
        }
        function oe(H, q) {
            L = M(function() {
                H(r.unstable_now())
            }, q)
        }
        r.unstable_IdlePriority = 5,
        r.unstable_ImmediatePriority = 1,
        r.unstable_LowPriority = 4,
        r.unstable_NormalPriority = 3,
        r.unstable_Profiling = null,
        r.unstable_UserBlockingPriority = 2,
        r.unstable_cancelCallback = function(H) {
            H.callback = null
        }
        ,
        r.unstable_continueExecution = function() {
            S || y || (S = !0,
            Z())
        }
        ,
        r.unstable_forceFrameRate = function(H) {
            0 > H || 125 < H ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : z = 0 < H ? Math.floor(1e3 / H) : 5
        }
        ,
        r.unstable_getCurrentPriorityLevel = function() {
            return v
        }
        ,
        r.unstable_getFirstCallbackNode = function() {
            return t(u)
        }
        ,
        r.unstable_next = function(H) {
            switch (v) {
            case 1:
            case 2:
            case 3:
                var q = 3;
                break;
            default:
                q = v
            }
            var Q = v;
            v = q;
            try {
                return H()
            } finally {
                v = Q
            }
        }
        ,
        r.unstable_pauseExecution = function() {}
        ,
        r.unstable_requestPaint = function() {}
        ,
        r.unstable_runWithPriority = function(H, q) {
            switch (H) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                H = 3
            }
            var Q = v;
            v = H;
            try {
                return q()
            } finally {
                v = Q
            }
        }
        ,
        r.unstable_scheduleCallback = function(H, q, Q) {
            var se = r.unstable_now();
            switch (typeof Q == "object" && Q !== null ? (Q = Q.delay,
            Q = typeof Q == "number" && 0 < Q ? se + Q : se) : Q = se,
            H) {
            case 1:
                var B = -1;
                break;
            case 2:
                B = 250;
                break;
            case 5:
                B = 1073741823;
                break;
            case 4:
                B = 1e4;
                break;
            default:
                B = 5e3
            }
            return B = Q + B,
            H = {
                id: d++,
                callback: q,
                priorityLevel: H,
                startTime: Q,
                expirationTime: B,
                sortIndex: -1
            },
            Q > se ? (H.sortIndex = Q,
            e(f, H),
            t(u) === null && H === t(f) && (T ? (b(L),
            L = -1) : T = !0,
            oe(R, Q - se))) : (H.sortIndex = B,
            e(u, H),
            S || y || (S = !0,
            Z())),
            H
        }
        ,
        r.unstable_shouldYield = N,
        r.unstable_wrapCallback = function(H) {
            var q = v;
            return function() {
                var Q = v;
                v = q;
                try {
                    return H.apply(this, arguments)
                } finally {
                    v = Q
                }
            }
        }
    }(JT)),
    JT
}
var zO;
function eJ() {
    return zO || (zO = 1,
    QT.exports = $Q()),
    QT.exports
}
var IO = eJ();
function IC(r, e, t) {
    if (!r)
        return;
    if (t(r) === !0)
        return r;
    let n = e ? r.return : r.child;
    for (; n; ) {
        const i = IC(n, e, t);
        if (i)
            return i;
        n = e ? null : n.sibling
    }
}
function Uz(r) {
    try {
        return Object.defineProperties(r, {
            _currentRenderer: {
                get() {
                    return null
                },
                set() {}
            },
            _currentRenderer2: {
                get() {
                    return null
                },
                set() {}
            }
        })
    } catch {
        return r
    }
}
const FC = Uz(de.createContext(null));
class Oz extends de.Component {
    render() {
        return de.createElement(FC.Provider, {
            value: this._reactInternals
        }, this.props.children)
    }
}
function Nz() {
    const r = de.useContext(FC);
    if (r === null)
        throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
    const e = de.useId();
    return de.useMemo( () => {
        for (const t of [r, r == null ? void 0 : r.alternate]) {
            if (!t)
                continue;
            const n = IC(t, !1, i => {
                let a = i.memoizedState;
                for (; a; ) {
                    if (a.memoizedState === e)
                        return !0;
                    a = a.next
                }
            }
            );
            if (n)
                return n
        }
    }
    , [r, e])
}
const tJ = Symbol.for("react.context")
  , nJ = r => r !== null && typeof r == "object" && "$$typeof"in r && r.$$typeof === tJ;
function iJ() {
    const r = Nz()
      , [e] = de.useState( () => new Map);
    e.clear();
    let t = r;
    for (; t; ) {
        const n = t.type;
        nJ(n) && n !== FC && !e.has(n) && e.set(n, de.use(Uz(n))),
        t = t.return
    }
    return e
}
function rJ() {
    const r = iJ();
    return de.useMemo( () => Array.from(r.keys()).reduce( (e, t) => n => de.createElement(e, null, de.createElement(t.Provider, {
        ...n,
        value: r.get(t)
    })), e => de.createElement(Oz, {
        ...e
    })), [r])
}
function Lz(r) {
    let e = r.root;
    for (; e.getState().previousRoot; )
        e = e.getState().previousRoot;
    return e
}
const Pz = r => r && r.isOrthographicCamera
  , aJ = r => r && r.hasOwnProperty("current")
  , sJ = r => r != null && (typeof r == "string" || typeof r == "number" || r.isColor)
  , M_ = ( (r, e) => typeof window < "u" && (((r = window.document) == null ? void 0 : r.createElement) || ((e = window.navigator) == null ? void 0 : e.product) === "ReactNative"))() ? de.useLayoutEffect : de.useEffect;
function HC(r) {
    const e = de.useRef(r);
    return M_( () => void (e.current = r), [r]),
    e
}
function oJ() {
    const r = Nz()
      , e = rJ();
    return de.useMemo( () => ({children: t}) => {
        const i = !!IC(r, !0, a => a.type === de.StrictMode) ? de.StrictMode : de.Fragment;
        return ae.jsx(i, {
            children: ae.jsx(e, {
                children: t
            })
        })
    }
    , [r, e])
}
function lJ({set: r}) {
    return M_( () => (r(new Promise( () => null)),
    () => r(!1)), [r]),
    null
}
const uJ = (r => (r = class extends de.Component {
    constructor(...t) {
        super(...t),
        this.state = {
            error: !1
        }
    }
    componentDidCatch(t) {
        this.props.set(t)
    }
    render() {
        return this.state.error ? null : this.props.children
    }
}
,
r.getDerivedStateFromError = () => ({
    error: !0
}),
r))();
function Bz(r) {
    var e;
    const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
    return Array.isArray(r) ? Math.min(Math.max(r[0], t), r[1]) : r
}
function Fm(r) {
    var e;
    return (e = r.__r3f) == null ? void 0 : e.root.getState()
}
const ki = {
    obj: r => r === Object(r) && !ki.arr(r) && typeof r != "function",
    fun: r => typeof r == "function",
    str: r => typeof r == "string",
    num: r => typeof r == "number",
    boo: r => typeof r == "boolean",
    und: r => r === void 0,
    nul: r => r === null,
    arr: r => Array.isArray(r),
    equ(r, e, {arrays: t="shallow", objects: n="reference", strict: i=!0}={}) {
        if (typeof r != typeof e || !!r != !!e)
            return !1;
        if (ki.str(r) || ki.num(r) || ki.boo(r))
            return r === e;
        const a = ki.obj(r);
        if (a && n === "reference")
            return r === e;
        const s = ki.arr(r);
        if (s && t === "reference")
            return r === e;
        if ((s || a) && r === e)
            return !0;
        let l;
        for (l in r)
            if (!(l in e))
                return !1;
        if (a && t === "shallow" && n === "shallow") {
            for (l in i ? e : r)
                if (!ki.equ(r[l], e[l], {
                    strict: i,
                    objects: "reference"
                }))
                    return !1
        } else
            for (l in i ? e : r)
                if (r[l] !== e[l])
                    return !1;
        if (ki.und(l)) {
            if (s && r.length === 0 && e.length === 0 || a && Object.keys(r).length === 0 && Object.keys(e).length === 0)
                return !0;
            if (r !== e)
                return !1
        }
        return !0
    }
};
function cJ(r) {
    const e = {
        nodes: {},
        materials: {},
        meshes: {}
    };
    return r && r.traverse(t => {
        t.name && (e.nodes[t.name] = t),
        t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material),
        t.isMesh && !e.meshes[t.name] && (e.meshes[t.name] = t)
    }
    ),
    e
}
function fJ(r) {
    r.type !== "Scene" && (r.dispose == null || r.dispose());
    for (const e in r) {
        const t = r[e];
        (t == null ? void 0 : t.type) !== "Scene" && (t == null || t.dispose == null || t.dispose())
    }
}
const zz = ["children", "key", "ref"];
function hJ(r) {
    const e = {};
    for (const t in r)
        zz.includes(t) || (e[t] = r[t]);
    return e
}
function Nb(r, e, t, n) {
    const i = r;
    let a = i == null ? void 0 : i.__r3f;
    return a || (a = {
        root: e,
        type: t,
        parent: null,
        children: [],
        props: hJ(n),
        object: i,
        eventCount: 0,
        handlers: {},
        isHidden: !1
    },
    i && (i.__r3f = a)),
    a
}
function Qy(r, e) {
    if (!e.includes("-"))
        return {
            root: r,
            key: e,
            target: r[e]
        };
    if (e in r)
        return {
            root: r,
            key: e,
            target: r[e]
        };
    let t = r;
    const n = e.split("-");
    for (const i of n) {
        if (typeof t != "object" || t === null) {
            if (t !== void 0) {
                const a = n.slice(n.indexOf(i)).join("-");
                return {
                    root: t,
                    key: a,
                    target: void 0
                }
            }
            return {
                root: r,
                key: e,
                target: void 0
            }
        }
        e = i,
        r = t,
        t = t[e]
    }
    return {
        root: r,
        key: e,
        target: t
    }
}
const FO = /-\d+$/;
function Lb(r, e) {
    if (ki.str(e.props.attach)) {
        if (FO.test(e.props.attach)) {
            const i = e.props.attach.replace(FO, "")
              , {root: a, key: s} = Qy(r.object, i);
            Array.isArray(a[s]) || (a[s] = [])
        }
        const {root: t, key: n} = Qy(r.object, e.props.attach);
        e.previousAttach = t[n],
        t[n] = e.object
    } else
        ki.fun(e.props.attach) && (e.previousAttach = e.props.attach(r.object, e.object))
}
function Pb(r, e) {
    if (ki.str(e.props.attach)) {
        const {root: t, key: n} = Qy(r.object, e.props.attach)
          , i = e.previousAttach;
        i === void 0 ? delete t[n] : t[n] = i
    } else
        e.previousAttach == null || e.previousAttach(r.object, e.object);
    delete e.previousAttach
}
const Sw = [...zz, "args", "dispose", "attach", "object", "onUpdate", "dispose"]
  , HO = new Map;
function dJ(r) {
    let e = HO.get(r.constructor);
    try {
        e || (e = new r.constructor,
        HO.set(r.constructor, e))
    } catch {}
    return e
}
function pJ(r, e) {
    const t = {};
    for (const n in e)
        if (!Sw.includes(n) && !ki.equ(e[n], r.props[n])) {
            t[n] = e[n];
            for (const i in e)
                i.startsWith(`${n}-`) && (t[i] = e[i])
        }
    for (const n in r.props) {
        if (Sw.includes(n) || e.hasOwnProperty(n))
            continue;
        const {root: i, key: a} = Qy(r.object, n);
        if (i.constructor && i.constructor.length === 0) {
            const s = dJ(i);
            ki.und(s) || (t[a] = s[a])
        } else
            t[a] = 0
    }
    return t
}
const mJ = ["map", "emissiveMap", "sheenColorMap", "specularColorMap", "envMap"]
  , gJ = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;
function Vu(r, e) {
    var t;
    const n = r.__r3f
      , i = n && Lz(n).getState()
      , a = n == null ? void 0 : n.eventCount;
    for (const l in e) {
        let u = e[l];
        if (Sw.includes(l))
            continue;
        if (n && gJ.test(l)) {
            typeof u == "function" ? n.handlers[l] = u : delete n.handlers[l],
            n.eventCount = Object.keys(n.handlers).length;
            continue
        }
        if (u === void 0)
            continue;
        let {root: f, key: d, target: g} = Qy(r, l);
        if (g === void 0 && (typeof f != "object" || f === null))
            throw Error(`R3F: Cannot set "${l}". Ensure it is an object before setting "${d}".`);
        if (g instanceof Dg && u instanceof Dg)
            g.mask = u.mask;
        else if (g instanceof kt && sJ(u))
            g.set(u);
        else if (g !== null && typeof g == "object" && typeof g.set == "function" && typeof g.copy == "function" && u != null && u.constructor && g.constructor === u.constructor)
            g.copy(u);
        else if (g !== null && typeof g == "object" && typeof g.set == "function" && Array.isArray(u))
            typeof g.fromArray == "function" ? g.fromArray(u) : g.set(...u);
        else if (g !== null && typeof g == "object" && typeof g.set == "function" && typeof u == "number")
            typeof g.setScalar == "function" ? g.setScalar(u) : g.set(u);
        else {
            var s;
            f[d] = u,
            i && !i.linear && mJ.includes(d) && (s = f[d]) != null && s.isTexture && f[d].format === vr && f[d].type === ys && (f[d].colorSpace = pa)
        }
    }
    if (n != null && n.parent && i != null && i.internal && (t = n.object) != null && t.isObject3D && a !== n.eventCount) {
        const l = n.object
          , u = i.internal.interaction.indexOf(l);
        u > -1 && i.internal.interaction.splice(u, 1),
        n.eventCount && l.raycast !== null && i.internal.interaction.push(l)
    }
    return n && n.props.attach === void 0 && (n.object.isBufferGeometry ? n.props.attach = "geometry" : n.object.isMaterial && (n.props.attach = "material")),
    n && Zg(n),
    r
}
function Zg(r) {
    var e;
    if (!r.parent)
        return;
    r.props.onUpdate == null || r.props.onUpdate(r.object);
    const t = (e = r.root) == null || e.getState == null ? void 0 : e.getState();
    t && t.internal.frames === 0 && t.invalidate()
}
function Iz(r, e) {
    r.manual || (Pz(r) ? (r.left = e.width / -2,
    r.right = e.width / 2,
    r.top = e.height / 2,
    r.bottom = e.height / -2) : r.aspect = e.width / e.height,
    r.updateProjectionMatrix())
}
const hs = r => r == null ? void 0 : r.isObject3D;
function Gx(r) {
    return (r.eventObject || r.object).uuid + "/" + r.index + r.instanceId
}
function Fz(r, e, t, n) {
    const i = t.get(e);
    i && (t.delete(e),
    t.size === 0 && (r.delete(n),
    i.target.releasePointerCapture(n)))
}
function vJ(r, e) {
    const {internal: t} = r.getState();
    t.interaction = t.interaction.filter(n => n !== e),
    t.initialHits = t.initialHits.filter(n => n !== e),
    t.hovered.forEach( (n, i) => {
        (n.eventObject === e || n.object === e) && t.hovered.delete(i)
    }
    ),
    t.capturedMap.forEach( (n, i) => {
        Fz(t.capturedMap, e, n, i)
    }
    )
}
function yJ(r) {
    function e(u) {
        const {internal: f} = r.getState()
          , d = u.offsetX - f.initialClick[0]
          , g = u.offsetY - f.initialClick[1];
        return Math.round(Math.sqrt(d * d + g * g))
    }
    function t(u) {
        return u.filter(f => ["Move", "Over", "Enter", "Out", "Leave"].some(d => {
            var g;
            return (g = f.__r3f) == null ? void 0 : g.handlers["onPointer" + d]
        }
        ))
    }
    function n(u, f) {
        const d = r.getState()
          , g = new Set
          , v = []
          , y = f ? f(d.internal.interaction) : d.internal.interaction;
        for (let b = 0; b < y.length; b++) {
            const A = Fm(y[b]);
            A && (A.raycaster.camera = void 0)
        }
        d.previousRoot || d.events.compute == null || d.events.compute(u, d);
        function S(b) {
            const A = Fm(b);
            if (!A || !A.events.enabled || A.raycaster.camera === null)
                return [];
            if (A.raycaster.camera === void 0) {
                var C;
                A.events.compute == null || A.events.compute(u, A, (C = A.previousRoot) == null ? void 0 : C.getState()),
                A.raycaster.camera === void 0 && (A.raycaster.camera = null)
            }
            return A.raycaster.camera ? A.raycaster.intersectObject(b, !0) : []
        }
        let T = y.flatMap(S).sort( (b, A) => {
            const C = Fm(b.object)
              , R = Fm(A.object);
            return !C || !R ? b.distance - A.distance : R.events.priority - C.events.priority || b.distance - A.distance
        }
        ).filter(b => {
            const A = Gx(b);
            return g.has(A) ? !1 : (g.add(A),
            !0)
        }
        );
        d.events.filter && (T = d.events.filter(T, d));
        for (const b of T) {
            let A = b.object;
            for (; A; ) {
                var M;
                (M = A.__r3f) != null && M.eventCount && v.push({
                    ...b,
                    eventObject: A
                }),
                A = A.parent
            }
        }
        if ("pointerId"in u && d.internal.capturedMap.has(u.pointerId))
            for (let b of d.internal.capturedMap.get(u.pointerId).values())
                g.has(Gx(b.intersection)) || v.push(b.intersection);
        return v
    }
    function i(u, f, d, g) {
        if (u.length) {
            const v = {
                stopped: !1
            };
            for (const y of u) {
                let S = Fm(y.object);
                if (S || y.object.traverseAncestors(T => {
                    const M = Fm(T);
                    if (M)
                        return S = M,
                        !1
                }
                ),
                S) {
                    const {raycaster: T, pointer: M, camera: b, internal: A} = S
                      , C = new he(M.x,M.y,0).unproject(b)
                      , R = N => {
                        var P, Y;
                        return (P = (Y = A.capturedMap.get(N)) == null ? void 0 : Y.has(y.eventObject)) != null ? P : !1
                    }
                      , O = N => {
                        const P = {
                            intersection: y,
                            target: f.target
                        };
                        A.capturedMap.has(N) ? A.capturedMap.get(N).set(y.eventObject, P) : A.capturedMap.set(N, new Map([[y.eventObject, P]])),
                        f.target.setPointerCapture(N)
                    }
                      , L = N => {
                        const P = A.capturedMap.get(N);
                        P && Fz(A.capturedMap, y.eventObject, P, N)
                    }
                    ;
                    let z = {};
                    for (let N in f) {
                        let P = f[N];
                        typeof P != "function" && (z[N] = P)
                    }
                    let I = {
                        ...y,
                        ...z,
                        pointer: M,
                        intersections: u,
                        stopped: v.stopped,
                        delta: d,
                        unprojectedPoint: C,
                        ray: T.ray,
                        camera: b,
                        stopPropagation() {
                            const N = "pointerId"in f && A.capturedMap.get(f.pointerId);
                            if ((!N || N.has(y.eventObject)) && (I.stopped = v.stopped = !0,
                            A.hovered.size && Array.from(A.hovered.values()).find(P => P.eventObject === y.eventObject))) {
                                const P = u.slice(0, u.indexOf(y));
                                a([...P, y])
                            }
                        },
                        target: {
                            hasPointerCapture: R,
                            setPointerCapture: O,
                            releasePointerCapture: L
                        },
                        currentTarget: {
                            hasPointerCapture: R,
                            setPointerCapture: O,
                            releasePointerCapture: L
                        },
                        nativeEvent: f
                    };
                    if (g(I),
                    v.stopped === !0)
                        break
                }
            }
        }
        return u
    }
    function a(u) {
        const {internal: f} = r.getState();
        for (const d of f.hovered.values())
            if (!u.length || !u.find(g => g.object === d.object && g.index === d.index && g.instanceId === d.instanceId)) {
                const v = d.eventObject.__r3f;
                if (f.hovered.delete(Gx(d)),
                v != null && v.eventCount) {
                    const y = v.handlers
                      , S = {
                        ...d,
                        intersections: u
                    };
                    y.onPointerOut == null || y.onPointerOut(S),
                    y.onPointerLeave == null || y.onPointerLeave(S)
                }
            }
    }
    function s(u, f) {
        for (let d = 0; d < f.length; d++) {
            const g = f[d].__r3f;
            g == null || g.handlers.onPointerMissed == null || g.handlers.onPointerMissed(u)
        }
    }
    function l(u) {
        switch (u) {
        case "onPointerLeave":
        case "onPointerCancel":
            return () => a([]);
        case "onLostPointerCapture":
            return f => {
                const {internal: d} = r.getState();
                "pointerId"in f && d.capturedMap.has(f.pointerId) && requestAnimationFrame( () => {
                    d.capturedMap.has(f.pointerId) && (d.capturedMap.delete(f.pointerId),
                    a([]))
                }
                )
            }
        }
        return function(d) {
            const {onPointerMissed: g, internal: v} = r.getState();
            v.lastEvent.current = d;
            const y = u === "onPointerMove"
              , S = u === "onClick" || u === "onContextMenu" || u === "onDoubleClick"
              , M = n(d, y ? t : void 0)
              , b = S ? e(d) : 0;
            u === "onPointerDown" && (v.initialClick = [d.offsetX, d.offsetY],
            v.initialHits = M.map(C => C.eventObject)),
            S && !M.length && b <= 2 && (s(d, v.interaction),
            g && g(d)),
            y && a(M);
            function A(C) {
                const R = C.eventObject
                  , O = R.__r3f;
                if (!(O != null && O.eventCount))
                    return;
                const L = O.handlers;
                if (y) {
                    if (L.onPointerOver || L.onPointerEnter || L.onPointerOut || L.onPointerLeave) {
                        const z = Gx(C)
                          , I = v.hovered.get(z);
                        I ? I.stopped && C.stopPropagation() : (v.hovered.set(z, C),
                        L.onPointerOver == null || L.onPointerOver(C),
                        L.onPointerEnter == null || L.onPointerEnter(C))
                    }
                    L.onPointerMove == null || L.onPointerMove(C)
                } else {
                    const z = L[u];
                    z ? (!S || v.initialHits.includes(R)) && (s(d, v.interaction.filter(I => !v.initialHits.includes(I))),
                    z(C)) : S && v.initialHits.includes(R) && s(d, v.interaction.filter(I => !v.initialHits.includes(I)))
                }
            }
            i(M, d, b, A)
        }
    }
    return {
        handlePointer: l
    }
}
const VO = r => !!(r != null && r.render)
  , VC = de.createContext(null)
  , _J = (r, e) => {
    const t = Az( (l, u) => {
        const f = new he
          , d = new he
          , g = new he;
        function v(b=u().camera, A=d, C=u().size) {
            const {width: R, height: O, top: L, left: z} = C
              , I = R / O;
            A.isVector3 ? g.copy(A) : g.set(...A);
            const N = b.getWorldPosition(f).distanceTo(g);
            if (Pz(b))
                return {
                    width: R / b.zoom,
                    height: O / b.zoom,
                    top: L,
                    left: z,
                    factor: 1,
                    distance: N,
                    aspect: I
                };
            {
                const P = b.fov * Math.PI / 180
                  , Y = 2 * Math.tan(P / 2) * N
                  , V = Y * (R / O);
                return {
                    width: V,
                    height: Y,
                    top: L,
                    left: z,
                    factor: R / V,
                    distance: N,
                    aspect: I
                }
            }
        }
        let y;
        const S = b => l(A => ({
            performance: {
                ...A.performance,
                current: b
            }
        }))
          , T = new xt;
        return {
            set: l,
            get: u,
            gl: null,
            camera: null,
            raycaster: null,
            events: {
                priority: 1,
                enabled: !0,
                connected: !1
            },
            scene: null,
            xr: null,
            invalidate: (b=1) => r(u(), b),
            advance: (b, A) => e(b, A, u()),
            legacy: !1,
            linear: !1,
            flat: !1,
            controls: null,
            clock: new DC,
            pointer: T,
            mouse: T,
            frameloop: "always",
            onPointerMissed: void 0,
            performance: {
                current: 1,
                min: .5,
                max: 1,
                debounce: 200,
                regress: () => {
                    const b = u();
                    y && clearTimeout(y),
                    b.performance.current !== b.performance.min && S(b.performance.min),
                    y = setTimeout( () => S(u().performance.max), b.performance.debounce)
                }
            },
            size: {
                width: 0,
                height: 0,
                top: 0,
                left: 0
            },
            viewport: {
                initialDpr: 0,
                dpr: 0,
                width: 0,
                height: 0,
                top: 0,
                left: 0,
                aspect: 0,
                distance: 0,
                factor: 0,
                getCurrentViewport: v
            },
            setEvents: b => l(A => ({
                ...A,
                events: {
                    ...A.events,
                    ...b
                }
            })),
            setSize: (b, A, C=0, R=0) => {
                const O = u().camera
                  , L = {
                    width: b,
                    height: A,
                    top: C,
                    left: R
                };
                l(z => ({
                    size: L,
                    viewport: {
                        ...z.viewport,
                        ...v(O, d, L)
                    }
                }))
            }
            ,
            setDpr: b => l(A => {
                const C = Bz(b);
                return {
                    viewport: {
                        ...A.viewport,
                        dpr: C,
                        initialDpr: A.viewport.initialDpr || C
                    }
                }
            }
            ),
            setFrameloop: (b="always") => {
                const A = u().clock;
                A.stop(),
                A.elapsedTime = 0,
                b !== "never" && (A.start(),
                A.elapsedTime = 0),
                l( () => ({
                    frameloop: b
                }))
            }
            ,
            previousRoot: void 0,
            internal: {
                interaction: [],
                hovered: new Map,
                subscribers: [],
                initialClick: [0, 0],
                initialHits: [],
                capturedMap: new Map,
                lastEvent: de.createRef(),
                active: !1,
                frames: 0,
                priority: 0,
                subscribe: (b, A, C) => {
                    const R = u().internal;
                    return R.priority = R.priority + (A > 0 ? 1 : 0),
                    R.subscribers.push({
                        ref: b,
                        priority: A,
                        store: C
                    }),
                    R.subscribers = R.subscribers.sort( (O, L) => O.priority - L.priority),
                    () => {
                        const O = u().internal;
                        O != null && O.subscribers && (O.priority = O.priority - (A > 0 ? 1 : 0),
                        O.subscribers = O.subscribers.filter(L => L.ref !== b))
                    }
                }
            }
        }
    }
    )
      , n = t.getState();
    let i = n.size
      , a = n.viewport.dpr
      , s = n.camera;
    return t.subscribe( () => {
        const {camera: l, size: u, viewport: f, gl: d, set: g} = t.getState();
        if (u.width !== i.width || u.height !== i.height || f.dpr !== a) {
            i = u,
            a = f.dpr,
            Iz(l, u),
            f.dpr > 0 && d.setPixelRatio(f.dpr);
            const v = typeof HTMLCanvasElement < "u" && d.domElement instanceof HTMLCanvasElement;
            d.setSize(u.width, u.height, v)
        }
        l !== s && (s = l,
        g(v => ({
            viewport: {
                ...v.viewport,
                ...v.viewport.getCurrentViewport(l)
            }
        })))
    }
    ),
    t.subscribe(l => r(l)),
    t
}
;
function kC() {
    const r = de.useContext(VC);
    if (!r)
        throw new Error("R3F: Hooks can only be used within the Canvas component!");
    return r
}
function Ng(r=t => t, e) {
    return kC()(r, e)
}
function T_(r, e=0) {
    const t = kC()
      , n = t.getState().internal.subscribe
      , i = HC(r);
    return M_( () => n(i, e, t), [e, n, t]),
    null
}
const kO = new WeakMap
  , xJ = r => {
    var e;
    return typeof r == "function" && (r == null || (e = r.prototype) == null ? void 0 : e.constructor) === r
}
;
function Hz(r, e) {
    return function(t, ...n) {
        let i;
        return xJ(t) ? (i = kO.get(t),
        i || (i = new t,
        kO.set(t, i))) : i = t,
        r && r(i),
        Promise.all(n.map(a => new Promise( (s, l) => i.load(a, u => {
            hs(u == null ? void 0 : u.scene) && Object.assign(u, cJ(u.scene)),
            s(u)
        }
        , e, u => l(new Error(`Could not load ${a}: ${u == null ? void 0 : u.message}`))))))
    }
}
function Lg(r, e, t, n) {
    const i = Array.isArray(e) ? e : [e]
      , a = Dz(Hz(t, n), [r, ...i], {
        equal: ki.equ
    });
    return Array.isArray(e) ? a : a[0]
}
Lg.preload = function(r, e, t) {
    const n = Array.isArray(e) ? e : [e];
    return jQ(Hz(t), [r, ...n])
}
;
Lg.clear = function(r, e) {
    const t = Array.isArray(e) ? e : [e];
    return WQ([r, ...t])
}
;
function SJ(r) {
    const e = JQ(r);
    return e.injectIntoDevTools({
        bundleType: 0,
        rendererPackageName: "@react-three/fiber",
        version: de.version
    }),
    e
}
const Vz = 0
  , Pg = {}
  , bJ = /^three(?=[A-Z])/
  , IM = r => `${r[0].toUpperCase()}${r.slice(1)}`;
let MJ = 0;
const TJ = r => typeof r == "function";
function kz(r) {
    if (TJ(r)) {
        const e = `${MJ++}`;
        return Pg[e] = r,
        e
    } else
        Object.assign(Pg, r)
}
function Gz(r, e) {
    const t = IM(r)
      , n = Pg[t];
    if (r !== "primitive" && !n)
        throw new Error(`R3F: ${t} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
    if (r === "primitive" && !e.object)
        throw new Error("R3F: Primitives without 'object' are invalid!");
    if (e.args !== void 0 && !Array.isArray(e.args))
        throw new Error("R3F: The args prop must be an array!")
}
function EJ(r, e, t) {
    var n;
    return r = IM(r)in Pg ? r : r.replace(bJ, ""),
    Gz(r, e),
    r === "primitive" && (n = e.object) != null && n.__r3f && delete e.object.__r3f,
    Nb(e.object, t, r, e)
}
function wJ(r) {
    if (!r.isHidden) {
        var e;
        r.props.attach && (e = r.parent) != null && e.object ? Pb(r.parent, r) : hs(r.object) && (r.object.visible = !1),
        r.isHidden = !0,
        Zg(r)
    }
}
function Xz(r) {
    if (r.isHidden) {
        var e;
        r.props.attach && (e = r.parent) != null && e.object ? Lb(r.parent, r) : hs(r.object) && r.props.visible !== !1 && (r.object.visible = !0),
        r.isHidden = !1,
        Zg(r)
    }
}
function GC(r, e, t) {
    const n = e.root.getState();
    if (!(!r.parent && r.object !== n.scene)) {
        if (!e.object) {
            var i, a;
            const s = Pg[IM(e.type)];
            e.object = (i = e.props.object) != null ? i : new s(...(a = e.props.args) != null ? a : []),
            e.object.__r3f = e
        }
        if (Vu(e.object, e.props),
        e.props.attach)
            Lb(r, e);
        else if (hs(e.object) && hs(r.object)) {
            const s = r.object.children.indexOf(t == null ? void 0 : t.object);
            if (t && s !== -1) {
                const l = r.object.children.indexOf(e.object);
                if (l !== -1) {
                    r.object.children.splice(l, 1);
                    const u = l < s ? s - 1 : s;
                    r.object.children.splice(u, 0, e.object)
                } else
                    e.object.parent = r.object,
                    r.object.children.splice(s, 0, e.object),
                    e.object.dispatchEvent({
                        type: "added"
                    }),
                    r.object.dispatchEvent({
                        type: "childadded",
                        child: e.object
                    })
            } else
                r.object.add(e.object)
        }
        for (const s of e.children)
            GC(e, s);
        Zg(e)
    }
}
function $T(r, e) {
    e && (e.parent = r,
    r.children.push(e),
    GC(r, e))
}
function GO(r, e, t) {
    if (!e || !t)
        return;
    e.parent = r;
    const n = r.children.indexOf(t);
    n !== -1 ? r.children.splice(n, 0, e) : r.children.push(e),
    GC(r, e, t)
}
function jz(r) {
    if (typeof r.dispose == "function") {
        const e = () => {
            try {
                r.dispose()
            } catch {}
        }
        ;
        typeof IS_REACT_ACT_ENVIRONMENT < "u" ? e() : IO.unstable_scheduleCallback(IO.unstable_IdlePriority, e)
    }
}
function bw(r, e, t) {
    if (!e)
        return;
    e.parent = null;
    const n = r.children.indexOf(e);
    n !== -1 && r.children.splice(n, 1),
    e.props.attach ? Pb(r, e) : hs(e.object) && hs(r.object) && (r.object.remove(e.object),
    vJ(Lz(e), e.object));
    const i = e.props.dispose !== null && t !== !1;
    for (let a = e.children.length - 1; a >= 0; a--) {
        const s = e.children[a];
        bw(e, s, i)
    }
    e.children.length = 0,
    delete e.object.__r3f,
    i && e.type !== "primitive" && e.object.type !== "Scene" && jz(e.object),
    t === void 0 && Zg(e)
}
function AJ(r, e) {
    for (const t of [r, r.alternate])
        if (t !== null)
            if (typeof t.ref == "function") {
                t.refCleanup == null || t.refCleanup();
                const n = t.ref(e);
                typeof n == "function" && (t.refCleanup = n)
            } else
                t.ref && (t.ref.current = e)
}
const bS = [];
function CJ() {
    for (const [t] of bS) {
        const n = t.parent;
        if (n) {
            t.props.attach ? Pb(n, t) : hs(t.object) && hs(n.object) && n.object.remove(t.object);
            for (const i of t.children)
                i.props.attach ? Pb(t, i) : hs(i.object) && hs(t.object) && t.object.remove(i.object)
        }
        t.isHidden && Xz(t),
        t.object.__r3f && delete t.object.__r3f,
        t.type !== "primitive" && jz(t.object)
    }
    for (const [t,n,i] of bS) {
        t.props = n;
        const a = t.parent;
        if (a) {
            var r, e;
            const s = Pg[IM(t.type)];
            t.object = (r = t.props.object) != null ? r : new s(...(e = t.props.args) != null ? e : []),
            t.object.__r3f = t,
            AJ(i, t.object),
            Vu(t.object, t.props),
            t.props.attach ? Lb(a, t) : hs(t.object) && hs(a.object) && a.object.add(t.object);
            for (const l of t.children)
                l.props.attach ? Lb(t, l) : hs(l.object) && hs(t.object) && t.object.add(l.object);
            Zg(t)
        }
    }
    bS.length = 0
}
const eE = () => {}
  , XO = {};
let Xx = Vz;
const RJ = 0
  , DJ = 4
  , Bb = SJ({
    isPrimaryRenderer: !1,
    warnsIfNotActing: !1,
    supportsMutation: !0,
    supportsPersistence: !1,
    supportsHydration: !1,
    createInstance: EJ,
    removeChild: bw,
    appendChild: $T,
    appendInitialChild: $T,
    insertBefore: GO,
    appendChildToContainer(r, e) {
        const t = r.getState().scene.__r3f;
        !e || !t || $T(t, e)
    },
    removeChildFromContainer(r, e) {
        const t = r.getState().scene.__r3f;
        !e || !t || bw(t, e)
    },
    insertInContainerBefore(r, e, t) {
        const n = r.getState().scene.__r3f;
        !e || !t || !n || GO(n, e, t)
    },
    getRootHostContext: () => XO,
    getChildHostContext: () => XO,
    commitUpdate(r, e, t, n, i) {
        var a, s, l;
        Gz(e, n);
        let u = !1;
        if ((r.type === "primitive" && t.object !== n.object || ((a = n.args) == null ? void 0 : a.length) !== ((s = t.args) == null ? void 0 : s.length) || (l = n.args) != null && l.some( (d, g) => {
            var v;
            return d !== ((v = t.args) == null ? void 0 : v[g])
        }
        )) && (u = !0),
        u)
            bS.push([r, {
                ...n
            }, i]);
        else {
            const d = pJ(r, n);
            Object.keys(d).length && (Object.assign(r.props, d),
            Vu(r.object, d))
        }
        (i.sibling === null || (i.flags & DJ) === RJ) && CJ()
    },
    finalizeInitialChildren: () => !1,
    commitMount() {},
    getPublicInstance: r => r == null ? void 0 : r.object,
    prepareForCommit: () => null,
    preparePortalMount: r => Nb(r.getState().scene, r, "", {}),
    resetAfterCommit: () => {}
    ,
    shouldSetTextContent: () => !1,
    clearContainer: () => !1,
    hideInstance: wJ,
    unhideInstance: Xz,
    createTextInstance: eE,
    hideTextInstance: eE,
    unhideTextInstance: eE,
    scheduleTimeout: typeof setTimeout == "function" ? setTimeout : void 0,
    cancelTimeout: typeof clearTimeout == "function" ? clearTimeout : void 0,
    noTimeout: -1,
    getInstanceFromNode: () => null,
    beforeActiveInstanceBlur() {},
    afterActiveInstanceBlur() {},
    detachDeletedInstance() {},
    prepareScopeUpdate() {},
    getInstanceFromScope: () => null,
    shouldAttemptEagerTransition: () => !1,
    trackSchedulerEvent: () => {}
    ,
    resolveEventType: () => null,
    resolveEventTimeStamp: () => -1.1,
    requestPostPaintCallback() {},
    maySuspendCommit: () => !1,
    preloadInstance: () => !0,
    startSuspendingCommit() {},
    suspendInstance() {},
    waitForCommitToBeReady: () => null,
    NotPendingTransition: null,
    HostTransitionContext: de.createContext(null),
    setCurrentUpdatePriority(r) {
        Xx = r
    },
    getCurrentUpdatePriority() {
        return Xx
    },
    resolveUpdatePriority() {
        var r;
        if (Xx !== Vz)
            return Xx;
        switch (typeof window < "u" && ((r = window.event) == null ? void 0 : r.type)) {
        case "click":
        case "contextmenu":
        case "dblclick":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
            return yS.DiscreteEventPriority;
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "pointerenter":
        case "pointerleave":
        case "wheel":
            return yS.ContinuousEventPriority;
        default:
            return yS.DefaultEventPriority
        }
    },
    resetFormInstance() {}
})
  , dp = new Map
  , Hm = {
    objects: "shallow",
    strict: !1
};
function UJ(r, e) {
    if (!e && typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement && r.parentElement) {
        const {width: t, height: n, top: i, left: a} = r.parentElement.getBoundingClientRect();
        return {
            width: t,
            height: n,
            top: i,
            left: a
        }
    } else if (!e && typeof OffscreenCanvas < "u" && r instanceof OffscreenCanvas)
        return {
            width: r.width,
            height: r.height,
            top: 0,
            left: 0
        };
    return {
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        ...e
    }
}
function OJ(r) {
    const e = dp.get(r)
      , t = e == null ? void 0 : e.fiber
      , n = e == null ? void 0 : e.store;
    e && console.warn("R3F.createRoot should only be called once!");
    const i = typeof reportError == "function" ? reportError : console.error
      , a = n || _J(Ew, WO)
      , s = t || Bb.createContainer(a, yS.ConcurrentRoot, null, !1, null, "", i, i, i, null);
    e || dp.set(r, {
        fiber: s,
        store: a
    });
    let l, u, f = !1, d = null;
    return {
        async configure(g={}) {
            let v;
            d = new Promise(W => v = W);
            let {gl: y, size: S, scene: T, events: M, onCreated: b, shadows: A=!1, linear: C=!1, flat: R=!1, legacy: O=!1, orthographic: L=!1, frameloop: z="always", dpr: I=[1, 2], performance: N, raycaster: P, camera: Y, onPointerMissed: V} = g
              , K = a.getState()
              , Z = K.gl;
            if (!K.gl) {
                const W = {
                    canvas: r,
                    powerPreference: "high-performance",
                    antialias: !0,
                    alpha: !0
                }
                  , te = typeof y == "function" ? await y(W) : y;
                VO(te) ? Z = te : Z = new zC({
                    ...W,
                    ...y
                }),
                K.set({
                    gl: Z
                })
            }
            let oe = K.raycaster;
            oe || K.set({
                raycaster: oe = new LC
            });
            const {params: H, ...q} = P || {};
            if (ki.equ(q, oe, Hm) || Vu(oe, {
                ...q
            }),
            ki.equ(H, oe.params, Hm) || Vu(oe, {
                params: {
                    ...oe.params,
                    ...H
                }
            }),
            !K.camera || K.camera === u && !ki.equ(u, Y, Hm)) {
                u = Y;
                const W = Y == null ? void 0 : Y.isCamera
                  , te = W ? Y : L ? new Yg(0,0,0,0,.1,1e3) : new Jr(75,0,.1,1e3);
                W || (te.position.z = 5,
                Y && (Vu(te, Y),
                te.manual || ("aspect"in Y || "left"in Y || "right"in Y || "bottom"in Y || "top"in Y) && (te.manual = !0,
                te.updateProjectionMatrix())),
                !K.camera && !(Y != null && Y.rotation) && te.lookAt(0, 0, 0)),
                K.set({
                    camera: te
                }),
                oe.camera = te
            }
            if (!K.scene) {
                let W;
                T != null && T.isScene ? (W = T,
                Nb(W, a, "", {})) : (W = new m_,
                Nb(W, a, "", {}),
                T && Vu(W, T)),
                K.set({
                    scene: W
                })
            }
            M && !K.events.handlers && K.set({
                events: M(a)
            });
            const Q = UJ(r, S);
            if (ki.equ(Q, K.size, Hm) || K.setSize(Q.width, Q.height, Q.top, Q.left),
            I && K.viewport.dpr !== Bz(I) && K.setDpr(I),
            K.frameloop !== z && K.setFrameloop(z),
            K.onPointerMissed || K.set({
                onPointerMissed: V
            }),
            N && !ki.equ(N, K.performance, Hm) && K.set(W => ({
                performance: {
                    ...W.performance,
                    ...N
                }
            })),
            !K.xr) {
                var se;
                const W = (pe, _e) => {
                    const ue = a.getState();
                    ue.frameloop !== "never" && WO(pe, !0, ue, _e)
                }
                  , te = () => {
                    const pe = a.getState();
                    pe.gl.xr.enabled = pe.gl.xr.isPresenting,
                    pe.gl.xr.setAnimationLoop(pe.gl.xr.isPresenting ? W : null),
                    pe.gl.xr.isPresenting || Ew(pe)
                }
                  , fe = {
                    connect() {
                        const pe = a.getState().gl;
                        pe.xr.addEventListener("sessionstart", te),
                        pe.xr.addEventListener("sessionend", te)
                    },
                    disconnect() {
                        const pe = a.getState().gl;
                        pe.xr.removeEventListener("sessionstart", te),
                        pe.xr.removeEventListener("sessionend", te)
                    }
                };
                typeof ((se = Z.xr) == null ? void 0 : se.addEventListener) == "function" && fe.connect(),
                K.set({
                    xr: fe
                })
            }
            if (Z.shadowMap) {
                const W = Z.shadowMap.enabled
                  , te = Z.shadowMap.type;
                if (Z.shadowMap.enabled = !!A,
                ki.boo(A))
                    Z.shadowMap.type = Jv;
                else if (ki.str(A)) {
                    var B;
                    const fe = {
                        basic: OP,
                        percentage: rM,
                        soft: Jv,
                        variance: Wl
                    };
                    Z.shadowMap.type = (B = fe[A]) != null ? B : Jv
                } else
                    ki.obj(A) && Object.assign(Z.shadowMap, A);
                (W !== Z.shadowMap.enabled || te !== Z.shadowMap.type) && (Z.shadowMap.needsUpdate = !0)
            }
            return Kn.enabled = !O,
            f || (Z.outputColorSpace = C ? Jl : pa,
            Z.toneMapping = R ? Ju : ZA),
            K.legacy !== O && K.set( () => ({
                legacy: O
            })),
            K.linear !== C && K.set( () => ({
                linear: C
            })),
            K.flat !== R && K.set( () => ({
                flat: R
            })),
            y && !ki.fun(y) && !VO(y) && !ki.equ(y, Z, Hm) && Vu(Z, y),
            l = b,
            f = !0,
            v(),
            this
        },
        render(g) {
            return !f && !d && this.configure(),
            d.then( () => {
                Bb.updateContainer(ae.jsx(NJ, {
                    store: a,
                    children: g,
                    onCreated: l,
                    rootElement: r
                }), s, null, () => {}
                )
            }
            ),
            a
        },
        unmount() {
            Wz(r)
        }
    }
}
function NJ({store: r, children: e, onCreated: t, rootElement: n}) {
    return M_( () => {
        const i = r.getState();
        i.set(a => ({
            internal: {
                ...a.internal,
                active: !0
            }
        })),
        t && t(i),
        r.getState().events.connected || i.events.connect == null || i.events.connect(n)
    }
    , []),
    ae.jsx(VC.Provider, {
        value: r,
        children: e
    })
}
function Wz(r, e) {
    const t = dp.get(r)
      , n = t == null ? void 0 : t.fiber;
    if (n) {
        const i = t == null ? void 0 : t.store.getState();
        i && (i.internal.active = !1),
        Bb.updateContainer(null, n, null, () => {
            i && setTimeout( () => {
                try {
                    var a, s, l, u;
                    i.events.disconnect == null || i.events.disconnect(),
                    (a = i.gl) == null || (s = a.renderLists) == null || s.dispose == null || s.dispose(),
                    (l = i.gl) == null || l.forceContextLoss == null || l.forceContextLoss(),
                    (u = i.gl) != null && u.xr && i.xr.disconnect(),
                    fJ(i.scene),
                    dp.delete(r)
                } catch {}
            }
            , 500)
        }
        )
    }
}
function LJ(r, e, t) {
    return ae.jsx(PJ, {
        children: r,
        container: e,
        state: t
    })
}
function PJ({state: r={}, children: e, container: t}) {
    const {events: n, size: i, ...a} = r
      , s = kC()
      , [l] = de.useState( () => new LC)
      , [u] = de.useState( () => new xt)
      , f = HC( (g, v) => {
        let y;
        if (v.camera && i) {
            const S = v.camera;
            y = g.viewport.getCurrentViewport(S, new he, i),
            S !== g.camera && Iz(S, i)
        }
        return {
            ...g,
            ...v,
            scene: t,
            raycaster: l,
            pointer: u,
            mouse: u,
            previousRoot: s,
            events: {
                ...g.events,
                ...v.events,
                ...n
            },
            size: {
                ...g.size,
                ...i
            },
            viewport: {
                ...g.viewport,
                ...y
            },
            setEvents: S => v.set(T => ({
                ...T,
                events: {
                    ...T.events,
                    ...S
                }
            }))
        }
    }
    )
      , d = de.useMemo( () => {
        const g = Az( (y, S) => ({
            ...a,
            set: y,
            get: S
        }))
          , v = y => g.setState(S => f.current(y, S));
        return v(s.getState()),
        s.subscribe(v),
        g
    }
    , [s, t]);
    return ae.jsx(ae.Fragment, {
        children: Bb.createPortal(ae.jsx(VC.Provider, {
            value: d,
            children: e
        }), d, null)
    })
}
const BJ = new Set
  , zJ = new Set
  , IJ = new Set;
function tE(r, e) {
    if (r.size)
        for (const {callback: t} of r.values())
            t(e)
}
function oy(r, e) {
    switch (r) {
    case "before":
        return tE(BJ, e);
    case "after":
        return tE(zJ, e);
    case "tail":
        return tE(IJ, e)
    }
}
let nE, iE;
function Mw(r, e, t) {
    let n = e.clock.getDelta();
    e.frameloop === "never" && typeof r == "number" && (n = r - e.clock.elapsedTime,
    e.clock.oldTime = e.clock.elapsedTime,
    e.clock.elapsedTime = r),
    nE = e.internal.subscribers;
    for (let i = 0; i < nE.length; i++)
        iE = nE[i],
        iE.ref.current(iE.store.getState(), n, t);
    return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    e.internal.frames = Math.max(0, e.internal.frames - 1),
    e.frameloop === "always" ? 1 : e.internal.frames
}
let zb = !1, Tw = !1, rE, jO, Vm;
function Yz(r) {
    jO = requestAnimationFrame(Yz),
    zb = !0,
    rE = 0,
    oy("before", r),
    Tw = !0;
    for (const t of dp.values()) {
        var e;
        Vm = t.store.getState(),
        Vm.internal.active && (Vm.frameloop === "always" || Vm.internal.frames > 0) && !((e = Vm.gl.xr) != null && e.isPresenting) && (rE += Mw(r, Vm))
    }
    if (Tw = !1,
    oy("after", r),
    rE === 0)
        return oy("tail", r),
        zb = !1,
        cancelAnimationFrame(jO)
}
function Ew(r, e=1) {
    var t;
    if (!r)
        return dp.forEach(n => Ew(n.store.getState(), e));
    (t = r.gl.xr) != null && t.isPresenting || !r.internal.active || r.frameloop === "never" || (e > 1 ? r.internal.frames = Math.min(60, r.internal.frames + e) : Tw ? r.internal.frames = 2 : r.internal.frames = 1,
    zb || (zb = !0,
    requestAnimationFrame(Yz)))
}
function WO(r, e=!0, t, n) {
    if (e && oy("before", r),
    t)
        Mw(r, t, n);
    else
        for (const i of dp.values())
            Mw(r, i.store.getState());
    e && oy("after", r)
}
const aE = {
    onClick: ["click", !1],
    onContextMenu: ["contextmenu", !1],
    onDoubleClick: ["dblclick", !1],
    onWheel: ["wheel", !0],
    onPointerDown: ["pointerdown", !0],
    onPointerUp: ["pointerup", !0],
    onPointerLeave: ["pointerleave", !0],
    onPointerMove: ["pointermove", !0],
    onPointerCancel: ["pointercancel", !0],
    onLostPointerCapture: ["lostpointercapture", !0]
};
function FJ(r) {
    const {handlePointer: e} = yJ(r);
    return {
        priority: 1,
        enabled: !0,
        compute(t, n, i) {
            n.pointer.set(t.offsetX / n.size.width * 2 - 1, -(t.offsetY / n.size.height) * 2 + 1),
            n.raycaster.setFromCamera(n.pointer, n.camera)
        },
        connected: void 0,
        handlers: Object.keys(aE).reduce( (t, n) => ({
            ...t,
            [n]: e(n)
        }), {}),
        update: () => {
            var t;
            const {events: n, internal: i} = r.getState();
            (t = i.lastEvent) != null && t.current && n.handlers && n.handlers.onPointerMove(i.lastEvent.current)
        }
        ,
        connect: t => {
            const {set: n, events: i} = r.getState();
            if (i.disconnect == null || i.disconnect(),
            n(a => ({
                events: {
                    ...a.events,
                    connected: t
                }
            })),
            i.handlers)
                for (const a in i.handlers) {
                    const s = i.handlers[a]
                      , [l,u] = aE[a];
                    t.addEventListener(l, s, {
                        passive: u
                    })
                }
        }
        ,
        disconnect: () => {
            const {set: t, events: n} = r.getState();
            if (n.connected) {
                if (n.handlers)
                    for (const i in n.handlers) {
                        const a = n.handlers[i]
                          , [s] = aE[i];
                        n.connected.removeEventListener(s, a)
                    }
                t(i => ({
                    events: {
                        ...i.events,
                        connected: void 0
                    }
                }))
            }
        }
    }
}
function YO(r, e) {
    let t;
    return (...n) => {
        window.clearTimeout(t),
        t = window.setTimeout( () => r(...n), e)
    }
}
function HJ({debounce: r, scroll: e, polyfill: t, offsetSize: n}={
    debounce: 0,
    scroll: !1,
    offsetSize: !1
}) {
    const i = t || (typeof window > "u" ? class {
    }
    : window.ResizeObserver);
    if (!i)
        throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
    const [a,s] = de.useState({
        left: 0,
        top: 0,
        width: 0,
        height: 0,
        bottom: 0,
        right: 0,
        x: 0,
        y: 0
    })
      , l = de.useRef({
        element: null,
        scrollContainers: null,
        resizeObserver: null,
        lastBounds: a,
        orientationHandler: null
    })
      , u = r ? typeof r == "number" ? r : r.scroll : null
      , f = r ? typeof r == "number" ? r : r.resize : null
      , d = de.useRef(!1);
    de.useEffect( () => (d.current = !0,
    () => void (d.current = !1)));
    const [g,v,y] = de.useMemo( () => {
        const b = () => {
            if (!l.current.element)
                return;
            const {left: A, top: C, width: R, height: O, bottom: L, right: z, x: I, y: N} = l.current.element.getBoundingClientRect()
              , P = {
                left: A,
                top: C,
                width: R,
                height: O,
                bottom: L,
                right: z,
                x: I,
                y: N
            };
            l.current.element instanceof HTMLElement && n && (P.height = l.current.element.offsetHeight,
            P.width = l.current.element.offsetWidth),
            Object.freeze(P),
            d.current && !XJ(l.current.lastBounds, P) && s(l.current.lastBounds = P)
        }
        ;
        return [b, f ? YO(b, f) : b, u ? YO(b, u) : b]
    }
    , [s, n, u, f]);
    function S() {
        l.current.scrollContainers && (l.current.scrollContainers.forEach(b => b.removeEventListener("scroll", y, !0)),
        l.current.scrollContainers = null),
        l.current.resizeObserver && (l.current.resizeObserver.disconnect(),
        l.current.resizeObserver = null),
        l.current.orientationHandler && ("orientation"in screen && "removeEventListener"in screen.orientation ? screen.orientation.removeEventListener("change", l.current.orientationHandler) : "onorientationchange"in window && window.removeEventListener("orientationchange", l.current.orientationHandler))
    }
    function T() {
        l.current.element && (l.current.resizeObserver = new i(y),
        l.current.resizeObserver.observe(l.current.element),
        e && l.current.scrollContainers && l.current.scrollContainers.forEach(b => b.addEventListener("scroll", y, {
            capture: !0,
            passive: !0
        })),
        l.current.orientationHandler = () => {
            y()
        }
        ,
        "orientation"in screen && "addEventListener"in screen.orientation ? screen.orientation.addEventListener("change", l.current.orientationHandler) : "onorientationchange"in window && window.addEventListener("orientationchange", l.current.orientationHandler))
    }
    const M = b => {
        !b || b === l.current.element || (S(),
        l.current.element = b,
        l.current.scrollContainers = qz(b),
        T())
    }
    ;
    return kJ(y, !!e),
    VJ(v),
    de.useEffect( () => {
        S(),
        T()
    }
    , [e, y, v]),
    de.useEffect( () => S, []),
    [M, a, g]
}
function VJ(r) {
    de.useEffect( () => {
        const e = r;
        return window.addEventListener("resize", e),
        () => void window.removeEventListener("resize", e)
    }
    , [r])
}
function kJ(r, e) {
    de.useEffect( () => {
        if (e) {
            const t = r;
            return window.addEventListener("scroll", t, {
                capture: !0,
                passive: !0
            }),
            () => void window.removeEventListener("scroll", t, !0)
        }
    }
    , [r, e])
}
function qz(r) {
    const e = [];
    if (!r || r === document.body)
        return e;
    const {overflow: t, overflowX: n, overflowY: i} = window.getComputedStyle(r);
    return [t, n, i].some(a => a === "auto" || a === "scroll") && e.push(r),
    [...e, ...qz(r.parentElement)]
}
const GJ = ["x", "y", "top", "bottom", "left", "right", "width", "height"]
  , XJ = (r, e) => GJ.every(t => r[t] === e[t]);
function jJ({ref: r, children: e, fallback: t, resize: n, style: i, gl: a, events: s=FJ, eventSource: l, eventPrefix: u, shadows: f, linear: d, flat: g, legacy: v, orthographic: y, frameloop: S, dpr: T, performance: M, raycaster: b, camera: A, scene: C, onPointerMissed: R, onCreated: O, ...L}) {
    de.useMemo( () => kz(NQ), []);
    const z = oJ()
      , [I,N] = HJ({
        scroll: !0,
        debounce: {
            scroll: 50,
            resize: 0
        },
        ...n
    })
      , P = de.useRef(null)
      , Y = de.useRef(null);
    de.useImperativeHandle(r, () => P.current);
    const V = HC(R)
      , [K,Z] = de.useState(!1)
      , [oe,H] = de.useState(!1);
    if (K)
        throw K;
    if (oe)
        throw oe;
    const q = de.useRef(null);
    M_( () => {
        const se = P.current;
        if (N.width > 0 && N.height > 0 && se) {
            q.current || (q.current = OJ(se));
            async function B() {
                await q.current.configure({
                    gl: a,
                    scene: C,
                    events: s,
                    shadows: f,
                    linear: d,
                    flat: g,
                    legacy: v,
                    orthographic: y,
                    frameloop: S,
                    dpr: T,
                    performance: M,
                    raycaster: b,
                    camera: A,
                    size: N,
                    onPointerMissed: (...W) => V.current == null ? void 0 : V.current(...W),
                    onCreated: W => {
                        W.events.connect == null || W.events.connect(l ? aJ(l) ? l.current : l : Y.current),
                        u && W.setEvents({
                            compute: (te, fe) => {
                                const pe = te[u + "X"]
                                  , _e = te[u + "Y"];
                                fe.pointer.set(pe / fe.size.width * 2 - 1, -(_e / fe.size.height) * 2 + 1),
                                fe.raycaster.setFromCamera(fe.pointer, fe.camera)
                            }
                        }),
                        O == null || O(W)
                    }
                }),
                q.current.render(ae.jsx(z, {
                    children: ae.jsx(uJ, {
                        set: H,
                        children: ae.jsx(de.Suspense, {
                            fallback: ae.jsx(lJ, {
                                set: Z
                            }),
                            children: e ?? null
                        })
                    })
                }))
            }
            B()
        }
    }
    ),
    de.useEffect( () => {
        const se = P.current;
        if (se)
            return () => Wz(se)
    }
    , []);
    const Q = l ? "none" : "auto";
    return ae.jsx("div", {
        ref: Y,
        style: {
            position: "relative",
            width: "100%",
            height: "100%",
            overflow: "hidden",
            pointerEvents: Q,
            ...i
        },
        ...L,
        children: ae.jsx("div", {
            ref: I,
            style: {
                width: "100%",
                height: "100%"
            },
            children: ae.jsx("canvas", {
                ref: P,
                style: {
                    display: "block"
                },
                children: t
            })
        })
    })
}
function XC(r) {
    return ae.jsx(Oz, {
        children: ae.jsx(jJ, {
            ...r
        })
    })
}
function Ib() {
    return Ib = Object.assign ? Object.assign.bind() : function(r) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var n in t)
                ({}).hasOwnProperty.call(t, n) && (r[n] = t[n])
        }
        return r
    }
    ,
    Ib.apply(null, arguments)
}
const Zz = parseInt(u_.replace(/\D+/g, ""));
var nl = Uint8Array
  , uh = Uint16Array
  , ww = Uint32Array
  , Kz = new nl([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
  , Qz = new nl([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
  , WJ = new nl([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  , Jz = function(r, e) {
    for (var t = new uh(31), n = 0; n < 31; ++n)
        t[n] = e += 1 << r[n - 1];
    for (var i = new ww(t[30]), n = 1; n < 30; ++n)
        for (var a = t[n]; a < t[n + 1]; ++a)
            i[a] = a - t[n] << 5 | n;
    return [t, i]
}
  , $z = Jz(Kz, 2)
  , eI = $z[0]
  , YJ = $z[1];
eI[28] = 258,
YJ[258] = 28;
var qJ = Jz(Qz, 0)
  , ZJ = qJ[0]
  , Aw = new uh(32768);
for (var Bi = 0; Bi < 32768; ++Bi) {
    var Qf = (Bi & 43690) >>> 1 | (Bi & 21845) << 1;
    Qf = (Qf & 52428) >>> 2 | (Qf & 13107) << 2,
    Qf = (Qf & 61680) >>> 4 | (Qf & 3855) << 4,
    Aw[Bi] = ((Qf & 65280) >>> 8 | (Qf & 255) << 8) >>> 1
}
var ly = function(r, e, t) {
    for (var n = r.length, i = 0, a = new uh(e); i < n; ++i)
        ++a[r[i] - 1];
    var s = new uh(e);
    for (i = 0; i < e; ++i)
        s[i] = s[i - 1] + a[i - 1] << 1;
    var l;
    if (t) {
        l = new uh(1 << e);
        var u = 15 - e;
        for (i = 0; i < n; ++i)
            if (r[i])
                for (var f = i << 4 | r[i], d = e - r[i], g = s[r[i] - 1]++ << d, v = g | (1 << d) - 1; g <= v; ++g)
                    l[Aw[g] >>> u] = f
    } else
        for (l = new uh(n),
        i = 0; i < n; ++i)
            r[i] && (l[i] = Aw[s[r[i] - 1]++] >>> 15 - r[i]);
    return l
}
  , E_ = new nl(288);
for (var Bi = 0; Bi < 144; ++Bi)
    E_[Bi] = 8;
for (var Bi = 144; Bi < 256; ++Bi)
    E_[Bi] = 9;
for (var Bi = 256; Bi < 280; ++Bi)
    E_[Bi] = 7;
for (var Bi = 280; Bi < 288; ++Bi)
    E_[Bi] = 8;
var tI = new nl(32);
for (var Bi = 0; Bi < 32; ++Bi)
    tI[Bi] = 5;
var KJ = ly(E_, 9, 1)
  , QJ = ly(tI, 5, 1)
  , sE = function(r) {
    for (var e = r[0], t = 1; t < r.length; ++t)
        r[t] > e && (e = r[t]);
    return e
}
  , Gl = function(r, e, t) {
    var n = e / 8 | 0;
    return (r[n] | r[n + 1] << 8) >> (e & 7) & t
}
  , oE = function(r, e) {
    var t = e / 8 | 0;
    return (r[t] | r[t + 1] << 8 | r[t + 2] << 16) >> (e & 7)
}
  , JJ = function(r) {
    return (r / 8 | 0) + (r & 7 && 1)
}
  , $J = function(r, e, t) {
    (t == null || t > r.length) && (t = r.length);
    var n = new (r instanceof uh ? uh : r instanceof ww ? ww : nl)(t - e);
    return n.set(r.subarray(e, t)),
    n
}
  , e$ = function(r, e, t) {
    var n = r.length;
    if (!n || t && !t.l && n < 5)
        return e || new nl(0);
    var i = !e || t
      , a = !t || t.i;
    t || (t = {}),
    e || (e = new nl(n * 3));
    var s = function(ue) {
        var ge = e.length;
        if (ue > ge) {
            var Te = new nl(Math.max(ge * 2, ue));
            Te.set(e),
            e = Te
        }
    }
      , l = t.f || 0
      , u = t.p || 0
      , f = t.b || 0
      , d = t.l
      , g = t.d
      , v = t.m
      , y = t.n
      , S = n * 8;
    do {
        if (!d) {
            t.f = l = Gl(r, u, 1);
            var T = Gl(r, u + 1, 3);
            if (u += 3,
            T)
                if (T == 1)
                    d = KJ,
                    g = QJ,
                    v = 9,
                    y = 5;
                else if (T == 2) {
                    var C = Gl(r, u, 31) + 257
                      , R = Gl(r, u + 10, 15) + 4
                      , O = C + Gl(r, u + 5, 31) + 1;
                    u += 14;
                    for (var L = new nl(O), z = new nl(19), I = 0; I < R; ++I)
                        z[WJ[I]] = Gl(r, u + I * 3, 7);
                    u += R * 3;
                    for (var N = sE(z), P = (1 << N) - 1, Y = ly(z, N, 1), I = 0; I < O; ) {
                        var V = Y[Gl(r, u, P)];
                        u += V & 15;
                        var M = V >>> 4;
                        if (M < 16)
                            L[I++] = M;
                        else {
                            var K = 0
                              , Z = 0;
                            for (M == 16 ? (Z = 3 + Gl(r, u, 3),
                            u += 2,
                            K = L[I - 1]) : M == 17 ? (Z = 3 + Gl(r, u, 7),
                            u += 3) : M == 18 && (Z = 11 + Gl(r, u, 127),
                            u += 7); Z--; )
                                L[I++] = K
                        }
                    }
                    var oe = L.subarray(0, C)
                      , H = L.subarray(C);
                    v = sE(oe),
                    y = sE(H),
                    d = ly(oe, v, 1),
                    g = ly(H, y, 1)
                } else
                    throw "invalid block type";
            else {
                var M = JJ(u) + 4
                  , b = r[M - 4] | r[M - 3] << 8
                  , A = M + b;
                if (A > n) {
                    if (a)
                        throw "unexpected EOF";
                    break
                }
                i && s(f + b),
                e.set(r.subarray(M, A), f),
                t.b = f += b,
                t.p = u = A * 8;
                continue
            }
            if (u > S) {
                if (a)
                    throw "unexpected EOF";
                break
            }
        }
        i && s(f + 131072);
        for (var q = (1 << v) - 1, Q = (1 << y) - 1, se = u; ; se = u) {
            var K = d[oE(r, u) & q]
              , B = K >>> 4;
            if (u += K & 15,
            u > S) {
                if (a)
                    throw "unexpected EOF";
                break
            }
            if (!K)
                throw "invalid length/literal";
            if (B < 256)
                e[f++] = B;
            else if (B == 256) {
                se = u,
                d = null;
                break
            } else {
                var W = B - 254;
                if (B > 264) {
                    var I = B - 257
                      , te = Kz[I];
                    W = Gl(r, u, (1 << te) - 1) + eI[I],
                    u += te
                }
                var fe = g[oE(r, u) & Q]
                  , pe = fe >>> 4;
                if (!fe)
                    throw "invalid distance";
                u += fe & 15;
                var H = ZJ[pe];
                if (pe > 3) {
                    var te = Qz[pe];
                    H += oE(r, u) & (1 << te) - 1,
                    u += te
                }
                if (u > S) {
                    if (a)
                        throw "unexpected EOF";
                    break
                }
                i && s(f + 131072);
                for (var _e = f + W; f < _e; f += 4)
                    e[f] = e[f - H],
                    e[f + 1] = e[f + 1 - H],
                    e[f + 2] = e[f + 2 - H],
                    e[f + 3] = e[f + 3 - H];
                f = _e
            }
        }
        t.l = d,
        t.p = se,
        t.b = f,
        d && (l = 1,
        t.m = v,
        t.d = g,
        t.n = y)
    } while (!l);
    return f == e.length ? e : $J(e, 0, f)
}
  , t$ = new nl(0)
  , n$ = function(r) {
    if ((r[0] & 15) != 8 || r[0] >>> 4 > 7 || (r[0] << 8 | r[1]) % 31)
        throw "invalid zlib data";
    if (r[1] & 32)
        throw "invalid zlib data: preset dictionaries not supported"
};
function jx(r, e) {
    return e$((n$(r),
    r.subarray(2, -4)), e)
}
var i$ = typeof TextDecoder < "u" && new TextDecoder
  , r$ = 0;
try {
    i$.decode(t$, {
        stream: !0
    }),
    r$ = 1
} catch {}
const a$ = r => r && r.isCubeTexture;
class s$ extends Ni {
    constructor(e, t) {
        var n, i;
        const a = a$(e)
          , l = ((i = a ? (n = e.image[0]) == null ? void 0 : n.width : e.image.width) != null ? i : 1024) / 4
          , u = Math.floor(Math.log2(l))
          , f = Math.pow(2, u)
          , d = 3 * Math.max(f, 16 * 7)
          , g = 4 * f
          , v = [a ? "#define ENVMAP_TYPE_CUBE" : "", `#define CUBEUV_TEXEL_WIDTH ${1 / d}`, `#define CUBEUV_TEXEL_HEIGHT ${1 / g}`, `#define CUBEUV_MAX_MIP ${u}.0`]
          , y = `
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `
          , S = v.join(`
`) + `
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${Zz >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
        }
        `
          , T = {
            map: {
                value: e
            },
            height: {
                value: (t == null ? void 0 : t.height) || 15
            },
            radius: {
                value: (t == null ? void 0 : t.radius) || 100
            }
        }
          , M = new y_(1,16)
          , b = new Ks({
            uniforms: T,
            fragmentShader: S,
            vertexShader: y,
            side: tl
        });
        super(M, b)
    }
    set radius(e) {
        this.material.uniforms.radius.value = e
    }
    get radius() {
        return this.material.uniforms.radius.value
    }
    set height(e) {
        this.material.uniforms.height.value = e
    }
    get height() {
        return this.material.uniforms.height.value
    }
}
class o$ extends wC {
    constructor(e) {
        super(e),
        this.type = $r
    }
    parse(e) {
        const s = function(I, N) {
            switch (I) {
            case 1:
                throw new Error("THREE.RGBELoader: Read Error: " + (N || ""));
            case 2:
                throw new Error("THREE.RGBELoader: Write Error: " + (N || ""));
            case 3:
                throw new Error("THREE.RGBELoader: Bad File Format: " + (N || ""));
            default:
            case 4:
                throw new Error("THREE.RGBELoader: Memory Error: " + (N || ""))
            }
        }
          , d = `
`
          , g = function(I, N, P) {
            N = N || 1024;
            let V = I.pos
              , K = -1
              , Z = 0
              , oe = ""
              , H = String.fromCharCode.apply(null, new Uint16Array(I.subarray(V, V + 128)));
            for (; 0 > (K = H.indexOf(d)) && Z < N && V < I.byteLength; )
                oe += H,
                Z += H.length,
                V += 128,
                H += String.fromCharCode.apply(null, new Uint16Array(I.subarray(V, V + 128)));
            return -1 < K ? (I.pos += Z + K + 1,
            oe + H.slice(0, K)) : !1
        }
          , v = function(I) {
            const N = /^#\?(\S+)/
              , P = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/
              , Y = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/
              , V = /^\s*FORMAT=(\S+)\s*$/
              , K = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/
              , Z = {
                valid: 0,
                string: "",
                comments: "",
                programtype: "RGBE",
                format: "",
                gamma: 1,
                exposure: 1,
                width: 0,
                height: 0
            };
            let oe, H;
            for ((I.pos >= I.byteLength || !(oe = g(I))) && s(1, "no header found"),
            (H = oe.match(N)) || s(3, "bad initial token"),
            Z.valid |= 1,
            Z.programtype = H[1],
            Z.string += oe + `
`; oe = g(I),
            oe !== !1; ) {
                if (Z.string += oe + `
`,
                oe.charAt(0) === "#") {
                    Z.comments += oe + `
`;
                    continue
                }
                if ((H = oe.match(P)) && (Z.gamma = parseFloat(H[1])),
                (H = oe.match(Y)) && (Z.exposure = parseFloat(H[1])),
                (H = oe.match(V)) && (Z.valid |= 2,
                Z.format = H[1]),
                (H = oe.match(K)) && (Z.valid |= 4,
                Z.height = parseInt(H[1], 10),
                Z.width = parseInt(H[2], 10)),
                Z.valid & 2 && Z.valid & 4)
                    break
            }
            return Z.valid & 2 || s(3, "missing format specifier"),
            Z.valid & 4 || s(3, "missing image size specifier"),
            Z
        }
          , y = function(I, N, P) {
            const Y = N;
            if (Y < 8 || Y > 32767 || I[0] !== 2 || I[1] !== 2 || I[2] & 128)
                return new Uint8Array(I);
            Y !== (I[2] << 8 | I[3]) && s(3, "wrong scanline width");
            const V = new Uint8Array(4 * N * P);
            V.length || s(4, "unable to allocate buffer space");
            let K = 0
              , Z = 0;
            const oe = 4 * Y
              , H = new Uint8Array(4)
              , q = new Uint8Array(oe);
            let Q = P;
            for (; Q > 0 && Z < I.byteLength; ) {
                Z + 4 > I.byteLength && s(1),
                H[0] = I[Z++],
                H[1] = I[Z++],
                H[2] = I[Z++],
                H[3] = I[Z++],
                (H[0] != 2 || H[1] != 2 || (H[2] << 8 | H[3]) != Y) && s(3, "bad rgbe scanline format");
                let se = 0, B;
                for (; se < oe && Z < I.byteLength; ) {
                    B = I[Z++];
                    const te = B > 128;
                    if (te && (B -= 128),
                    (B === 0 || se + B > oe) && s(3, "bad scanline data"),
                    te) {
                        const fe = I[Z++];
                        for (let pe = 0; pe < B; pe++)
                            q[se++] = fe
                    } else
                        q.set(I.subarray(Z, Z + B), se),
                        se += B,
                        Z += B
                }
                const W = Y;
                for (let te = 0; te < W; te++) {
                    let fe = 0;
                    V[K] = q[te + fe],
                    fe += Y,
                    V[K + 1] = q[te + fe],
                    fe += Y,
                    V[K + 2] = q[te + fe],
                    fe += Y,
                    V[K + 3] = q[te + fe],
                    K += 4
                }
                Q--
            }
            return V
        }
          , S = function(I, N, P, Y) {
            const V = I[N + 3]
              , K = Math.pow(2, V - 128) / 255;
            P[Y + 0] = I[N + 0] * K,
            P[Y + 1] = I[N + 1] * K,
            P[Y + 2] = I[N + 2] * K,
            P[Y + 3] = 1
        }
          , T = function(I, N, P, Y) {
            const V = I[N + 3]
              , K = Math.pow(2, V - 128) / 255;
            P[Y + 0] = jd.toHalfFloat(Math.min(I[N + 0] * K, 65504)),
            P[Y + 1] = jd.toHalfFloat(Math.min(I[N + 1] * K, 65504)),
            P[Y + 2] = jd.toHalfFloat(Math.min(I[N + 2] * K, 65504)),
            P[Y + 3] = jd.toHalfFloat(1)
        }
          , M = new Uint8Array(e);
        M.pos = 0;
        const b = v(M)
          , A = b.width
          , C = b.height
          , R = y(M.subarray(M.pos), A, C);
        let O, L, z;
        switch (this.type) {
        case tr:
            z = R.length / 4;
            const I = new Float32Array(z * 4);
            for (let P = 0; P < z; P++)
                S(R, P * 4, I, P * 4);
            O = I,
            L = tr;
            break;
        case $r:
            z = R.length / 4;
            const N = new Uint16Array(z * 4);
            for (let P = 0; P < z; P++)
                T(R, P * 4, N, P * 4);
            O = N,
            L = $r;
            break;
        default:
            throw new Error("THREE.RGBELoader: Unsupported type: " + this.type)
        }
        return {
            width: A,
            height: C,
            data: O,
            header: b.string,
            gamma: b.gamma,
            exposure: b.exposure,
            type: L
        }
    }
    setDataType(e) {
        return this.type = e,
        this
    }
    load(e, t, n, i) {
        function a(s, l) {
            switch (s.type) {
            case tr:
            case $r:
                "colorSpace"in s ? s.colorSpace = "srgb-linear" : s.encoding = 3e3,
                s.minFilter = fi,
                s.magFilter = fi,
                s.generateMipmaps = !1,
                s.flipY = !0;
                break
            }
            t && t(s, l)
        }
        return super.load(e, a, n, i)
    }
}
const Tv = Zz >= 152;
class l$ extends wC {
    constructor(e) {
        super(e),
        this.type = $r
    }
    parse(e) {
        const N = Math.pow(2.7182818, 2.2);
        function P(k, $) {
            for (var Se = 0, Ue = 0; Ue < 65536; ++Ue)
                (Ue == 0 || k[Ue >> 3] & 1 << (Ue & 7)) && ($[Se++] = Ue);
            for (var Fe = Se - 1; Se < 65536; )
                $[Se++] = 0;
            return Fe
        }
        function Y(k) {
            for (var $ = 0; $ < 16384; $++)
                k[$] = {},
                k[$].len = 0,
                k[$].lit = 0,
                k[$].p = null
        }
        const V = {
            l: 0,
            c: 0,
            lc: 0
        };
        function K(k, $, Se, Ue, Fe) {
            for (; Se < k; )
                $ = $ << 8 | ct(Ue, Fe),
                Se += 8;
            Se -= k,
            V.l = $ >> Se & (1 << k) - 1,
            V.c = $,
            V.lc = Se
        }
        const Z = new Array(59);
        function oe(k) {
            for (var $ = 0; $ <= 58; ++$)
                Z[$] = 0;
            for (var $ = 0; $ < 65537; ++$)
                Z[k[$]] += 1;
            for (var Se = 0, $ = 58; $ > 0; --$) {
                var Ue = Se + Z[$] >> 1;
                Z[$] = Se,
                Se = Ue
            }
            for (var $ = 0; $ < 65537; ++$) {
                var Fe = k[$];
                Fe > 0 && (k[$] = Fe | Z[Fe]++ << 6)
            }
        }
        function H(k, $, Se, Ue, Fe, Ke, yt) {
            for (var G = Se, ce = 0, ye = 0; Fe <= Ke; Fe++) {
                if (G.value - Se.value > Ue)
                    return !1;
                K(6, ce, ye, k, G);
                var xe = V.l;
                if (ce = V.c,
                ye = V.lc,
                yt[Fe] = xe,
                xe == 63) {
                    if (G.value - Se.value > Ue)
                        throw "Something wrong with hufUnpackEncTable";
                    K(8, ce, ye, k, G);
                    var ne = V.l + 6;
                    if (ce = V.c,
                    ye = V.lc,
                    Fe + ne > Ke + 1)
                        throw "Something wrong with hufUnpackEncTable";
                    for (; ne--; )
                        yt[Fe++] = 0;
                    Fe--
                } else if (xe >= 59) {
                    var ne = xe - 59 + 2;
                    if (Fe + ne > Ke + 1)
                        throw "Something wrong with hufUnpackEncTable";
                    for (; ne--; )
                        yt[Fe++] = 0;
                    Fe--
                }
            }
            oe(yt)
        }
        function q(k) {
            return k & 63
        }
        function Q(k) {
            return k >> 6
        }
        function se(k, $, Se, Ue) {
            for (; $ <= Se; $++) {
                var Fe = Q(k[$])
                  , Ke = q(k[$]);
                if (Fe >> Ke)
                    throw "Invalid table entry";
                if (Ke > 14) {
                    var yt = Ue[Fe >> Ke - 14];
                    if (yt.len)
                        throw "Invalid table entry";
                    if (yt.lit++,
                    yt.p) {
                        var G = yt.p;
                        yt.p = new Array(yt.lit);
                        for (var ce = 0; ce < yt.lit - 1; ++ce)
                            yt.p[ce] = G[ce]
                    } else
                        yt.p = new Array(1);
                    yt.p[yt.lit - 1] = $
                } else if (Ke)
                    for (var ye = 0, ce = 1 << 14 - Ke; ce > 0; ce--) {
                        var yt = Ue[(Fe << 14 - Ke) + ye];
                        if (yt.len || yt.p)
                            throw "Invalid table entry";
                        yt.len = Ke,
                        yt.lit = $,
                        ye++
                    }
            }
            return !0
        }
        const B = {
            c: 0,
            lc: 0
        };
        function W(k, $, Se, Ue) {
            k = k << 8 | ct(Se, Ue),
            $ += 8,
            B.c = k,
            B.lc = $
        }
        const te = {
            c: 0,
            lc: 0
        };
        function fe(k, $, Se, Ue, Fe, Ke, yt, G, ce, ye) {
            if (k == $) {
                Ue < 8 && (W(Se, Ue, Fe, yt),
                Se = B.c,
                Ue = B.lc),
                Ue -= 8;
                var xe = Se >> Ue
                  , xe = new Uint8Array([xe])[0];
                if (ce.value + xe > ye)
                    return !1;
                for (var ne = G[ce.value - 1]; xe-- > 0; )
                    G[ce.value++] = ne
            } else if (ce.value < ye)
                G[ce.value++] = k;
            else
                return !1;
            te.c = Se,
            te.lc = Ue
        }
        function pe(k) {
            return k & 65535
        }
        function _e(k) {
            var $ = pe(k);
            return $ > 32767 ? $ - 65536 : $
        }
        const ue = {
            a: 0,
            b: 0
        };
        function ge(k, $) {
            var Se = _e(k)
              , Ue = _e($)
              , Fe = Ue
              , Ke = Se + (Fe & 1) + (Fe >> 1)
              , yt = Ke
              , G = Ke - Fe;
            ue.a = yt,
            ue.b = G
        }
        function Te(k, $) {
            var Se = pe(k)
              , Ue = pe($)
              , Fe = Se - (Ue >> 1) & 65535
              , Ke = Ue + Fe - 32768 & 65535;
            ue.a = Ke,
            ue.b = Fe
        }
        function Ze(k, $, Se, Ue, Fe, Ke, yt) {
            for (var G = yt < 16384, ce = Se > Fe ? Fe : Se, ye = 1, xe; ye <= ce; )
                ye <<= 1;
            for (ye >>= 1,
            xe = ye,
            ye >>= 1; ye >= 1; ) {
                for (var ne = 0, nt = ne + Ke * (Fe - xe), We = Ke * ye, st = Ke * xe, ft = Ue * ye, Tt = Ue * xe, At, Et, Xt, Jt; ne <= nt; ne += st) {
                    for (var en = ne, Sn = ne + Ue * (Se - xe); en <= Sn; en += Tt) {
                        var Vt = en + ft
                          , It = en + We
                          , Cn = It + ft;
                        G ? (ge(k[en + $], k[It + $]),
                        At = ue.a,
                        Xt = ue.b,
                        ge(k[Vt + $], k[Cn + $]),
                        Et = ue.a,
                        Jt = ue.b,
                        ge(At, Et),
                        k[en + $] = ue.a,
                        k[Vt + $] = ue.b,
                        ge(Xt, Jt),
                        k[It + $] = ue.a,
                        k[Cn + $] = ue.b) : (Te(k[en + $], k[It + $]),
                        At = ue.a,
                        Xt = ue.b,
                        Te(k[Vt + $], k[Cn + $]),
                        Et = ue.a,
                        Jt = ue.b,
                        Te(At, Et),
                        k[en + $] = ue.a,
                        k[Vt + $] = ue.b,
                        Te(Xt, Jt),
                        k[It + $] = ue.a,
                        k[Cn + $] = ue.b)
                    }
                    if (Se & ye) {
                        var It = en + We;
                        G ? ge(k[en + $], k[It + $]) : Te(k[en + $], k[It + $]),
                        At = ue.a,
                        k[It + $] = ue.b,
                        k[en + $] = At
                    }
                }
                if (Fe & ye)
                    for (var en = ne, Sn = ne + Ue * (Se - xe); en <= Sn; en += Tt) {
                        var Vt = en + ft;
                        G ? ge(k[en + $], k[Vt + $]) : Te(k[en + $], k[Vt + $]),
                        At = ue.a,
                        k[Vt + $] = ue.b,
                        k[en + $] = At
                    }
                xe = ye,
                ye >>= 1
            }
            return ne
        }
        function ot(k, $, Se, Ue, Fe, Ke, yt, G, ce, ye) {
            for (var xe = 0, ne = 0, nt = G, We = Math.trunc(Fe.value + (Ke + 7) / 8); Fe.value < We; )
                for (W(xe, ne, Se, Fe),
                xe = B.c,
                ne = B.lc; ne >= 14; ) {
                    var st = xe >> ne - 14 & 16383
                      , ft = $[st];
                    if (ft.len)
                        ne -= ft.len,
                        fe(ft.lit, yt, xe, ne, Se, Ue, Fe, ce, ye, nt),
                        xe = te.c,
                        ne = te.lc;
                    else {
                        if (!ft.p)
                            throw "hufDecode issues";
                        var Tt;
                        for (Tt = 0; Tt < ft.lit; Tt++) {
                            for (var At = q(k[ft.p[Tt]]); ne < At && Fe.value < We; )
                                W(xe, ne, Se, Fe),
                                xe = B.c,
                                ne = B.lc;
                            if (ne >= At && Q(k[ft.p[Tt]]) == (xe >> ne - At & (1 << At) - 1)) {
                                ne -= At,
                                fe(ft.p[Tt], yt, xe, ne, Se, Ue, Fe, ce, ye, nt),
                                xe = te.c,
                                ne = te.lc;
                                break
                            }
                        }
                        if (Tt == ft.lit)
                            throw "hufDecode issues"
                    }
                }
            var Et = 8 - Ke & 7;
            for (xe >>= Et,
            ne -= Et; ne > 0; ) {
                var ft = $[xe << 14 - ne & 16383];
                if (ft.len)
                    ne -= ft.len,
                    fe(ft.lit, yt, xe, ne, Se, Ue, Fe, ce, ye, nt),
                    xe = te.c,
                    ne = te.lc;
                else
                    throw "hufDecode issues"
            }
            return !0
        }
        function tt(k, $, Se, Ue, Fe, Ke) {
            var yt = {
                value: 0
            }
              , G = Se.value
              , ce = Ye($, Se)
              , ye = Ye($, Se);
            Se.value += 4;
            var xe = Ye($, Se);
            if (Se.value += 4,
            ce < 0 || ce >= 65537 || ye < 0 || ye >= 65537)
                throw "Something wrong with HUF_ENCSIZE";
            var ne = new Array(65537)
              , nt = new Array(16384);
            Y(nt);
            var We = Ue - (Se.value - G);
            if (H(k, $, Se, We, ce, ye, ne),
            xe > 8 * (Ue - (Se.value - G)))
                throw "Something wrong with hufUncompress";
            se(ne, ce, ye, nt),
            ot(ne, nt, k, $, Se, xe, ye, Ke, Fe, yt)
        }
        function $e(k, $, Se) {
            for (var Ue = 0; Ue < Se; ++Ue)
                $[Ue] = k[$[Ue]]
        }
        function re(k) {
            for (var $ = 1; $ < k.length; $++) {
                var Se = k[$ - 1] + k[$] - 128;
                k[$] = Se
            }
        }
        function Le(k, $) {
            for (var Se = 0, Ue = Math.floor((k.length + 1) / 2), Fe = 0, Ke = k.length - 1; !(Fe > Ke || ($[Fe++] = k[Se++],
            Fe > Ke)); )
                $[Fe++] = k[Ue++]
        }
        function Ne(k) {
            for (var $ = k.byteLength, Se = new Array, Ue = 0, Fe = new DataView(k); $ > 0; ) {
                var Ke = Fe.getInt8(Ue++);
                if (Ke < 0) {
                    var yt = -Ke;
                    $ -= yt + 1;
                    for (var G = 0; G < yt; G++)
                        Se.push(Fe.getUint8(Ue++))
                } else {
                    var yt = Ke;
                    $ -= 2;
                    for (var ce = Fe.getUint8(Ue++), G = 0; G < yt + 1; G++)
                        Se.push(ce)
                }
            }
            return Se
        }
        function Oe(k, $, Se, Ue, Fe, Ke) {
            var Vt = new DataView(Ke.buffer)
              , yt = Se[k.idx[0]].width
              , G = Se[k.idx[0]].height
              , ce = 3
              , ye = Math.floor(yt / 8)
              , xe = Math.ceil(yt / 8)
              , ne = Math.ceil(G / 8)
              , nt = yt - (xe - 1) * 8
              , We = G - (ne - 1) * 8
              , st = {
                value: 0
            }
              , ft = new Array(ce)
              , Tt = new Array(ce)
              , At = new Array(ce)
              , Et = new Array(ce)
              , Xt = new Array(ce);
            for (let xn = 0; xn < ce; ++xn)
                Xt[xn] = $[k.idx[xn]],
                ft[xn] = xn < 1 ? 0 : ft[xn - 1] + xe * ne,
                Tt[xn] = new Float32Array(64),
                At[xn] = new Uint16Array(64),
                Et[xn] = new Uint16Array(xe * 64);
            for (let xn = 0; xn < ne; ++xn) {
                var Jt = 8;
                xn == ne - 1 && (Jt = We);
                var en = 8;
                for (let hn = 0; hn < xe; ++hn) {
                    hn == xe - 1 && (en = nt);
                    for (let Yt = 0; Yt < ce; ++Yt)
                        At[Yt].fill(0),
                        At[Yt][0] = Fe[ft[Yt]++],
                        le(st, Ue, At[Yt]),
                        Pe(At[Yt], Tt[Yt]),
                        He(Tt[Yt]);
                    Ve(Tt);
                    for (let Yt = 0; Yt < ce; ++Yt)
                        De(Tt[Yt], Et[Yt], hn * 64)
                }
                let Bn = 0;
                for (let hn = 0; hn < ce; ++hn) {
                    const Yt = Se[k.idx[hn]].type;
                    for (let ti = 8 * xn; ti < 8 * xn + Jt; ++ti) {
                        Bn = Xt[hn][ti];
                        for (let ri = 0; ri < ye; ++ri) {
                            const bn = ri * 64 + (ti & 7) * 8;
                            Vt.setUint16(Bn + 0 * 2 * Yt, Et[hn][bn + 0], !0),
                            Vt.setUint16(Bn + 1 * 2 * Yt, Et[hn][bn + 1], !0),
                            Vt.setUint16(Bn + 2 * 2 * Yt, Et[hn][bn + 2], !0),
                            Vt.setUint16(Bn + 3 * 2 * Yt, Et[hn][bn + 3], !0),
                            Vt.setUint16(Bn + 4 * 2 * Yt, Et[hn][bn + 4], !0),
                            Vt.setUint16(Bn + 5 * 2 * Yt, Et[hn][bn + 5], !0),
                            Vt.setUint16(Bn + 6 * 2 * Yt, Et[hn][bn + 6], !0),
                            Vt.setUint16(Bn + 7 * 2 * Yt, Et[hn][bn + 7], !0),
                            Bn += 8 * 2 * Yt
                        }
                    }
                    if (ye != xe)
                        for (let ti = 8 * xn; ti < 8 * xn + Jt; ++ti) {
                            const ri = Xt[hn][ti] + 8 * ye * 2 * Yt
                              , bn = ye * 64 + (ti & 7) * 8;
                            for (let ui = 0; ui < en; ++ui)
                                Vt.setUint16(ri + ui * 2 * Yt, Et[hn][bn + ui], !0)
                        }
                }
            }
            for (var Sn = new Uint16Array(yt), Vt = new DataView(Ke.buffer), It = 0; It < ce; ++It) {
                Se[k.idx[It]].decoded = !0;
                var Cn = Se[k.idx[It]].type;
                if (Se[It].type == 2)
                    for (var fn = 0; fn < G; ++fn) {
                        const xn = Xt[It][fn];
                        for (var In = 0; In < yt; ++In)
                            Sn[In] = Vt.getUint16(xn + In * 2 * Cn, !0);
                        for (var In = 0; In < yt; ++In)
                            Vt.setFloat32(xn + In * 2 * Cn, Ee(Sn[In]), !0)
                    }
            }
        }
        function le(k, $, Se) {
            for (var Ue, Fe = 1; Fe < 64; )
                Ue = $[k.value],
                Ue == 65280 ? Fe = 64 : Ue >> 8 == 255 ? Fe += Ue & 255 : (Se[Fe] = Ue,
                Fe++),
                k.value++
        }
        function Pe(k, $) {
            $[0] = Ee(k[0]),
            $[1] = Ee(k[1]),
            $[2] = Ee(k[5]),
            $[3] = Ee(k[6]),
            $[4] = Ee(k[14]),
            $[5] = Ee(k[15]),
            $[6] = Ee(k[27]),
            $[7] = Ee(k[28]),
            $[8] = Ee(k[2]),
            $[9] = Ee(k[4]),
            $[10] = Ee(k[7]),
            $[11] = Ee(k[13]),
            $[12] = Ee(k[16]),
            $[13] = Ee(k[26]),
            $[14] = Ee(k[29]),
            $[15] = Ee(k[42]),
            $[16] = Ee(k[3]),
            $[17] = Ee(k[8]),
            $[18] = Ee(k[12]),
            $[19] = Ee(k[17]),
            $[20] = Ee(k[25]),
            $[21] = Ee(k[30]),
            $[22] = Ee(k[41]),
            $[23] = Ee(k[43]),
            $[24] = Ee(k[9]),
            $[25] = Ee(k[11]),
            $[26] = Ee(k[18]),
            $[27] = Ee(k[24]),
            $[28] = Ee(k[31]),
            $[29] = Ee(k[40]),
            $[30] = Ee(k[44]),
            $[31] = Ee(k[53]),
            $[32] = Ee(k[10]),
            $[33] = Ee(k[19]),
            $[34] = Ee(k[23]),
            $[35] = Ee(k[32]),
            $[36] = Ee(k[39]),
            $[37] = Ee(k[45]),
            $[38] = Ee(k[52]),
            $[39] = Ee(k[54]),
            $[40] = Ee(k[20]),
            $[41] = Ee(k[22]),
            $[42] = Ee(k[33]),
            $[43] = Ee(k[38]),
            $[44] = Ee(k[46]),
            $[45] = Ee(k[51]),
            $[46] = Ee(k[55]),
            $[47] = Ee(k[60]),
            $[48] = Ee(k[21]),
            $[49] = Ee(k[34]),
            $[50] = Ee(k[37]),
            $[51] = Ee(k[47]),
            $[52] = Ee(k[50]),
            $[53] = Ee(k[56]),
            $[54] = Ee(k[59]),
            $[55] = Ee(k[61]),
            $[56] = Ee(k[35]),
            $[57] = Ee(k[36]),
            $[58] = Ee(k[48]),
            $[59] = Ee(k[49]),
            $[60] = Ee(k[57]),
            $[61] = Ee(k[58]),
            $[62] = Ee(k[62]),
            $[63] = Ee(k[63])
        }
        function He(k) {
            const $ = .5 * Math.cos(.7853975)
              , Se = .5 * Math.cos(3.14159 / 16)
              , Ue = .5 * Math.cos(3.14159 / 8)
              , Fe = .5 * Math.cos(3 * 3.14159 / 16)
              , Ke = .5 * Math.cos(5 * 3.14159 / 16)
              , yt = .5 * Math.cos(3 * 3.14159 / 8)
              , G = .5 * Math.cos(7 * 3.14159 / 16);
            for (var ce = new Array(4), ye = new Array(4), xe = new Array(4), ne = new Array(4), nt = 0; nt < 8; ++nt) {
                var We = nt * 8;
                ce[0] = Ue * k[We + 2],
                ce[1] = yt * k[We + 2],
                ce[2] = Ue * k[We + 6],
                ce[3] = yt * k[We + 6],
                ye[0] = Se * k[We + 1] + Fe * k[We + 3] + Ke * k[We + 5] + G * k[We + 7],
                ye[1] = Fe * k[We + 1] - G * k[We + 3] - Se * k[We + 5] - Ke * k[We + 7],
                ye[2] = Ke * k[We + 1] - Se * k[We + 3] + G * k[We + 5] + Fe * k[We + 7],
                ye[3] = G * k[We + 1] - Ke * k[We + 3] + Fe * k[We + 5] - Se * k[We + 7],
                xe[0] = $ * (k[We + 0] + k[We + 4]),
                xe[3] = $ * (k[We + 0] - k[We + 4]),
                xe[1] = ce[0] + ce[3],
                xe[2] = ce[1] - ce[2],
                ne[0] = xe[0] + xe[1],
                ne[1] = xe[3] + xe[2],
                ne[2] = xe[3] - xe[2],
                ne[3] = xe[0] - xe[1],
                k[We + 0] = ne[0] + ye[0],
                k[We + 1] = ne[1] + ye[1],
                k[We + 2] = ne[2] + ye[2],
                k[We + 3] = ne[3] + ye[3],
                k[We + 4] = ne[3] - ye[3],
                k[We + 5] = ne[2] - ye[2],
                k[We + 6] = ne[1] - ye[1],
                k[We + 7] = ne[0] - ye[0]
            }
            for (var st = 0; st < 8; ++st)
                ce[0] = Ue * k[16 + st],
                ce[1] = yt * k[16 + st],
                ce[2] = Ue * k[48 + st],
                ce[3] = yt * k[48 + st],
                ye[0] = Se * k[8 + st] + Fe * k[24 + st] + Ke * k[40 + st] + G * k[56 + st],
                ye[1] = Fe * k[8 + st] - G * k[24 + st] - Se * k[40 + st] - Ke * k[56 + st],
                ye[2] = Ke * k[8 + st] - Se * k[24 + st] + G * k[40 + st] + Fe * k[56 + st],
                ye[3] = G * k[8 + st] - Ke * k[24 + st] + Fe * k[40 + st] - Se * k[56 + st],
                xe[0] = $ * (k[st] + k[32 + st]),
                xe[3] = $ * (k[st] - k[32 + st]),
                xe[1] = ce[0] + ce[3],
                xe[2] = ce[1] - ce[2],
                ne[0] = xe[0] + xe[1],
                ne[1] = xe[3] + xe[2],
                ne[2] = xe[3] - xe[2],
                ne[3] = xe[0] - xe[1],
                k[0 + st] = ne[0] + ye[0],
                k[8 + st] = ne[1] + ye[1],
                k[16 + st] = ne[2] + ye[2],
                k[24 + st] = ne[3] + ye[3],
                k[32 + st] = ne[3] - ye[3],
                k[40 + st] = ne[2] - ye[2],
                k[48 + st] = ne[1] - ye[1],
                k[56 + st] = ne[0] - ye[0]
        }
        function Ve(k) {
            for (var $ = 0; $ < 64; ++$) {
                var Se = k[0][$]
                  , Ue = k[1][$]
                  , Fe = k[2][$];
                k[0][$] = Se + 1.5747 * Fe,
                k[1][$] = Se - .1873 * Ue - .4682 * Fe,
                k[2][$] = Se + 1.8556 * Ue
            }
        }
        function De(k, $, Se) {
            for (var Ue = 0; Ue < 64; ++Ue)
                $[Se + Ue] = jd.toHalfFloat(vt(k[Ue]))
        }
        function vt(k) {
            return k <= 1 ? Math.sign(k) * Math.pow(Math.abs(k), 2.2) : Math.sign(k) * Math.pow(N, Math.abs(k) - 1)
        }
        function J(k) {
            return new DataView(k.array.buffer,k.offset.value,k.size)
        }
        function j(k) {
            var $ = k.viewer.buffer.slice(k.offset.value, k.offset.value + k.size)
              , Se = new Uint8Array(Ne($))
              , Ue = new Uint8Array(Se.length);
            return re(Se),
            Le(Se, Ue),
            new DataView(Ue.buffer)
        }
        function ve(k) {
            var $ = k.array.slice(k.offset.value, k.offset.value + k.size)
              , Se = jx($)
              , Ue = new Uint8Array(Se.length);
            return re(Se),
            Le(Se, Ue),
            new DataView(Ue.buffer)
        }
        function Be(k) {
            for (var $ = k.viewer, Se = {
                value: k.offset.value
            }, Ue = new Uint16Array(k.width * k.scanlineBlockSize * (k.channels * k.type)), Fe = new Uint8Array(8192), Ke = 0, yt = new Array(k.channels), G = 0; G < k.channels; G++)
                yt[G] = {},
                yt[G].start = Ke,
                yt[G].end = yt[G].start,
                yt[G].nx = k.width,
                yt[G].ny = k.lines,
                yt[G].size = k.type,
                Ke += yt[G].nx * yt[G].ny * yt[G].size;
            var ce = at($, Se)
              , ye = at($, Se);
            if (ye >= 8192)
                throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
            if (ce <= ye)
                for (var G = 0; G < ye - ce + 1; G++)
                    Fe[G + ce] = _t($, Se);
            var xe = new Uint16Array(65536)
              , ne = P(Fe, xe)
              , nt = Ye($, Se);
            tt(k.array, $, Se, nt, Ue, Ke);
            for (var G = 0; G < k.channels; ++G)
                for (var We = yt[G], st = 0; st < yt[G].size; ++st)
                    Ze(Ue, We.start + st, We.nx, We.size, We.ny, We.nx * We.size, ne);
            $e(xe, Ue, Ke);
            for (var ft = 0, Tt = new Uint8Array(Ue.buffer.byteLength), At = 0; At < k.lines; At++)
                for (var Et = 0; Et < k.channels; Et++) {
                    var We = yt[Et]
                      , Xt = We.nx * We.size
                      , Jt = new Uint8Array(Ue.buffer,We.end * 2,Xt * 2);
                    Tt.set(Jt, ft),
                    ft += Xt * 2,
                    We.end += Xt
                }
            return new DataView(Tt.buffer)
        }
        function we(k) {
            var $ = k.array.slice(k.offset.value, k.offset.value + k.size)
              , Se = jx($);
            const Ue = k.lines * k.channels * k.width
              , Fe = k.type == 1 ? new Uint16Array(Ue) : new Uint32Array(Ue);
            let Ke = 0
              , yt = 0;
            const G = new Array(4);
            for (let ce = 0; ce < k.lines; ce++)
                for (let ye = 0; ye < k.channels; ye++) {
                    let xe = 0;
                    switch (k.type) {
                    case 1:
                        G[0] = Ke,
                        G[1] = G[0] + k.width,
                        Ke = G[1] + k.width;
                        for (let ne = 0; ne < k.width; ++ne) {
                            const nt = Se[G[0]++] << 8 | Se[G[1]++];
                            xe += nt,
                            Fe[yt] = xe,
                            yt++
                        }
                        break;
                    case 2:
                        G[0] = Ke,
                        G[1] = G[0] + k.width,
                        G[2] = G[1] + k.width,
                        Ke = G[2] + k.width;
                        for (let ne = 0; ne < k.width; ++ne) {
                            const nt = Se[G[0]++] << 24 | Se[G[1]++] << 16 | Se[G[2]++] << 8;
                            xe += nt,
                            Fe[yt] = xe,
                            yt++
                        }
                        break
                    }
                }
            return new DataView(Fe.buffer)
        }
        function Ce(k) {
            var $ = k.viewer
              , Se = {
                value: k.offset.value
            }
              , Ue = new Uint8Array(k.width * k.lines * (k.channels * k.type * 2))
              , Fe = {
                version: ut($, Se),
                unknownUncompressedSize: ut($, Se),
                unknownCompressedSize: ut($, Se),
                acCompressedSize: ut($, Se),
                dcCompressedSize: ut($, Se),
                rleCompressedSize: ut($, Se),
                rleUncompressedSize: ut($, Se),
                rleRawSize: ut($, Se),
                totalAcUncompressedCount: ut($, Se),
                totalDcUncompressedCount: ut($, Se),
                acCompression: ut($, Se)
            };
            if (Fe.version < 2)
                throw "EXRLoader.parse: " + qt.compression + " version " + Fe.version + " is unsupported";
            for (var Ke = new Array, yt = at($, Se) - 2; yt > 0; ) {
                var G = it($.buffer, Se)
                  , ce = _t($, Se)
                  , ye = ce >> 2 & 3
                  , xe = (ce >> 4) - 1
                  , ne = new Int8Array([xe])[0]
                  , nt = _t($, Se);
                Ke.push({
                    name: G,
                    index: ne,
                    type: nt,
                    compression: ye
                }),
                yt -= G.length + 3
            }
            for (var We = qt.channels, st = new Array(k.channels), ft = 0; ft < k.channels; ++ft) {
                var Tt = st[ft] = {}
                  , At = We[ft];
                Tt.name = At.name,
                Tt.compression = 0,
                Tt.decoded = !1,
                Tt.type = At.pixelType,
                Tt.pLinear = At.pLinear,
                Tt.width = k.width,
                Tt.height = k.lines
            }
            for (var Et = {
                idx: new Array(3)
            }, Xt = 0; Xt < k.channels; ++Xt)
                for (var Tt = st[Xt], ft = 0; ft < Ke.length; ++ft) {
                    var Jt = Ke[ft];
                    Tt.name == Jt.name && (Tt.compression = Jt.compression,
                    Jt.index >= 0 && (Et.idx[Jt.index] = Xt),
                    Tt.offset = Xt)
                }
            if (Fe.acCompressedSize > 0)
                switch (Fe.acCompression) {
                case 0:
                    var Vt = new Uint16Array(Fe.totalAcUncompressedCount);
                    tt(k.array, $, Se, Fe.acCompressedSize, Vt, Fe.totalAcUncompressedCount);
                    break;
                case 1:
                    var en = k.array.slice(Se.value, Se.value + Fe.totalAcUncompressedCount)
                      , Sn = jx(en)
                      , Vt = new Uint16Array(Sn.buffer);
                    Se.value += Fe.totalAcUncompressedCount;
                    break
                }
            if (Fe.dcCompressedSize > 0) {
                var It = {
                    array: k.array,
                    offset: Se,
                    size: Fe.dcCompressedSize
                }
                  , Cn = new Uint16Array(ve(It).buffer);
                Se.value += Fe.dcCompressedSize
            }
            if (Fe.rleRawSize > 0) {
                var en = k.array.slice(Se.value, Se.value + Fe.rleCompressedSize)
                  , Sn = jx(en)
                  , fn = Ne(Sn.buffer);
                Se.value += Fe.rleCompressedSize
            }
            for (var In = 0, xn = new Array(st.length), ft = 0; ft < xn.length; ++ft)
                xn[ft] = new Array;
            for (var Bn = 0; Bn < k.lines; ++Bn)
                for (var hn = 0; hn < st.length; ++hn)
                    xn[hn].push(In),
                    In += st[hn].width * k.type * 2;
            Oe(Et, xn, st, Vt, Cn, Ue);
            for (var ft = 0; ft < st.length; ++ft) {
                var Tt = st[ft];
                if (!Tt.decoded)
                    switch (Tt.compression) {
                    case 2:
                        for (var Yt = 0, ti = 0, Bn = 0; Bn < k.lines; ++Bn) {
                            for (var ri = xn[ft][Yt], bn = 0; bn < Tt.width; ++bn) {
                                for (var ui = 0; ui < 2 * Tt.type; ++ui)
                                    Ue[ri++] = fn[ti + ui * Tt.width * Tt.height];
                                ti++
                            }
                            Yt++
                        }
                        break;
                    case 1:
                    default:
                        throw "EXRLoader.parse: unsupported channel compression"
                    }
            }
            return new DataView(Ue.buffer)
        }
        function it(k, $) {
            for (var Se = new Uint8Array(k), Ue = 0; Se[$.value + Ue] != 0; )
                Ue += 1;
            var Fe = new TextDecoder().decode(Se.slice($.value, $.value + Ue));
            return $.value = $.value + Ue + 1,
            Fe
        }
        function lt(k, $, Se) {
            var Ue = new TextDecoder().decode(new Uint8Array(k).slice($.value, $.value + Se));
            return $.value = $.value + Se,
            Ue
        }
        function Mt(k, $) {
            var Se = je(k, $)
              , Ue = Ye(k, $);
            return [Se, Ue]
        }
        function pt(k, $) {
            var Se = Ye(k, $)
              , Ue = Ye(k, $);
            return [Se, Ue]
        }
        function je(k, $) {
            var Se = k.getInt32($.value, !0);
            return $.value = $.value + 4,
            Se
        }
        function Ye(k, $) {
            var Se = k.getUint32($.value, !0);
            return $.value = $.value + 4,
            Se
        }
        function ct(k, $) {
            var Se = k[$.value];
            return $.value = $.value + 1,
            Se
        }
        function _t(k, $) {
            var Se = k.getUint8($.value);
            return $.value = $.value + 1,
            Se
        }
        const ut = function(k, $) {
            let Se;
            return "getBigInt64"in DataView.prototype ? Se = Number(k.getBigInt64($.value, !0)) : Se = k.getUint32($.value + 4, !0) + Number(k.getUint32($.value, !0) << 32),
            $.value += 8,
            Se
        };
        function Ut(k, $) {
            var Se = k.getFloat32($.value, !0);
            return $.value += 4,
            Se
        }
        function me(k, $) {
            return jd.toHalfFloat(Ut(k, $))
        }
        function Ee(k) {
            var $ = (k & 31744) >> 10
              , Se = k & 1023;
            return (k >> 15 ? -1 : 1) * ($ ? $ === 31 ? Se ? NaN : 1 / 0 : Math.pow(2, $ - 15) * (1 + Se / 1024) : 6103515625e-14 * (Se / 1024))
        }
        function at(k, $) {
            var Se = k.getUint16($.value, !0);
            return $.value += 2,
            Se
        }
        function Ct(k, $) {
            return Ee(at(k, $))
        }
        function rt(k, $, Se, Ue) {
            for (var Fe = Se.value, Ke = []; Se.value < Fe + Ue - 1; ) {
                var yt = it($, Se)
                  , G = je(k, Se)
                  , ce = _t(k, Se);
                Se.value += 3;
                var ye = je(k, Se)
                  , xe = je(k, Se);
                Ke.push({
                    name: yt,
                    pixelType: G,
                    pLinear: ce,
                    xSampling: ye,
                    ySampling: xe
                })
            }
            return Se.value += 1,
            Ke
        }
        function Ge(k, $) {
            var Se = Ut(k, $)
              , Ue = Ut(k, $)
              , Fe = Ut(k, $)
              , Ke = Ut(k, $)
              , yt = Ut(k, $)
              , G = Ut(k, $)
              , ce = Ut(k, $)
              , ye = Ut(k, $);
            return {
                redX: Se,
                redY: Ue,
                greenX: Fe,
                greenY: Ke,
                blueX: yt,
                blueY: G,
                whiteX: ce,
                whiteY: ye
            }
        }
        function wt(k, $) {
            var Se = ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"]
              , Ue = _t(k, $);
            return Se[Ue]
        }
        function Ot(k, $) {
            var Se = Ye(k, $)
              , Ue = Ye(k, $)
              , Fe = Ye(k, $)
              , Ke = Ye(k, $);
            return {
                xMin: Se,
                yMin: Ue,
                xMax: Fe,
                yMax: Ke
            }
        }
        function Nt(k, $) {
            var Se = ["INCREASING_Y"]
              , Ue = _t(k, $);
            return Se[Ue]
        }
        function bt(k, $) {
            var Se = Ut(k, $)
              , Ue = Ut(k, $);
            return [Se, Ue]
        }
        function Bt(k, $) {
            var Se = Ut(k, $)
              , Ue = Ut(k, $)
              , Fe = Ut(k, $);
            return [Se, Ue, Fe]
        }
        function Gt(k, $, Se, Ue, Fe) {
            if (Ue === "string" || Ue === "stringvector" || Ue === "iccProfile")
                return lt($, Se, Fe);
            if (Ue === "chlist")
                return rt(k, $, Se, Fe);
            if (Ue === "chromaticities")
                return Ge(k, Se);
            if (Ue === "compression")
                return wt(k, Se);
            if (Ue === "box2i")
                return Ot(k, Se);
            if (Ue === "lineOrder")
                return Nt(k, Se);
            if (Ue === "float")
                return Ut(k, Se);
            if (Ue === "v2f")
                return bt(k, Se);
            if (Ue === "v3f")
                return Bt(k, Se);
            if (Ue === "int")
                return je(k, Se);
            if (Ue === "rational")
                return Mt(k, Se);
            if (Ue === "timecode")
                return pt(k, Se);
            if (Ue === "preview")
                return Se.value += Fe,
                "skipped";
            Se.value += Fe
        }
        function mt(k, $, Se) {
            const Ue = {};
            if (k.getUint32(0, !0) != 20000630)
                throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
            Ue.version = k.getUint8(4);
            const Fe = k.getUint8(5);
            Ue.spec = {
                singleTile: !!(Fe & 2),
                longName: !!(Fe & 4),
                deepFormat: !!(Fe & 8),
                multiPart: !!(Fe & 16)
            },
            Se.value = 8;
            for (var Ke = !0; Ke; ) {
                var yt = it($, Se);
                if (yt == 0)
                    Ke = !1;
                else {
                    var G = it($, Se)
                      , ce = Ye(k, Se)
                      , ye = Gt(k, $, Se, G, ce);
                    ye === void 0 ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${G}'.`) : Ue[yt] = ye
                }
            }
            if ((Fe & -5) != 0)
                throw console.error("EXRHeader:", Ue),
                "THREE.EXRLoader: provided file is currently unsupported.";
            return Ue
        }
        function Lt(k, $, Se, Ue, Fe) {
            const Ke = {
                size: 0,
                viewer: $,
                array: Se,
                offset: Ue,
                width: k.dataWindow.xMax - k.dataWindow.xMin + 1,
                height: k.dataWindow.yMax - k.dataWindow.yMin + 1,
                channels: k.channels.length,
                bytesPerLine: null,
                lines: null,
                inputSize: null,
                type: k.channels[0].pixelType,
                uncompress: null,
                getter: null,
                format: null,
                [Tv ? "colorSpace" : "encoding"]: null
            };
            switch (k.compression) {
            case "NO_COMPRESSION":
                Ke.lines = 1,
                Ke.uncompress = J;
                break;
            case "RLE_COMPRESSION":
                Ke.lines = 1,
                Ke.uncompress = j;
                break;
            case "ZIPS_COMPRESSION":
                Ke.lines = 1,
                Ke.uncompress = ve;
                break;
            case "ZIP_COMPRESSION":
                Ke.lines = 16,
                Ke.uncompress = ve;
                break;
            case "PIZ_COMPRESSION":
                Ke.lines = 32,
                Ke.uncompress = Be;
                break;
            case "PXR24_COMPRESSION":
                Ke.lines = 16,
                Ke.uncompress = we;
                break;
            case "DWAA_COMPRESSION":
                Ke.lines = 32,
                Ke.uncompress = Ce;
                break;
            case "DWAB_COMPRESSION":
                Ke.lines = 256,
                Ke.uncompress = Ce;
                break;
            default:
                throw "EXRLoader.parse: " + k.compression + " is unsupported"
            }
            if (Ke.scanlineBlockSize = Ke.lines,
            Ke.type == 1)
                switch (Fe) {
                case tr:
                    Ke.getter = Ct,
                    Ke.inputSize = 2;
                    break;
                case $r:
                    Ke.getter = at,
                    Ke.inputSize = 2;
                    break
                }
            else if (Ke.type == 2)
                switch (Fe) {
                case tr:
                    Ke.getter = Ut,
                    Ke.inputSize = 4;
                    break;
                case $r:
                    Ke.getter = me,
                    Ke.inputSize = 4
                }
            else
                throw "EXRLoader.parse: unsupported pixelType " + Ke.type + " for " + k.compression + ".";
            Ke.blockCount = (k.dataWindow.yMax + 1) / Ke.scanlineBlockSize;
            for (var yt = 0; yt < Ke.blockCount; yt++)
                ut($, Ue);
            Ke.outputChannels = Ke.channels == 3 ? 4 : Ke.channels;
            const G = Ke.width * Ke.height * Ke.outputChannels;
            switch (Fe) {
            case tr:
                Ke.byteArray = new Float32Array(G),
                Ke.channels < Ke.outputChannels && Ke.byteArray.fill(1, 0, G);
                break;
            case $r:
                Ke.byteArray = new Uint16Array(G),
                Ke.channels < Ke.outputChannels && Ke.byteArray.fill(15360, 0, G);
                break;
            default:
                console.error("THREE.EXRLoader: unsupported type: ", Fe);
                break
            }
            return Ke.bytesPerLine = Ke.width * Ke.inputSize * Ke.channels,
            Ke.outputChannels == 4 ? Ke.format = vr : Ke.format = h_,
            Tv ? Ke.colorSpace = "srgb-linear" : Ke.encoding = 3e3,
            Ke
        }
        const zt = new DataView(e)
          , Wt = new Uint8Array(e)
          , Ln = {
            value: 0
        }
          , qt = mt(zt, e, Ln)
          , Pt = Lt(qt, zt, Wt, Ln, this.type)
          , un = {
            value: 0
        }
          , $t = {
            R: 0,
            G: 1,
            B: 2,
            A: 3,
            Y: 0
        };
        for (let k = 0; k < Pt.height / Pt.scanlineBlockSize; k++) {
            const $ = Ye(zt, Ln);
            Pt.size = Ye(zt, Ln),
            Pt.lines = $ + Pt.scanlineBlockSize > Pt.height ? Pt.height - $ : Pt.scanlineBlockSize;
            const Ue = Pt.size < Pt.lines * Pt.bytesPerLine ? Pt.uncompress(Pt) : J(Pt);
            Ln.value += Pt.size;
            for (let Fe = 0; Fe < Pt.scanlineBlockSize; Fe++) {
                const Ke = Fe + k * Pt.scanlineBlockSize;
                if (Ke >= Pt.height)
                    break;
                for (let yt = 0; yt < Pt.channels; yt++) {
                    const G = $t[qt.channels[yt].name];
                    for (let ce = 0; ce < Pt.width; ce++) {
                        un.value = (Fe * (Pt.channels * Pt.width) + yt * Pt.width + ce) * Pt.inputSize;
                        const ye = (Pt.height - 1 - Ke) * (Pt.width * Pt.outputChannels) + ce * Pt.outputChannels + G;
                        Pt.byteArray[ye] = Pt.getter(Ue, un)
                    }
                }
            }
        }
        return {
            header: qt,
            width: Pt.width,
            height: Pt.height,
            data: Pt.byteArray,
            format: Pt.format,
            [Tv ? "colorSpace" : "encoding"]: Pt[Tv ? "colorSpace" : "encoding"],
            type: this.type
        }
    }
    setDataType(e) {
        return this.type = e,
        this
    }
    load(e, t, n, i) {
        function a(s, l) {
            Tv ? s.colorSpace = l.colorSpace : s.encoding = l.encoding,
            s.minFilter = fi,
            s.magFilter = fi,
            s.generateMipmaps = !1,
            s.flipY = !1,
            t && t(s, l)
        }
        return super.load(e, a, n, i)
    }
}
function u$() {
    var r = Object.create(null);
    function e(i, a) {
        var s = i.id
          , l = i.name
          , u = i.dependencies;
        u === void 0 && (u = []);
        var f = i.init;
        f === void 0 && (f = function() {}
        );
        var d = i.getTransferables;
        if (d === void 0 && (d = null),
        !r[s])
            try {
                u = u.map(function(v) {
                    return v && v.isWorkerModule && (e(v, function(y) {
                        if (y instanceof Error)
                            throw y
                    }),
                    v = r[v.id].value),
                    v
                }),
                f = n("<" + l + ">.init", f),
                d && (d = n("<" + l + ">.getTransferables", d));
                var g = null;
                typeof f == "function" ? g = f.apply(void 0, u) : console.error("worker module init function failed to rehydrate"),
                r[s] = {
                    id: s,
                    value: g,
                    getTransferables: d
                },
                a(g)
            } catch (v) {
                v && v.noLog || console.error(v),
                a(v)
            }
    }
    function t(i, a) {
        var s, l = i.id, u = i.args;
        (!r[l] || typeof r[l].value != "function") && a(new Error("Worker module " + l + ": not found or its 'init' did not return a function"));
        try {
            var f = (s = r[l]).value.apply(s, u);
            f && typeof f.then == "function" ? f.then(d, function(g) {
                return a(g instanceof Error ? g : new Error("" + g))
            }) : d(f)
        } catch (g) {
            a(g)
        }
        function d(g) {
            try {
                var v = r[l].getTransferables && r[l].getTransferables(g);
                (!v || !Array.isArray(v) || !v.length) && (v = void 0),
                a(g, v)
            } catch (y) {
                console.error(y),
                a(y)
            }
        }
    }
    function n(i, a) {
        var s = void 0;
        self.troikaDefine = function(u) {
            return s = u
        }
        ;
        var l = URL.createObjectURL(new Blob(["/** " + i.replace(/\*/g, "") + ` **/

troikaDefine(
` + a + `
)`],{
            type: "application/javascript"
        }));
        try {
            importScripts(l)
        } catch (u) {
            console.error(u)
        }
        return URL.revokeObjectURL(l),
        delete self.troikaDefine,
        s
    }
    self.addEventListener("message", function(i) {
        var a = i.data
          , s = a.messageId
          , l = a.action
          , u = a.data;
        try {
            l === "registerModule" && e(u, function(f) {
                f instanceof Error ? postMessage({
                    messageId: s,
                    success: !1,
                    error: f.message
                }) : postMessage({
                    messageId: s,
                    success: !0,
                    result: {
                        isCallable: typeof f == "function"
                    }
                })
            }),
            l === "callModule" && t(u, function(f, d) {
                f instanceof Error ? postMessage({
                    messageId: s,
                    success: !1,
                    error: f.message
                }) : postMessage({
                    messageId: s,
                    success: !0,
                    result: f
                }, d || void 0)
            })
        } catch (f) {
            postMessage({
                messageId: s,
                success: !1,
                error: f.stack
            })
        }
    })
}
function c$(r) {
    var e = function() {
        for (var t = [], n = arguments.length; n--; )
            t[n] = arguments[n];
        return e._getInitResult().then(function(i) {
            if (typeof i == "function")
                return i.apply(void 0, t);
            throw new Error("Worker module function was called but `init` did not return a callable function")
        })
    };
    return e._getInitResult = function() {
        var t = r.dependencies
          , n = r.init;
        t = Array.isArray(t) ? t.map(function(a) {
            return a && (a = a.onMainThread || a,
            a._getInitResult && (a = a._getInitResult())),
            a
        }) : [];
        var i = Promise.all(t).then(function(a) {
            return n.apply(null, a)
        });
        return e._getInitResult = function() {
            return i
        }
        ,
        i
    }
    ,
    e
}
var nI = function() {
    var r = !1;
    if (typeof window < "u" && typeof window.document < "u")
        try {
            var e = new Worker(URL.createObjectURL(new Blob([""],{
                type: "application/javascript"
            })));
            e.terminate(),
            r = !0
        } catch (t) {
            console.log("Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + t.message + "]")
        }
    return nI = function() {
        return r
    }
    ,
    r
}
  , f$ = 0
  , h$ = 0
  , lE = !1
  , uy = Object.create(null)
  , cy = Object.create(null)
  , Cw = Object.create(null);
function Kg(r) {
    if ((!r || typeof r.init != "function") && !lE)
        throw new Error("requires `options.init` function");
    var e = r.dependencies
      , t = r.init
      , n = r.getTransferables
      , i = r.workerId
      , a = c$(r);
    i == null && (i = "#default");
    var s = "workerModule" + ++f$
      , l = r.name || s
      , u = null;
    e = e && e.map(function(d) {
        return typeof d == "function" && !d.workerModuleData && (lE = !0,
        d = Kg({
            workerId: i,
            name: "<" + l + "> function dependency: " + d.name,
            init: `function(){return (
` + MS(d) + `
)}`
        }),
        lE = !1),
        d && d.workerModuleData && (d = d.workerModuleData),
        d
    });
    function f() {
        for (var d = [], g = arguments.length; g--; )
            d[g] = arguments[g];
        if (!nI())
            return a.apply(void 0, d);
        if (!u) {
            u = qO(i, "registerModule", f.workerModuleData);
            var v = function() {
                u = null,
                cy[i].delete(v)
            };
            (cy[i] || (cy[i] = new Set)).add(v)
        }
        return u.then(function(y) {
            var S = y.isCallable;
            if (S)
                return qO(i, "callModule", {
                    id: s,
                    args: d
                });
            throw new Error("Worker module function was called but `init` did not return a callable function")
        })
    }
    return f.workerModuleData = {
        isWorkerModule: !0,
        id: s,
        name: l,
        dependencies: e,
        init: MS(t),
        getTransferables: n && MS(n)
    },
    f.onMainThread = a,
    f
}
function d$(r) {
    cy[r] && cy[r].forEach(function(e) {
        e()
    }),
    uy[r] && (uy[r].terminate(),
    delete uy[r])
}
function MS(r) {
    var e = r.toString();
    return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e),
    e
}
function p$(r) {
    var e = uy[r];
    if (!e) {
        var t = MS(u$);
        e = uy[r] = new Worker(URL.createObjectURL(new Blob(["/** Worker Module Bootstrap: " + r.replace(/\*/g, "") + ` **/

;(` + t + ")()"],{
            type: "application/javascript"
        }))),
        e.onmessage = function(n) {
            var i = n.data
              , a = i.messageId
              , s = Cw[a];
            if (!s)
                throw new Error("WorkerModule response with empty or unknown messageId");
            delete Cw[a],
            s(i)
        }
    }
    return e
}
function qO(r, e, t) {
    return new Promise(function(n, i) {
        var a = ++h$;
        Cw[a] = function(s) {
            s.success ? n(s.result) : i(new Error("Error in worker " + e + " call: " + s.error))
        }
        ,
        p$(r).postMessage({
            messageId: a,
            action: e,
            data: t
        })
    }
    )
}
function iI() {
    var r = function(e) {
        function t(se, B, W, te, fe, pe, _e, ue) {
            var ge = 1 - _e;
            ue.x = ge * ge * se + 2 * ge * _e * W + _e * _e * fe,
            ue.y = ge * ge * B + 2 * ge * _e * te + _e * _e * pe
        }
        function n(se, B, W, te, fe, pe, _e, ue, ge, Te) {
            var Ze = 1 - ge;
            Te.x = Ze * Ze * Ze * se + 3 * Ze * Ze * ge * W + 3 * Ze * ge * ge * fe + ge * ge * ge * _e,
            Te.y = Ze * Ze * Ze * B + 3 * Ze * Ze * ge * te + 3 * Ze * ge * ge * pe + ge * ge * ge * ue
        }
        function i(se, B) {
            for (var W = /([MLQCZ])([^MLQCZ]*)/g, te, fe, pe, _e, ue; te = W.exec(se); ) {
                var ge = te[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(Te) {
                    return parseFloat(Te)
                });
                switch (te[1]) {
                case "M":
                    _e = fe = ge[0],
                    ue = pe = ge[1];
                    break;
                case "L":
                    (ge[0] !== _e || ge[1] !== ue) && B("L", _e, ue, _e = ge[0], ue = ge[1]);
                    break;
                case "Q":
                    {
                        B("Q", _e, ue, _e = ge[2], ue = ge[3], ge[0], ge[1]);
                        break
                    }
                case "C":
                    {
                        B("C", _e, ue, _e = ge[4], ue = ge[5], ge[0], ge[1], ge[2], ge[3]);
                        break
                    }
                case "Z":
                    (_e !== fe || ue !== pe) && B("L", _e, ue, fe, pe);
                    break
                }
            }
        }
        function a(se, B, W) {
            W === void 0 && (W = 16);
            var te = {
                x: 0,
                y: 0
            };
            i(se, function(fe, pe, _e, ue, ge, Te, Ze, ot, tt) {
                switch (fe) {
                case "L":
                    B(pe, _e, ue, ge);
                    break;
                case "Q":
                    {
                        for (var $e = pe, re = _e, Le = 1; Le < W; Le++)
                            t(pe, _e, Te, Ze, ue, ge, Le / (W - 1), te),
                            B($e, re, te.x, te.y),
                            $e = te.x,
                            re = te.y;
                        break
                    }
                case "C":
                    {
                        for (var Ne = pe, Oe = _e, le = 1; le < W; le++)
                            n(pe, _e, Te, Ze, ot, tt, ue, ge, le / (W - 1), te),
                            B(Ne, Oe, te.x, te.y),
                            Ne = te.x,
                            Oe = te.y;
                        break
                    }
                }
            })
        }
        var s = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}"
          , l = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}"
          , u = new WeakMap
          , f = {
            premultipliedAlpha: !1,
            preserveDrawingBuffer: !0,
            antialias: !1,
            depth: !1
        };
        function d(se, B) {
            var W = se.getContext ? se.getContext("webgl", f) : se
              , te = u.get(W);
            if (!te) {
                let Ne = function(De) {
                    var vt = pe[De];
                    if (!vt && (vt = pe[De] = W.getExtension(De),
                    !vt))
                        throw new Error(De + " not supported");
                    return vt
                }
                  , Oe = function(De, vt) {
                    var J = W.createShader(vt);
                    return W.shaderSource(J, De),
                    W.compileShader(J),
                    J
                }
                  , le = function(De, vt, J, j) {
                    if (!_e[De]) {
                        var ve = {}
                          , Be = {}
                          , we = W.createProgram();
                        W.attachShader(we, Oe(vt, W.VERTEX_SHADER)),
                        W.attachShader(we, Oe(J, W.FRAGMENT_SHADER)),
                        W.linkProgram(we),
                        _e[De] = {
                            program: we,
                            transaction: function(it) {
                                W.useProgram(we),
                                it({
                                    setUniform: function(Mt, pt) {
                                        for (var je = [], Ye = arguments.length - 2; Ye-- > 0; )
                                            je[Ye] = arguments[Ye + 2];
                                        var ct = Be[pt] || (Be[pt] = W.getUniformLocation(we, pt));
                                        W["uniform" + Mt].apply(W, [ct].concat(je))
                                    },
                                    setAttribute: function(Mt, pt, je, Ye, ct) {
                                        var _t = ve[Mt];
                                        _t || (_t = ve[Mt] = {
                                            buf: W.createBuffer(),
                                            loc: W.getAttribLocation(we, Mt),
                                            data: null
                                        }),
                                        W.bindBuffer(W.ARRAY_BUFFER, _t.buf),
                                        W.vertexAttribPointer(_t.loc, pt, W.FLOAT, !1, 0, 0),
                                        W.enableVertexAttribArray(_t.loc),
                                        fe ? W.vertexAttribDivisor(_t.loc, Ye) : Ne("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(_t.loc, Ye),
                                        ct !== _t.data && (W.bufferData(W.ARRAY_BUFFER, ct, je),
                                        _t.data = ct)
                                    }
                                })
                            }
                        }
                    }
                    _e[De].transaction(j)
                }
                  , Pe = function(De, vt) {
                    ge++;
                    try {
                        W.activeTexture(W.TEXTURE0 + ge);
                        var J = ue[De];
                        J || (J = ue[De] = W.createTexture(),
                        W.bindTexture(W.TEXTURE_2D, J),
                        W.texParameteri(W.TEXTURE_2D, W.TEXTURE_MIN_FILTER, W.NEAREST),
                        W.texParameteri(W.TEXTURE_2D, W.TEXTURE_MAG_FILTER, W.NEAREST)),
                        W.bindTexture(W.TEXTURE_2D, J),
                        vt(J, ge)
                    } finally {
                        ge--
                    }
                }
                  , He = function(De, vt, J) {
                    var j = W.createFramebuffer();
                    Te.push(j),
                    W.bindFramebuffer(W.FRAMEBUFFER, j),
                    W.activeTexture(W.TEXTURE0 + vt),
                    W.bindTexture(W.TEXTURE_2D, De),
                    W.framebufferTexture2D(W.FRAMEBUFFER, W.COLOR_ATTACHMENT0, W.TEXTURE_2D, De, 0);
                    try {
                        J(j)
                    } finally {
                        W.deleteFramebuffer(j),
                        W.bindFramebuffer(W.FRAMEBUFFER, Te[--Te.length - 1] || null)
                    }
                }
                  , Ve = function() {
                    pe = {},
                    _e = {},
                    ue = {},
                    ge = -1,
                    Te.length = 0
                };
                var Ze = Ne
                  , ot = Oe
                  , tt = le
                  , $e = Pe
                  , re = He
                  , Le = Ve
                  , fe = typeof WebGL2RenderingContext < "u" && W instanceof WebGL2RenderingContext
                  , pe = {}
                  , _e = {}
                  , ue = {}
                  , ge = -1
                  , Te = [];
                W.canvas.addEventListener("webglcontextlost", function(De) {
                    Ve(),
                    De.preventDefault()
                }, !1),
                u.set(W, te = {
                    gl: W,
                    isWebGL2: fe,
                    getExtension: Ne,
                    withProgram: le,
                    withTexture: Pe,
                    withTextureFramebuffer: He,
                    handleContextLoss: Ve
                })
            }
            B(te)
        }
        function g(se, B, W, te, fe, pe, _e, ue) {
            _e === void 0 && (_e = 15),
            ue === void 0 && (ue = null),
            d(se, function(ge) {
                var Te = ge.gl
                  , Ze = ge.withProgram
                  , ot = ge.withTexture;
                ot("copy", function(tt, $e) {
                    Te.texImage2D(Te.TEXTURE_2D, 0, Te.RGBA, fe, pe, 0, Te.RGBA, Te.UNSIGNED_BYTE, B),
                    Ze("copy", s, l, function(re) {
                        var Le = re.setUniform
                          , Ne = re.setAttribute;
                        Ne("aUV", 2, Te.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])),
                        Le("1i", "image", $e),
                        Te.bindFramebuffer(Te.FRAMEBUFFER, ue || null),
                        Te.disable(Te.BLEND),
                        Te.colorMask(_e & 8, _e & 4, _e & 2, _e & 1),
                        Te.viewport(W, te, fe, pe),
                        Te.scissor(W, te, fe, pe),
                        Te.drawArrays(Te.TRIANGLES, 0, 3)
                    })
                })
            })
        }
        function v(se, B, W) {
            var te = se.width
              , fe = se.height;
            d(se, function(pe) {
                var _e = pe.gl
                  , ue = new Uint8Array(te * fe * 4);
                _e.readPixels(0, 0, te, fe, _e.RGBA, _e.UNSIGNED_BYTE, ue),
                se.width = B,
                se.height = W,
                g(_e, ue, 0, 0, te, fe)
            })
        }
        var y = Object.freeze({
            __proto__: null,
            withWebGLContext: d,
            renderImageData: g,
            resizeWebGLCanvasWithoutClearing: v
        });
        function S(se, B, W, te, fe, pe) {
            pe === void 0 && (pe = 1);
            var _e = new Uint8Array(se * B)
              , ue = te[2] - te[0]
              , ge = te[3] - te[1]
              , Te = [];
            a(W, function(Ne, Oe, le, Pe) {
                Te.push({
                    x1: Ne,
                    y1: Oe,
                    x2: le,
                    y2: Pe,
                    minX: Math.min(Ne, le),
                    minY: Math.min(Oe, Pe),
                    maxX: Math.max(Ne, le),
                    maxY: Math.max(Oe, Pe)
                })
            }),
            Te.sort(function(Ne, Oe) {
                return Ne.maxX - Oe.maxX
            });
            for (var Ze = 0; Ze < se; Ze++)
                for (var ot = 0; ot < B; ot++) {
                    var tt = re(te[0] + ue * (Ze + .5) / se, te[1] + ge * (ot + .5) / B)
                      , $e = Math.pow(1 - Math.abs(tt) / fe, pe) / 2;
                    tt < 0 && ($e = 1 - $e),
                    $e = Math.max(0, Math.min(255, Math.round($e * 255))),
                    _e[ot * se + Ze] = $e
                }
            return _e;
            function re(Ne, Oe) {
                for (var le = 1 / 0, Pe = 1 / 0, He = Te.length; He--; ) {
                    var Ve = Te[He];
                    if (Ve.maxX + Pe <= Ne)
                        break;
                    if (Ne + Pe > Ve.minX && Oe - Pe < Ve.maxY && Oe + Pe > Ve.minY) {
                        var De = b(Ne, Oe, Ve.x1, Ve.y1, Ve.x2, Ve.y2);
                        De < le && (le = De,
                        Pe = Math.sqrt(le))
                    }
                }
                return Le(Ne, Oe) && (Pe = -Pe),
                Pe
            }
            function Le(Ne, Oe) {
                for (var le = 0, Pe = Te.length; Pe--; ) {
                    var He = Te[Pe];
                    if (He.maxX <= Ne)
                        break;
                    var Ve = He.y1 > Oe != He.y2 > Oe && Ne < (He.x2 - He.x1) * (Oe - He.y1) / (He.y2 - He.y1) + He.x1;
                    Ve && (le += He.y1 < He.y2 ? 1 : -1)
                }
                return le !== 0
            }
        }
        function T(se, B, W, te, fe, pe, _e, ue, ge, Te) {
            pe === void 0 && (pe = 1),
            ue === void 0 && (ue = 0),
            ge === void 0 && (ge = 0),
            Te === void 0 && (Te = 0),
            M(se, B, W, te, fe, pe, _e, null, ue, ge, Te)
        }
        function M(se, B, W, te, fe, pe, _e, ue, ge, Te, Ze) {
            pe === void 0 && (pe = 1),
            ge === void 0 && (ge = 0),
            Te === void 0 && (Te = 0),
            Ze === void 0 && (Ze = 0);
            for (var ot = S(se, B, W, te, fe, pe), tt = new Uint8Array(ot.length * 4), $e = 0; $e < ot.length; $e++)
                tt[$e * 4 + Ze] = ot[$e];
            g(_e, tt, ge, Te, se, B, 1 << 3 - Ze, ue)
        }
        function b(se, B, W, te, fe, pe) {
            var _e = fe - W
              , ue = pe - te
              , ge = _e * _e + ue * ue
              , Te = ge ? Math.max(0, Math.min(1, ((se - W) * _e + (B - te) * ue) / ge)) : 0
              , Ze = se - (W + Te * _e)
              , ot = B - (te + Te * ue);
            return Ze * Ze + ot * ot
        }
        var A = Object.freeze({
            __proto__: null,
            generate: S,
            generateIntoCanvas: T,
            generateIntoFramebuffer: M
        })
          , C = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}"
          , R = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}"
          , O = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}"
          , L = new Float32Array([0, 0, 2, 0, 0, 2])
          , z = null
          , I = !1
          , N = {}
          , P = new WeakMap;
        function Y(se) {
            if (!I && !oe(se))
                throw new Error("WebGL generation not supported")
        }
        function V(se, B, W, te, fe, pe, _e) {
            if (pe === void 0 && (pe = 1),
            _e === void 0 && (_e = null),
            !_e && (_e = z,
            !_e)) {
                var ue = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1,1) : typeof document < "u" ? document.createElement("canvas") : null;
                if (!ue)
                    throw new Error("OffscreenCanvas or DOM canvas not supported");
                _e = z = ue.getContext("webgl", {
                    depth: !1
                })
            }
            Y(_e);
            var ge = new Uint8Array(se * B * 4);
            d(_e, function(tt) {
                var $e = tt.gl
                  , re = tt.withTexture
                  , Le = tt.withTextureFramebuffer;
                re("readable", function(Ne, Oe) {
                    $e.texImage2D($e.TEXTURE_2D, 0, $e.RGBA, se, B, 0, $e.RGBA, $e.UNSIGNED_BYTE, null),
                    Le(Ne, Oe, function(le) {
                        Z(se, B, W, te, fe, pe, $e, le, 0, 0, 0),
                        $e.readPixels(0, 0, se, B, $e.RGBA, $e.UNSIGNED_BYTE, ge)
                    })
                })
            });
            for (var Te = new Uint8Array(se * B), Ze = 0, ot = 0; Ze < ge.length; Ze += 4)
                Te[ot++] = ge[Ze];
            return Te
        }
        function K(se, B, W, te, fe, pe, _e, ue, ge, Te) {
            pe === void 0 && (pe = 1),
            ue === void 0 && (ue = 0),
            ge === void 0 && (ge = 0),
            Te === void 0 && (Te = 0),
            Z(se, B, W, te, fe, pe, _e, null, ue, ge, Te)
        }
        function Z(se, B, W, te, fe, pe, _e, ue, ge, Te, Ze) {
            pe === void 0 && (pe = 1),
            ge === void 0 && (ge = 0),
            Te === void 0 && (Te = 0),
            Ze === void 0 && (Ze = 0),
            Y(_e);
            var ot = [];
            a(W, function(tt, $e, re, Le) {
                ot.push(tt, $e, re, Le)
            }),
            ot = new Float32Array(ot),
            d(_e, function(tt) {
                var $e = tt.gl
                  , re = tt.isWebGL2
                  , Le = tt.getExtension
                  , Ne = tt.withProgram
                  , Oe = tt.withTexture
                  , le = tt.withTextureFramebuffer
                  , Pe = tt.handleContextLoss;
                if (Oe("rawDistances", function(He, Ve) {
                    (se !== He._lastWidth || B !== He._lastHeight) && $e.texImage2D($e.TEXTURE_2D, 0, $e.RGBA, He._lastWidth = se, He._lastHeight = B, 0, $e.RGBA, $e.UNSIGNED_BYTE, null),
                    Ne("main", C, R, function(De) {
                        var vt = De.setAttribute
                          , J = De.setUniform
                          , j = !re && Le("ANGLE_instanced_arrays")
                          , ve = !re && Le("EXT_blend_minmax");
                        vt("aUV", 2, $e.STATIC_DRAW, 0, L),
                        vt("aLineSegment", 4, $e.DYNAMIC_DRAW, 1, ot),
                        J.apply(void 0, ["4f", "uGlyphBounds"].concat(te)),
                        J("1f", "uMaxDistance", fe),
                        J("1f", "uExponent", pe),
                        le(He, Ve, function(Be) {
                            $e.enable($e.BLEND),
                            $e.colorMask(!0, !0, !0, !0),
                            $e.viewport(0, 0, se, B),
                            $e.scissor(0, 0, se, B),
                            $e.blendFunc($e.ONE, $e.ONE),
                            $e.blendEquationSeparate($e.FUNC_ADD, re ? $e.MAX : ve.MAX_EXT),
                            $e.clear($e.COLOR_BUFFER_BIT),
                            re ? $e.drawArraysInstanced($e.TRIANGLES, 0, 3, ot.length / 4) : j.drawArraysInstancedANGLE($e.TRIANGLES, 0, 3, ot.length / 4)
                        })
                    }),
                    Ne("post", s, O, function(De) {
                        De.setAttribute("aUV", 2, $e.STATIC_DRAW, 0, L),
                        De.setUniform("1i", "tex", Ve),
                        $e.bindFramebuffer($e.FRAMEBUFFER, ue),
                        $e.disable($e.BLEND),
                        $e.colorMask(Ze === 0, Ze === 1, Ze === 2, Ze === 3),
                        $e.viewport(ge, Te, se, B),
                        $e.scissor(ge, Te, se, B),
                        $e.drawArrays($e.TRIANGLES, 0, 3)
                    })
                }),
                $e.isContextLost())
                    throw Pe(),
                    new Error("webgl context lost")
            })
        }
        function oe(se) {
            var B = !se || se === z ? N : se.canvas || se
              , W = P.get(B);
            if (W === void 0) {
                I = !0;
                var te = null;
                try {
                    var fe = [97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106, 97]
                      , pe = V(4, 4, "M8,8L16,8L24,24L16,24Z", [0, 0, 32, 32], 24, 1, se);
                    W = pe && fe.length === pe.length && pe.every(function(_e, ue) {
                        return _e === fe[ue]
                    }),
                    W || (te = "bad trial run results",
                    console.info(fe, pe))
                } catch (_e) {
                    W = !1,
                    te = _e.message
                }
                te && console.warn("WebGL SDF generation not supported:", te),
                I = !1,
                P.set(B, W)
            }
            return W
        }
        var H = Object.freeze({
            __proto__: null,
            generate: V,
            generateIntoCanvas: K,
            generateIntoFramebuffer: Z,
            isSupported: oe
        });
        function q(se, B, W, te, fe, pe) {
            fe === void 0 && (fe = Math.max(te[2] - te[0], te[3] - te[1]) / 2),
            pe === void 0 && (pe = 1);
            try {
                return V.apply(H, arguments)
            } catch (_e) {
                return console.info("WebGL SDF generation failed, falling back to JS", _e),
                S.apply(A, arguments)
            }
        }
        function Q(se, B, W, te, fe, pe, _e, ue, ge, Te) {
            fe === void 0 && (fe = Math.max(te[2] - te[0], te[3] - te[1]) / 2),
            pe === void 0 && (pe = 1),
            ue === void 0 && (ue = 0),
            ge === void 0 && (ge = 0),
            Te === void 0 && (Te = 0);
            try {
                return K.apply(H, arguments)
            } catch (Ze) {
                return console.info("WebGL SDF generation failed, falling back to JS", Ze),
                T.apply(A, arguments)
            }
        }
        return e.forEachPathCommand = i,
        e.generate = q,
        e.generateIntoCanvas = Q,
        e.javascript = A,
        e.pathToLineSegments = a,
        e.webgl = H,
        e.webglUtils = y,
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e
    }({});
    return r
}
function m$() {
    var r = function(e) {
        var t = {
            R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
            EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
            ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
            ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
            AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
            CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
            B: "a,3,f+2,2v,690",
            S: "9,2,k",
            WS: "c,k,4f4,1vk+a,u,1j,335",
            ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
            BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
            NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
            AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
            LRO: "6ct",
            RLO: "6cu",
            LRE: "6cq",
            RLE: "6cr",
            PDF: "6cs",
            LRI: "6ee",
            RLI: "6ef",
            FSI: "6eg",
            PDI: "6eh"
        }
          , n = {}
          , i = {};
        n.L = 1,
        i[1] = "L",
        Object.keys(t).forEach(function(Pe, He) {
            n[Pe] = 1 << He + 1,
            i[n[Pe]] = Pe
        }),
        Object.freeze(n);
        var a = n.LRI | n.RLI | n.FSI
          , s = n.L | n.R | n.AL
          , l = n.B | n.S | n.WS | n.ON | n.FSI | n.LRI | n.RLI | n.PDI
          , u = n.BN | n.RLE | n.LRE | n.RLO | n.LRO | n.PDF
          , f = n.S | n.WS | n.B | a | n.PDI | u
          , d = null;
        function g() {
            if (!d) {
                d = new Map;
                var Pe = function(Ve) {
                    if (t.hasOwnProperty(Ve)) {
                        var De = 0;
                        t[Ve].split(",").forEach(function(vt) {
                            var J = vt.split("+")
                              , j = J[0]
                              , ve = J[1];
                            j = parseInt(j, 36),
                            ve = ve ? parseInt(ve, 36) : 0,
                            d.set(De += j, n[Ve]);
                            for (var Be = 0; Be < ve; Be++)
                                d.set(++De, n[Ve])
                        })
                    }
                };
                for (var He in t)
                    Pe(He)
            }
        }
        function v(Pe) {
            return g(),
            d.get(Pe.codePointAt(0)) || n.L
        }
        function y(Pe) {
            return i[v(Pe)]
        }
        var S = {
            pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
            canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
        };
        function T(Pe, He) {
            var Ve = 36, De = 0, vt = new Map, J = He && new Map, j;
            return Pe.split(",").forEach(function ve(Be) {
                if (Be.indexOf("+") !== -1)
                    for (var we = +Be; we--; )
                        ve(j);
                else {
                    j = Be;
                    var Ce = Be.split(">")
                      , it = Ce[0]
                      , lt = Ce[1];
                    it = String.fromCodePoint(De += parseInt(it, Ve)),
                    lt = String.fromCodePoint(De += parseInt(lt, Ve)),
                    vt.set(it, lt),
                    He && J.set(lt, it)
                }
            }),
            {
                map: vt,
                reverseMap: J
            }
        }
        var M, b, A;
        function C() {
            if (!M) {
                var Pe = T(S.pairs, !0)
                  , He = Pe.map
                  , Ve = Pe.reverseMap;
                M = He,
                b = Ve,
                A = T(S.canonical, !1).map
            }
        }
        function R(Pe) {
            return C(),
            M.get(Pe) || null
        }
        function O(Pe) {
            return C(),
            b.get(Pe) || null
        }
        function L(Pe) {
            return C(),
            A.get(Pe) || null
        }
        var z = n.L
          , I = n.R
          , N = n.EN
          , P = n.ES
          , Y = n.ET
          , V = n.AN
          , K = n.CS
          , Z = n.B
          , oe = n.S
          , H = n.ON
          , q = n.BN
          , Q = n.NSM
          , se = n.AL
          , B = n.LRO
          , W = n.RLO
          , te = n.LRE
          , fe = n.RLE
          , pe = n.PDF
          , _e = n.LRI
          , ue = n.RLI
          , ge = n.FSI
          , Te = n.PDI;
        function Ze(Pe, He) {
            for (var Ve = 125, De = new Uint32Array(Pe.length), vt = 0; vt < Pe.length; vt++)
                De[vt] = v(Pe[vt]);
            var J = new Map;
            function j(Rr, xa) {
                var ir = De[Rr];
                De[Rr] = xa,
                J.set(ir, J.get(ir) - 1),
                ir & l && J.set(l, J.get(l) - 1),
                J.set(xa, (J.get(xa) || 0) + 1),
                xa & l && J.set(l, (J.get(l) || 0) + 1)
            }
            for (var ve = new Uint8Array(Pe.length), Be = new Map, we = [], Ce = null, it = 0; it < Pe.length; it++)
                Ce || we.push(Ce = {
                    start: it,
                    end: Pe.length - 1,
                    level: He === "rtl" ? 1 : He === "ltr" ? 0 : Rh(it, !1)
                }),
                De[it] & Z && (Ce.end = it,
                Ce = null);
            for (var lt = fe | te | W | B | a | Te | pe | Z, Mt = function(Rr) {
                return Rr + (Rr & 1 ? 1 : 2)
            }, pt = function(Rr) {
                return Rr + (Rr & 1 ? 2 : 1)
            }, je = 0; je < we.length; je++) {
                Ce = we[je];
                var Ye = [{
                    _level: Ce.level,
                    _override: 0,
                    _isolate: 0
                }]
                  , ct = void 0
                  , _t = 0
                  , ut = 0
                  , Ut = 0;
                J.clear();
                for (var me = Ce.start; me <= Ce.end; me++) {
                    var Ee = De[me];
                    if (ct = Ye[Ye.length - 1],
                    J.set(Ee, (J.get(Ee) || 0) + 1),
                    Ee & l && J.set(l, (J.get(l) || 0) + 1),
                    Ee & lt)
                        if (Ee & (fe | te)) {
                            ve[me] = ct._level;
                            var at = (Ee === fe ? pt : Mt)(ct._level);
                            at <= Ve && !_t && !ut ? Ye.push({
                                _level: at,
                                _override: 0,
                                _isolate: 0
                            }) : _t || ut++
                        } else if (Ee & (W | B)) {
                            ve[me] = ct._level;
                            var Ct = (Ee === W ? pt : Mt)(ct._level);
                            Ct <= Ve && !_t && !ut ? Ye.push({
                                _level: Ct,
                                _override: Ee & W ? I : z,
                                _isolate: 0
                            }) : _t || ut++
                        } else if (Ee & a) {
                            Ee & ge && (Ee = Rh(me + 1, !0) === 1 ? ue : _e),
                            ve[me] = ct._level,
                            ct._override && j(me, ct._override);
                            var rt = (Ee === ue ? pt : Mt)(ct._level);
                            rt <= Ve && _t === 0 && ut === 0 ? (Ut++,
                            Ye.push({
                                _level: rt,
                                _override: 0,
                                _isolate: 1,
                                _isolInitIndex: me
                            })) : _t++
                        } else if (Ee & Te) {
                            if (_t > 0)
                                _t--;
                            else if (Ut > 0) {
                                for (ut = 0; !Ye[Ye.length - 1]._isolate; )
                                    Ye.pop();
                                var Ge = Ye[Ye.length - 1]._isolInitIndex;
                                Ge != null && (Be.set(Ge, me),
                                Be.set(me, Ge)),
                                Ye.pop(),
                                Ut--
                            }
                            ct = Ye[Ye.length - 1],
                            ve[me] = ct._level,
                            ct._override && j(me, ct._override)
                        } else
                            Ee & pe ? (_t === 0 && (ut > 0 ? ut-- : !ct._isolate && Ye.length > 1 && (Ye.pop(),
                            ct = Ye[Ye.length - 1])),
                            ve[me] = ct._level) : Ee & Z && (ve[me] = Ce.level);
                    else
                        ve[me] = ct._level,
                        ct._override && Ee !== q && j(me, ct._override)
                }
                for (var wt = [], Ot = null, Nt = Ce.start; Nt <= Ce.end; Nt++) {
                    var bt = De[Nt];
                    if (!(bt & u)) {
                        var Bt = ve[Nt]
                          , Gt = bt & a
                          , mt = bt === Te;
                        Ot && Bt === Ot._level ? (Ot._end = Nt,
                        Ot._endsWithIsolInit = Gt) : wt.push(Ot = {
                            _start: Nt,
                            _end: Nt,
                            _level: Bt,
                            _startsWithPDI: mt,
                            _endsWithIsolInit: Gt
                        })
                    }
                }
                for (var Lt = [], zt = 0; zt < wt.length; zt++) {
                    var Wt = wt[zt];
                    if (!Wt._startsWithPDI || Wt._startsWithPDI && !Be.has(Wt._start)) {
                        for (var Ln = [Ot = Wt], qt = void 0; Ot && Ot._endsWithIsolInit && (qt = Be.get(Ot._end)) != null; )
                            for (var Pt = zt + 1; Pt < wt.length; Pt++)
                                if (wt[Pt]._start === qt) {
                                    Ln.push(Ot = wt[Pt]);
                                    break
                                }
                        for (var un = [], $t = 0; $t < Ln.length; $t++)
                            for (var k = Ln[$t], $ = k._start; $ <= k._end; $++)
                                un.push($);
                        for (var Se = ve[un[0]], Ue = Ce.level, Fe = un[0] - 1; Fe >= 0; Fe--)
                            if (!(De[Fe] & u)) {
                                Ue = ve[Fe];
                                break
                            }
                        var Ke = un[un.length - 1]
                          , yt = ve[Ke]
                          , G = Ce.level;
                        if (!(De[Ke] & a)) {
                            for (var ce = Ke + 1; ce <= Ce.end; ce++)
                                if (!(De[ce] & u)) {
                                    G = ve[ce];
                                    break
                                }
                        }
                        Lt.push({
                            _seqIndices: un,
                            _sosType: Math.max(Ue, Se) % 2 ? I : z,
                            _eosType: Math.max(G, yt) % 2 ? I : z
                        })
                    }
                }
                for (var ye = 0; ye < Lt.length; ye++) {
                    var xe = Lt[ye]
                      , ne = xe._seqIndices
                      , nt = xe._sosType
                      , We = xe._eosType
                      , st = ve[ne[0]] & 1 ? I : z;
                    if (J.get(Q))
                        for (var ft = 0; ft < ne.length; ft++) {
                            var Tt = ne[ft];
                            if (De[Tt] & Q) {
                                for (var At = nt, Et = ft - 1; Et >= 0; Et--)
                                    if (!(De[ne[Et]] & u)) {
                                        At = De[ne[Et]];
                                        break
                                    }
                                j(Tt, At & (a | Te) ? H : At)
                            }
                        }
                    if (J.get(N))
                        for (var Xt = 0; Xt < ne.length; Xt++) {
                            var Jt = ne[Xt];
                            if (De[Jt] & N)
                                for (var en = Xt - 1; en >= -1; en--) {
                                    var Sn = en === -1 ? nt : De[ne[en]];
                                    if (Sn & s) {
                                        Sn === se && j(Jt, V);
                                        break
                                    }
                                }
                        }
                    if (J.get(se))
                        for (var Vt = 0; Vt < ne.length; Vt++) {
                            var It = ne[Vt];
                            De[It] & se && j(It, I)
                        }
                    if (J.get(P) || J.get(K))
                        for (var Cn = 1; Cn < ne.length - 1; Cn++) {
                            var fn = ne[Cn];
                            if (De[fn] & (P | K)) {
                                for (var In = 0, xn = 0, Bn = Cn - 1; Bn >= 0 && (In = De[ne[Bn]],
                                !!(In & u)); Bn--)
                                    ;
                                for (var hn = Cn + 1; hn < ne.length && (xn = De[ne[hn]],
                                !!(xn & u)); hn++)
                                    ;
                                In === xn && (De[fn] === P ? In === N : In & (N | V)) && j(fn, In)
                            }
                        }
                    if (J.get(N))
                        for (var Yt = 0; Yt < ne.length; Yt++) {
                            var ti = ne[Yt];
                            if (De[ti] & N) {
                                for (var ri = Yt - 1; ri >= 0 && De[ne[ri]] & (Y | u); ri--)
                                    j(ne[ri], N);
                                for (Yt++; Yt < ne.length && De[ne[Yt]] & (Y | u | N); Yt++)
                                    De[ne[Yt]] !== N && j(ne[Yt], N)
                            }
                        }
                    if (J.get(Y) || J.get(P) || J.get(K))
                        for (var bn = 0; bn < ne.length; bn++) {
                            var ui = ne[bn];
                            if (De[ui] & (Y | P | K)) {
                                j(ui, H);
                                for (var Ss = bn - 1; Ss >= 0 && De[ne[Ss]] & u; Ss--)
                                    j(ne[Ss], H);
                                for (var Di = bn + 1; Di < ne.length && De[ne[Di]] & u; Di++)
                                    j(ne[Di], H)
                            }
                        }
                    if (J.get(N))
                        for (var rf = 0, tu = nt; rf < ne.length; rf++) {
                            var nu = ne[rf]
                              , iu = De[nu];
                            iu & N ? tu === z && j(nu, z) : iu & s && (tu = iu)
                        }
                    if (J.get(l)) {
                        var ll = I | N | V
                          , Ch = ll | z
                          , Ro = [];
                        {
                            for (var Qs = [], Js = 0; Js < ne.length; Js++)
                                if (De[ne[Js]] & l) {
                                    var ya = Pe[ne[Js]]
                                      , Do = void 0;
                                    if (R(ya) !== null)
                                        if (Qs.length < 63)
                                            Qs.push({
                                                char: ya,
                                                seqIndex: Js
                                            });
                                        else
                                            break;
                                    else if ((Do = O(ya)) !== null)
                                        for (var ul = Qs.length - 1; ul >= 0; ul--) {
                                            var cl = Qs[ul].char;
                                            if (cl === Do || cl === O(L(ya)) || R(L(cl)) === ya) {
                                                Ro.push([Qs[ul].seqIndex, Js]),
                                                Qs.length = ul;
                                                break
                                            }
                                        }
                                }
                            Ro.sort(function(Rr, xa) {
                                return Rr[0] - xa[0]
                            })
                        }
                        for (var uc = 0; uc < Ro.length; uc++) {
                            for (var fl = Ro[uc], ia = fl[0], hl = fl[1], dl = !1, Xi = 0, cc = ia + 1; cc < hl; cc++) {
                                var fc = ne[cc];
                                if (De[fc] & Ch) {
                                    dl = !0;
                                    var af = De[fc] & ll ? I : z;
                                    if (af === st) {
                                        Xi = af;
                                        break
                                    }
                                }
                            }
                            if (dl && !Xi) {
                                Xi = nt;
                                for (var bs = ia - 1; bs >= 0; bs--) {
                                    var pl = ne[bs];
                                    if (De[pl] & Ch) {
                                        var ru = De[pl] & ll ? I : z;
                                        ru !== st ? Xi = ru : Xi = st;
                                        break
                                    }
                                }
                            }
                            if (Xi) {
                                if (De[ne[ia]] = De[ne[hl]] = Xi,
                                Xi !== st) {
                                    for (var ji = ia + 1; ji < ne.length; ji++)
                                        if (!(De[ne[ji]] & u)) {
                                            v(Pe[ne[ji]]) & Q && (De[ne[ji]] = Xi);
                                            break
                                        }
                                }
                                if (Xi !== st) {
                                    for (var _a = hl + 1; _a < ne.length; _a++)
                                        if (!(De[ne[_a]] & u)) {
                                            v(Pe[ne[_a]]) & Q && (De[ne[_a]] = Xi);
                                            break
                                        }
                                }
                            }
                        }
                        for (var ra = 0; ra < ne.length; ra++)
                            if (De[ne[ra]] & l) {
                                for (var ml = ra, sf = ra, ka = nt, Ms = ra - 1; Ms >= 0; Ms--)
                                    if (De[ne[Ms]] & u)
                                        ml = Ms;
                                    else {
                                        ka = De[ne[Ms]] & ll ? I : z;
                                        break
                                    }
                                for (var gl = We, Ts = ra + 1; Ts < ne.length; Ts++)
                                    if (De[ne[Ts]] & (l | u))
                                        sf = Ts;
                                    else {
                                        gl = De[ne[Ts]] & ll ? I : z;
                                        break
                                    }
                                for (var hc = ml; hc <= sf; hc++)
                                    De[ne[hc]] = ka === gl ? ka : st;
                                ra = sf
                            }
                    }
                }
                for (var kr = Ce.start; kr <= Ce.end; kr++) {
                    var Qg = ve[kr]
                      , zi = De[kr];
                    if (Qg & 1 ? zi & (z | N | V) && ve[kr]++ : zi & I ? ve[kr]++ : zi & (V | N) && (ve[kr] += 2),
                    zi & u && (ve[kr] = kr === 0 ? Ce.level : ve[kr - 1]),
                    kr === Ce.end || v(Pe[kr]) & (oe | Z))
                        for (var vl = kr; vl >= 0 && v(Pe[vl]) & f; vl--)
                            ve[vl] = Ce.level
                }
            }
            return {
                levels: ve,
                paragraphs: we
            };
            function Rh(Rr, xa) {
                for (var ir = Rr; ir < Pe.length; ir++) {
                    var Ga = De[ir];
                    if (Ga & (I | se))
                        return 1;
                    if (Ga & (Z | z) || xa && Ga === Te)
                        return 0;
                    if (Ga & a) {
                        var Dh = Sp(ir);
                        ir = Dh === -1 ? Pe.length : Dh
                    }
                }
                return 0
            }
            function Sp(Rr) {
                for (var xa = 1, ir = Rr + 1; ir < Pe.length; ir++) {
                    var Ga = De[ir];
                    if (Ga & Z)
                        break;
                    if (Ga & Te) {
                        if (--xa === 0)
                            return ir
                    } else
                        Ga & a && xa++
                }
                return -1
            }
        }
        var ot = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", tt;
        function $e() {
            if (!tt) {
                var Pe = T(ot, !0)
                  , He = Pe.map
                  , Ve = Pe.reverseMap;
                Ve.forEach(function(De, vt) {
                    He.set(vt, De)
                }),
                tt = He
            }
        }
        function re(Pe) {
            return $e(),
            tt.get(Pe) || null
        }
        function Le(Pe, He, Ve, De) {
            var vt = Pe.length;
            Ve = Math.max(0, Ve == null ? 0 : +Ve),
            De = Math.min(vt - 1, De == null ? vt - 1 : +De);
            for (var J = new Map, j = Ve; j <= De; j++)
                if (He[j] & 1) {
                    var ve = re(Pe[j]);
                    ve !== null && J.set(j, ve)
                }
            return J
        }
        function Ne(Pe, He, Ve, De) {
            var vt = Pe.length;
            Ve = Math.max(0, Ve == null ? 0 : +Ve),
            De = Math.min(vt - 1, De == null ? vt - 1 : +De);
            var J = [];
            return He.paragraphs.forEach(function(j) {
                var ve = Math.max(Ve, j.start)
                  , Be = Math.min(De, j.end);
                if (ve < Be) {
                    for (var we = He.levels.slice(ve, Be + 1), Ce = Be; Ce >= ve && v(Pe[Ce]) & f; Ce--)
                        we[Ce] = j.level;
                    for (var it = j.level, lt = 1 / 0, Mt = 0; Mt < we.length; Mt++) {
                        var pt = we[Mt];
                        pt > it && (it = pt),
                        pt < lt && (lt = pt | 1)
                    }
                    for (var je = it; je >= lt; je--)
                        for (var Ye = 0; Ye < we.length; Ye++)
                            if (we[Ye] >= je) {
                                for (var ct = Ye; Ye + 1 < we.length && we[Ye + 1] >= je; )
                                    Ye++;
                                Ye > ct && J.push([ct + ve, Ye + ve])
                            }
                }
            }),
            J
        }
        function Oe(Pe, He, Ve, De) {
            var vt = le(Pe, He, Ve, De)
              , J = [].concat(Pe);
            return vt.forEach(function(j, ve) {
                J[ve] = (He.levels[j] & 1 ? re(Pe[j]) : null) || Pe[j]
            }),
            J.join("")
        }
        function le(Pe, He, Ve, De) {
            for (var vt = Ne(Pe, He, Ve, De), J = [], j = 0; j < Pe.length; j++)
                J[j] = j;
            return vt.forEach(function(ve) {
                for (var Be = ve[0], we = ve[1], Ce = J.slice(Be, we + 1), it = Ce.length; it--; )
                    J[we - it] = Ce[it]
            }),
            J
        }
        return e.closingToOpeningBracket = O,
        e.getBidiCharType = v,
        e.getBidiCharTypeName = y,
        e.getCanonicalBracket = L,
        e.getEmbeddingLevels = Ze,
        e.getMirroredCharacter = re,
        e.getMirroredCharactersMap = Le,
        e.getReorderSegments = Ne,
        e.getReorderedIndices = le,
        e.getReorderedString = Oe,
        e.openingToClosingBracket = R,
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e
    }({});
    return r
}
const rI = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function Rw(r) {
    const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function t(n, i) {
        let a = Un[i];
        return a ? Rw(a) : n
    }
    return r.replace(e, t)
}
const da = [];
for (let r = 0; r < 256; r++)
    da[r] = (r < 16 ? "0" : "") + r.toString(16);
function g$() {
    const r = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , n = Math.random() * 4294967295 | 0;
    return (da[r & 255] + da[r >> 8 & 255] + da[r >> 16 & 255] + da[r >> 24 & 255] + "-" + da[e & 255] + da[e >> 8 & 255] + "-" + da[e >> 16 & 15 | 64] + da[e >> 24 & 255] + "-" + da[t & 63 | 128] + da[t >> 8 & 255] + "-" + da[t >> 16 & 255] + da[t >> 24 & 255] + da[n & 255] + da[n >> 8 & 255] + da[n >> 16 & 255] + da[n >> 24 & 255]).toUpperCase()
}
const Od = Object.assign || function() {
    let r = arguments[0];
    for (let e = 1, t = arguments.length; e < t; e++) {
        let n = arguments[e];
        if (n)
            for (let i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (r[i] = n[i])
    }
    return r
}
  , v$ = Date.now()
  , ZO = new WeakMap
  , KO = new Map;
let y$ = 1e10;
function Dw(r, e) {
    const t = b$(e);
    let n = ZO.get(r);
    if (n || ZO.set(r, n = Object.create(null)),
    n[t])
        return new n[t];
    const i = `_onBeforeCompile${t}`
      , a = function(f, d) {
        r.onBeforeCompile.call(this, f, d);
        const g = this.customProgramCacheKey() + "|" + f.vertexShader + "|" + f.fragmentShader;
        let v = KO[g];
        if (!v) {
            const y = _$(this, f, e, t);
            v = KO[g] = y
        }
        f.vertexShader = v.vertexShader,
        f.fragmentShader = v.fragmentShader,
        Od(f.uniforms, this.uniforms),
        e.timeUniform && (f.uniforms[e.timeUniform] = {
            get value() {
                return Date.now() - v$
            }
        }),
        this[i] && this[i](f)
    }
      , s = function() {
        return l(e.chained ? r : r.clone())
    }
      , l = function(f) {
        const d = Object.create(f, u);
        return Object.defineProperty(d, "baseMaterial", {
            value: r
        }),
        Object.defineProperty(d, "id", {
            value: y$++
        }),
        d.uuid = g$(),
        d.uniforms = Od({}, f.uniforms, e.uniforms),
        d.defines = Od({}, f.defines, e.defines),
        d.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = "",
        d.extensions = Od({}, f.extensions, e.extensions),
        d._listeners = void 0,
        d
    }
      , u = {
        constructor: {
            value: s
        },
        isDerivedMaterial: {
            value: !0
        },
        type: {
            get: () => r.type,
            set: f => {
                r.type = f
            }
        },
        isDerivedFrom: {
            writable: !0,
            configurable: !0,
            value: function(f) {
                const d = this.baseMaterial;
                return f === d || d.isDerivedMaterial && d.isDerivedFrom(f) || !1
            }
        },
        customProgramCacheKey: {
            writable: !0,
            configurable: !0,
            value: function() {
                return r.customProgramCacheKey() + "|" + t
            }
        },
        onBeforeCompile: {
            get() {
                return a
            },
            set(f) {
                this[i] = f
            }
        },
        copy: {
            writable: !0,
            configurable: !0,
            value: function(f) {
                return r.copy.call(this, f),
                !r.isShaderMaterial && !r.isDerivedMaterial && (Od(this.extensions, f.extensions),
                Od(this.defines, f.defines),
                Od(this.uniforms, uC.clone(f.uniforms))),
                this
            }
        },
        clone: {
            writable: !0,
            configurable: !0,
            value: function() {
                const f = new r.constructor;
                return l(f).copy(this)
            }
        },
        getDepthMaterial: {
            writable: !0,
            configurable: !0,
            value: function() {
                let f = this._depthMaterial;
                return f || (f = this._depthMaterial = Dw(r.isDerivedMaterial ? r.getDepthMaterial() : new NM({
                    depthPacking: iC
                }), e),
                f.defines.IS_DEPTH_MATERIAL = "",
                f.uniforms = this.uniforms),
                f
            }
        },
        getDistanceMaterial: {
            writable: !0,
            configurable: !0,
            value: function() {
                let f = this._distanceMaterial;
                return f || (f = this._distanceMaterial = Dw(r.isDerivedMaterial ? r.getDistanceMaterial() : new LM, e),
                f.defines.IS_DISTANCE_MATERIAL = "",
                f.uniforms = this.uniforms),
                f
            }
        },
        dispose: {
            writable: !0,
            configurable: !0,
            value() {
                const {_depthMaterial: f, _distanceMaterial: d} = this;
                f && f.dispose(),
                d && d.dispose(),
                r.dispose.call(this)
            }
        }
    };
    return n[t] = s,
    new s
}
function _$(r, {vertexShader: e, fragmentShader: t}, n, i) {
    let {vertexDefs: a, vertexMainIntro: s, vertexMainOutro: l, vertexTransform: u, fragmentDefs: f, fragmentMainIntro: d, fragmentMainOutro: g, fragmentColorTransform: v, customRewriter: y, timeUniform: S} = n;
    if (a = a || "",
    s = s || "",
    l = l || "",
    f = f || "",
    d = d || "",
    g = g || "",
    (u || y) && (e = Rw(e)),
    (v || y) && (t = t.replace(/^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm, `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`),
    t = Rw(t)),
    y) {
        let T = y({
            vertexShader: e,
            fragmentShader: t
        });
        e = T.vertexShader,
        t = T.fragmentShader
    }
    if (v) {
        let T = [];
        t = t.replace(/^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm, M => (T.push(M),
        "")),
        g = `${v}
${T.join(`
`)}
${g}`
    }
    if (S) {
        const T = `
uniform float ${S};
`;
        a = T + a,
        f = T + f
    }
    return u && (e = `vec3 troika_position_${i};
vec3 troika_normal_${i};
vec2 troika_uv_${i};
${e}
`,
    a = `${a}
void troikaVertexTransform${i}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${u}
}
`,
    s = `
troika_position_${i} = vec3(position);
troika_normal_${i} = vec3(normal);
troika_uv_${i} = vec2(uv);
troikaVertexTransform${i}(troika_position_${i}, troika_normal_${i}, troika_uv_${i});
${s}
`,
    e = e.replace(/\b(position|normal|uv)\b/g, (T, M, b, A) => /\battribute\s+vec[23]\s+$/.test(A.substr(0, b)) ? M : `troika_${M}_${i}`),
    r.map && r.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${i}`))),
    e = QO(e, i, a, s, l),
    t = QO(t, i, f, d, g),
    {
        vertexShader: e,
        fragmentShader: t
    }
}
function QO(r, e, t, n, i) {
    return (n || i || t) && (r = r.replace(rI, `
${t}
void troikaOrigMain${e}() {`),
    r += `
void main() {
  ${n}
  troikaOrigMain${e}();
  ${i}
}`),
    r
}
function x$(r, e) {
    return r === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e
}
let S$ = 0;
const JO = new Map;
function b$(r) {
    const e = JSON.stringify(r, x$);
    let t = JO.get(e);
    return t == null && JO.set(e, t = ++S$),
    t
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function M$() {
    return typeof window > "u" && (self.window = self),
    function(r) {
        var e = {
            parse: function(i) {
                var a = e._bin
                  , s = new Uint8Array(i);
                if (a.readASCII(s, 0, 4) == "ttcf") {
                    var l = 4;
                    a.readUshort(s, l),
                    l += 2,
                    a.readUshort(s, l),
                    l += 2;
                    var u = a.readUint(s, l);
                    l += 4;
                    for (var f = [], d = 0; d < u; d++) {
                        var g = a.readUint(s, l);
                        l += 4,
                        f.push(e._readFont(s, g))
                    }
                    return f
                }
                return [e._readFont(s, 0)]
            },
            _readFont: function(i, a) {
                var s = e._bin
                  , l = a;
                s.readFixed(i, a),
                a += 4;
                var u = s.readUshort(i, a);
                a += 2,
                s.readUshort(i, a),
                a += 2,
                s.readUshort(i, a),
                a += 2,
                s.readUshort(i, a),
                a += 2;
                for (var f = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], d = {
                    _data: i,
                    _offset: l
                }, g = {}, v = 0; v < u; v++) {
                    var y = s.readASCII(i, a, 4);
                    a += 4,
                    s.readUint(i, a),
                    a += 4;
                    var S = s.readUint(i, a);
                    a += 4;
                    var T = s.readUint(i, a);
                    a += 4,
                    g[y] = {
                        offset: S,
                        length: T
                    }
                }
                for (v = 0; v < f.length; v++) {
                    var M = f[v];
                    g[M] && (d[M.trim()] = e[M.trim()].parse(i, g[M].offset, g[M].length, d))
                }
                return d
            },
            _tabOffset: function(i, a, s) {
                for (var l = e._bin, u = l.readUshort(i, s + 4), f = s + 12, d = 0; d < u; d++) {
                    var g = l.readASCII(i, f, 4);
                    f += 4,
                    l.readUint(i, f),
                    f += 4;
                    var v = l.readUint(i, f);
                    if (f += 4,
                    l.readUint(i, f),
                    f += 4,
                    g == a)
                        return v
                }
                return 0
            }
        };
        e._bin = {
            readFixed: function(i, a) {
                return (i[a] << 8 | i[a + 1]) + (i[a + 2] << 8 | i[a + 3]) / 65540
            },
            readF2dot14: function(i, a) {
                return e._bin.readShort(i, a) / 16384
            },
            readInt: function(i, a) {
                return e._bin._view(i).getInt32(a)
            },
            readInt8: function(i, a) {
                return e._bin._view(i).getInt8(a)
            },
            readShort: function(i, a) {
                return e._bin._view(i).getInt16(a)
            },
            readUshort: function(i, a) {
                return e._bin._view(i).getUint16(a)
            },
            readUshorts: function(i, a, s) {
                for (var l = [], u = 0; u < s; u++)
                    l.push(e._bin.readUshort(i, a + 2 * u));
                return l
            },
            readUint: function(i, a) {
                return e._bin._view(i).getUint32(a)
            },
            readUint64: function(i, a) {
                return 4294967296 * e._bin.readUint(i, a) + e._bin.readUint(i, a + 4)
            },
            readASCII: function(i, a, s) {
                for (var l = "", u = 0; u < s; u++)
                    l += String.fromCharCode(i[a + u]);
                return l
            },
            readUnicode: function(i, a, s) {
                for (var l = "", u = 0; u < s; u++) {
                    var f = i[a++] << 8 | i[a++];
                    l += String.fromCharCode(f)
                }
                return l
            },
            _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder : null,
            readUTF8: function(i, a, s) {
                var l = e._bin._tdec;
                return l && a == 0 && s == i.length ? l.decode(i) : e._bin.readASCII(i, a, s)
            },
            readBytes: function(i, a, s) {
                for (var l = [], u = 0; u < s; u++)
                    l.push(i[a + u]);
                return l
            },
            readASCIIArray: function(i, a, s) {
                for (var l = [], u = 0; u < s; u++)
                    l.push(String.fromCharCode(i[a + u]));
                return l
            },
            _view: function(i) {
                return i._dataView || (i._dataView = i.buffer ? new DataView(i.buffer,i.byteOffset,i.byteLength) : new DataView(new Uint8Array(i).buffer))
            }
        },
        e._lctf = {},
        e._lctf.parse = function(i, a, s, l, u) {
            var f = e._bin
              , d = {}
              , g = a;
            f.readFixed(i, a),
            a += 4;
            var v = f.readUshort(i, a);
            a += 2;
            var y = f.readUshort(i, a);
            a += 2;
            var S = f.readUshort(i, a);
            return a += 2,
            d.scriptList = e._lctf.readScriptList(i, g + v),
            d.featureList = e._lctf.readFeatureList(i, g + y),
            d.lookupList = e._lctf.readLookupList(i, g + S, u),
            d
        }
        ,
        e._lctf.readLookupList = function(i, a, s) {
            var l = e._bin
              , u = a
              , f = []
              , d = l.readUshort(i, a);
            a += 2;
            for (var g = 0; g < d; g++) {
                var v = l.readUshort(i, a);
                a += 2;
                var y = e._lctf.readLookupTable(i, u + v, s);
                f.push(y)
            }
            return f
        }
        ,
        e._lctf.readLookupTable = function(i, a, s) {
            var l = e._bin
              , u = a
              , f = {
                tabs: []
            };
            f.ltype = l.readUshort(i, a),
            a += 2,
            f.flag = l.readUshort(i, a),
            a += 2;
            var d = l.readUshort(i, a);
            a += 2;
            for (var g = f.ltype, v = 0; v < d; v++) {
                var y = l.readUshort(i, a);
                a += 2;
                var S = s(i, g, u + y, f);
                f.tabs.push(S)
            }
            return f
        }
        ,
        e._lctf.numOfOnes = function(i) {
            for (var a = 0, s = 0; s < 32; s++)
                (i >>> s & 1) != 0 && a++;
            return a
        }
        ,
        e._lctf.readClassDef = function(i, a) {
            var s = e._bin
              , l = []
              , u = s.readUshort(i, a);
            if (a += 2,
            u == 1) {
                var f = s.readUshort(i, a);
                a += 2;
                var d = s.readUshort(i, a);
                a += 2;
                for (var g = 0; g < d; g++)
                    l.push(f + g),
                    l.push(f + g),
                    l.push(s.readUshort(i, a)),
                    a += 2
            }
            if (u == 2) {
                var v = s.readUshort(i, a);
                for (a += 2,
                g = 0; g < v; g++)
                    l.push(s.readUshort(i, a)),
                    a += 2,
                    l.push(s.readUshort(i, a)),
                    a += 2,
                    l.push(s.readUshort(i, a)),
                    a += 2
            }
            return l
        }
        ,
        e._lctf.getInterval = function(i, a) {
            for (var s = 0; s < i.length; s += 3) {
                var l = i[s]
                  , u = i[s + 1];
                if (i[s + 2],
                l <= a && a <= u)
                    return s
            }
            return -1
        }
        ,
        e._lctf.readCoverage = function(i, a) {
            var s = e._bin
              , l = {};
            l.fmt = s.readUshort(i, a),
            a += 2;
            var u = s.readUshort(i, a);
            return a += 2,
            l.fmt == 1 && (l.tab = s.readUshorts(i, a, u)),
            l.fmt == 2 && (l.tab = s.readUshorts(i, a, 3 * u)),
            l
        }
        ,
        e._lctf.coverageIndex = function(i, a) {
            var s = i.tab;
            if (i.fmt == 1)
                return s.indexOf(a);
            if (i.fmt == 2) {
                var l = e._lctf.getInterval(s, a);
                if (l != -1)
                    return s[l + 2] + (a - s[l])
            }
            return -1
        }
        ,
        e._lctf.readFeatureList = function(i, a) {
            var s = e._bin
              , l = a
              , u = []
              , f = s.readUshort(i, a);
            a += 2;
            for (var d = 0; d < f; d++) {
                var g = s.readASCII(i, a, 4);
                a += 4;
                var v = s.readUshort(i, a);
                a += 2;
                var y = e._lctf.readFeatureTable(i, l + v);
                y.tag = g.trim(),
                u.push(y)
            }
            return u
        }
        ,
        e._lctf.readFeatureTable = function(i, a) {
            var s = e._bin
              , l = a
              , u = {}
              , f = s.readUshort(i, a);
            a += 2,
            f > 0 && (u.featureParams = l + f);
            var d = s.readUshort(i, a);
            a += 2,
            u.tab = [];
            for (var g = 0; g < d; g++)
                u.tab.push(s.readUshort(i, a + 2 * g));
            return u
        }
        ,
        e._lctf.readScriptList = function(i, a) {
            var s = e._bin
              , l = a
              , u = {}
              , f = s.readUshort(i, a);
            a += 2;
            for (var d = 0; d < f; d++) {
                var g = s.readASCII(i, a, 4);
                a += 4;
                var v = s.readUshort(i, a);
                a += 2,
                u[g.trim()] = e._lctf.readScriptTable(i, l + v)
            }
            return u
        }
        ,
        e._lctf.readScriptTable = function(i, a) {
            var s = e._bin
              , l = a
              , u = {}
              , f = s.readUshort(i, a);
            a += 2,
            f > 0 && (u.default = e._lctf.readLangSysTable(i, l + f));
            var d = s.readUshort(i, a);
            a += 2;
            for (var g = 0; g < d; g++) {
                var v = s.readASCII(i, a, 4);
                a += 4;
                var y = s.readUshort(i, a);
                a += 2,
                u[v.trim()] = e._lctf.readLangSysTable(i, l + y)
            }
            return u
        }
        ,
        e._lctf.readLangSysTable = function(i, a) {
            var s = e._bin
              , l = {};
            s.readUshort(i, a),
            a += 2,
            l.reqFeature = s.readUshort(i, a),
            a += 2;
            var u = s.readUshort(i, a);
            return a += 2,
            l.features = s.readUshorts(i, a, u),
            l
        }
        ,
        e.CFF = {},
        e.CFF.parse = function(i, a, s) {
            var l = e._bin;
            (i = new Uint8Array(i.buffer,a,s))[a = 0],
            i[++a],
            i[++a],
            i[++a],
            a++;
            var u = [];
            a = e.CFF.readIndex(i, a, u);
            for (var f = [], d = 0; d < u.length - 1; d++)
                f.push(l.readASCII(i, a + u[d], u[d + 1] - u[d]));
            a += u[u.length - 1];
            var g = [];
            a = e.CFF.readIndex(i, a, g);
            var v = [];
            for (d = 0; d < g.length - 1; d++)
                v.push(e.CFF.readDict(i, a + g[d], a + g[d + 1]));
            a += g[g.length - 1];
            var y = v[0]
              , S = [];
            a = e.CFF.readIndex(i, a, S);
            var T = [];
            for (d = 0; d < S.length - 1; d++)
                T.push(l.readASCII(i, a + S[d], S[d + 1] - S[d]));
            if (a += S[S.length - 1],
            e.CFF.readSubrs(i, a, y),
            y.CharStrings) {
                a = y.CharStrings,
                S = [],
                a = e.CFF.readIndex(i, a, S);
                var M = [];
                for (d = 0; d < S.length - 1; d++)
                    M.push(l.readBytes(i, a + S[d], S[d + 1] - S[d]));
                y.CharStrings = M
            }
            if (y.ROS) {
                a = y.FDArray;
                var b = [];
                for (a = e.CFF.readIndex(i, a, b),
                y.FDArray = [],
                d = 0; d < b.length - 1; d++) {
                    var A = e.CFF.readDict(i, a + b[d], a + b[d + 1]);
                    e.CFF._readFDict(i, A, T),
                    y.FDArray.push(A)
                }
                a += b[b.length - 1],
                a = y.FDSelect,
                y.FDSelect = [];
                var C = i[a];
                if (a++,
                C != 3)
                    throw C;
                var R = l.readUshort(i, a);
                for (a += 2,
                d = 0; d < R + 1; d++)
                    y.FDSelect.push(l.readUshort(i, a), i[a + 2]),
                    a += 3
            }
            return y.Encoding && (y.Encoding = e.CFF.readEncoding(i, y.Encoding, y.CharStrings.length)),
            y.charset && (y.charset = e.CFF.readCharset(i, y.charset, y.CharStrings.length)),
            e.CFF._readFDict(i, y, T),
            y
        }
        ,
        e.CFF._readFDict = function(i, a, s) {
            var l;
            for (var u in a.Private && (l = a.Private[1],
            a.Private = e.CFF.readDict(i, l, l + a.Private[0]),
            a.Private.Subrs && e.CFF.readSubrs(i, l + a.Private.Subrs, a.Private)),
            a)
                ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(u) != -1 && (a[u] = s[a[u] - 426 + 35])
        }
        ,
        e.CFF.readSubrs = function(i, a, s) {
            var l = e._bin
              , u = [];
            a = e.CFF.readIndex(i, a, u);
            var f, d = u.length;
            f = d < 1240 ? 107 : d < 33900 ? 1131 : 32768,
            s.Bias = f,
            s.Subrs = [];
            for (var g = 0; g < u.length - 1; g++)
                s.Subrs.push(l.readBytes(i, a + u[g], u[g + 1] - u[g]))
        }
        ,
        e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0],
        e.CFF.glyphByUnicode = function(i, a) {
            for (var s = 0; s < i.charset.length; s++)
                if (i.charset[s] == a)
                    return s;
            return -1
        }
        ,
        e.CFF.glyphBySE = function(i, a) {
            return a < 0 || a > 255 ? -1 : e.CFF.glyphByUnicode(i, e.CFF.tableSE[a])
        }
        ,
        e.CFF.readEncoding = function(i, a, s) {
            e._bin;
            var l = [".notdef"]
              , u = i[a];
            if (a++,
            u != 0)
                throw "error: unknown encoding format: " + u;
            var f = i[a];
            a++;
            for (var d = 0; d < f; d++)
                l.push(i[a + d]);
            return l
        }
        ,
        e.CFF.readCharset = function(i, a, s) {
            var l = e._bin
              , u = [".notdef"]
              , f = i[a];
            if (a++,
            f == 0)
                for (var d = 0; d < s; d++) {
                    var g = l.readUshort(i, a);
                    a += 2,
                    u.push(g)
                }
            else {
                if (f != 1 && f != 2)
                    throw "error: format: " + f;
                for (; u.length < s; ) {
                    g = l.readUshort(i, a),
                    a += 2;
                    var v = 0;
                    for (f == 1 ? (v = i[a],
                    a++) : (v = l.readUshort(i, a),
                    a += 2),
                    d = 0; d <= v; d++)
                        u.push(g),
                        g++
                }
            }
            return u
        }
        ,
        e.CFF.readIndex = function(i, a, s) {
            var l = e._bin
              , u = l.readUshort(i, a) + 1
              , f = i[a += 2];
            if (a++,
            f == 1)
                for (var d = 0; d < u; d++)
                    s.push(i[a + d]);
            else if (f == 2)
                for (d = 0; d < u; d++)
                    s.push(l.readUshort(i, a + 2 * d));
            else if (f == 3)
                for (d = 0; d < u; d++)
                    s.push(16777215 & l.readUint(i, a + 3 * d - 1));
            else if (u != 1)
                throw "unsupported offset size: " + f + ", count: " + u;
            return (a += u * f) - 1
        }
        ,
        e.CFF.getCharString = function(i, a, s) {
            var l = e._bin
              , u = i[a]
              , f = i[a + 1];
            i[a + 2],
            i[a + 3],
            i[a + 4];
            var d = 1
              , g = null
              , v = null;
            u <= 20 && (g = u,
            d = 1),
            u == 12 && (g = 100 * u + f,
            d = 2),
            21 <= u && u <= 27 && (g = u,
            d = 1),
            u == 28 && (v = l.readShort(i, a + 1),
            d = 3),
            29 <= u && u <= 31 && (g = u,
            d = 1),
            32 <= u && u <= 246 && (v = u - 139,
            d = 1),
            247 <= u && u <= 250 && (v = 256 * (u - 247) + f + 108,
            d = 2),
            251 <= u && u <= 254 && (v = 256 * -(u - 251) - f - 108,
            d = 2),
            u == 255 && (v = l.readInt(i, a + 1) / 65535,
            d = 5),
            s.val = v ?? "o" + g,
            s.size = d
        }
        ,
        e.CFF.readCharString = function(i, a, s) {
            for (var l = a + s, u = e._bin, f = []; a < l; ) {
                var d = i[a]
                  , g = i[a + 1];
                i[a + 2],
                i[a + 3],
                i[a + 4];
                var v = 1
                  , y = null
                  , S = null;
                d <= 20 && (y = d,
                v = 1),
                d == 12 && (y = 100 * d + g,
                v = 2),
                d != 19 && d != 20 || (y = d,
                v = 2),
                21 <= d && d <= 27 && (y = d,
                v = 1),
                d == 28 && (S = u.readShort(i, a + 1),
                v = 3),
                29 <= d && d <= 31 && (y = d,
                v = 1),
                32 <= d && d <= 246 && (S = d - 139,
                v = 1),
                247 <= d && d <= 250 && (S = 256 * (d - 247) + g + 108,
                v = 2),
                251 <= d && d <= 254 && (S = 256 * -(d - 251) - g - 108,
                v = 2),
                d == 255 && (S = u.readInt(i, a + 1) / 65535,
                v = 5),
                f.push(S ?? "o" + y),
                a += v
            }
            return f
        }
        ,
        e.CFF.readDict = function(i, a, s) {
            for (var l = e._bin, u = {}, f = []; a < s; ) {
                var d = i[a]
                  , g = i[a + 1];
                i[a + 2],
                i[a + 3],
                i[a + 4];
                var v = 1
                  , y = null
                  , S = null;
                if (d == 28 && (S = l.readShort(i, a + 1),
                v = 3),
                d == 29 && (S = l.readInt(i, a + 1),
                v = 5),
                32 <= d && d <= 246 && (S = d - 139,
                v = 1),
                247 <= d && d <= 250 && (S = 256 * (d - 247) + g + 108,
                v = 2),
                251 <= d && d <= 254 && (S = 256 * -(d - 251) - g - 108,
                v = 2),
                d == 255)
                    throw S = l.readInt(i, a + 1) / 65535,
                    v = 5,
                    "unknown number";
                if (d == 30) {
                    var T = [];
                    for (v = 1; ; ) {
                        var M = i[a + v];
                        v++;
                        var b = M >> 4
                          , A = 15 & M;
                        if (b != 15 && T.push(b),
                        A != 15 && T.push(A),
                        A == 15)
                            break
                    }
                    for (var C = "", R = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], O = 0; O < T.length; O++)
                        C += R[T[O]];
                    S = parseFloat(C)
                }
                d <= 21 && (y = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][d],
                v = 1,
                d == 12 && (y = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][g],
                v = 2)),
                y != null ? (u[y] = f.length == 1 ? f[0] : f,
                f = []) : f.push(S),
                a += v
            }
            return u
        }
        ,
        e.cmap = {},
        e.cmap.parse = function(i, a, s) {
            i = new Uint8Array(i.buffer,a,s),
            a = 0;
            var l = e._bin
              , u = {};
            l.readUshort(i, a),
            a += 2;
            var f = l.readUshort(i, a);
            a += 2;
            var d = [];
            u.tables = [];
            for (var g = 0; g < f; g++) {
                var v = l.readUshort(i, a);
                a += 2;
                var y = l.readUshort(i, a);
                a += 2;
                var S = l.readUint(i, a);
                a += 4;
                var T = "p" + v + "e" + y
                  , M = d.indexOf(S);
                if (M == -1) {
                    var b;
                    M = u.tables.length,
                    d.push(S);
                    var A = l.readUshort(i, S);
                    A == 0 ? b = e.cmap.parse0(i, S) : A == 4 ? b = e.cmap.parse4(i, S) : A == 6 ? b = e.cmap.parse6(i, S) : A == 12 ? b = e.cmap.parse12(i, S) : console.debug("unknown format: " + A, v, y, S),
                    u.tables.push(b)
                }
                if (u[T] != null)
                    throw "multiple tables for one platform+encoding";
                u[T] = M
            }
            return u
        }
        ,
        e.cmap.parse0 = function(i, a) {
            var s = e._bin
              , l = {};
            l.format = s.readUshort(i, a),
            a += 2;
            var u = s.readUshort(i, a);
            a += 2,
            s.readUshort(i, a),
            a += 2,
            l.map = [];
            for (var f = 0; f < u - 6; f++)
                l.map.push(i[a + f]);
            return l
        }
        ,
        e.cmap.parse4 = function(i, a) {
            var s = e._bin
              , l = a
              , u = {};
            u.format = s.readUshort(i, a),
            a += 2;
            var f = s.readUshort(i, a);
            a += 2,
            s.readUshort(i, a),
            a += 2;
            var d = s.readUshort(i, a);
            a += 2;
            var g = d / 2;
            u.searchRange = s.readUshort(i, a),
            a += 2,
            u.entrySelector = s.readUshort(i, a),
            a += 2,
            u.rangeShift = s.readUshort(i, a),
            a += 2,
            u.endCount = s.readUshorts(i, a, g),
            a += 2 * g,
            a += 2,
            u.startCount = s.readUshorts(i, a, g),
            a += 2 * g,
            u.idDelta = [];
            for (var v = 0; v < g; v++)
                u.idDelta.push(s.readShort(i, a)),
                a += 2;
            for (u.idRangeOffset = s.readUshorts(i, a, g),
            a += 2 * g,
            u.glyphIdArray = []; a < l + f; )
                u.glyphIdArray.push(s.readUshort(i, a)),
                a += 2;
            return u
        }
        ,
        e.cmap.parse6 = function(i, a) {
            var s = e._bin
              , l = {};
            l.format = s.readUshort(i, a),
            a += 2,
            s.readUshort(i, a),
            a += 2,
            s.readUshort(i, a),
            a += 2,
            l.firstCode = s.readUshort(i, a),
            a += 2;
            var u = s.readUshort(i, a);
            a += 2,
            l.glyphIdArray = [];
            for (var f = 0; f < u; f++)
                l.glyphIdArray.push(s.readUshort(i, a)),
                a += 2;
            return l
        }
        ,
        e.cmap.parse12 = function(i, a) {
            var s = e._bin
              , l = {};
            l.format = s.readUshort(i, a),
            a += 2,
            a += 2,
            s.readUint(i, a),
            a += 4,
            s.readUint(i, a),
            a += 4;
            var u = s.readUint(i, a);
            a += 4,
            l.groups = [];
            for (var f = 0; f < u; f++) {
                var d = a + 12 * f
                  , g = s.readUint(i, d + 0)
                  , v = s.readUint(i, d + 4)
                  , y = s.readUint(i, d + 8);
                l.groups.push([g, v, y])
            }
            return l
        }
        ,
        e.glyf = {},
        e.glyf.parse = function(i, a, s, l) {
            for (var u = [], f = 0; f < l.maxp.numGlyphs; f++)
                u.push(null);
            return u
        }
        ,
        e.glyf._parseGlyf = function(i, a) {
            var s = e._bin
              , l = i._data
              , u = e._tabOffset(l, "glyf", i._offset) + i.loca[a];
            if (i.loca[a] == i.loca[a + 1])
                return null;
            var f = {};
            if (f.noc = s.readShort(l, u),
            u += 2,
            f.xMin = s.readShort(l, u),
            u += 2,
            f.yMin = s.readShort(l, u),
            u += 2,
            f.xMax = s.readShort(l, u),
            u += 2,
            f.yMax = s.readShort(l, u),
            u += 2,
            f.xMin >= f.xMax || f.yMin >= f.yMax)
                return null;
            if (f.noc > 0) {
                f.endPts = [];
                for (var d = 0; d < f.noc; d++)
                    f.endPts.push(s.readUshort(l, u)),
                    u += 2;
                var g = s.readUshort(l, u);
                if (u += 2,
                l.length - u < g)
                    return null;
                f.instructions = s.readBytes(l, u, g),
                u += g;
                var v = f.endPts[f.noc - 1] + 1;
                for (f.flags = [],
                d = 0; d < v; d++) {
                    var y = l[u];
                    if (u++,
                    f.flags.push(y),
                    (8 & y) != 0) {
                        var S = l[u];
                        u++;
                        for (var T = 0; T < S; T++)
                            f.flags.push(y),
                            d++
                    }
                }
                for (f.xs = [],
                d = 0; d < v; d++) {
                    var M = (2 & f.flags[d]) != 0
                      , b = (16 & f.flags[d]) != 0;
                    M ? (f.xs.push(b ? l[u] : -l[u]),
                    u++) : b ? f.xs.push(0) : (f.xs.push(s.readShort(l, u)),
                    u += 2)
                }
                for (f.ys = [],
                d = 0; d < v; d++)
                    M = (4 & f.flags[d]) != 0,
                    b = (32 & f.flags[d]) != 0,
                    M ? (f.ys.push(b ? l[u] : -l[u]),
                    u++) : b ? f.ys.push(0) : (f.ys.push(s.readShort(l, u)),
                    u += 2);
                var A = 0
                  , C = 0;
                for (d = 0; d < v; d++)
                    A += f.xs[d],
                    C += f.ys[d],
                    f.xs[d] = A,
                    f.ys[d] = C
            } else {
                var R;
                f.parts = [];
                do {
                    R = s.readUshort(l, u),
                    u += 2;
                    var O = {
                        m: {
                            a: 1,
                            b: 0,
                            c: 0,
                            d: 1,
                            tx: 0,
                            ty: 0
                        },
                        p1: -1,
                        p2: -1
                    };
                    if (f.parts.push(O),
                    O.glyphIndex = s.readUshort(l, u),
                    u += 2,
                    1 & R) {
                        var L = s.readShort(l, u);
                        u += 2;
                        var z = s.readShort(l, u);
                        u += 2
                    } else
                        L = s.readInt8(l, u),
                        u++,
                        z = s.readInt8(l, u),
                        u++;
                    2 & R ? (O.m.tx = L,
                    O.m.ty = z) : (O.p1 = L,
                    O.p2 = z),
                    8 & R ? (O.m.a = O.m.d = s.readF2dot14(l, u),
                    u += 2) : 64 & R ? (O.m.a = s.readF2dot14(l, u),
                    u += 2,
                    O.m.d = s.readF2dot14(l, u),
                    u += 2) : 128 & R && (O.m.a = s.readF2dot14(l, u),
                    u += 2,
                    O.m.b = s.readF2dot14(l, u),
                    u += 2,
                    O.m.c = s.readF2dot14(l, u),
                    u += 2,
                    O.m.d = s.readF2dot14(l, u),
                    u += 2)
                } while (32 & R);
                if (256 & R) {
                    var I = s.readUshort(l, u);
                    for (u += 2,
                    f.instr = [],
                    d = 0; d < I; d++)
                        f.instr.push(l[u]),
                        u++
                }
            }
            return f
        }
        ,
        e.GDEF = {},
        e.GDEF.parse = function(i, a, s, l) {
            var u = a;
            a += 4;
            var f = e._bin.readUshort(i, a);
            return {
                glyphClassDef: f === 0 ? null : e._lctf.readClassDef(i, u + f)
            }
        }
        ,
        e.GPOS = {},
        e.GPOS.parse = function(i, a, s, l) {
            return e._lctf.parse(i, a, s, l, e.GPOS.subt)
        }
        ,
        e.GPOS.subt = function(i, a, s, l) {
            var u = e._bin
              , f = s
              , d = {};
            if (d.fmt = u.readUshort(i, s),
            s += 2,
            a == 1 || a == 2 || a == 3 || a == 7 || a == 8 && d.fmt <= 2) {
                var g = u.readUshort(i, s);
                s += 2,
                d.coverage = e._lctf.readCoverage(i, g + f)
            }
            if (a == 1 && d.fmt == 1) {
                var v = u.readUshort(i, s);
                s += 2,
                v != 0 && (d.pos = e.GPOS.readValueRecord(i, s, v))
            } else if (a == 2 && d.fmt >= 1 && d.fmt <= 2) {
                v = u.readUshort(i, s),
                s += 2;
                var y = u.readUshort(i, s);
                s += 2;
                var S = e._lctf.numOfOnes(v)
                  , T = e._lctf.numOfOnes(y);
                if (d.fmt == 1) {
                    d.pairsets = [];
                    var M = u.readUshort(i, s);
                    s += 2;
                    for (var b = 0; b < M; b++) {
                        var A = f + u.readUshort(i, s);
                        s += 2;
                        var C = u.readUshort(i, A);
                        A += 2;
                        for (var R = [], O = 0; O < C; O++) {
                            var L = u.readUshort(i, A);
                            A += 2,
                            v != 0 && (V = e.GPOS.readValueRecord(i, A, v),
                            A += 2 * S),
                            y != 0 && (K = e.GPOS.readValueRecord(i, A, y),
                            A += 2 * T),
                            R.push({
                                gid2: L,
                                val1: V,
                                val2: K
                            })
                        }
                        d.pairsets.push(R)
                    }
                }
                if (d.fmt == 2) {
                    var z = u.readUshort(i, s);
                    s += 2;
                    var I = u.readUshort(i, s);
                    s += 2;
                    var N = u.readUshort(i, s);
                    s += 2;
                    var P = u.readUshort(i, s);
                    for (s += 2,
                    d.classDef1 = e._lctf.readClassDef(i, f + z),
                    d.classDef2 = e._lctf.readClassDef(i, f + I),
                    d.matrix = [],
                    b = 0; b < N; b++) {
                        var Y = [];
                        for (O = 0; O < P; O++) {
                            var V = null
                              , K = null;
                            v != 0 && (V = e.GPOS.readValueRecord(i, s, v),
                            s += 2 * S),
                            y != 0 && (K = e.GPOS.readValueRecord(i, s, y),
                            s += 2 * T),
                            Y.push({
                                val1: V,
                                val2: K
                            })
                        }
                        d.matrix.push(Y)
                    }
                }
            } else if (a == 4 && d.fmt == 1)
                d.markCoverage = e._lctf.readCoverage(i, u.readUshort(i, s) + f),
                d.baseCoverage = e._lctf.readCoverage(i, u.readUshort(i, s + 2) + f),
                d.markClassCount = u.readUshort(i, s + 4),
                d.markArray = e.GPOS.readMarkArray(i, u.readUshort(i, s + 6) + f),
                d.baseArray = e.GPOS.readBaseArray(i, u.readUshort(i, s + 8) + f, d.markClassCount);
            else if (a == 6 && d.fmt == 1)
                d.mark1Coverage = e._lctf.readCoverage(i, u.readUshort(i, s) + f),
                d.mark2Coverage = e._lctf.readCoverage(i, u.readUshort(i, s + 2) + f),
                d.markClassCount = u.readUshort(i, s + 4),
                d.mark1Array = e.GPOS.readMarkArray(i, u.readUshort(i, s + 6) + f),
                d.mark2Array = e.GPOS.readBaseArray(i, u.readUshort(i, s + 8) + f, d.markClassCount);
            else {
                if (a == 9 && d.fmt == 1) {
                    var Z = u.readUshort(i, s);
                    s += 2;
                    var oe = u.readUint(i, s);
                    if (s += 4,
                    l.ltype == 9)
                        l.ltype = Z;
                    else if (l.ltype != Z)
                        throw "invalid extension substitution";
                    return e.GPOS.subt(i, l.ltype, f + oe)
                }
                console.debug("unsupported GPOS table LookupType", a, "format", d.fmt)
            }
            return d
        }
        ,
        e.GPOS.readValueRecord = function(i, a, s) {
            var l = e._bin
              , u = [];
            return u.push(1 & s ? l.readShort(i, a) : 0),
            a += 1 & s ? 2 : 0,
            u.push(2 & s ? l.readShort(i, a) : 0),
            a += 2 & s ? 2 : 0,
            u.push(4 & s ? l.readShort(i, a) : 0),
            a += 4 & s ? 2 : 0,
            u.push(8 & s ? l.readShort(i, a) : 0),
            a += 8 & s ? 2 : 0,
            u
        }
        ,
        e.GPOS.readBaseArray = function(i, a, s) {
            var l = e._bin
              , u = []
              , f = a
              , d = l.readUshort(i, a);
            a += 2;
            for (var g = 0; g < d; g++) {
                for (var v = [], y = 0; y < s; y++)
                    v.push(e.GPOS.readAnchorRecord(i, f + l.readUshort(i, a))),
                    a += 2;
                u.push(v)
            }
            return u
        }
        ,
        e.GPOS.readMarkArray = function(i, a) {
            var s = e._bin
              , l = []
              , u = a
              , f = s.readUshort(i, a);
            a += 2;
            for (var d = 0; d < f; d++) {
                var g = e.GPOS.readAnchorRecord(i, s.readUshort(i, a + 2) + u);
                g.markClass = s.readUshort(i, a),
                l.push(g),
                a += 4
            }
            return l
        }
        ,
        e.GPOS.readAnchorRecord = function(i, a) {
            var s = e._bin
              , l = {};
            return l.fmt = s.readUshort(i, a),
            l.x = s.readShort(i, a + 2),
            l.y = s.readShort(i, a + 4),
            l
        }
        ,
        e.GSUB = {},
        e.GSUB.parse = function(i, a, s, l) {
            return e._lctf.parse(i, a, s, l, e.GSUB.subt)
        }
        ,
        e.GSUB.subt = function(i, a, s, l) {
            var u = e._bin
              , f = s
              , d = {};
            if (d.fmt = u.readUshort(i, s),
            s += 2,
            a != 1 && a != 2 && a != 4 && a != 5 && a != 6)
                return null;
            if (a == 1 || a == 2 || a == 4 || a == 5 && d.fmt <= 2 || a == 6 && d.fmt <= 2) {
                var g = u.readUshort(i, s);
                s += 2,
                d.coverage = e._lctf.readCoverage(i, f + g)
            }
            if (a == 1 && d.fmt >= 1 && d.fmt <= 2) {
                if (d.fmt == 1)
                    d.delta = u.readShort(i, s),
                    s += 2;
                else if (d.fmt == 2) {
                    var v = u.readUshort(i, s);
                    s += 2,
                    d.newg = u.readUshorts(i, s, v),
                    s += 2 * d.newg.length
                }
            } else if (a == 2 && d.fmt == 1) {
                v = u.readUshort(i, s),
                s += 2,
                d.seqs = [];
                for (var y = 0; y < v; y++) {
                    var S = u.readUshort(i, s) + f;
                    s += 2;
                    var T = u.readUshort(i, S);
                    d.seqs.push(u.readUshorts(i, S + 2, T))
                }
            } else if (a == 4)
                for (d.vals = [],
                v = u.readUshort(i, s),
                s += 2,
                y = 0; y < v; y++) {
                    var M = u.readUshort(i, s);
                    s += 2,
                    d.vals.push(e.GSUB.readLigatureSet(i, f + M))
                }
            else if (a == 5 && d.fmt == 2) {
                if (d.fmt == 2) {
                    var b = u.readUshort(i, s);
                    s += 2,
                    d.cDef = e._lctf.readClassDef(i, f + b),
                    d.scset = [];
                    var A = u.readUshort(i, s);
                    for (s += 2,
                    y = 0; y < A; y++) {
                        var C = u.readUshort(i, s);
                        s += 2,
                        d.scset.push(C == 0 ? null : e.GSUB.readSubClassSet(i, f + C))
                    }
                }
            } else if (a == 6 && d.fmt == 3) {
                if (d.fmt == 3) {
                    for (y = 0; y < 3; y++) {
                        v = u.readUshort(i, s),
                        s += 2;
                        for (var R = [], O = 0; O < v; O++)
                            R.push(e._lctf.readCoverage(i, f + u.readUshort(i, s + 2 * O)));
                        s += 2 * v,
                        y == 0 && (d.backCvg = R),
                        y == 1 && (d.inptCvg = R),
                        y == 2 && (d.ahedCvg = R)
                    }
                    v = u.readUshort(i, s),
                    s += 2,
                    d.lookupRec = e.GSUB.readSubstLookupRecords(i, s, v)
                }
            } else {
                if (a == 7 && d.fmt == 1) {
                    var L = u.readUshort(i, s);
                    s += 2;
                    var z = u.readUint(i, s);
                    if (s += 4,
                    l.ltype == 9)
                        l.ltype = L;
                    else if (l.ltype != L)
                        throw "invalid extension substitution";
                    return e.GSUB.subt(i, l.ltype, f + z)
                }
                console.debug("unsupported GSUB table LookupType", a, "format", d.fmt)
            }
            return d
        }
        ,
        e.GSUB.readSubClassSet = function(i, a) {
            var s = e._bin.readUshort
              , l = a
              , u = []
              , f = s(i, a);
            a += 2;
            for (var d = 0; d < f; d++) {
                var g = s(i, a);
                a += 2,
                u.push(e.GSUB.readSubClassRule(i, l + g))
            }
            return u
        }
        ,
        e.GSUB.readSubClassRule = function(i, a) {
            var s = e._bin.readUshort
              , l = {}
              , u = s(i, a)
              , f = s(i, a += 2);
            a += 2,
            l.input = [];
            for (var d = 0; d < u - 1; d++)
                l.input.push(s(i, a)),
                a += 2;
            return l.substLookupRecords = e.GSUB.readSubstLookupRecords(i, a, f),
            l
        }
        ,
        e.GSUB.readSubstLookupRecords = function(i, a, s) {
            for (var l = e._bin.readUshort, u = [], f = 0; f < s; f++)
                u.push(l(i, a), l(i, a + 2)),
                a += 4;
            return u
        }
        ,
        e.GSUB.readChainSubClassSet = function(i, a) {
            var s = e._bin
              , l = a
              , u = []
              , f = s.readUshort(i, a);
            a += 2;
            for (var d = 0; d < f; d++) {
                var g = s.readUshort(i, a);
                a += 2,
                u.push(e.GSUB.readChainSubClassRule(i, l + g))
            }
            return u
        }
        ,
        e.GSUB.readChainSubClassRule = function(i, a) {
            for (var s = e._bin, l = {}, u = ["backtrack", "input", "lookahead"], f = 0; f < u.length; f++) {
                var d = s.readUshort(i, a);
                a += 2,
                f == 1 && d--,
                l[u[f]] = s.readUshorts(i, a, d),
                a += 2 * l[u[f]].length
            }
            return d = s.readUshort(i, a),
            a += 2,
            l.subst = s.readUshorts(i, a, 2 * d),
            a += 2 * l.subst.length,
            l
        }
        ,
        e.GSUB.readLigatureSet = function(i, a) {
            var s = e._bin
              , l = a
              , u = []
              , f = s.readUshort(i, a);
            a += 2;
            for (var d = 0; d < f; d++) {
                var g = s.readUshort(i, a);
                a += 2,
                u.push(e.GSUB.readLigature(i, l + g))
            }
            return u
        }
        ,
        e.GSUB.readLigature = function(i, a) {
            var s = e._bin
              , l = {
                chain: []
            };
            l.nglyph = s.readUshort(i, a),
            a += 2;
            var u = s.readUshort(i, a);
            a += 2;
            for (var f = 0; f < u - 1; f++)
                l.chain.push(s.readUshort(i, a)),
                a += 2;
            return l
        }
        ,
        e.head = {},
        e.head.parse = function(i, a, s) {
            var l = e._bin
              , u = {};
            return l.readFixed(i, a),
            a += 4,
            u.fontRevision = l.readFixed(i, a),
            a += 4,
            l.readUint(i, a),
            a += 4,
            l.readUint(i, a),
            a += 4,
            u.flags = l.readUshort(i, a),
            a += 2,
            u.unitsPerEm = l.readUshort(i, a),
            a += 2,
            u.created = l.readUint64(i, a),
            a += 8,
            u.modified = l.readUint64(i, a),
            a += 8,
            u.xMin = l.readShort(i, a),
            a += 2,
            u.yMin = l.readShort(i, a),
            a += 2,
            u.xMax = l.readShort(i, a),
            a += 2,
            u.yMax = l.readShort(i, a),
            a += 2,
            u.macStyle = l.readUshort(i, a),
            a += 2,
            u.lowestRecPPEM = l.readUshort(i, a),
            a += 2,
            u.fontDirectionHint = l.readShort(i, a),
            a += 2,
            u.indexToLocFormat = l.readShort(i, a),
            a += 2,
            u.glyphDataFormat = l.readShort(i, a),
            a += 2,
            u
        }
        ,
        e.hhea = {},
        e.hhea.parse = function(i, a, s) {
            var l = e._bin
              , u = {};
            return l.readFixed(i, a),
            a += 4,
            u.ascender = l.readShort(i, a),
            a += 2,
            u.descender = l.readShort(i, a),
            a += 2,
            u.lineGap = l.readShort(i, a),
            a += 2,
            u.advanceWidthMax = l.readUshort(i, a),
            a += 2,
            u.minLeftSideBearing = l.readShort(i, a),
            a += 2,
            u.minRightSideBearing = l.readShort(i, a),
            a += 2,
            u.xMaxExtent = l.readShort(i, a),
            a += 2,
            u.caretSlopeRise = l.readShort(i, a),
            a += 2,
            u.caretSlopeRun = l.readShort(i, a),
            a += 2,
            u.caretOffset = l.readShort(i, a),
            a += 2,
            a += 8,
            u.metricDataFormat = l.readShort(i, a),
            a += 2,
            u.numberOfHMetrics = l.readUshort(i, a),
            a += 2,
            u
        }
        ,
        e.hmtx = {},
        e.hmtx.parse = function(i, a, s, l) {
            for (var u = e._bin, f = {
                aWidth: [],
                lsBearing: []
            }, d = 0, g = 0, v = 0; v < l.maxp.numGlyphs; v++)
                v < l.hhea.numberOfHMetrics && (d = u.readUshort(i, a),
                a += 2,
                g = u.readShort(i, a),
                a += 2),
                f.aWidth.push(d),
                f.lsBearing.push(g);
            return f
        }
        ,
        e.kern = {},
        e.kern.parse = function(i, a, s, l) {
            var u = e._bin
              , f = u.readUshort(i, a);
            if (a += 2,
            f == 1)
                return e.kern.parseV1(i, a - 2, s, l);
            var d = u.readUshort(i, a);
            a += 2;
            for (var g = {
                glyph1: [],
                rval: []
            }, v = 0; v < d; v++) {
                a += 2,
                s = u.readUshort(i, a),
                a += 2;
                var y = u.readUshort(i, a);
                a += 2;
                var S = y >>> 8;
                if ((S &= 15) != 0)
                    throw "unknown kern table format: " + S;
                a = e.kern.readFormat0(i, a, g)
            }
            return g
        }
        ,
        e.kern.parseV1 = function(i, a, s, l) {
            var u = e._bin;
            u.readFixed(i, a),
            a += 4;
            var f = u.readUint(i, a);
            a += 4;
            for (var d = {
                glyph1: [],
                rval: []
            }, g = 0; g < f; g++) {
                u.readUint(i, a),
                a += 4;
                var v = u.readUshort(i, a);
                a += 2,
                u.readUshort(i, a),
                a += 2;
                var y = v >>> 8;
                if ((y &= 15) != 0)
                    throw "unknown kern table format: " + y;
                a = e.kern.readFormat0(i, a, d)
            }
            return d
        }
        ,
        e.kern.readFormat0 = function(i, a, s) {
            var l = e._bin
              , u = -1
              , f = l.readUshort(i, a);
            a += 2,
            l.readUshort(i, a),
            a += 2,
            l.readUshort(i, a),
            a += 2,
            l.readUshort(i, a),
            a += 2;
            for (var d = 0; d < f; d++) {
                var g = l.readUshort(i, a);
                a += 2;
                var v = l.readUshort(i, a);
                a += 2;
                var y = l.readShort(i, a);
                a += 2,
                g != u && (s.glyph1.push(g),
                s.rval.push({
                    glyph2: [],
                    vals: []
                }));
                var S = s.rval[s.rval.length - 1];
                S.glyph2.push(v),
                S.vals.push(y),
                u = g
            }
            return a
        }
        ,
        e.loca = {},
        e.loca.parse = function(i, a, s, l) {
            var u = e._bin
              , f = []
              , d = l.head.indexToLocFormat
              , g = l.maxp.numGlyphs + 1;
            if (d == 0)
                for (var v = 0; v < g; v++)
                    f.push(u.readUshort(i, a + (v << 1)) << 1);
            if (d == 1)
                for (v = 0; v < g; v++)
                    f.push(u.readUint(i, a + (v << 2)));
            return f
        }
        ,
        e.maxp = {},
        e.maxp.parse = function(i, a, s) {
            var l = e._bin
              , u = {}
              , f = l.readUint(i, a);
            return a += 4,
            u.numGlyphs = l.readUshort(i, a),
            a += 2,
            f == 65536 && (u.maxPoints = l.readUshort(i, a),
            a += 2,
            u.maxContours = l.readUshort(i, a),
            a += 2,
            u.maxCompositePoints = l.readUshort(i, a),
            a += 2,
            u.maxCompositeContours = l.readUshort(i, a),
            a += 2,
            u.maxZones = l.readUshort(i, a),
            a += 2,
            u.maxTwilightPoints = l.readUshort(i, a),
            a += 2,
            u.maxStorage = l.readUshort(i, a),
            a += 2,
            u.maxFunctionDefs = l.readUshort(i, a),
            a += 2,
            u.maxInstructionDefs = l.readUshort(i, a),
            a += 2,
            u.maxStackElements = l.readUshort(i, a),
            a += 2,
            u.maxSizeOfInstructions = l.readUshort(i, a),
            a += 2,
            u.maxComponentElements = l.readUshort(i, a),
            a += 2,
            u.maxComponentDepth = l.readUshort(i, a),
            a += 2),
            u
        }
        ,
        e.name = {},
        e.name.parse = function(i, a, s) {
            var l = e._bin
              , u = {};
            l.readUshort(i, a),
            a += 2;
            var f = l.readUshort(i, a);
            a += 2,
            l.readUshort(i, a);
            for (var d, g = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], v = a += 2, y = 0; y < f; y++) {
                var S = l.readUshort(i, a);
                a += 2;
                var T = l.readUshort(i, a);
                a += 2;
                var M = l.readUshort(i, a);
                a += 2;
                var b = l.readUshort(i, a);
                a += 2;
                var A = l.readUshort(i, a);
                a += 2;
                var C = l.readUshort(i, a);
                a += 2;
                var R, O = g[b], L = v + 12 * f + C;
                if (S == 0)
                    R = l.readUnicode(i, L, A / 2);
                else if (S == 3 && T == 0)
                    R = l.readUnicode(i, L, A / 2);
                else if (T == 0)
                    R = l.readASCII(i, L, A);
                else if (T == 1)
                    R = l.readUnicode(i, L, A / 2);
                else if (T == 3)
                    R = l.readUnicode(i, L, A / 2);
                else {
                    if (S != 1)
                        throw "unknown encoding " + T + ", platformID: " + S;
                    R = l.readASCII(i, L, A),
                    console.debug("reading unknown MAC encoding " + T + " as ASCII")
                }
                var z = "p" + S + "," + M.toString(16);
                u[z] == null && (u[z] = {}),
                u[z][O !== void 0 ? O : b] = R,
                u[z]._lang = M
            }
            for (var I in u)
                if (u[I].postScriptName != null && u[I]._lang == 1033)
                    return u[I];
            for (var I in u)
                if (u[I].postScriptName != null && u[I]._lang == 0)
                    return u[I];
            for (var I in u)
                if (u[I].postScriptName != null && u[I]._lang == 3084)
                    return u[I];
            for (var I in u)
                if (u[I].postScriptName != null)
                    return u[I];
            for (var I in u) {
                d = I;
                break
            }
            return console.debug("returning name table with languageID " + u[d]._lang),
            u[d]
        }
        ,
        e["OS/2"] = {},
        e["OS/2"].parse = function(i, a, s) {
            var l = e._bin.readUshort(i, a);
            a += 2;
            var u = {};
            if (l == 0)
                e["OS/2"].version0(i, a, u);
            else if (l == 1)
                e["OS/2"].version1(i, a, u);
            else if (l == 2 || l == 3 || l == 4)
                e["OS/2"].version2(i, a, u);
            else {
                if (l != 5)
                    throw "unknown OS/2 table version: " + l;
                e["OS/2"].version5(i, a, u)
            }
            return u
        }
        ,
        e["OS/2"].version0 = function(i, a, s) {
            var l = e._bin;
            return s.xAvgCharWidth = l.readShort(i, a),
            a += 2,
            s.usWeightClass = l.readUshort(i, a),
            a += 2,
            s.usWidthClass = l.readUshort(i, a),
            a += 2,
            s.fsType = l.readUshort(i, a),
            a += 2,
            s.ySubscriptXSize = l.readShort(i, a),
            a += 2,
            s.ySubscriptYSize = l.readShort(i, a),
            a += 2,
            s.ySubscriptXOffset = l.readShort(i, a),
            a += 2,
            s.ySubscriptYOffset = l.readShort(i, a),
            a += 2,
            s.ySuperscriptXSize = l.readShort(i, a),
            a += 2,
            s.ySuperscriptYSize = l.readShort(i, a),
            a += 2,
            s.ySuperscriptXOffset = l.readShort(i, a),
            a += 2,
            s.ySuperscriptYOffset = l.readShort(i, a),
            a += 2,
            s.yStrikeoutSize = l.readShort(i, a),
            a += 2,
            s.yStrikeoutPosition = l.readShort(i, a),
            a += 2,
            s.sFamilyClass = l.readShort(i, a),
            a += 2,
            s.panose = l.readBytes(i, a, 10),
            a += 10,
            s.ulUnicodeRange1 = l.readUint(i, a),
            a += 4,
            s.ulUnicodeRange2 = l.readUint(i, a),
            a += 4,
            s.ulUnicodeRange3 = l.readUint(i, a),
            a += 4,
            s.ulUnicodeRange4 = l.readUint(i, a),
            a += 4,
            s.achVendID = [l.readInt8(i, a), l.readInt8(i, a + 1), l.readInt8(i, a + 2), l.readInt8(i, a + 3)],
            a += 4,
            s.fsSelection = l.readUshort(i, a),
            a += 2,
            s.usFirstCharIndex = l.readUshort(i, a),
            a += 2,
            s.usLastCharIndex = l.readUshort(i, a),
            a += 2,
            s.sTypoAscender = l.readShort(i, a),
            a += 2,
            s.sTypoDescender = l.readShort(i, a),
            a += 2,
            s.sTypoLineGap = l.readShort(i, a),
            a += 2,
            s.usWinAscent = l.readUshort(i, a),
            a += 2,
            s.usWinDescent = l.readUshort(i, a),
            a += 2
        }
        ,
        e["OS/2"].version1 = function(i, a, s) {
            var l = e._bin;
            return a = e["OS/2"].version0(i, a, s),
            s.ulCodePageRange1 = l.readUint(i, a),
            a += 4,
            s.ulCodePageRange2 = l.readUint(i, a),
            a += 4
        }
        ,
        e["OS/2"].version2 = function(i, a, s) {
            var l = e._bin;
            return a = e["OS/2"].version1(i, a, s),
            s.sxHeight = l.readShort(i, a),
            a += 2,
            s.sCapHeight = l.readShort(i, a),
            a += 2,
            s.usDefault = l.readUshort(i, a),
            a += 2,
            s.usBreak = l.readUshort(i, a),
            a += 2,
            s.usMaxContext = l.readUshort(i, a),
            a += 2
        }
        ,
        e["OS/2"].version5 = function(i, a, s) {
            var l = e._bin;
            return a = e["OS/2"].version2(i, a, s),
            s.usLowerOpticalPointSize = l.readUshort(i, a),
            a += 2,
            s.usUpperOpticalPointSize = l.readUshort(i, a),
            a += 2
        }
        ,
        e.post = {},
        e.post.parse = function(i, a, s) {
            var l = e._bin
              , u = {};
            return u.version = l.readFixed(i, a),
            a += 4,
            u.italicAngle = l.readFixed(i, a),
            a += 4,
            u.underlinePosition = l.readShort(i, a),
            a += 2,
            u.underlineThickness = l.readShort(i, a),
            a += 2,
            u
        }
        ,
        e == null && (e = {}),
        e.U == null && (e.U = {}),
        e.U.codeToGlyph = function(i, a) {
            var s = i.cmap
              , l = -1;
            if (s.p0e4 != null ? l = s.p0e4 : s.p3e1 != null ? l = s.p3e1 : s.p1e0 != null ? l = s.p1e0 : s.p0e3 != null && (l = s.p0e3),
            l == -1)
                throw "no familiar platform and encoding!";
            var u = s.tables[l];
            if (u.format == 0)
                return a >= u.map.length ? 0 : u.map[a];
            if (u.format == 4) {
                for (var f = -1, d = 0; d < u.endCount.length; d++)
                    if (a <= u.endCount[d]) {
                        f = d;
                        break
                    }
                return f == -1 || u.startCount[f] > a ? 0 : 65535 & (u.idRangeOffset[f] != 0 ? u.glyphIdArray[a - u.startCount[f] + (u.idRangeOffset[f] >> 1) - (u.idRangeOffset.length - f)] : a + u.idDelta[f])
            }
            if (u.format == 12) {
                if (a > u.groups[u.groups.length - 1][1])
                    return 0;
                for (d = 0; d < u.groups.length; d++) {
                    var g = u.groups[d];
                    if (g[0] <= a && a <= g[1])
                        return g[2] + (a - g[0])
                }
                return 0
            }
            throw "unknown cmap table format " + u.format
        }
        ,
        e.U.glyphToPath = function(i, a) {
            var s = {
                cmds: [],
                crds: []
            };
            if (i.SVG && i.SVG.entries[a]) {
                var l = i.SVG.entries[a];
                return l == null ? s : (typeof l == "string" && (l = e.SVG.toPath(l),
                i.SVG.entries[a] = l),
                l)
            }
            if (i.CFF) {
                var u = {
                    x: 0,
                    y: 0,
                    stack: [],
                    nStems: 0,
                    haveWidth: !1,
                    width: i.CFF.Private ? i.CFF.Private.defaultWidthX : 0,
                    open: !1
                }
                  , f = i.CFF
                  , d = i.CFF.Private;
                if (f.ROS) {
                    for (var g = 0; f.FDSelect[g + 2] <= a; )
                        g += 2;
                    d = f.FDArray[f.FDSelect[g + 1]].Private
                }
                e.U._drawCFF(i.CFF.CharStrings[a], u, f, d, s)
            } else
                i.glyf && e.U._drawGlyf(a, i, s);
            return s
        }
        ,
        e.U._drawGlyf = function(i, a, s) {
            var l = a.glyf[i];
            l == null && (l = a.glyf[i] = e.glyf._parseGlyf(a, i)),
            l != null && (l.noc > -1 ? e.U._simpleGlyph(l, s) : e.U._compoGlyph(l, a, s))
        }
        ,
        e.U._simpleGlyph = function(i, a) {
            for (var s = 0; s < i.noc; s++) {
                for (var l = s == 0 ? 0 : i.endPts[s - 1] + 1, u = i.endPts[s], f = l; f <= u; f++) {
                    var d = f == l ? u : f - 1
                      , g = f == u ? l : f + 1
                      , v = 1 & i.flags[f]
                      , y = 1 & i.flags[d]
                      , S = 1 & i.flags[g]
                      , T = i.xs[f]
                      , M = i.ys[f];
                    if (f == l)
                        if (v) {
                            if (!y) {
                                e.U.P.moveTo(a, T, M);
                                continue
                            }
                            e.U.P.moveTo(a, i.xs[d], i.ys[d])
                        } else
                            y ? e.U.P.moveTo(a, i.xs[d], i.ys[d]) : e.U.P.moveTo(a, (i.xs[d] + T) / 2, (i.ys[d] + M) / 2);
                    v ? y && e.U.P.lineTo(a, T, M) : S ? e.U.P.qcurveTo(a, T, M, i.xs[g], i.ys[g]) : e.U.P.qcurveTo(a, T, M, (T + i.xs[g]) / 2, (M + i.ys[g]) / 2)
                }
                e.U.P.closePath(a)
            }
        }
        ,
        e.U._compoGlyph = function(i, a, s) {
            for (var l = 0; l < i.parts.length; l++) {
                var u = {
                    cmds: [],
                    crds: []
                }
                  , f = i.parts[l];
                e.U._drawGlyf(f.glyphIndex, a, u);
                for (var d = f.m, g = 0; g < u.crds.length; g += 2) {
                    var v = u.crds[g]
                      , y = u.crds[g + 1];
                    s.crds.push(v * d.a + y * d.b + d.tx),
                    s.crds.push(v * d.c + y * d.d + d.ty)
                }
                for (g = 0; g < u.cmds.length; g++)
                    s.cmds.push(u.cmds[g])
            }
        }
        ,
        e.U._getGlyphClass = function(i, a) {
            var s = e._lctf.getInterval(a, i);
            return s == -1 ? 0 : a[s + 2]
        }
        ,
        e.U._applySubs = function(i, a, s, l) {
            for (var u = i.length - a - 1, f = 0; f < s.tabs.length; f++)
                if (s.tabs[f] != null) {
                    var d, g = s.tabs[f];
                    if (!g.coverage || (d = e._lctf.coverageIndex(g.coverage, i[a])) != -1) {
                        if (s.ltype == 1)
                            i[a],
                            g.fmt == 1 ? i[a] = i[a] + g.delta : i[a] = g.newg[d];
                        else if (s.ltype == 4)
                            for (var v = g.vals[d], y = 0; y < v.length; y++) {
                                var S = v[y]
                                  , T = S.chain.length;
                                if (!(T > u)) {
                                    for (var M = !0, b = 0, A = 0; A < T; A++) {
                                        for (; i[a + b + (1 + A)] == -1; )
                                            b++;
                                        S.chain[A] != i[a + b + (1 + A)] && (M = !1)
                                    }
                                    if (M) {
                                        for (i[a] = S.nglyph,
                                        A = 0; A < T + b; A++)
                                            i[a + A + 1] = -1;
                                        break
                                    }
                                }
                            }
                        else if (s.ltype == 5 && g.fmt == 2)
                            for (var C = e._lctf.getInterval(g.cDef, i[a]), R = g.cDef[C + 2], O = g.scset[R], L = 0; L < O.length; L++) {
                                var z = O[L]
                                  , I = z.input;
                                if (!(I.length > u)) {
                                    for (M = !0,
                                    A = 0; A < I.length; A++) {
                                        var N = e._lctf.getInterval(g.cDef, i[a + 1 + A]);
                                        if (C == -1 && g.cDef[N + 2] != I[A]) {
                                            M = !1;
                                            break
                                        }
                                    }
                                    if (M) {
                                        var P = z.substLookupRecords;
                                        for (y = 0; y < P.length; y += 2)
                                            P[y],
                                            P[y + 1]
                                    }
                                }
                            }
                        else if (s.ltype == 6 && g.fmt == 3) {
                            if (!e.U._glsCovered(i, g.backCvg, a - g.backCvg.length) || !e.U._glsCovered(i, g.inptCvg, a) || !e.U._glsCovered(i, g.ahedCvg, a + g.inptCvg.length))
                                continue;
                            var Y = g.lookupRec;
                            for (L = 0; L < Y.length; L += 2) {
                                C = Y[L];
                                var V = l[Y[L + 1]];
                                e.U._applySubs(i, a + C, V, l)
                            }
                        }
                    }
                }
        }
        ,
        e.U._glsCovered = function(i, a, s) {
            for (var l = 0; l < a.length; l++)
                if (e._lctf.coverageIndex(a[l], i[s + l]) == -1)
                    return !1;
            return !0
        }
        ,
        e.U.glyphsToPath = function(i, a, s) {
            for (var l = {
                cmds: [],
                crds: []
            }, u = 0, f = 0; f < a.length; f++) {
                var d = a[f];
                if (d != -1) {
                    for (var g = f < a.length - 1 && a[f + 1] != -1 ? a[f + 1] : 0, v = e.U.glyphToPath(i, d), y = 0; y < v.crds.length; y += 2)
                        l.crds.push(v.crds[y] + u),
                        l.crds.push(v.crds[y + 1]);
                    for (s && l.cmds.push(s),
                    y = 0; y < v.cmds.length; y++)
                        l.cmds.push(v.cmds[y]);
                    s && l.cmds.push("X"),
                    u += i.hmtx.aWidth[d],
                    f < a.length - 1 && (u += e.U.getPairAdjustment(i, d, g))
                }
            }
            return l
        }
        ,
        e.U.P = {},
        e.U.P.moveTo = function(i, a, s) {
            i.cmds.push("M"),
            i.crds.push(a, s)
        }
        ,
        e.U.P.lineTo = function(i, a, s) {
            i.cmds.push("L"),
            i.crds.push(a, s)
        }
        ,
        e.U.P.curveTo = function(i, a, s, l, u, f, d) {
            i.cmds.push("C"),
            i.crds.push(a, s, l, u, f, d)
        }
        ,
        e.U.P.qcurveTo = function(i, a, s, l, u) {
            i.cmds.push("Q"),
            i.crds.push(a, s, l, u)
        }
        ,
        e.U.P.closePath = function(i) {
            i.cmds.push("Z")
        }
        ,
        e.U._drawCFF = function(i, a, s, l, u) {
            for (var f = a.stack, d = a.nStems, g = a.haveWidth, v = a.width, y = a.open, S = 0, T = a.x, M = a.y, b = 0, A = 0, C = 0, R = 0, O = 0, L = 0, z = 0, I = 0, N = 0, P = 0, Y = {
                val: 0,
                size: 0
            }; S < i.length; ) {
                e.CFF.getCharString(i, S, Y);
                var V = Y.val;
                if (S += Y.size,
                V == "o1" || V == "o18")
                    f.length % 2 != 0 && !g && (v = f.shift() + l.nominalWidthX),
                    d += f.length >> 1,
                    f.length = 0,
                    g = !0;
                else if (V == "o3" || V == "o23")
                    f.length % 2 != 0 && !g && (v = f.shift() + l.nominalWidthX),
                    d += f.length >> 1,
                    f.length = 0,
                    g = !0;
                else if (V == "o4")
                    f.length > 1 && !g && (v = f.shift() + l.nominalWidthX,
                    g = !0),
                    y && e.U.P.closePath(u),
                    M += f.pop(),
                    e.U.P.moveTo(u, T, M),
                    y = !0;
                else if (V == "o5")
                    for (; f.length > 0; )
                        T += f.shift(),
                        M += f.shift(),
                        e.U.P.lineTo(u, T, M);
                else if (V == "o6" || V == "o7")
                    for (var K = f.length, Z = V == "o6", oe = 0; oe < K; oe++) {
                        var H = f.shift();
                        Z ? T += H : M += H,
                        Z = !Z,
                        e.U.P.lineTo(u, T, M)
                    }
                else if (V == "o8" || V == "o24") {
                    K = f.length;
                    for (var q = 0; q + 6 <= K; )
                        b = T + f.shift(),
                        A = M + f.shift(),
                        C = b + f.shift(),
                        R = A + f.shift(),
                        T = C + f.shift(),
                        M = R + f.shift(),
                        e.U.P.curveTo(u, b, A, C, R, T, M),
                        q += 6;
                    V == "o24" && (T += f.shift(),
                    M += f.shift(),
                    e.U.P.lineTo(u, T, M))
                } else {
                    if (V == "o11")
                        break;
                    if (V == "o1234" || V == "o1235" || V == "o1236" || V == "o1237")
                        V == "o1234" && (A = M,
                        C = (b = T + f.shift()) + f.shift(),
                        P = R = A + f.shift(),
                        L = R,
                        I = M,
                        T = (z = (O = (N = C + f.shift()) + f.shift()) + f.shift()) + f.shift(),
                        e.U.P.curveTo(u, b, A, C, R, N, P),
                        e.U.P.curveTo(u, O, L, z, I, T, M)),
                        V == "o1235" && (b = T + f.shift(),
                        A = M + f.shift(),
                        C = b + f.shift(),
                        R = A + f.shift(),
                        N = C + f.shift(),
                        P = R + f.shift(),
                        O = N + f.shift(),
                        L = P + f.shift(),
                        z = O + f.shift(),
                        I = L + f.shift(),
                        T = z + f.shift(),
                        M = I + f.shift(),
                        f.shift(),
                        e.U.P.curveTo(u, b, A, C, R, N, P),
                        e.U.P.curveTo(u, O, L, z, I, T, M)),
                        V == "o1236" && (b = T + f.shift(),
                        A = M + f.shift(),
                        C = b + f.shift(),
                        P = R = A + f.shift(),
                        L = R,
                        z = (O = (N = C + f.shift()) + f.shift()) + f.shift(),
                        I = L + f.shift(),
                        T = z + f.shift(),
                        e.U.P.curveTo(u, b, A, C, R, N, P),
                        e.U.P.curveTo(u, O, L, z, I, T, M)),
                        V == "o1237" && (b = T + f.shift(),
                        A = M + f.shift(),
                        C = b + f.shift(),
                        R = A + f.shift(),
                        N = C + f.shift(),
                        P = R + f.shift(),
                        O = N + f.shift(),
                        L = P + f.shift(),
                        z = O + f.shift(),
                        I = L + f.shift(),
                        Math.abs(z - T) > Math.abs(I - M) ? T = z + f.shift() : M = I + f.shift(),
                        e.U.P.curveTo(u, b, A, C, R, N, P),
                        e.U.P.curveTo(u, O, L, z, I, T, M));
                    else if (V == "o14") {
                        if (f.length > 0 && !g && (v = f.shift() + s.nominalWidthX,
                        g = !0),
                        f.length == 4) {
                            var Q = f.shift()
                              , se = f.shift()
                              , B = f.shift()
                              , W = f.shift()
                              , te = e.CFF.glyphBySE(s, B)
                              , fe = e.CFF.glyphBySE(s, W);
                            e.U._drawCFF(s.CharStrings[te], a, s, l, u),
                            a.x = Q,
                            a.y = se,
                            e.U._drawCFF(s.CharStrings[fe], a, s, l, u)
                        }
                        y && (e.U.P.closePath(u),
                        y = !1)
                    } else if (V == "o19" || V == "o20")
                        f.length % 2 != 0 && !g && (v = f.shift() + l.nominalWidthX),
                        d += f.length >> 1,
                        f.length = 0,
                        g = !0,
                        S += d + 7 >> 3;
                    else if (V == "o21")
                        f.length > 2 && !g && (v = f.shift() + l.nominalWidthX,
                        g = !0),
                        M += f.pop(),
                        T += f.pop(),
                        y && e.U.P.closePath(u),
                        e.U.P.moveTo(u, T, M),
                        y = !0;
                    else if (V == "o22")
                        f.length > 1 && !g && (v = f.shift() + l.nominalWidthX,
                        g = !0),
                        T += f.pop(),
                        y && e.U.P.closePath(u),
                        e.U.P.moveTo(u, T, M),
                        y = !0;
                    else if (V == "o25") {
                        for (; f.length > 6; )
                            T += f.shift(),
                            M += f.shift(),
                            e.U.P.lineTo(u, T, M);
                        b = T + f.shift(),
                        A = M + f.shift(),
                        C = b + f.shift(),
                        R = A + f.shift(),
                        T = C + f.shift(),
                        M = R + f.shift(),
                        e.U.P.curveTo(u, b, A, C, R, T, M)
                    } else if (V == "o26")
                        for (f.length % 2 && (T += f.shift()); f.length > 0; )
                            b = T,
                            A = M + f.shift(),
                            T = C = b + f.shift(),
                            M = (R = A + f.shift()) + f.shift(),
                            e.U.P.curveTo(u, b, A, C, R, T, M);
                    else if (V == "o27")
                        for (f.length % 2 && (M += f.shift()); f.length > 0; )
                            A = M,
                            C = (b = T + f.shift()) + f.shift(),
                            R = A + f.shift(),
                            T = C + f.shift(),
                            M = R,
                            e.U.P.curveTo(u, b, A, C, R, T, M);
                    else if (V == "o10" || V == "o29") {
                        var pe = V == "o10" ? l : s;
                        if (f.length == 0)
                            console.debug("error: empty stack");
                        else {
                            var _e = f.pop()
                              , ue = pe.Subrs[_e + pe.Bias];
                            a.x = T,
                            a.y = M,
                            a.nStems = d,
                            a.haveWidth = g,
                            a.width = v,
                            a.open = y,
                            e.U._drawCFF(ue, a, s, l, u),
                            T = a.x,
                            M = a.y,
                            d = a.nStems,
                            g = a.haveWidth,
                            v = a.width,
                            y = a.open
                        }
                    } else if (V == "o30" || V == "o31") {
                        var ge = f.length
                          , Te = (q = 0,
                        V == "o31");
                        for (q += ge - (K = -3 & ge); q < K; )
                            Te ? (A = M,
                            C = (b = T + f.shift()) + f.shift(),
                            M = (R = A + f.shift()) + f.shift(),
                            K - q == 5 ? (T = C + f.shift(),
                            q++) : T = C,
                            Te = !1) : (b = T,
                            A = M + f.shift(),
                            C = b + f.shift(),
                            R = A + f.shift(),
                            T = C + f.shift(),
                            K - q == 5 ? (M = R + f.shift(),
                            q++) : M = R,
                            Te = !0),
                            e.U.P.curveTo(u, b, A, C, R, T, M),
                            q += 4
                    } else {
                        if ((V + "").charAt(0) == "o")
                            throw console.debug("Unknown operation: " + V, i),
                            V;
                        f.push(V)
                    }
                }
            }
            a.x = T,
            a.y = M,
            a.nStems = d,
            a.haveWidth = g,
            a.width = v,
            a.open = y
        }
        ;
        var t = e
          , n = {
            Typr: t
        };
        return r.Typr = t,
        r.default = n,
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r
    }({}).Typr
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function T$() {
    return function(r) {
        var e = Uint8Array
          , t = Uint16Array
          , n = Uint32Array
          , i = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
          , a = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
          , s = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
          , l = function(V, K) {
            for (var Z = new t(31), oe = 0; oe < 31; ++oe)
                Z[oe] = K += 1 << V[oe - 1];
            var H = new n(Z[30]);
            for (oe = 1; oe < 30; ++oe)
                for (var q = Z[oe]; q < Z[oe + 1]; ++q)
                    H[q] = q - Z[oe] << 5 | oe;
            return [Z, H]
        }
          , u = l(i, 2)
          , f = u[0]
          , d = u[1];
        f[28] = 258,
        d[258] = 28;
        for (var g = l(a, 0)[0], v = new t(32768), y = 0; y < 32768; ++y) {
            var S = (43690 & y) >>> 1 | (21845 & y) << 1;
            S = (61680 & (S = (52428 & S) >>> 2 | (13107 & S) << 2)) >>> 4 | (3855 & S) << 4,
            v[y] = ((65280 & S) >>> 8 | (255 & S) << 8) >>> 1
        }
        var T = function(V, K, Z) {
            for (var oe = V.length, H = 0, q = new t(K); H < oe; ++H)
                ++q[V[H] - 1];
            var Q, se = new t(K);
            for (H = 0; H < K; ++H)
                se[H] = se[H - 1] + q[H - 1] << 1;
            {
                Q = new t(1 << K);
                var B = 15 - K;
                for (H = 0; H < oe; ++H)
                    if (V[H])
                        for (var W = H << 4 | V[H], te = K - V[H], fe = se[V[H] - 1]++ << te, pe = fe | (1 << te) - 1; fe <= pe; ++fe)
                            Q[v[fe] >>> B] = W
            }
            return Q
        }
          , M = new e(288);
        for (y = 0; y < 144; ++y)
            M[y] = 8;
        for (y = 144; y < 256; ++y)
            M[y] = 9;
        for (y = 256; y < 280; ++y)
            M[y] = 7;
        for (y = 280; y < 288; ++y)
            M[y] = 8;
        var b = new e(32);
        for (y = 0; y < 32; ++y)
            b[y] = 5;
        var A = T(M, 9)
          , C = T(b, 5)
          , R = function(V) {
            for (var K = V[0], Z = 1; Z < V.length; ++Z)
                V[Z] > K && (K = V[Z]);
            return K
        }
          , O = function(V, K, Z) {
            var oe = K / 8 | 0;
            return (V[oe] | V[oe + 1] << 8) >> (7 & K) & Z
        }
          , L = function(V, K) {
            var Z = K / 8 | 0;
            return (V[Z] | V[Z + 1] << 8 | V[Z + 2] << 16) >> (7 & K)
        }
          , z = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"]
          , I = function(V, K, Z) {
            var oe = new Error(K || z[V]);
            if (oe.code = V,
            Error.captureStackTrace && Error.captureStackTrace(oe, I),
            !Z)
                throw oe;
            return oe
        }
          , N = function(V, K, Z) {
            var oe = V.length;
            if (!oe || Z && !Z.l && oe < 5)
                return K || new e(0);
            var H = !K || Z
              , q = !Z || Z.i;
            Z || (Z = {}),
            K || (K = new e(3 * oe));
            var Q, se = function(ct) {
                var _t = K.length;
                if (ct > _t) {
                    var ut = new e(Math.max(2 * _t, ct));
                    ut.set(K),
                    K = ut
                }
            }, B = Z.f || 0, W = Z.p || 0, te = Z.b || 0, fe = Z.l, pe = Z.d, _e = Z.m, ue = Z.n, ge = 8 * oe;
            do {
                if (!fe) {
                    Z.f = B = O(V, W, 1);
                    var Te = O(V, W + 1, 3);
                    if (W += 3,
                    !Te) {
                        var Ze = V[(Ve = ((Q = W) / 8 | 0) + (7 & Q && 1) + 4) - 4] | V[Ve - 3] << 8
                          , ot = Ve + Ze;
                        if (ot > oe) {
                            q && I(0);
                            break
                        }
                        H && se(te + Ze),
                        K.set(V.subarray(Ve, ot), te),
                        Z.b = te += Ze,
                        Z.p = W = 8 * ot;
                        continue
                    }
                    if (Te == 1)
                        fe = A,
                        pe = C,
                        _e = 9,
                        ue = 5;
                    else if (Te == 2) {
                        var tt = O(V, W, 31) + 257
                          , $e = O(V, W + 10, 15) + 4
                          , re = tt + O(V, W + 5, 31) + 1;
                        W += 14;
                        for (var Le = new e(re), Ne = new e(19), Oe = 0; Oe < $e; ++Oe)
                            Ne[s[Oe]] = O(V, W + 3 * Oe, 7);
                        W += 3 * $e;
                        var le = R(Ne)
                          , Pe = (1 << le) - 1
                          , He = T(Ne, le);
                        for (Oe = 0; Oe < re; ) {
                            var Ve, De = He[O(V, W, Pe)];
                            if (W += 15 & De,
                            (Ve = De >>> 4) < 16)
                                Le[Oe++] = Ve;
                            else {
                                var vt = 0
                                  , J = 0;
                                for (Ve == 16 ? (J = 3 + O(V, W, 3),
                                W += 2,
                                vt = Le[Oe - 1]) : Ve == 17 ? (J = 3 + O(V, W, 7),
                                W += 3) : Ve == 18 && (J = 11 + O(V, W, 127),
                                W += 7); J--; )
                                    Le[Oe++] = vt
                            }
                        }
                        var j = Le.subarray(0, tt)
                          , ve = Le.subarray(tt);
                        _e = R(j),
                        ue = R(ve),
                        fe = T(j, _e),
                        pe = T(ve, ue)
                    } else
                        I(1);
                    if (W > ge) {
                        q && I(0);
                        break
                    }
                }
                H && se(te + 131072);
                for (var Be = (1 << _e) - 1, we = (1 << ue) - 1, Ce = W; ; Ce = W) {
                    var it = (vt = fe[L(V, W) & Be]) >>> 4;
                    if ((W += 15 & vt) > ge) {
                        q && I(0);
                        break
                    }
                    if (vt || I(2),
                    it < 256)
                        K[te++] = it;
                    else {
                        if (it == 256) {
                            Ce = W,
                            fe = null;
                            break
                        }
                        var lt = it - 254;
                        if (it > 264) {
                            var Mt = i[Oe = it - 257];
                            lt = O(V, W, (1 << Mt) - 1) + f[Oe],
                            W += Mt
                        }
                        var pt = pe[L(V, W) & we]
                          , je = pt >>> 4;
                        if (pt || I(3),
                        W += 15 & pt,
                        ve = g[je],
                        je > 3 && (Mt = a[je],
                        ve += L(V, W) & (1 << Mt) - 1,
                        W += Mt),
                        W > ge) {
                            q && I(0);
                            break
                        }
                        H && se(te + 131072);
                        for (var Ye = te + lt; te < Ye; te += 4)
                            K[te] = K[te - ve],
                            K[te + 1] = K[te + 1 - ve],
                            K[te + 2] = K[te + 2 - ve],
                            K[te + 3] = K[te + 3 - ve];
                        te = Ye
                    }
                }
                Z.l = fe,
                Z.p = Ce,
                Z.b = te,
                fe && (B = 1,
                Z.m = _e,
                Z.d = pe,
                Z.n = ue)
            } while (!B);
            return te == K.length ? K : function(ct, _t, ut) {
                (ut == null || ut > ct.length) && (ut = ct.length);
                var Ut = new (ct instanceof t ? t : ct instanceof n ? n : e)(ut - _t);
                return Ut.set(ct.subarray(_t, ut)),
                Ut
            }(K, 0, te)
        }
          , P = new e(0)
          , Y = typeof TextDecoder < "u" && new TextDecoder;
        try {
            Y.decode(P, {
                stream: !0
            })
        } catch {}
        return r.convert_streams = function(V) {
            var K = new DataView(V)
              , Z = 0;
            function oe() {
                var tt = K.getUint16(Z);
                return Z += 2,
                tt
            }
            function H() {
                var tt = K.getUint32(Z);
                return Z += 4,
                tt
            }
            function q(tt) {
                Ze.setUint16(ot, tt),
                ot += 2
            }
            function Q(tt) {
                Ze.setUint32(ot, tt),
                ot += 4
            }
            for (var se = {
                signature: H(),
                flavor: H(),
                length: H(),
                numTables: oe(),
                reserved: oe(),
                totalSfntSize: H(),
                majorVersion: oe(),
                minorVersion: oe(),
                metaOffset: H(),
                metaLength: H(),
                metaOrigLength: H(),
                privOffset: H(),
                privLength: H()
            }, B = 0; Math.pow(2, B) <= se.numTables; )
                B++;
            B--;
            for (var W = 16 * Math.pow(2, B), te = 16 * se.numTables - W, fe = 12, pe = [], _e = 0; _e < se.numTables; _e++)
                pe.push({
                    tag: H(),
                    offset: H(),
                    compLength: H(),
                    origLength: H(),
                    origChecksum: H()
                }),
                fe += 16;
            var ue, ge = new Uint8Array(12 + 16 * pe.length + pe.reduce(function(tt, $e) {
                return tt + $e.origLength + 4
            }, 0)), Te = ge.buffer, Ze = new DataView(Te), ot = 0;
            return Q(se.flavor),
            q(se.numTables),
            q(W),
            q(B),
            q(te),
            pe.forEach(function(tt) {
                Q(tt.tag),
                Q(tt.origChecksum),
                Q(fe),
                Q(tt.origLength),
                tt.outOffset = fe,
                (fe += tt.origLength) % 4 != 0 && (fe += 4 - fe % 4)
            }),
            pe.forEach(function(tt) {
                var $e, re = V.slice(tt.offset, tt.offset + tt.compLength);
                if (tt.compLength != tt.origLength) {
                    var Le = new Uint8Array(tt.origLength);
                    $e = new Uint8Array(re,2),
                    N($e, Le)
                } else
                    Le = new Uint8Array(re);
                ge.set(Le, tt.outOffset);
                var Ne = 0;
                (fe = tt.outOffset + tt.origLength) % 4 != 0 && (Ne = 4 - fe % 4),
                ge.set(new Uint8Array(Ne).buffer, tt.outOffset + tt.origLength),
                ue = fe + Ne
            }),
            Te.slice(0, ue)
        }
        ,
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r
    }({}).convert_streams
}
function E$(r, e) {
    const t = {
        M: 2,
        L: 2,
        Q: 4,
        C: 6,
        Z: 0
    }
      , n = {
        C: "18g,ca,368,1kz",
        D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v",
        R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6",
        L: "x9u,jff,a,fd,jv",
        T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n"
    }
      , i = 1
      , a = 2
      , s = 4
      , l = 8
      , u = 16
      , f = 32;
    let d;
    function g(z) {
        if (!d) {
            const I = {
                R: a,
                L: i,
                D: s,
                C: u,
                U: f,
                T: l
            };
            d = new Map;
            for (let N in n) {
                let P = 0;
                n[N].split(",").forEach(Y => {
                    let[V,K] = Y.split("+");
                    V = parseInt(V, 36),
                    K = K ? parseInt(K, 36) : 0,
                    d.set(P += V, I[N]);
                    for (let Z = K; Z--; )
                        d.set(++P, I[N])
                }
                )
            }
        }
        return d.get(z) || f
    }
    const v = 1
      , y = 2
      , S = 3
      , T = 4
      , M = [null, "isol", "init", "fina", "medi"];
    function b(z) {
        const I = new Uint8Array(z.length);
        let N = f
          , P = v
          , Y = -1;
        for (let V = 0; V < z.length; V++) {
            const K = z.codePointAt(V);
            let Z = g(K) | 0
              , oe = v;
            Z & l || (N & (i | s | u) ? Z & (a | s | u) ? (oe = S,
            (P === v || P === S) && I[Y]++) : Z & (i | f) && (P === y || P === T) && I[Y]-- : N & (a | f) && (P === y || P === T) && I[Y]--,
            P = I[V] = oe,
            N = Z,
            Y = V,
            K > 65535 && V++)
        }
        return I
    }
    function A(z, I) {
        const N = [];
        for (let Y = 0; Y < I.length; Y++) {
            const V = I.codePointAt(Y);
            V > 65535 && Y++,
            N.push(r.U.codeToGlyph(z, V))
        }
        const P = z.GSUB;
        if (P) {
            const {lookupList: Y, featureList: V} = P;
            let K;
            const Z = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/
              , oe = [];
            V.forEach(H => {
                if (Z.test(H.tag))
                    for (let q = 0; q < H.tab.length; q++) {
                        if (oe[H.tab[q]])
                            continue;
                        oe[H.tab[q]] = !0;
                        const Q = Y[H.tab[q]]
                          , se = /^(isol|init|fina|medi)$/.test(H.tag);
                        se && !K && (K = b(I));
                        for (let B = 0; B < N.length; B++)
                            (!K || !se || M[K[B]] === H.tag) && r.U._applySubs(N, B, Q, Y)
                    }
            }
            )
        }
        return N
    }
    function C(z, I) {
        const N = new Int16Array(I.length * 3);
        let P = 0;
        for (; P < I.length; P++) {
            const Z = I[P];
            if (Z === -1)
                continue;
            N[P * 3 + 2] = z.hmtx.aWidth[Z];
            const oe = z.GPOS;
            if (oe) {
                const H = oe.lookupList;
                for (let q = 0; q < H.length; q++) {
                    const Q = H[q];
                    for (let se = 0; se < Q.tabs.length; se++) {
                        const B = Q.tabs[se];
                        if (Q.ltype === 1) {
                            if (r._lctf.coverageIndex(B.coverage, Z) !== -1 && B.pos) {
                                K(B.pos, P);
                                break
                            }
                        } else if (Q.ltype === 2) {
                            let W = null
                              , te = Y();
                            if (te !== -1) {
                                const fe = r._lctf.coverageIndex(B.coverage, I[te]);
                                if (fe !== -1) {
                                    if (B.fmt === 1) {
                                        const pe = B.pairsets[fe];
                                        for (let _e = 0; _e < pe.length; _e++)
                                            pe[_e].gid2 === Z && (W = pe[_e])
                                    } else if (B.fmt === 2) {
                                        const pe = r.U._getGlyphClass(I[te], B.classDef1)
                                          , _e = r.U._getGlyphClass(Z, B.classDef2);
                                        W = B.matrix[pe][_e]
                                    }
                                    if (W) {
                                        W.val1 && K(W.val1, te),
                                        W.val2 && K(W.val2, P);
                                        break
                                    }
                                }
                            }
                        } else if (Q.ltype === 4) {
                            const W = r._lctf.coverageIndex(B.markCoverage, Z);
                            if (W !== -1) {
                                const te = Y(V)
                                  , fe = te === -1 ? -1 : r._lctf.coverageIndex(B.baseCoverage, I[te]);
                                if (fe !== -1) {
                                    const pe = B.markArray[W]
                                      , _e = B.baseArray[fe][pe.markClass];
                                    N[P * 3] = _e.x - pe.x + N[te * 3] - N[te * 3 + 2],
                                    N[P * 3 + 1] = _e.y - pe.y + N[te * 3 + 1];
                                    break
                                }
                            }
                        } else if (Q.ltype === 6) {
                            const W = r._lctf.coverageIndex(B.mark1Coverage, Z);
                            if (W !== -1) {
                                const te = Y();
                                if (te !== -1) {
                                    const fe = I[te];
                                    if (R(z, fe) === 3) {
                                        const pe = r._lctf.coverageIndex(B.mark2Coverage, fe);
                                        if (pe !== -1) {
                                            const _e = B.mark1Array[W]
                                              , ue = B.mark2Array[pe][_e.markClass];
                                            N[P * 3] = ue.x - _e.x + N[te * 3] - N[te * 3 + 2],
                                            N[P * 3 + 1] = ue.y - _e.y + N[te * 3 + 1];
                                            break
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else if (z.kern && !z.cff) {
                const H = Y();
                if (H !== -1) {
                    const q = z.kern.glyph1.indexOf(I[H]);
                    if (q !== -1) {
                        const Q = z.kern.rval[q].glyph2.indexOf(Z);
                        Q !== -1 && (N[H * 3 + 2] += z.kern.rval[q].vals[Q])
                    }
                }
            }
        }
        return N;
        function Y(Z) {
            for (let oe = P - 1; oe >= 0; oe--)
                if (I[oe] !== -1 && (!Z || Z(I[oe])))
                    return oe;
            return -1
        }
        function V(Z) {
            return R(z, Z) === 1
        }
        function K(Z, oe) {
            for (let H = 0; H < 3; H++)
                N[oe * 3 + H] += Z[H] || 0
        }
    }
    function R(z, I) {
        const N = z.GDEF && z.GDEF.glyphClassDef;
        return N ? r.U._getGlyphClass(I, N) : 0
    }
    function O(...z) {
        for (let I = 0; I < z.length; I++)
            if (typeof z[I] == "number")
                return z[I]
    }
    function L(z) {
        const I = Object.create(null)
          , N = z["OS/2"]
          , P = z.hhea
          , Y = z.head.unitsPerEm
          , V = O(N && N.sTypoAscender, P && P.ascender, Y)
          , K = {
            unitsPerEm: Y,
            ascender: V,
            descender: O(N && N.sTypoDescender, P && P.descender, 0),
            capHeight: O(N && N.sCapHeight, V),
            xHeight: O(N && N.sxHeight, V),
            lineGap: O(N && N.sTypoLineGap, P && P.lineGap),
            supportsCodePoint(Z) {
                return r.U.codeToGlyph(z, Z) > 0
            },
            forEachGlyph(Z, oe, H, q) {
                let Q = 0;
                const se = 1 / K.unitsPerEm * oe
                  , B = A(z, Z);
                let W = 0;
                const te = C(z, B);
                return B.forEach( (fe, pe) => {
                    if (fe !== -1) {
                        let _e = I[fe];
                        if (!_e) {
                            const {cmds: ue, crds: ge} = r.U.glyphToPath(z, fe);
                            let Te = ""
                              , Ze = 0;
                            for (let Le = 0, Ne = ue.length; Le < Ne; Le++) {
                                const Oe = t[ue[Le]];
                                Te += ue[Le];
                                for (let le = 1; le <= Oe; le++)
                                    Te += (le > 1 ? "," : "") + ge[Ze++]
                            }
                            let ot, tt, $e, re;
                            if (ge.length) {
                                ot = tt = 1 / 0,
                                $e = re = -1 / 0;
                                for (let Le = 0, Ne = ge.length; Le < Ne; Le += 2) {
                                    let Oe = ge[Le]
                                      , le = ge[Le + 1];
                                    Oe < ot && (ot = Oe),
                                    le < tt && (tt = le),
                                    Oe > $e && ($e = Oe),
                                    le > re && (re = le)
                                }
                            } else
                                ot = $e = tt = re = 0;
                            _e = I[fe] = {
                                index: fe,
                                advanceWidth: z.hmtx.aWidth[fe],
                                xMin: ot,
                                yMin: tt,
                                xMax: $e,
                                yMax: re,
                                path: Te
                            }
                        }
                        q.call(null, _e, Q + te[pe * 3] * se, te[pe * 3 + 1] * se, W),
                        Q += te[pe * 3 + 2] * se,
                        H && (Q += H * oe)
                    }
                    W += Z.codePointAt(W) > 65535 ? 2 : 1
                }
                ),
                Q
            }
        };
        return K
    }
    return function(I) {
        const N = new Uint8Array(I,0,4)
          , P = r._bin.readASCII(N, 0, 4);
        if (P === "wOFF")
            I = e(I);
        else if (P === "wOF2")
            throw new Error("woff2 fonts not supported");
        return L(r.parse(I)[0])
    }
}
const w$ = Kg({
    name: "Typr Font Parser",
    dependencies: [M$, T$, E$],
    init(r, e, t) {
        const n = r()
          , i = e();
        return t(n, i)
    }
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function A$() {
    return function(r) {
        var e = function() {
            this.buckets = new Map
        };
        e.prototype.add = function(C) {
            var R = C >> 5;
            this.buckets.set(R, (this.buckets.get(R) || 0) | 1 << (31 & C))
        }
        ,
        e.prototype.has = function(C) {
            var R = this.buckets.get(C >> 5);
            return R !== void 0 && (R & 1 << (31 & C)) != 0
        }
        ,
        e.prototype.serialize = function() {
            var C = [];
            return this.buckets.forEach(function(R, O) {
                C.push((+O).toString(36) + ":" + R.toString(36))
            }),
            C.join(",")
        }
        ,
        e.prototype.deserialize = function(C) {
            var R = this;
            this.buckets.clear(),
            C.split(",").forEach(function(O) {
                var L = O.split(":");
                R.buckets.set(parseInt(L[0], 36), parseInt(L[1], 36))
            })
        }
        ;
        var t = Math.pow(2, 8)
          , n = t - 1
          , i = ~n;
        function a(C) {
            var R = function(L) {
                return L & i
            }(C).toString(16)
              , O = function(L) {
                return (L & i) + t - 1
            }(C).toString(16);
            return "codepoint-index/plane" + (C >> 16) + "/" + R + "-" + O + ".json"
        }
        function s(C, R) {
            var O = C & n
              , L = R.codePointAt(O / 6 | 0);
            return ((L = (L || 48) - 48) & 1 << O % 6) != 0
        }
        function l(C, R) {
            var O;
            (O = C,
            O.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(L) {
                return L.split("-").map(function(z) {
                    return parseInt(z.trim(), 16)
                })
            })).forEach(function(L) {
                var z = L[0]
                  , I = L[1];
                I === void 0 && (I = z),
                R(z, I)
            })
        }
        function u(C, R) {
            l(C, function(O, L) {
                for (var z = O; z <= L; z++)
                    R(z)
            })
        }
        var f = {}
          , d = {}
          , g = new WeakMap
          , v = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
        function y(C) {
            var R = g.get(C);
            return R || (R = new e,
            u(C.ranges, function(O) {
                return R.add(O)
            }),
            g.set(C, R)),
            R
        }
        var S, T = new Map;
        function M(C, R, O) {
            return C[R] ? R : C[O] ? O : function(L) {
                for (var z in L)
                    return z
            }(C)
        }
        function b(C, R) {
            var O = R;
            if (!C.includes(O)) {
                O = 1 / 0;
                for (var L = 0; L < C.length; L++)
                    Math.abs(C[L] - R) < Math.abs(O - R) && (O = C[L])
            }
            return O
        }
        function A(C) {
            return S || (S = new Set,
            u("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(R) {
                S.add(R)
            })),
            S.has(C)
        }
        return r.CodePointSet = e,
        r.clearCache = function() {
            f = {},
            d = {}
        }
        ,
        r.getFontsForString = function(C, R) {
            R === void 0 && (R = {});
            var O, L = R.lang;
            L === void 0 && (L = new RegExp("\\p{Script=Hangul}","u").test(O = C) ? "ko" : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}","u").test(O) ? "ja" : "en");
            var z = R.category;
            z === void 0 && (z = "sans-serif");
            var I = R.style;
            I === void 0 && (I = "normal");
            var N = R.weight;
            N === void 0 && (N = 400);
            var P = (R.dataUrl || v).replace(/\/$/g, "")
              , Y = new Map
              , V = new Uint8Array(C.length)
              , K = {}
              , Z = {}
              , oe = new Array(C.length)
              , H = new Map
              , q = !1;
            function Q(W) {
                var te = T.get(W);
                return te || (te = fetch(P + "/" + W).then(function(fe) {
                    if (!fe.ok)
                        throw new Error(fe.statusText);
                    return fe.json().then(function(pe) {
                        if (!Array.isArray(pe) || pe[0] !== 1)
                            throw new Error("Incorrect schema version; need 1, got " + pe[0]);
                        return pe[1]
                    })
                }).catch(function(fe) {
                    if (P !== v)
                        return q || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + P + '", trying default CDN. ' + fe.message),
                        q = !0),
                        P = v,
                        T.delete(W),
                        Q(W);
                    throw fe
                }),
                T.set(W, te)),
                te
            }
            for (var se = function(W) {
                var te = C.codePointAt(W)
                  , fe = a(te);
                oe[W] = fe,
                f[fe] || H.has(fe) || H.set(fe, Q(fe).then(function(pe) {
                    f[fe] = pe
                })),
                te > 65535 && (W++,
                B = W)
            }, B = 0; B < C.length; B++)
                se(B);
            return Promise.all(H.values()).then(function() {
                H.clear();
                for (var W = function(fe) {
                    var pe = C.codePointAt(fe)
                      , _e = null
                      , ue = f[oe[fe]]
                      , ge = void 0;
                    for (var Te in ue) {
                        var Ze = Z[Te];
                        if (Ze === void 0 && (Ze = Z[Te] = new RegExp(Te).test(L || "en")),
                        Ze) {
                            for (var ot in ge = Te,
                            ue[Te])
                                if (s(pe, ue[Te][ot])) {
                                    _e = ot;
                                    break
                                }
                            break
                        }
                    }
                    if (!_e) {
                        e: for (var tt in ue)
                            if (tt !== ge) {
                                for (var $e in ue[tt])
                                    if (s(pe, ue[tt][$e])) {
                                        _e = $e;
                                        break e
                                    }
                            }
                    }
                    _e || (console.debug("No font coverage for U+" + pe.toString(16)),
                    _e = "latin"),
                    oe[fe] = _e,
                    d[_e] || H.has(_e) || H.set(_e, Q("font-meta/" + _e + ".json").then(function(re) {
                        d[_e] = re
                    })),
                    pe > 65535 && (fe++,
                    te = fe)
                }, te = 0; te < C.length; te++)
                    W(te);
                return Promise.all(H.values())
            }).then(function() {
                for (var W, te = null, fe = 0; fe < C.length; fe++) {
                    var pe = C.codePointAt(fe);
                    if (te && (A(pe) || y(te).has(pe)))
                        V[fe] = V[fe - 1];
                    else {
                        te = d[oe[fe]];
                        var _e = K[te.id];
                        if (!_e) {
                            var ue = te.typeforms
                              , ge = M(ue, z, "sans-serif")
                              , Te = M(ue[ge], I, "normal")
                              , Ze = b((W = ue[ge]) === null || W === void 0 ? void 0 : W[Te], N);
                            _e = K[te.id] = P + "/font-files/" + te.id + "/" + ge + "." + Te + "." + Ze + ".woff"
                        }
                        var ot = Y.get(_e);
                        ot == null && (ot = Y.size,
                        Y.set(_e, ot)),
                        V[fe] = ot
                    }
                    pe > 65535 && (fe++,
                    V[fe] = V[fe - 1])
                }
                return {
                    fontUrls: Array.from(Y.keys()),
                    chars: V
                }
            })
        }
        ,
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r
    }({})
}
function C$(r, e) {
    const t = Object.create(null)
      , n = Object.create(null);
    function i(s, l) {
        const u = f => {
            console.error(`Failure loading font ${s}`, f)
        }
        ;
        try {
            const f = new XMLHttpRequest;
            f.open("get", s, !0),
            f.responseType = "arraybuffer",
            f.onload = function() {
                if (f.status >= 400)
                    u(new Error(f.statusText));
                else if (f.status > 0)
                    try {
                        const d = r(f.response);
                        d.src = s,
                        l(d)
                    } catch (d) {
                        u(d)
                    }
            }
            ,
            f.onerror = u,
            f.send()
        } catch (f) {
            u(f)
        }
    }
    function a(s, l) {
        let u = t[s];
        u ? l(u) : n[s] ? n[s].push(l) : (n[s] = [l],
        i(s, f => {
            f.src = s,
            t[s] = f,
            n[s].forEach(d => d(f)),
            delete n[s]
        }
        ))
    }
    return function(s, l, {lang: u, fonts: f=[], style: d="normal", weight: g="normal", unicodeFontsURL: v}={}) {
        const y = new Uint8Array(s.length)
          , S = [];
        s.length || A();
        const T = new Map
          , M = [];
        if (d !== "italic" && (d = "normal"),
        typeof g != "number" && (g = g === "bold" ? 700 : 400),
        f && !Array.isArray(f) && (f = [f]),
        f = f.slice().filter(R => !R.lang || R.lang.test(u)).reverse(),
        f.length) {
            let z = 0;
            (function I(N=0) {
                for (let P = N, Y = s.length; P < Y; P++) {
                    const V = s.codePointAt(P);
                    if (z === 1 && S[y[P - 1]].supportsCodePoint(V) || P > 0 && /\s/.test(s[P]))
                        y[P] = y[P - 1],
                        z === 2 && (M[M.length - 1][1] = P);
                    else
                        for (let K = y[P], Z = f.length; K <= Z; K++)
                            if (K === Z) {
                                const oe = z === 2 ? M[M.length - 1] : M[M.length] = [P, P];
                                oe[1] = P,
                                z = 2
                            } else {
                                y[P] = K;
                                const {src: oe, unicodeRange: H} = f[K];
                                if (!H || C(V, H)) {
                                    const q = t[oe];
                                    if (!q) {
                                        a(oe, () => {
                                            I(P)
                                        }
                                        );
                                        return
                                    }
                                    if (q.supportsCodePoint(V)) {
                                        let Q = T.get(q);
                                        typeof Q != "number" && (Q = S.length,
                                        S.push(q),
                                        T.set(q, Q)),
                                        y[P] = Q,
                                        z = 1;
                                        break
                                    }
                                }
                            }
                    V > 65535 && P + 1 < Y && (y[P + 1] = y[P],
                    P++,
                    z === 2 && (M[M.length - 1][1] = P))
                }
                b()
            }
            )()
        } else
            M.push([0, s.length - 1]),
            b();
        function b() {
            if (M.length) {
                const R = M.map(O => s.substring(O[0], O[1] + 1)).join(`
`);
                e.getFontsForString(R, {
                    lang: u || void 0,
                    style: d,
                    weight: g,
                    dataUrl: v
                }).then( ({fontUrls: O, chars: L}) => {
                    const z = S.length;
                    let I = 0;
                    M.forEach(P => {
                        for (let Y = 0, V = P[1] - P[0]; Y <= V; Y++)
                            y[P[0] + Y] = L[I++] + z;
                        I++
                    }
                    );
                    let N = 0;
                    O.forEach( (P, Y) => {
                        a(P, V => {
                            S[Y + z] = V,
                            ++N === O.length && A()
                        }
                        )
                    }
                    )
                }
                )
            } else
                A()
        }
        function A() {
            l({
                chars: y,
                fonts: S
            })
        }
        function C(R, O) {
            for (let L = 0; L < O.length; L++) {
                const [z,I=z] = O[L];
                if (z <= R && R <= I)
                    return !0
            }
            return !1
        }
    }
}
const R$ = Kg({
    name: "FontResolver",
    dependencies: [C$, w$, A$],
    init(r, e, t) {
        return r(e, t())
    }
});
function D$(r, e) {
    const n = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/
      , i = "[^\\S\\u00A0]"
      , a = new RegExp(`${i}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
    function s({text: S, lang: T, fonts: M, style: b, weight: A, preResolvedFonts: C, unicodeFontsURL: R}, O) {
        const L = ({chars: z, fonts: I}) => {
            let N, P;
            const Y = [];
            for (let V = 0; V < z.length; V++)
                z[V] !== P ? (P = z[V],
                Y.push(N = {
                    start: V,
                    end: V,
                    fontObj: I[z[V]]
                })) : N.end = V;
            O(Y)
        }
        ;
        C ? L(C) : r(S, L, {
            lang: T,
            fonts: M,
            style: b,
            weight: A,
            unicodeFontsURL: R
        })
    }
    function l({text: S="", font: T, lang: M, sdfGlyphSize: b=64, fontSize: A=400, fontWeight: C=1, fontStyle: R="normal", letterSpacing: O=0, lineHeight: L="normal", maxWidth: z=1 / 0, direction: I, textAlign: N="left", textIndent: P=0, whiteSpace: Y="normal", overflowWrap: V="normal", anchorX: K=0, anchorY: Z=0, metricsOnly: oe=!1, unicodeFontsURL: H, preResolvedFonts: q=null, includeCaretPositions: Q=!1, chunkedBoundsSize: se=8192, colorRanges: B=null}, W) {
        const te = g()
          , fe = {
            fontLoad: 0,
            typesetting: 0
        };
        S.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"),
        S = S.replace(/\r\n/g, `
`).replace(/\r/g, `
`)),
        A = +A,
        O = +O,
        z = +z,
        L = L || "normal",
        P = +P,
        s({
            text: S,
            lang: M,
            style: R,
            weight: C,
            fonts: typeof T == "string" ? [{
                src: T
            }] : T,
            unicodeFontsURL: H,
            preResolvedFonts: q
        }, pe => {
            fe.fontLoad = g() - te;
            const _e = isFinite(z);
            let ue = null
              , ge = null
              , Te = null
              , Ze = null
              , ot = null
              , tt = null
              , $e = null
              , re = null
              , Le = 0
              , Ne = 0
              , Oe = Y !== "nowrap";
            const le = new Map
              , Pe = g();
            let He = P
              , Ve = 0
              , De = new v;
            const vt = [De];
            pe.forEach(we => {
                const {fontObj: Ce} = we
                  , {ascender: it, descender: lt, unitsPerEm: Mt, lineGap: pt, capHeight: je, xHeight: Ye} = Ce;
                let ct = le.get(Ce);
                if (!ct) {
                    const Ee = A / Mt
                      , at = L === "normal" ? (it - lt + pt) * Ee : L * A
                      , Ct = (at - (it - lt) * Ee) / 2
                      , rt = Math.min(at, (it - lt) * Ee)
                      , Ge = (it + lt) / 2 * Ee + rt / 2;
                    ct = {
                        index: le.size,
                        src: Ce.src,
                        fontObj: Ce,
                        fontSizeMult: Ee,
                        unitsPerEm: Mt,
                        ascender: it * Ee,
                        descender: lt * Ee,
                        capHeight: je * Ee,
                        xHeight: Ye * Ee,
                        lineHeight: at,
                        baseline: -Ct - it * Ee,
                        caretTop: Ge,
                        caretBottom: Ge - rt
                    },
                    le.set(Ce, ct)
                }
                const {fontSizeMult: _t} = ct
                  , ut = S.slice(we.start, we.end + 1);
                let Ut, me;
                Ce.forEachGlyph(ut, A, O, (Ee, at, Ct, rt) => {
                    at += Ve,
                    rt += we.start,
                    Ut = at,
                    me = Ee;
                    const Ge = S.charAt(rt)
                      , wt = Ee.advanceWidth * _t
                      , Ot = De.count;
                    let Nt;
                    if ("isEmpty"in Ee || (Ee.isWhitespace = !!Ge && new RegExp(i).test(Ge),
                    Ee.canBreakAfter = !!Ge && a.test(Ge),
                    Ee.isEmpty = Ee.xMin === Ee.xMax || Ee.yMin === Ee.yMax || n.test(Ge)),
                    !Ee.isWhitespace && !Ee.isEmpty && Ne++,
                    Oe && _e && !Ee.isWhitespace && at + wt + He > z && Ot) {
                        if (De.glyphAt(Ot - 1).glyphObj.canBreakAfter)
                            Nt = new v,
                            He = -at;
                        else
                            for (let Bt = Ot; Bt--; )
                                if (Bt === 0 && V === "break-word") {
                                    Nt = new v,
                                    He = -at;
                                    break
                                } else if (De.glyphAt(Bt).glyphObj.canBreakAfter) {
                                    Nt = De.splitAt(Bt + 1);
                                    const Gt = Nt.glyphAt(0).x;
                                    He -= Gt;
                                    for (let mt = Nt.count; mt--; )
                                        Nt.glyphAt(mt).x -= Gt;
                                    break
                                }
                        Nt && (De.isSoftWrapped = !0,
                        De = Nt,
                        vt.push(De),
                        Le = z)
                    }
                    let bt = De.glyphAt(De.count);
                    bt.glyphObj = Ee,
                    bt.x = at + He,
                    bt.y = Ct,
                    bt.width = wt,
                    bt.charIndex = rt,
                    bt.fontData = ct,
                    Ge === `
` && (De = new v,
                    vt.push(De),
                    He = -(at + wt + O * A) + P)
                }
                ),
                Ve = Ut + me.advanceWidth * _t + O * A
            }
            );
            let J = 0;
            vt.forEach(we => {
                let Ce = !0;
                for (let it = we.count; it--; ) {
                    const lt = we.glyphAt(it);
                    Ce && !lt.glyphObj.isWhitespace && (we.width = lt.x + lt.width,
                    we.width > Le && (Le = we.width),
                    Ce = !1);
                    let {lineHeight: Mt, capHeight: pt, xHeight: je, baseline: Ye} = lt.fontData;
                    Mt > we.lineHeight && (we.lineHeight = Mt);
                    const ct = Ye - we.baseline;
                    ct < 0 && (we.baseline += ct,
                    we.cap += ct,
                    we.ex += ct),
                    we.cap = Math.max(we.cap, we.baseline + pt),
                    we.ex = Math.max(we.ex, we.baseline + je)
                }
                we.baseline -= J,
                we.cap -= J,
                we.ex -= J,
                J += we.lineHeight
            }
            );
            let j = 0
              , ve = 0;
            if (K && (typeof K == "number" ? j = -K : typeof K == "string" && (j = -Le * (K === "left" ? 0 : K === "center" ? .5 : K === "right" ? 1 : f(K)))),
            Z && (typeof Z == "number" ? ve = -Z : typeof Z == "string" && (ve = Z === "top" ? 0 : Z === "top-baseline" ? -vt[0].baseline : Z === "top-cap" ? -vt[0].cap : Z === "top-ex" ? -vt[0].ex : Z === "middle" ? J / 2 : Z === "bottom" ? J : Z === "bottom-baseline" ? -vt[vt.length - 1].baseline : f(Z) * J)),
            !oe) {
                const we = e.getEmbeddingLevels(S, I);
                ue = new Uint16Array(Ne),
                ge = new Uint8Array(Ne),
                Te = new Float32Array(Ne * 2),
                Ze = {},
                $e = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                re = [],
                Q && (tt = new Float32Array(S.length * 4)),
                B && (ot = new Uint8Array(Ne * 3));
                let Ce = 0, it = -1, lt = -1, Mt, pt;
                if (vt.forEach( (je, Ye) => {
                    let {count: ct, width: _t} = je;
                    if (ct > 0) {
                        let ut = 0;
                        for (let rt = ct; rt-- && je.glyphAt(rt).glyphObj.isWhitespace; )
                            ut++;
                        let Ut = 0
                          , me = 0;
                        if (N === "center")
                            Ut = (Le - _t) / 2;
                        else if (N === "right")
                            Ut = Le - _t;
                        else if (N === "justify" && je.isSoftWrapped) {
                            let rt = 0;
                            for (let Ge = ct - ut; Ge--; )
                                je.glyphAt(Ge).glyphObj.isWhitespace && rt++;
                            me = (Le - _t) / rt
                        }
                        if (me || Ut) {
                            let rt = 0;
                            for (let Ge = 0; Ge < ct; Ge++) {
                                let wt = je.glyphAt(Ge);
                                const Ot = wt.glyphObj;
                                wt.x += Ut + rt,
                                me !== 0 && Ot.isWhitespace && Ge < ct - ut && (rt += me,
                                wt.width += me)
                            }
                        }
                        const Ee = e.getReorderSegments(S, we, je.glyphAt(0).charIndex, je.glyphAt(je.count - 1).charIndex);
                        for (let rt = 0; rt < Ee.length; rt++) {
                            const [Ge,wt] = Ee[rt];
                            let Ot = 1 / 0
                              , Nt = -1 / 0;
                            for (let bt = 0; bt < ct; bt++)
                                if (je.glyphAt(bt).charIndex >= Ge) {
                                    let Bt = bt
                                      , Gt = bt;
                                    for (; Gt < ct; Gt++) {
                                        let mt = je.glyphAt(Gt);
                                        if (mt.charIndex > wt)
                                            break;
                                        Gt < ct - ut && (Ot = Math.min(Ot, mt.x),
                                        Nt = Math.max(Nt, mt.x + mt.width))
                                    }
                                    for (let mt = Bt; mt < Gt; mt++) {
                                        const Lt = je.glyphAt(mt);
                                        Lt.x = Nt - (Lt.x + Lt.width - Ot)
                                    }
                                    break
                                }
                        }
                        let at;
                        const Ct = rt => at = rt;
                        for (let rt = 0; rt < ct; rt++) {
                            const Ge = je.glyphAt(rt);
                            at = Ge.glyphObj;
                            const wt = at.index
                              , Ot = we.levels[Ge.charIndex] & 1;
                            if (Ot) {
                                const Nt = e.getMirroredCharacter(S[Ge.charIndex]);
                                Nt && Ge.fontData.fontObj.forEachGlyph(Nt, 0, 0, Ct)
                            }
                            if (Q) {
                                const {charIndex: Nt, fontData: bt} = Ge
                                  , Bt = Ge.x + j
                                  , Gt = Ge.x + Ge.width + j;
                                tt[Nt * 4] = Ot ? Gt : Bt,
                                tt[Nt * 4 + 1] = Ot ? Bt : Gt,
                                tt[Nt * 4 + 2] = je.baseline + bt.caretBottom + ve,
                                tt[Nt * 4 + 3] = je.baseline + bt.caretTop + ve;
                                const mt = Nt - it;
                                mt > 1 && d(tt, it, mt),
                                it = Nt
                            }
                            if (B) {
                                const {charIndex: Nt} = Ge;
                                for (; Nt > lt; )
                                    lt++,
                                    B.hasOwnProperty(lt) && (pt = B[lt])
                            }
                            if (!at.isWhitespace && !at.isEmpty) {
                                const Nt = Ce++
                                  , {fontSizeMult: bt, src: Bt, index: Gt} = Ge.fontData
                                  , mt = Ze[Bt] || (Ze[Bt] = {});
                                mt[wt] || (mt[wt] = {
                                    path: at.path,
                                    pathBounds: [at.xMin, at.yMin, at.xMax, at.yMax]
                                });
                                const Lt = Ge.x + j
                                  , zt = Ge.y + je.baseline + ve;
                                Te[Nt * 2] = Lt,
                                Te[Nt * 2 + 1] = zt;
                                const Wt = Lt + at.xMin * bt
                                  , Ln = zt + at.yMin * bt
                                  , qt = Lt + at.xMax * bt
                                  , Pt = zt + at.yMax * bt;
                                Wt < $e[0] && ($e[0] = Wt),
                                Ln < $e[1] && ($e[1] = Ln),
                                qt > $e[2] && ($e[2] = qt),
                                Pt > $e[3] && ($e[3] = Pt),
                                Nt % se === 0 && (Mt = {
                                    start: Nt,
                                    end: Nt,
                                    rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                },
                                re.push(Mt)),
                                Mt.end++;
                                const un = Mt.rect;
                                if (Wt < un[0] && (un[0] = Wt),
                                Ln < un[1] && (un[1] = Ln),
                                qt > un[2] && (un[2] = qt),
                                Pt > un[3] && (un[3] = Pt),
                                ue[Nt] = wt,
                                ge[Nt] = Gt,
                                B) {
                                    const $t = Nt * 3;
                                    ot[$t] = pt >> 16 & 255,
                                    ot[$t + 1] = pt >> 8 & 255,
                                    ot[$t + 2] = pt & 255
                                }
                            }
                        }
                    }
                }
                ),
                tt) {
                    const je = S.length - it;
                    je > 1 && d(tt, it, je)
                }
            }
            const Be = [];
            le.forEach( ({index: we, src: Ce, unitsPerEm: it, ascender: lt, descender: Mt, lineHeight: pt, capHeight: je, xHeight: Ye}) => {
                Be[we] = {
                    src: Ce,
                    unitsPerEm: it,
                    ascender: lt,
                    descender: Mt,
                    lineHeight: pt,
                    capHeight: je,
                    xHeight: Ye
                }
            }
            ),
            fe.typesetting = g() - Pe,
            W({
                glyphIds: ue,
                glyphFontIndices: ge,
                glyphPositions: Te,
                glyphData: Ze,
                fontData: Be,
                caretPositions: tt,
                glyphColors: ot,
                chunkedBounds: re,
                fontSize: A,
                topBaseline: ve + vt[0].baseline,
                blockBounds: [j, ve - J, j + Le, ve],
                visibleBounds: $e,
                timings: fe
            })
        }
        )
    }
    function u(S, T) {
        l({
            ...S,
            metricsOnly: !0
        }, M => {
            const [b,A,C,R] = M.blockBounds;
            T({
                width: C - b,
                height: R - A
            })
        }
        )
    }
    function f(S) {
        let T = S.match(/^([\d.]+)%$/)
          , M = T ? parseFloat(T[1]) : NaN;
        return isNaN(M) ? 0 : M / 100
    }
    function d(S, T, M) {
        const b = S[T * 4]
          , A = S[T * 4 + 1]
          , C = S[T * 4 + 2]
          , R = S[T * 4 + 3]
          , O = (A - b) / M;
        for (let L = 0; L < M; L++) {
            const z = (T + L) * 4;
            S[z] = b + O * L,
            S[z + 1] = b + O * (L + 1),
            S[z + 2] = C,
            S[z + 3] = R
        }
    }
    function g() {
        return (self.performance || Date).now()
    }
    function v() {
        this.data = []
    }
    const y = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
    return v.prototype = {
        width: 0,
        lineHeight: 0,
        baseline: 0,
        cap: 0,
        ex: 0,
        isSoftWrapped: !1,
        get count() {
            return Math.ceil(this.data.length / y.length)
        },
        glyphAt(S) {
            let T = v.flyweight;
            return T.data = this.data,
            T.index = S,
            T
        },
        splitAt(S) {
            let T = new v;
            return T.data = this.data.splice(S * y.length),
            T
        }
    },
    v.flyweight = y.reduce( (S, T, M, b) => (Object.defineProperty(S, T, {
        get() {
            return this.data[this.index * y.length + M]
        },
        set(A) {
            this.data[this.index * y.length + M] = A
        }
    }),
    S), {
        data: null,
        index: 0
    }),
    {
        typeset: l,
        measure: u
    }
}
const rp = () => (self.performance || Date).now()
  , FM = iI();
let $O;
function U$(r, e, t, n, i, a, s, l, u, f, d=!0) {
    return d ? N$(r, e, t, n, i, a, s, l, u, f).then(null, g => ($O || (console.warn("WebGL SDF generation failed, falling back to JS", g),
    $O = !0),
    tN(r, e, t, n, i, a, s, l, u, f))) : tN(r, e, t, n, i, a, s, l, u, f)
}
const TS = []
  , O$ = 5;
let Uw = 0;
function aI() {
    const r = rp();
    for (; TS.length && rp() - r < O$; )
        TS.shift()();
    Uw = TS.length ? setTimeout(aI, 0) : 0
}
const N$ = (...r) => new Promise( (e, t) => {
    TS.push( () => {
        const n = rp();
        try {
            FM.webgl.generateIntoCanvas(...r),
            e({
                timing: rp() - n
            })
        } catch (i) {
            t(i)
        }
    }
    ),
    Uw || (Uw = setTimeout(aI, 0))
}
)
  , L$ = 4
  , P$ = 2e3
  , eN = {};
let B$ = 0;
function tN(r, e, t, n, i, a, s, l, u, f) {
    const d = "TroikaTextSDFGenerator_JS_" + B$++ % L$;
    let g = eN[d];
    return g || (g = eN[d] = {
        workerModule: Kg({
            name: d,
            workerId: d,
            dependencies: [iI, rp],
            init(v, y) {
                const S = v().javascript.generate;
                return function(...T) {
                    const M = y();
                    return {
                        textureData: S(...T),
                        timing: y() - M
                    }
                }
            },
            getTransferables(v) {
                return [v.textureData.buffer]
            }
        }),
        requests: 0,
        idleTimer: null
    }),
    g.requests++,
    clearTimeout(g.idleTimer),
    g.workerModule(r, e, t, n, i, a).then( ({textureData: v, timing: y}) => {
        const S = rp()
          , T = new Uint8Array(v.length * 4);
        for (let M = 0; M < v.length; M++)
            T[M * 4 + f] = v[M];
        return FM.webglUtils.renderImageData(s, T, l, u, r, e, 1 << 3 - f),
        y += rp() - S,
        --g.requests === 0 && (g.idleTimer = setTimeout( () => {
            d$(d)
        }
        , P$)),
        {
            timing: y
        }
    }
    )
}
function z$(r) {
    r._warm || (FM.webgl.isSupported(r),
    r._warm = !0)
}
const I$ = FM.webglUtils.resizeWebGLCanvasWithoutClearing
  , Pv = {
    unicodeFontsURL: null,
    sdfGlyphSize: 64,
    sdfMargin: 1 / 16,
    sdfExponent: 9,
    textureWidth: 2048
}
  , F$ = new kt;
function km() {
    return (self.performance || Date).now()
}
const nN = Object.create(null);
function sI(r, e) {
    r = k$({}, r);
    const t = km()
      , n = [];
    if (r.font && n.push({
        label: "user",
        src: G$(r.font)
    }),
    r.font = n,
    r.text = "" + r.text,
    r.sdfGlyphSize = r.sdfGlyphSize || Pv.sdfGlyphSize,
    r.unicodeFontsURL = r.unicodeFontsURL || Pv.unicodeFontsURL,
    r.colorRanges != null) {
        let v = {};
        for (let y in r.colorRanges)
            if (r.colorRanges.hasOwnProperty(y)) {
                let S = r.colorRanges[y];
                typeof S != "number" && (S = F$.set(S).getHex()),
                v[y] = S
            }
        r.colorRanges = v
    }
    Object.freeze(r);
    const {textureWidth: i, sdfExponent: a} = Pv
      , {sdfGlyphSize: s} = r
      , l = i / s * 4;
    let u = nN[s];
    if (!u) {
        const v = document.createElement("canvas");
        v.width = i,
        v.height = s * 256 / l,
        u = nN[s] = {
            glyphCount: 0,
            sdfGlyphSize: s,
            sdfCanvas: v,
            sdfTexture: new _i(v,void 0,void 0,void 0,fi,fi),
            contextLost: !1,
            glyphsByFont: new Map
        },
        u.sdfTexture.generateMipmaps = !1,
        H$(u)
    }
    const {sdfTexture: f, sdfCanvas: d} = u;
    uI(r).then(v => {
        const {glyphIds: y, glyphFontIndices: S, fontData: T, glyphPositions: M, fontSize: b, timings: A} = v
          , C = []
          , R = new Float32Array(y.length * 4);
        let O = 0
          , L = 0;
        const z = km()
          , I = T.map(K => {
            let Z = u.glyphsByFont.get(K.src);
            return Z || u.glyphsByFont.set(K.src, Z = new Map),
            Z
        }
        );
        y.forEach( (K, Z) => {
            const oe = S[Z]
              , {src: H, unitsPerEm: q} = T[oe];
            let Q = I[oe].get(K);
            if (!Q) {
                const {path: fe, pathBounds: pe} = v.glyphData[H][K]
                  , _e = Math.max(pe[2] - pe[0], pe[3] - pe[1]) / s * (Pv.sdfMargin * s + .5)
                  , ue = u.glyphCount++
                  , ge = [pe[0] - _e, pe[1] - _e, pe[2] + _e, pe[3] + _e];
                I[oe].set(K, Q = {
                    path: fe,
                    atlasIndex: ue,
                    sdfViewBox: ge
                }),
                C.push(Q)
            }
            const {sdfViewBox: se} = Q
              , B = M[L++]
              , W = M[L++]
              , te = b / q;
            R[O++] = B + se[0] * te,
            R[O++] = W + se[1] * te,
            R[O++] = B + se[2] * te,
            R[O++] = W + se[3] * te,
            y[Z] = Q.atlasIndex
        }
        ),
        A.quads = (A.quads || 0) + (km() - z);
        const N = km();
        A.sdf = {};
        const P = d.height
          , Y = Math.ceil(u.glyphCount / l)
          , V = Math.pow(2, Math.ceil(Math.log2(Y * s)));
        V > P && (console.info(`Increasing SDF texture size ${P}->${V}`),
        I$(d, i, V),
        f.dispose()),
        Promise.all(C.map(K => oI(K, u, r.gpuAccelerateSDF).then( ({timing: Z}) => {
            A.sdf[K.atlasIndex] = Z
        }
        ))).then( () => {
            C.length && !u.contextLost && (lI(u),
            f.needsUpdate = !0),
            A.sdfTotal = km() - N,
            A.total = km() - t,
            e(Object.freeze({
                parameters: r,
                sdfTexture: f,
                sdfGlyphSize: s,
                sdfExponent: a,
                glyphBounds: R,
                glyphAtlasIndices: y,
                glyphColors: v.glyphColors,
                caretPositions: v.caretPositions,
                chunkedBounds: v.chunkedBounds,
                ascender: v.ascender,
                descender: v.descender,
                lineHeight: v.lineHeight,
                capHeight: v.capHeight,
                xHeight: v.xHeight,
                topBaseline: v.topBaseline,
                blockBounds: v.blockBounds,
                visibleBounds: v.visibleBounds,
                timings: v.timings
            }))
        }
        )
    }
    ),
    Promise.resolve().then( () => {
        u.contextLost || z$(d)
    }
    )
}
function oI({path: r, atlasIndex: e, sdfViewBox: t}, {sdfGlyphSize: n, sdfCanvas: i, contextLost: a}, s) {
    if (a)
        return Promise.resolve({
            timing: -1
        });
    const {textureWidth: l, sdfExponent: u} = Pv
      , f = Math.max(t[2] - t[0], t[3] - t[1])
      , d = Math.floor(e / 4)
      , g = d % (l / n) * n
      , v = Math.floor(d / (l / n)) * n
      , y = e % 4;
    return U$(n, n, r, t, f, u, i, g, v, y, s)
}
function H$(r) {
    const e = r.sdfCanvas;
    e.addEventListener("webglcontextlost", t => {
        console.log("Context Lost", t),
        t.preventDefault(),
        r.contextLost = !0
    }
    ),
    e.addEventListener("webglcontextrestored", t => {
        console.log("Context Restored", t),
        r.contextLost = !1;
        const n = [];
        r.glyphsByFont.forEach(i => {
            i.forEach(a => {
                n.push(oI(a, r, !0))
            }
            )
        }
        ),
        Promise.all(n).then( () => {
            lI(r),
            r.sdfTexture.needsUpdate = !0
        }
        )
    }
    )
}
function V$({font: r, characters: e, sdfGlyphSize: t}, n) {
    let i = Array.isArray(e) ? e.join(`
`) : "" + e;
    sI({
        font: r,
        sdfGlyphSize: t,
        text: i
    }, n)
}
function k$(r, e) {
    for (let t in e)
        e.hasOwnProperty(t) && (r[t] = e[t]);
    return r
}
let Wx;
function G$(r) {
    return Wx || (Wx = typeof document > "u" ? {} : document.createElement("a")),
    Wx.href = r,
    Wx.href
}
function lI(r) {
    if (typeof createImageBitmap != "function") {
        console.info("Safari<15: applying SDF canvas workaround");
        const {sdfCanvas: e, sdfTexture: t} = r
          , {width: n, height: i} = e
          , a = r.sdfCanvas.getContext("webgl");
        let s = t.image.data;
        (!s || s.length !== n * i * 4) && (s = new Uint8Array(n * i * 4),
        t.image = {
            width: n,
            height: i,
            data: s
        },
        t.flipY = !1,
        t.isDataTexture = !0),
        a.readPixels(0, 0, n, i, a.RGBA, a.UNSIGNED_BYTE, s)
    }
}
const X$ = Kg({
    name: "Typesetter",
    dependencies: [D$, R$, m$],
    init(r, e, t) {
        return r(e, t())
    }
})
  , uI = Kg({
    name: "Typesetter",
    dependencies: [X$],
    init(r) {
        return function(e) {
            return new Promise(t => {
                r.typeset(e, t)
            }
            )
        }
    },
    getTransferables(r) {
        const e = [];
        for (let t in r)
            r[t] && r[t].buffer && e.push(r[t].buffer);
        return e
    }
});
uI.onMainThread;
const iN = {};
function j$(r) {
    let e = iN[r];
    return e || (e = iN[r] = new eu(1,1,r,r).translate(.5, .5, 0)),
    e
}
const W$ = "aTroikaGlyphBounds"
  , rN = "aTroikaGlyphIndex"
  , Y$ = "aTroikaGlyphColor";
class q$ extends CC {
    constructor() {
        super(),
        this.detail = 1,
        this.curveRadius = 0,
        this.groups = [{
            start: 0,
            count: 1 / 0,
            materialIndex: 0
        }, {
            start: 0,
            count: 1 / 0,
            materialIndex: 1
        }],
        this.boundingSphere = new ta,
        this.boundingBox = new ea
    }
    computeBoundingSphere() {}
    computeBoundingBox() {}
    set detail(e) {
        if (e !== this._detail) {
            this._detail = e,
            (typeof e != "number" || e < 1) && (e = 1);
            let t = j$(e);
            ["position", "normal", "uv"].forEach(n => {
                this.attributes[n] = t.attributes[n].clone()
            }
            ),
            this.setIndex(t.getIndex().clone())
        }
    }
    get detail() {
        return this._detail
    }
    set curveRadius(e) {
        e !== this._curveRadius && (this._curveRadius = e,
        this._updateBounds())
    }
    get curveRadius() {
        return this._curveRadius
    }
    updateGlyphs(e, t, n, i, a) {
        this.updateAttributeData(W$, e, 4),
        this.updateAttributeData(rN, t, 1),
        this.updateAttributeData(Y$, a, 3),
        this._blockBounds = n,
        this._chunkedBounds = i,
        this.instanceCount = t.length,
        this._updateBounds()
    }
    _updateBounds() {
        const e = this._blockBounds;
        if (e) {
            const {curveRadius: t, boundingBox: n} = this;
            if (t) {
                const {PI: i, floor: a, min: s, max: l, sin: u, cos: f} = Math
                  , d = i / 2
                  , g = i * 2
                  , v = Math.abs(t)
                  , y = e[0] / v
                  , S = e[2] / v
                  , T = a((y + d) / g) !== a((S + d) / g) ? -v : s(u(y) * v, u(S) * v)
                  , M = a((y - d) / g) !== a((S - d) / g) ? v : l(u(y) * v, u(S) * v)
                  , b = a((y + i) / g) !== a((S + i) / g) ? v * 2 : l(v - f(y) * v, v - f(S) * v);
                n.min.set(T, e[1], t < 0 ? -b : 0),
                n.max.set(M, e[3], t < 0 ? 0 : b)
            } else
                n.min.set(e[0], e[1], 0),
                n.max.set(e[2], e[3], 0);
            n.getBoundingSphere(this.boundingSphere)
        }
    }
    applyClipRect(e) {
        let t = this.getAttribute(rN).count
          , n = this._chunkedBounds;
        if (n)
            for (let i = n.length; i--; ) {
                t = n[i].end;
                let a = n[i].rect;
                if (a[1] < e.w && a[3] > e.y && a[0] < e.z && a[2] > e.x)
                    break
            }
        this.instanceCount = t
    }
    updateAttributeData(e, t, n) {
        const i = this.getAttribute(e);
        t ? i && i.array.length === t.length ? (i.array.set(t),
        i.needsUpdate = !0) : (this.setAttribute(e, new fp(t,n)),
        delete this._maxInstanceCount,
        this.dispose()) : i && this.deleteAttribute(e)
    }
}
const Z$ = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaEdgeOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`
  , K$ = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`
  , Q$ = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaEdgeOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`
  , J$ = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function $$(r) {
    const e = Dw(r, {
        chained: !0,
        extensions: {
            derivatives: !0
        },
        uniforms: {
            uTroikaSDFTexture: {
                value: null
            },
            uTroikaSDFTextureSize: {
                value: new xt
            },
            uTroikaSDFGlyphSize: {
                value: 0
            },
            uTroikaSDFExponent: {
                value: 0
            },
            uTroikaTotalBounds: {
                value: new Qn(0,0,0,0)
            },
            uTroikaClipRect: {
                value: new Qn(0,0,0,0)
            },
            uTroikaEdgeOffset: {
                value: 0
            },
            uTroikaFillOpacity: {
                value: 1
            },
            uTroikaPositionOffset: {
                value: new xt
            },
            uTroikaCurveRadius: {
                value: 0
            },
            uTroikaBlurRadius: {
                value: 0
            },
            uTroikaStrokeWidth: {
                value: 0
            },
            uTroikaStrokeColor: {
                value: new kt
            },
            uTroikaStrokeOpacity: {
                value: 1
            },
            uTroikaOrient: {
                value: new An
            },
            uTroikaUseGlyphColors: {
                value: !0
            },
            uTroikaSDFDebug: {
                value: !1
            }
        },
        vertexDefs: Z$,
        vertexTransform: K$,
        fragmentDefs: Q$,
        fragmentColorTransform: J$,
        customRewriter({vertexShader: t, fragmentShader: n}) {
            let i = /\buniform\s+vec3\s+diffuse\b/;
            return i.test(n) && (n = n.replace(i, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"),
            i.test(t) || (t = t.replace(rI, `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`))),
            {
                vertexShader: t,
                fragmentShader: n
            }
        }
    });
    return e.transparent = !0,
    e.forceSinglePass = !0,
    Object.defineProperties(e, {
        isTroikaTextMaterial: {
            value: !0
        },
        shadowSide: {
            get() {
                return this.side
            },
            set() {}
        }
    }),
    e
}
const jC = new oc({
    color: 16777215,
    side: tl,
    transparent: !0
})
  , aN = 8421504
  , sN = new vn
  , Yx = new he
  , uE = new he
  , Ev = []
  , eee = new he
  , cE = "+x+y";
function oN(r) {
    return Array.isArray(r) ? r[0] : r
}
let cI = () => {
    const r = new Ni(new eu(1,1),jC);
    return cI = () => r,
    r
}
  , fI = () => {
    const r = new Ni(new eu(1,1,32,1),jC);
    return fI = () => r,
    r
}
;
const tee = {
    type: "syncstart"
}
  , nee = {
    type: "synccomplete"
}
  , hI = ["font", "fontSize", "fontStyle", "fontWeight", "lang", "letterSpacing", "lineHeight", "maxWidth", "overflowWrap", "text", "direction", "textAlign", "textIndent", "whiteSpace", "anchorX", "anchorY", "colorRanges", "sdfGlyphSize"]
  , iee = hI.concat("material", "color", "depthOffset", "clipRect", "curveRadius", "orientation", "glyphGeometryDetail");
let dI = class extends Ni {
    constructor() {
        const e = new q$;
        super(e, null),
        this.text = "",
        this.anchorX = 0,
        this.anchorY = 0,
        this.curveRadius = 0,
        this.direction = "auto",
        this.font = null,
        this.unicodeFontsURL = null,
        this.fontSize = .1,
        this.fontWeight = "normal",
        this.fontStyle = "normal",
        this.lang = null,
        this.letterSpacing = 0,
        this.lineHeight = "normal",
        this.maxWidth = 1 / 0,
        this.overflowWrap = "normal",
        this.textAlign = "left",
        this.textIndent = 0,
        this.whiteSpace = "normal",
        this.material = null,
        this.color = null,
        this.colorRanges = null,
        this.outlineWidth = 0,
        this.outlineColor = 0,
        this.outlineOpacity = 1,
        this.outlineBlur = 0,
        this.outlineOffsetX = 0,
        this.outlineOffsetY = 0,
        this.strokeWidth = 0,
        this.strokeColor = aN,
        this.strokeOpacity = 1,
        this.fillOpacity = 1,
        this.depthOffset = 0,
        this.clipRect = null,
        this.orientation = cE,
        this.glyphGeometryDetail = 1,
        this.sdfGlyphSize = null,
        this.gpuAccelerateSDF = !0,
        this.debugSDF = !1
    }
    sync(e) {
        this._needsSync && (this._needsSync = !1,
        this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0,
        this.dispatchEvent(tee),
        sI({
            text: this.text,
            font: this.font,
            lang: this.lang,
            fontSize: this.fontSize || .1,
            fontWeight: this.fontWeight || "normal",
            fontStyle: this.fontStyle || "normal",
            letterSpacing: this.letterSpacing || 0,
            lineHeight: this.lineHeight || "normal",
            maxWidth: this.maxWidth,
            direction: this.direction || "auto",
            textAlign: this.textAlign,
            textIndent: this.textIndent,
            whiteSpace: this.whiteSpace,
            overflowWrap: this.overflowWrap,
            anchorX: this.anchorX,
            anchorY: this.anchorY,
            colorRanges: this.colorRanges,
            includeCaretPositions: !0,
            sdfGlyphSize: this.sdfGlyphSize,
            gpuAccelerateSDF: this.gpuAccelerateSDF,
            unicodeFontsURL: this.unicodeFontsURL
        }, t => {
            this._isSyncing = !1,
            this._textRenderInfo = t,
            this.geometry.updateGlyphs(t.glyphBounds, t.glyphAtlasIndices, t.blockBounds, t.chunkedBounds, t.glyphColors);
            const n = this._queuedSyncs;
            n && (this._queuedSyncs = null,
            this._needsSync = !0,
            this.sync( () => {
                n.forEach(i => i && i())
            }
            )),
            this.dispatchEvent(nee),
            e && e()
        }
        )))
    }
    onBeforeRender(e, t, n, i, a, s) {
        this.sync(),
        a.isTroikaTextMaterial && this._prepareForRender(a)
    }
    dispose() {
        this.geometry.dispose()
    }
    get textRenderInfo() {
        return this._textRenderInfo || null
    }
    createDerivedMaterial(e) {
        return $$(e)
    }
    get material() {
        let e = this._derivedMaterial;
        const t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = jC.clone());
        if ((!e || !e.isDerivedFrom(t)) && (e = this._derivedMaterial = this.createDerivedMaterial(t),
        t.addEventListener("dispose", function n() {
            t.removeEventListener("dispose", n),
            e.dispose()
        })),
        this.hasOutline()) {
            let n = e._outlineMtl;
            return n || (n = e._outlineMtl = Object.create(e, {
                id: {
                    value: e.id + .1
                }
            }),
            n.isTextOutlineMaterial = !0,
            n.depthWrite = !1,
            n.map = null,
            e.addEventListener("dispose", function i() {
                e.removeEventListener("dispose", i),
                n.dispose()
            })),
            [n, e]
        } else
            return e
    }
    set material(e) {
        e && e.isTroikaTextMaterial ? (this._derivedMaterial = e,
        this._baseMaterial = e.baseMaterial) : this._baseMaterial = e
    }
    hasOutline() {
        return !!(this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY)
    }
    get glyphGeometryDetail() {
        return this.geometry.detail
    }
    set glyphGeometryDetail(e) {
        this.geometry.detail = e
    }
    get curveRadius() {
        return this.geometry.curveRadius
    }
    set curveRadius(e) {
        this.geometry.curveRadius = e
    }
    get customDepthMaterial() {
        return oN(this.material).getDepthMaterial()
    }
    set customDepthMaterial(e) {}
    get customDistanceMaterial() {
        return oN(this.material).getDistanceMaterial()
    }
    set customDistanceMaterial(e) {}
    _prepareForRender(e) {
        const t = e.isTextOutlineMaterial
          , n = e.uniforms
          , i = this.textRenderInfo;
        if (i) {
            const {sdfTexture: l, blockBounds: u} = i;
            n.uTroikaSDFTexture.value = l,
            n.uTroikaSDFTextureSize.value.set(l.image.width, l.image.height),
            n.uTroikaSDFGlyphSize.value = i.sdfGlyphSize,
            n.uTroikaSDFExponent.value = i.sdfExponent,
            n.uTroikaTotalBounds.value.fromArray(u),
            n.uTroikaUseGlyphColors.value = !t && !!i.glyphColors;
            let f = 0, d = 0, g = 0, v, y, S, T = 0, M = 0;
            if (t) {
                let {outlineWidth: A, outlineOffsetX: C, outlineOffsetY: R, outlineBlur: O, outlineOpacity: L} = this;
                f = this._parsePercent(A) || 0,
                d = Math.max(0, this._parsePercent(O) || 0),
                v = L,
                T = this._parsePercent(C) || 0,
                M = this._parsePercent(R) || 0
            } else
                g = Math.max(0, this._parsePercent(this.strokeWidth) || 0),
                g && (S = this.strokeColor,
                n.uTroikaStrokeColor.value.set(S ?? aN),
                y = this.strokeOpacity,
                y == null && (y = 1)),
                v = this.fillOpacity;
            n.uTroikaEdgeOffset.value = f,
            n.uTroikaPositionOffset.value.set(T, M),
            n.uTroikaBlurRadius.value = d,
            n.uTroikaStrokeWidth.value = g,
            n.uTroikaStrokeOpacity.value = y,
            n.uTroikaFillOpacity.value = v ?? 1,
            n.uTroikaCurveRadius.value = this.curveRadius || 0;
            let b = this.clipRect;
            if (b && Array.isArray(b) && b.length === 4)
                n.uTroikaClipRect.value.fromArray(b);
            else {
                const A = (this.fontSize || .1) * 100;
                n.uTroikaClipRect.value.set(u[0] - A, u[1] - A, u[2] + A, u[3] + A)
            }
            this.geometry.applyClipRect(n.uTroikaClipRect.value)
        }
        n.uTroikaSDFDebug.value = !!this.debugSDF,
        e.polygonOffset = !!this.depthOffset,
        e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
        const a = t ? this.outlineColor || 0 : this.color;
        if (a == null)
            delete e.color;
        else {
            const l = e.hasOwnProperty("color") ? e.color : e.color = new kt;
            (a !== l._input || typeof a == "object") && l.set(l._input = a)
        }
        let s = this.orientation || cE;
        if (s !== e._orientation) {
            let l = n.uTroikaOrient.value;
            s = s.replace(/[^-+xyz]/g, "");
            let u = s !== cE && s.match(/^([-+])([xyz])([-+])([xyz])$/);
            if (u) {
                let[,f,d,g,v] = u;
                Yx.set(0, 0, 0)[d] = f === "-" ? 1 : -1,
                uE.set(0, 0, 0)[v] = g === "-" ? -1 : 1,
                sN.lookAt(eee, Yx.cross(uE), uE),
                l.setFromMatrix4(sN)
            } else
                l.identity();
            e._orientation = s
        }
    }
    _parsePercent(e) {
        if (typeof e == "string") {
            let t = e.match(/^(-?[\d.]+)%$/)
              , n = t ? parseFloat(t[1]) : NaN;
            e = (isNaN(n) ? 0 : n / 100) * this.fontSize
        }
        return e
    }
    localPositionToTextCoords(e, t=new xt) {
        t.copy(e);
        const n = this.curveRadius;
        return n && (t.x = Math.atan2(e.x, Math.abs(n) - Math.abs(e.z)) * Math.abs(n)),
        t
    }
    worldPositionToTextCoords(e, t=new xt) {
        return Yx.copy(e),
        this.localPositionToTextCoords(this.worldToLocal(Yx), t)
    }
    raycast(e, t) {
        const {textRenderInfo: n, curveRadius: i} = this;
        if (n) {
            const a = n.blockBounds
              , s = i ? fI() : cI()
              , l = s.geometry
              , {position: u, uv: f} = l.attributes;
            for (let d = 0; d < f.count; d++) {
                let g = a[0] + f.getX(d) * (a[2] - a[0]);
                const v = a[1] + f.getY(d) * (a[3] - a[1]);
                let y = 0;
                i && (y = i - Math.cos(g / i) * i,
                g = Math.sin(g / i) * i),
                u.setXYZ(d, g, v, y)
            }
            l.boundingSphere = this.geometry.boundingSphere,
            l.boundingBox = this.geometry.boundingBox,
            s.matrixWorld = this.matrixWorld,
            s.material.side = this.material.side,
            Ev.length = 0,
            s.raycast(e, Ev);
            for (let d = 0; d < Ev.length; d++)
                Ev[d].object = this,
                t.push(Ev[d])
        }
    }
    copy(e) {
        const t = this.geometry;
        return super.copy(e),
        this.geometry = t,
        iee.forEach(n => {
            this[n] = e[n]
        }
        ),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
;
hI.forEach(r => {
    const e = "_private_" + r;
    Object.defineProperty(dI.prototype, r, {
        get() {
            return this[e]
        },
        set(t) {
            t !== this[e] && (this[e] = t,
            this._needsSync = !0)
        }
    })
}
);
new ea;
new kt;
const ree = de.forwardRef( ({sdfGlyphSize: r=64, anchorX: e="center", anchorY: t="middle", font: n, fontSize: i=1, children: a, characters: s, onSync: l, ...u}, f) => {
    const d = Ng( ({invalidate: S}) => S)
      , [g] = de.useState( () => new dI)
      , [v,y] = de.useMemo( () => {
        const S = [];
        let T = "";
        return de.Children.forEach(a, M => {
            typeof M == "string" || typeof M == "number" ? T += M : S.push(M)
        }
        ),
        [S, T]
    }
    , [a]);
    return Dz( () => new Promise(S => V$({
        font: n,
        characters: s
    }, S)), ["troika-text", n, s]),
    de.useLayoutEffect( () => void g.sync( () => {
        d(),
        l && l(g)
    }
    )),
    de.useEffect( () => () => g.dispose(), [g]),
    de.createElement("primitive", Ib({
        object: g,
        ref: f,
        font: n,
        text: y,
        anchorX: e,
        anchorY: t,
        fontSize: i,
        sdfGlyphSize: r
    }, u), v)
}
)
  , pI = de.forwardRef( ({children: r, enabled: e=!0, speed: t=1, rotationIntensity: n=1, floatIntensity: i=1, floatingRange: a=[-.1, .1], autoInvalidate: s=!1, ...l}, u) => {
    const f = de.useRef(null);
    de.useImperativeHandle(u, () => f.current, []);
    const d = de.useRef(Math.random() * 1e4);
    return T_(g => {
        var v, y;
        if (!e || t === 0)
            return;
        s && g.invalidate();
        const S = d.current + g.clock.elapsedTime;
        f.current.rotation.x = Math.cos(S / 4 * t) / 8 * n,
        f.current.rotation.y = Math.sin(S / 4 * t) / 8 * n,
        f.current.rotation.z = Math.sin(S / 4 * t) / 20 * n;
        let T = Math.sin(S / 4 * t) / 10;
        T = yB.mapLinear(T, -.1, .1, (v = a == null ? void 0 : a[0]) !== null && v !== void 0 ? v : -.1, (y = a == null ? void 0 : a[1]) !== null && y !== void 0 ? y : .1),
        f.current.position.y = T * i,
        f.current.updateMatrix()
    }
    ),
    de.createElement("group", l, de.createElement("group", {
        ref: f,
        matrixAutoUpdate: !1
    }, r))
}
)
  , mI = (r, e, t) => {
    let n;
    switch (r) {
    case ys:
        n = new Uint8ClampedArray(e * t * 4);
        break;
    case $r:
        n = new Uint16Array(e * t * 4);
        break;
    case rc:
        n = new Uint32Array(e * t * 4);
        break;
    case aM:
        n = new Int8Array(e * t * 4);
        break;
    case sM:
        n = new Int16Array(e * t * 4);
        break;
    case f_:
        n = new Int32Array(e * t * 4);
        break;
    case tr:
        n = new Float32Array(e * t * 4);
        break;
    default:
        throw new Error("Unsupported data type")
    }
    return n
}
;
let qx;
const aee = (r, e, t, n) => {
    if (qx !== void 0)
        return qx;
    const i = new sl(1,1,n);
    e.setRenderTarget(i);
    const a = new Ni(new eu,new oc({
        color: 16777215
    }));
    e.render(a, t),
    e.setRenderTarget(null);
    const s = mI(r, i.width, i.height);
    return e.readRenderTargetPixels(i, 0, 0, i.width, i.height, s),
    i.dispose(),
    a.geometry.dispose(),
    a.material.dispose(),
    qx = s[0] !== 0,
    qx
}
;
class WC {
    constructor(e) {
        var t, n, i, a, s, l, u, f, d, g, v, y, S, T, M, b;
        this._rendererIsDisposable = !1,
        this._supportsReadPixels = !0,
        this.render = () => {
            this._renderer.setRenderTarget(this._renderTarget);
            try {
                this._renderer.render(this._scene, this._camera)
            } catch (C) {
                throw this._renderer.setRenderTarget(null),
                C
            }
            this._renderer.setRenderTarget(null)
        }
        ,
        this._width = e.width,
        this._height = e.height,
        this._type = e.type,
        this._colorSpace = e.colorSpace;
        const A = {
            format: vr,
            depthBuffer: !1,
            stencilBuffer: !1,
            type: this._type,
            colorSpace: this._colorSpace,
            anisotropy: ((t = e.renderTargetOptions) === null || t === void 0 ? void 0 : t.anisotropy) !== void 0 ? (n = e.renderTargetOptions) === null || n === void 0 ? void 0 : n.anisotropy : 1,
            generateMipmaps: ((i = e.renderTargetOptions) === null || i === void 0 ? void 0 : i.generateMipmaps) !== void 0 ? (a = e.renderTargetOptions) === null || a === void 0 ? void 0 : a.generateMipmaps : !1,
            magFilter: ((s = e.renderTargetOptions) === null || s === void 0 ? void 0 : s.magFilter) !== void 0 ? (l = e.renderTargetOptions) === null || l === void 0 ? void 0 : l.magFilter : fi,
            minFilter: ((u = e.renderTargetOptions) === null || u === void 0 ? void 0 : u.minFilter) !== void 0 ? (f = e.renderTargetOptions) === null || f === void 0 ? void 0 : f.minFilter : fi,
            samples: ((d = e.renderTargetOptions) === null || d === void 0 ? void 0 : d.samples) !== void 0 ? (g = e.renderTargetOptions) === null || g === void 0 ? void 0 : g.samples : void 0,
            wrapS: ((v = e.renderTargetOptions) === null || v === void 0 ? void 0 : v.wrapS) !== void 0 ? (y = e.renderTargetOptions) === null || y === void 0 ? void 0 : y.wrapS : Cr,
            wrapT: ((S = e.renderTargetOptions) === null || S === void 0 ? void 0 : S.wrapT) !== void 0 ? (T = e.renderTargetOptions) === null || T === void 0 ? void 0 : T.wrapT : Cr
        };
        if (this._material = e.material,
        e.renderer ? this._renderer = e.renderer : (this._renderer = WC.instantiateRenderer(),
        this._rendererIsDisposable = !0),
        this._scene = new m_,
        this._camera = new Yg,
        this._camera.position.set(0, 0, 10),
        this._camera.left = -.5,
        this._camera.right = .5,
        this._camera.top = .5,
        this._camera.bottom = -.5,
        this._camera.updateProjectionMatrix(),
        !aee(this._type, this._renderer, this._camera, A)) {
            let C;
            switch (this._type) {
            case $r:
                C = this._renderer.extensions.has("EXT_color_buffer_float") ? tr : void 0;
                break
            }
            C !== void 0 ? (console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${tr}`),
            this._type = C) : (this._supportsReadPixels = !1,
            console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"))
        }
        this._quad = new Ni(new eu,this._material),
        this._quad.geometry.computeBoundingBox(),
        this._scene.add(this._quad),
        this._renderTarget = new sl(this.width,this.height,A),
        this._renderTarget.texture.mapping = ((M = e.renderTargetOptions) === null || M === void 0 ? void 0 : M.mapping) !== void 0 ? (b = e.renderTargetOptions) === null || b === void 0 ? void 0 : b.mapping : yh
    }
    static instantiateRenderer() {
        const e = new zC;
        return e.setSize(128, 128),
        e
    }
    toArray() {
        if (!this._supportsReadPixels)
            throw new Error("Can't read pixels in this browser");
        const e = mI(this._type, this._width, this._height);
        return this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, e),
        e
    }
    toDataTexture(e) {
        const t = new Kl(this.toArray(),this.width,this.height,vr,this._type,(e == null ? void 0 : e.mapping) || yh,(e == null ? void 0 : e.wrapS) || Cr,(e == null ? void 0 : e.wrapT) || Cr,(e == null ? void 0 : e.magFilter) || fi,(e == null ? void 0 : e.minFilter) || fi,(e == null ? void 0 : e.anisotropy) || 1,Jl);
        return t.generateMipmaps = (e == null ? void 0 : e.generateMipmaps) !== void 0 ? e == null ? void 0 : e.generateMipmaps : !1,
        t
    }
    disposeOnDemandRenderer() {
        this._renderer.setRenderTarget(null),
        this._rendererIsDisposable && (this._renderer.dispose(),
        this._renderer.forceContextLoss())
    }
    dispose(e) {
        this.disposeOnDemandRenderer(),
        e && this.renderTarget.dispose(),
        this.material instanceof Ks && Object.values(this.material.uniforms).forEach(t => {
            t.value instanceof _i && t.value.dispose()
        }
        ),
        Object.values(this.material).forEach(t => {
            t instanceof _i && t.dispose()
        }
        ),
        this.material.dispose(),
        this._quad.geometry.dispose()
    }
    get width() {
        return this._width
    }
    set width(e) {
        this._width = e,
        this._renderTarget.setSize(this._width, this._height)
    }
    get height() {
        return this._height
    }
    set height(e) {
        this._height = e,
        this._renderTarget.setSize(this._width, this._height)
    }
    get renderer() {
        return this._renderer
    }
    get renderTarget() {
        return this._renderTarget
    }
    set renderTarget(e) {
        this._renderTarget = e,
        this._width = e.width,
        this._height = e.height
    }
    get material() {
        return this._material
    }
    get type() {
        return this._type
    }
    get colorSpace() {
        return this._colorSpace
    }
}
const see = `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`
  , oee = `
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;
class lee extends Ks {
    constructor({gamma: e, offsetHdr: t, offsetSdr: n, gainMapMin: i, gainMapMax: a, maxDisplayBoost: s, hdrCapacityMin: l, hdrCapacityMax: u, sdr: f, gainMap: d}) {
        super({
            name: "GainMapDecoderMaterial",
            vertexShader: see,
            fragmentShader: oee,
            uniforms: {
                sdr: {
                    value: f
                },
                gainMap: {
                    value: d
                },
                gamma: {
                    value: new he(1 / e[0],1 / e[1],1 / e[2])
                },
                offsetHdr: {
                    value: new he().fromArray(t)
                },
                offsetSdr: {
                    value: new he().fromArray(n)
                },
                gainMapMin: {
                    value: new he().fromArray(i)
                },
                gainMapMax: {
                    value: new he().fromArray(a)
                },
                weightFactor: {
                    value: (Math.log2(s) - l) / (u - l)
                }
            },
            blending: Qu,
            depthTest: !1,
            depthWrite: !1
        }),
        this._maxDisplayBoost = s,
        this._hdrCapacityMin = l,
        this._hdrCapacityMax = u,
        this.needsUpdate = !0,
        this.uniformsNeedUpdate = !0
    }
    get sdr() {
        return this.uniforms.sdr.value
    }
    set sdr(e) {
        this.uniforms.sdr.value = e
    }
    get gainMap() {
        return this.uniforms.gainMap.value
    }
    set gainMap(e) {
        this.uniforms.gainMap.value = e
    }
    get offsetHdr() {
        return this.uniforms.offsetHdr.value.toArray()
    }
    set offsetHdr(e) {
        this.uniforms.offsetHdr.value.fromArray(e)
    }
    get offsetSdr() {
        return this.uniforms.offsetSdr.value.toArray()
    }
    set offsetSdr(e) {
        this.uniforms.offsetSdr.value.fromArray(e)
    }
    get gainMapMin() {
        return this.uniforms.gainMapMin.value.toArray()
    }
    set gainMapMin(e) {
        this.uniforms.gainMapMin.value.fromArray(e)
    }
    get gainMapMax() {
        return this.uniforms.gainMapMax.value.toArray()
    }
    set gainMapMax(e) {
        this.uniforms.gainMapMax.value.fromArray(e)
    }
    get gamma() {
        const e = this.uniforms.gamma.value;
        return [1 / e.x, 1 / e.y, 1 / e.z]
    }
    set gamma(e) {
        const t = this.uniforms.gamma.value;
        t.x = 1 / e[0],
        t.y = 1 / e[1],
        t.z = 1 / e[2]
    }
    get hdrCapacityMin() {
        return this._hdrCapacityMin
    }
    set hdrCapacityMin(e) {
        this._hdrCapacityMin = e,
        this.calculateWeight()
    }
    get hdrCapacityMax() {
        return this._hdrCapacityMax
    }
    set hdrCapacityMax(e) {
        this._hdrCapacityMax = e,
        this.calculateWeight()
    }
    get maxDisplayBoost() {
        return this._maxDisplayBoost
    }
    set maxDisplayBoost(e) {
        this._maxDisplayBoost = Math.max(1, Math.min(65504, e)),
        this.calculateWeight()
    }
    calculateWeight() {
        const e = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);
        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, e))
    }
}
class gI extends Error {
}
class vI extends Error {
}
const wv = (r, e, t) => {
    const n = new RegExp(`${e}="([^"]*)"`,"i").exec(r);
    if (n)
        return n[1];
    const i = new RegExp(`<${e}[^>]*>([\\s\\S]*?)</${e}>`,"i").exec(r);
    if (i) {
        const a = i[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);
        return a && a.length === 3 ? a.map(s => s.replace(/<\/?rdf:li>/g, "")) : i[1].trim()
    }
    if (t !== void 0)
        return t;
    throw new Error(`Can't find ${e} in gainmap metadata`)
}
  , uee = r => {
    let e;
    typeof TextDecoder < "u" ? e = new TextDecoder().decode(r) : e = r.toString();
    let t = e.indexOf("<x:xmpmeta");
    for (; t !== -1; ) {
        const n = e.indexOf("x:xmpmeta>", t)
          , i = e.slice(t, n + 10);
        try {
            const a = wv(i, "hdrgm:GainMapMin", "0")
              , s = wv(i, "hdrgm:GainMapMax")
              , l = wv(i, "hdrgm:Gamma", "1")
              , u = wv(i, "hdrgm:OffsetSDR", "0.015625")
              , f = wv(i, "hdrgm:OffsetHDR", "0.015625")
              , d = /hdrgm:HDRCapacityMin="([^"]*)"/.exec(i)
              , g = d ? d[1] : "0"
              , v = /hdrgm:HDRCapacityMax="([^"]*)"/.exec(i);
            if (!v)
                throw new Error("Incomplete gainmap metadata");
            const y = v[1];
            return {
                gainMapMin: Array.isArray(a) ? a.map(S => parseFloat(S)) : [parseFloat(a), parseFloat(a), parseFloat(a)],
                gainMapMax: Array.isArray(s) ? s.map(S => parseFloat(S)) : [parseFloat(s), parseFloat(s), parseFloat(s)],
                gamma: Array.isArray(l) ? l.map(S => parseFloat(S)) : [parseFloat(l), parseFloat(l), parseFloat(l)],
                offsetSdr: Array.isArray(u) ? u.map(S => parseFloat(S)) : [parseFloat(u), parseFloat(u), parseFloat(u)],
                offsetHdr: Array.isArray(f) ? f.map(S => parseFloat(S)) : [parseFloat(f), parseFloat(f), parseFloat(f)],
                hdrCapacityMin: parseFloat(g),
                hdrCapacityMax: parseFloat(y)
            }
        } catch {}
        t = e.indexOf("<x:xmpmeta", n)
    }
}
;
class cee {
    constructor(e) {
        this.options = {
            debug: e && e.debug !== void 0 ? e.debug : !1,
            extractFII: e && e.extractFII !== void 0 ? e.extractFII : !0,
            extractNonFII: e && e.extractNonFII !== void 0 ? e.extractNonFII : !0
        }
    }
    extract(e) {
        return new Promise( (t, n) => {
            const i = this.options.debug
              , a = new DataView(e.buffer);
            if (a.getUint16(0) !== 65496) {
                n(new Error("Not a valid jpeg"));
                return
            }
            const s = a.byteLength;
            let l = 2, u = 0, f;
            for (; l < s; ) {
                if (++u > 250) {
                    n(new Error(`Found no marker after ${u} loops `));
                    return
                }
                if (a.getUint8(l) !== 255) {
                    n(new Error(`Not a valid marker at offset 0x${l.toString(16)}, found: 0x${a.getUint8(l).toString(16)}`));
                    return
                }
                if (f = a.getUint8(l + 1),
                i && console.log(`Marker: ${f.toString(16)}`),
                f === 226) {
                    i && console.log("Found APP2 marker (0xffe2)");
                    const d = l + 4;
                    if (a.getUint32(d) === 1297106432) {
                        const g = d + 4;
                        let v;
                        if (a.getUint16(g) === 18761)
                            v = !1;
                        else if (a.getUint16(g) === 19789)
                            v = !0;
                        else {
                            n(new Error("No valid endianness marker found in TIFF header"));
                            return
                        }
                        if (a.getUint16(g + 2, !v) !== 42) {
                            n(new Error("Not valid TIFF data! (no 0x002A marker)"));
                            return
                        }
                        const y = a.getUint32(g + 4, !v);
                        if (y < 8) {
                            n(new Error("Not valid TIFF data! (First offset less than 8)"));
                            return
                        }
                        const S = g + y
                          , T = a.getUint16(S, !v)
                          , M = S + 2;
                        let b = 0;
                        for (let O = M; O < M + 12 * T; O += 12)
                            a.getUint16(O, !v) === 45057 && (b = a.getUint32(O + 8, !v));
                        const C = S + 2 + T * 12 + 4
                          , R = [];
                        for (let O = C; O < C + b * 16; O += 16) {
                            const L = {
                                MPType: a.getUint32(O, !v),
                                size: a.getUint32(O + 4, !v),
                                dataOffset: a.getUint32(O + 8, !v),
                                dependantImages: a.getUint32(O + 12, !v),
                                start: -1,
                                end: -1,
                                isFII: !1
                            };
                            L.dataOffset ? (L.start = g + L.dataOffset,
                            L.isFII = !1) : (L.start = 0,
                            L.isFII = !0),
                            L.end = L.start + L.size,
                            R.push(L)
                        }
                        if (this.options.extractNonFII && R.length) {
                            const O = new Blob([a])
                              , L = [];
                            for (const z of R) {
                                if (z.isFII && !this.options.extractFII)
                                    continue;
                                const I = O.slice(z.start, z.end + 1, "image/jpeg");
                                L.push(I)
                            }
                            t(L)
                        }
                    }
                }
                l += 2 + a.getUint16(l + 2)
            }
        }
        )
    }
}
const fee = async r => {
    const e = uee(r);
    if (!e)
        throw new vI("Gain map XMP metadata not found");
    const n = await new cee({
        extractFII: !0,
        extractNonFII: !0
    }).extract(r);
    if (n.length !== 2)
        throw new gI("Gain map recovery image not found");
    return {
        sdr: new Uint8Array(await n[0].arrayBuffer()),
        gainMap: new Uint8Array(await n[1].arrayBuffer()),
        metadata: e
    }
}
  , lN = r => new Promise( (e, t) => {
    const n = document.createElement("img");
    n.onload = () => {
        e(n)
    }
    ,
    n.onerror = i => {
        t(i)
    }
    ,
    n.src = URL.createObjectURL(r)
}
);
class yI extends xs {
    constructor(e, t) {
        super(t),
        e && (this._renderer = e),
        this._internalLoadingManager = new PM
    }
    setRenderer(e) {
        return this._renderer = e,
        this
    }
    setRenderTargetOptions(e) {
        return this._renderTargetOptions = e,
        this
    }
    prepareQuadRenderer() {
        this._renderer || console.warn("WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.");
        const e = new lee({
            gainMapMax: [1, 1, 1],
            gainMapMin: [0, 0, 0],
            gamma: [1, 1, 1],
            offsetHdr: [1, 1, 1],
            offsetSdr: [1, 1, 1],
            hdrCapacityMax: 1,
            hdrCapacityMin: 0,
            maxDisplayBoost: 1,
            gainMap: new _i,
            sdr: new _i
        });
        return new WC({
            width: 16,
            height: 16,
            type: $r,
            colorSpace: Jl,
            material: e,
            renderer: this._renderer,
            renderTargetOptions: this._renderTargetOptions
        })
    }
    async render(e, t, n, i) {
        const a = i ? new Blob([i],{
            type: "image/jpeg"
        }) : void 0
          , s = new Blob([n],{
            type: "image/jpeg"
        });
        let l, u, f = !1;
        if (typeof createImageBitmap > "u") {
            const v = await Promise.all([a ? lN(a) : Promise.resolve(void 0), lN(s)]);
            u = v[0],
            l = v[1],
            f = !0
        } else {
            const v = await Promise.all([a ? createImageBitmap(a, {
                imageOrientation: "flipY"
            }) : Promise.resolve(void 0), createImageBitmap(s, {
                imageOrientation: "flipY"
            })]);
            u = v[0],
            l = v[1]
        }
        const d = new _i(u || new ImageData(2,2),yh,Cr,Cr,fi,uw,vr,ys,1,Jl);
        d.flipY = f,
        d.needsUpdate = !0;
        const g = new _i(l,yh,Cr,Cr,fi,uw,vr,ys,1,pa);
        g.flipY = f,
        g.needsUpdate = !0,
        e.width = l.width,
        e.height = l.height,
        e.material.gainMap = d,
        e.material.sdr = g,
        e.material.gainMapMin = t.gainMapMin,
        e.material.gainMapMax = t.gainMapMax,
        e.material.offsetHdr = t.offsetHdr,
        e.material.offsetSdr = t.offsetSdr,
        e.material.gamma = t.gamma,
        e.material.hdrCapacityMin = t.hdrCapacityMin,
        e.material.hdrCapacityMax = t.hdrCapacityMax,
        e.material.maxDisplayBoost = Math.pow(2, t.hdrCapacityMax),
        e.material.needsUpdate = !0,
        e.render()
    }
}
class hee extends yI {
    load([e,t,n], i, a, s) {
        const l = this.prepareQuadRenderer();
        let u, f, d;
        const g = async () => {
            if (u && f && d) {
                try {
                    await this.render(l, d, u, f)
                } catch (N) {
                    this.manager.itemError(e),
                    this.manager.itemError(t),
                    this.manager.itemError(n),
                    typeof s == "function" && s(N),
                    l.disposeOnDemandRenderer();
                    return
                }
                typeof i == "function" && i(l),
                this.manager.itemEnd(e),
                this.manager.itemEnd(t),
                this.manager.itemEnd(n),
                l.disposeOnDemandRenderer()
            }
        }
        ;
        let v = !0
          , y = 0
          , S = 0
          , T = !0
          , M = 0
          , b = 0
          , A = !0
          , C = 0
          , R = 0;
        const O = () => {
            if (typeof a == "function") {
                const N = y + M + C
                  , P = S + b + R
                  , Y = v && T && A;
                a(new ProgressEvent("progress",{
                    lengthComputable: Y,
                    loaded: P,
                    total: N
                }))
            }
        }
        ;
        this.manager.itemStart(e),
        this.manager.itemStart(t),
        this.manager.itemStart(n);
        const L = new Eo(this._internalLoadingManager);
        L.setResponseType("arraybuffer"),
        L.setRequestHeader(this.requestHeader),
        L.setPath(this.path),
        L.setWithCredentials(this.withCredentials),
        L.load(e, async N => {
            if (typeof N == "string")
                throw new Error("Invalid sdr buffer");
            u = N,
            await g()
        }
        , N => {
            v = N.lengthComputable,
            S = N.loaded,
            y = N.total,
            O()
        }
        , N => {
            this.manager.itemError(e),
            typeof s == "function" && s(N)
        }
        );
        const z = new Eo(this._internalLoadingManager);
        z.setResponseType("arraybuffer"),
        z.setRequestHeader(this.requestHeader),
        z.setPath(this.path),
        z.setWithCredentials(this.withCredentials),
        z.load(t, async N => {
            if (typeof N == "string")
                throw new Error("Invalid gainmap buffer");
            f = N,
            await g()
        }
        , N => {
            T = N.lengthComputable,
            b = N.loaded,
            M = N.total,
            O()
        }
        , N => {
            this.manager.itemError(t),
            typeof s == "function" && s(N)
        }
        );
        const I = new Eo(this._internalLoadingManager);
        return I.setRequestHeader(this.requestHeader),
        I.setPath(this.path),
        I.setWithCredentials(this.withCredentials),
        I.load(n, async N => {
            if (typeof N != "string")
                throw new Error("Invalid metadata string");
            d = JSON.parse(N),
            await g()
        }
        , N => {
            A = N.lengthComputable,
            R = N.loaded,
            C = N.total,
            O()
        }
        , N => {
            this.manager.itemError(n),
            typeof s == "function" && s(N)
        }
        ),
        l
    }
}
class dee extends yI {
    load(e, t, n, i) {
        const a = this.prepareQuadRenderer()
          , s = new Eo(this._internalLoadingManager);
        return s.setResponseType("arraybuffer"),
        s.setRequestHeader(this.requestHeader),
        s.setPath(this.path),
        s.setWithCredentials(this.withCredentials),
        this.manager.itemStart(e),
        s.load(e, async l => {
            if (typeof l == "string")
                throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");
            const u = new Uint8Array(l);
            let f, d, g;
            try {
                const v = await fee(u);
                f = v.sdr,
                d = v.gainMap,
                g = v.metadata
            } catch (v) {
                if (v instanceof vI || v instanceof gI)
                    console.warn(`Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`),
                    g = {
                        gainMapMin: [0, 0, 0],
                        gainMapMax: [1, 1, 1],
                        gamma: [1, 1, 1],
                        hdrCapacityMin: 0,
                        hdrCapacityMax: 1,
                        offsetHdr: [0, 0, 0],
                        offsetSdr: [0, 0, 0]
                    },
                    f = u;
                else
                    throw v
            }
            try {
                await this.render(a, g, f, d)
            } catch (v) {
                this.manager.itemError(e),
                typeof i == "function" && i(v),
                a.disposeOnDemandRenderer();
                return
            }
            typeof t == "function" && t(a),
            this.manager.itemEnd(e),
            a.disposeOnDemandRenderer()
        }
        , n, l => {
            this.manager.itemError(e),
            typeof i == "function" && i(l)
        }
        ),
        a
    }
}
const Jy = {
    apartment: "lebombo_1k.hdr",
    city: "potsdamer_platz_1k.hdr",
    dawn: "kiara_1_dawn_1k.hdr",
    forest: "forest_slope_1k.hdr",
    lobby: "st_fagans_interior_1k.hdr",
    night: "dikhololo_night_1k.hdr",
    park: "rooitou_park_1k.hdr",
    studio: "studio_small_03_1k.hdr",
    sunset: "venice_sunset_1k.hdr",
    warehouse: "empty_warehouse_01_1k.hdr"
}
  , _I = "https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/"
  , cg = r => Array.isArray(r)
  , YC = ["/px.png", "/nx.png", "/py.png", "/ny.png", "/pz.png", "/nz.png"];
function HM({files: r=YC, path: e="", preset: t=void 0, colorSpace: n=void 0, extensions: i}={}) {
    t && (qC(t),
    r = Jy[t],
    e = _I);
    const a = cg(r)
      , {extension: s, isCubemap: l} = ZC(r)
      , u = KC(s);
    if (!u)
        throw new Error("useEnvironment: Unrecognized file extension: " + r);
    const f = Ng(y => y.gl);
    de.useLayoutEffect( () => {
        if (s !== "webp" && s !== "jpg" && s !== "jpeg")
            return;
        function y() {
            Lg.clear(u, a ? [r] : r)
        }
        f.domElement.addEventListener("webglcontextlost", y, {
            once: !0
        })
    }
    , [r, f.domElement]);
    const d = Lg(u, a ? [r] : r, y => {
        (s === "webp" || s === "jpg" || s === "jpeg") && y.setRenderer(f),
        y.setPath == null || y.setPath(e),
        i && i(y)
    }
    );
    let g = a ? d[0] : d;
    if (s === "jpg" || s === "jpeg" || s === "webp") {
        var v;
        g = (v = g.renderTarget) == null ? void 0 : v.texture
    }
    return g.mapping = l ? ic : Mg,
    g.colorSpace = n ?? (l ? "srgb" : "srgb-linear"),
    g
}
const pee = {
    files: YC,
    path: "",
    preset: void 0,
    extensions: void 0
};
HM.preload = r => {
    const e = {
        ...pee,
        ...r
    };
    let {files: t, path: n=""} = e;
    const {preset: i, extensions: a} = e;
    i && (qC(i),
    t = Jy[i],
    n = _I);
    const {extension: s} = ZC(t);
    if (s === "webp" || s === "jpg" || s === "jpeg")
        throw new Error("useEnvironment: Preloading gainmaps is not supported");
    const l = KC(s);
    if (!l)
        throw new Error("useEnvironment: Unrecognized file extension: " + t);
    Lg.preload(l, cg(t) ? [t] : t, u => {
        u.setPath == null || u.setPath(n),
        a && a(u)
    }
    )
}
;
const mee = {
    files: YC,
    preset: void 0
};
HM.clear = r => {
    const e = {
        ...mee,
        ...r
    };
    let {files: t} = e;
    const {preset: n} = e;
    n && (qC(n),
    t = Jy[n]);
    const {extension: i} = ZC(t)
      , a = KC(i);
    if (!a)
        throw new Error("useEnvironment: Unrecognized file extension: " + t);
    Lg.clear(a, cg(t) ? [t] : t)
}
;
function qC(r) {
    if (!(r in Jy))
        throw new Error("Preset must be one of: " + Object.keys(Jy).join(", "))
}
function ZC(r) {
    var e;
    const t = cg(r) && r.length === 6
      , n = cg(r) && r.length === 3 && r.some(s => s.endsWith("json"))
      , i = cg(r) ? r[0] : r;
    return {
        extension: t ? "cube" : n ? "webp" : i.startsWith("data:application/exr") ? "exr" : i.startsWith("data:application/hdr") ? "hdr" : i.startsWith("data:image/jpeg") ? "jpg" : (e = i.split(".").pop()) == null || (e = e.split("?")) == null || (e = e.shift()) == null ? void 0 : e.toLowerCase(),
        isCubemap: t,
        isGainmap: n
    }
}
function KC(r) {
    return r === "cube" ? sz : r === "hdr" ? o$ : r === "exr" ? l$ : r === "jpg" || r === "jpeg" ? dee : r === "webp" ? hee : null
}
const gee = r => r.current && r.current.isScene
  , vee = r => gee(r) ? r.current : r;
function QC(r, e, t, n, i={}) {
    var a, s, l, u;
    i = {
        backgroundBlurriness: 0,
        backgroundIntensity: 1,
        backgroundRotation: [0, 0, 0],
        environmentIntensity: 1,
        environmentRotation: [0, 0, 0],
        ...i
    };
    const f = vee(e || t)
      , d = f.background
      , g = f.environment
      , v = {
        backgroundBlurriness: f.backgroundBlurriness,
        backgroundIntensity: f.backgroundIntensity,
        backgroundRotation: (a = (s = f.backgroundRotation) == null || s.clone == null ? void 0 : s.clone()) !== null && a !== void 0 ? a : [0, 0, 0],
        environmentIntensity: f.environmentIntensity,
        environmentRotation: (l = (u = f.environmentRotation) == null || u.clone == null ? void 0 : u.clone()) !== null && l !== void 0 ? l : [0, 0, 0]
    };
    return r !== "only" && (f.environment = n),
    r && (f.background = n),
    Vu(f, i),
    () => {
        r !== "only" && (f.environment = g),
        r && (f.background = d),
        Vu(f, v)
    }
}
function JC({scene: r, background: e=!1, map: t, ...n}) {
    const i = Ng(a => a.scene);
    return de.useLayoutEffect( () => {
        if (t)
            return QC(e, r, i, t, n)
    }
    ),
    null
}
function xI({background: r=!1, scene: e, blur: t, backgroundBlurriness: n, backgroundIntensity: i, backgroundRotation: a, environmentIntensity: s, environmentRotation: l, ...u}) {
    const f = HM(u)
      , d = Ng(g => g.scene);
    return de.useLayoutEffect( () => QC(r, e, d, f, {
        backgroundBlurriness: t ?? n,
        backgroundIntensity: i,
        backgroundRotation: a,
        environmentIntensity: s,
        environmentRotation: l
    })),
    de.useEffect( () => () => {
        f.dispose()
    }
    , [f]),
    null
}
function yee({children: r, near: e=.1, far: t=1e3, resolution: n=256, frames: i=1, map: a, background: s=!1, blur: l, backgroundBlurriness: u, backgroundIntensity: f, backgroundRotation: d, environmentIntensity: g, environmentRotation: v, scene: y, files: S, path: T, preset: M=void 0, extensions: b}) {
    const A = Ng(I => I.gl)
      , C = Ng(I => I.scene)
      , R = de.useRef(null)
      , [O] = de.useState( () => new m_)
      , L = de.useMemo( () => {
        const I = new cC(n);
        return I.texture.type = $r,
        I
    }
    , [n]);
    de.useEffect( () => () => {
        L.dispose()
    }
    , [L]),
    de.useLayoutEffect( () => {
        if (i === 1) {
            const I = A.autoClear;
            A.autoClear = !0,
            R.current.update(A, O),
            A.autoClear = I
        }
        return QC(s, y, C, L.texture, {
            backgroundBlurriness: l ?? u,
            backgroundIntensity: f,
            backgroundRotation: d,
            environmentIntensity: g,
            environmentRotation: v
        })
    }
    , [r, O, L.texture, y, C, s, i, A]);
    let z = 1;
    return T_( () => {
        if (i === 1 / 0 || z < i) {
            const I = A.autoClear;
            A.autoClear = !0,
            R.current.update(A, O),
            A.autoClear = I,
            z++
        }
    }
    ),
    de.createElement(de.Fragment, null, LJ(de.createElement(de.Fragment, null, r, de.createElement("cubeCamera", {
        ref: R,
        args: [e, t, L]
    }), S || M ? de.createElement(xI, {
        background: !0,
        files: S,
        preset: M,
        path: T,
        extensions: b
    }) : a ? de.createElement(JC, {
        background: !0,
        map: a,
        extensions: b
    }) : null), O))
}
function _ee(r) {
    var e, t, n, i;
    const a = HM(r)
      , s = r.map || a;
    de.useMemo( () => kz({
        GroundProjectedEnvImpl: s$
    }), []),
    de.useEffect( () => () => {
        a.dispose()
    }
    , [a]);
    const l = de.useMemo( () => [s], [s])
      , u = (e = r.ground) == null ? void 0 : e.height
      , f = (t = r.ground) == null ? void 0 : t.radius
      , d = (n = (i = r.ground) == null ? void 0 : i.scale) !== null && n !== void 0 ? n : 1e3;
    return de.createElement(de.Fragment, null, de.createElement(JC, Ib({}, r, {
        map: s
    })), de.createElement("groundProjectedEnvImpl", {
        args: l,
        scale: d,
        height: u,
        radius: f
    }))
}
function SI(r) {
    return r.ground ? de.createElement(_ee, r) : r.map ? de.createElement(JC, r) : r.children ? de.createElement(yee, r) : de.createElement(xI, r)
}
const xee = "/assets/ZN_PAT_RGB_HP_BLST_LM_01-DvmhuRJP.png"
  , See = ({text: r, position: e}) => {
    const t = de.useRef();
    return T_(n => {
        t.current && (t.current.rotation.y = Math.sin(n.clock.elapsedTime * .3) * .1,
        t.current.position.y = Math.sin(n.clock.elapsedTime * .5) * .05)
    }
    ),
    ae.jsx(pI, {
        speed: 2,
        rotationIntensity: .5,
        floatIntensity: .5,
        children: ae.jsx(ree, {
            ref: t,
            position: e,
            fontSize: .8,
            color: "#ffffff",
            anchorX: "center",
            anchorY: "middle",
            children: r
        })
    })
}
  , bee = ({count: r=200}) => {
    const e = de.useRef()
      , t = de.useRef(new Float32Array(r * 3));
    return de.useEffect( () => {
        for (let n = 0; n < r; n++)
            t.current[n * 3] = (Math.random() - .5) * 10,
            t.current[n * 3 + 1] = (Math.random() - .5) * 10,
            t.current[n * 3 + 2] = (Math.random() - .5) * 10;
        e.current.geometry.setAttribute("position", new xi(t.current,3))
    }
    , [r]),
    T_(n => {
        e.current && (e.current.rotation.y = n.clock.elapsedTime * .05)
    }
    ),
    ae.jsxs("points", {
        ref: e,
        children: [ae.jsx("bufferGeometry", {}), ae.jsx("pointsMaterial", {
            size: .005,
            color: "#ffffff",
            transparent: !0,
            opacity: .5
        })]
    })
}
  , Mee = () => {
    b4();
    const r = de.useRef()
      , e = de.useRef()
      , t = de.useRef();
    return de.useRef(),
    de.useEffect( () => {
        bg.timeline().fromTo(e.current, {
            opacity: 0,
            y: 100
        }, {
            opacity: 1,
            y: 0,
            duration: 1.5,
            ease: "power3.out"
        }).fromTo(t.current, {
            opacity: 0,
            scale: .8,
            rotationY: 10
        }, {
            opacity: 1,
            scale: 1,
            rotationY: 0,
            duration: 1.2,
            ease: "power2.out"
        }, "-=0.8"),
        bg.to(t.current, {
            yPercent: -20,
            ease: "none",
            scrollTrigger: {
                trigger: r.current,
                start: "top bottom",
                end: "bottom top",
                scrub: !0
            }
        })
    }
    , []),
    ae.jsxs("section", {
        ref: r,
        className: `min-h-screen bg-gradient-to-b
      from-[var(--hero-gradient-start)]
      to-[var(--hero-gradient-end)] 
      flex md:flex-row text-[var(--hero-text)]
      flex-col items-center justify-center
      pt-10 lg:px-20 px-10 md:pt-16 relative overflow-hidden
      md:gap-10
      md:content-start md:align-top`,
        children: [ae.jsx("div", {
            className: "absolute inset-0 z-0",
            children: ae.jsxs(XC, {
                camera: {
                    position: [0, 0, 5]
                },
                children: [ae.jsx("ambientLight", {
                    intensity: .5
                }), ae.jsx("pointLight", {
                    position: [10, 10, 10]
                }), ae.jsx(See, {}), ae.jsx(bee, {}), ae.jsx(SI, {
                    preset: "city"
                })]
            })
        }), ae.jsxs("div", {
            ref: e,
            className: "z-40 w-full pt-1 md:pt-2 md:w-1/2",
            children: [ae.jsx("h2", {
                className: `text-3xl md:text-5xl lg:text-6xl
             z-10  font-bold 
            `,
                children: "Welcome to"
            }), ae.jsx("h1", {
                className: `text-5xl md:text-7xl lg:text-8xl
            font-extrabold z-10 mb-6 text-[var(--yellow-rgb)]
            `,
                children: "The 10th Edition of Generation Z by Zain"
            }), ae.jsx(Jo.p, {
                className: `text-xl md:text-1xl lg:text-2xl
            text-white pb-1 mb-3`,
                initial: {
                    opacity: 0,
                    y: 80
                },
                animate: {
                    opacity: 1,
                    y: 0
                },
                transition: {
                    type: Zu,
                    stiffness: 40,
                    damping: 25,
                    delay: 1.8,
                    duration: 1.5
                },
                children: "Over the past several months, we, as Generation Z graduates at Zain Group, have gained invaluable hands-on experience across diverse areas including leadership, innovation, digital delivery, UI/UX design, and agile methodologies. These opportunities have not only enhanced our skills but also empowered us to make meaningful contributions to the companys growth and transformation."
            })]
        }), ae.jsxs("div", {
            className: `w-full h-full mx-1 md:w-1/2 justify-center items-center 
      flex flex-col 
         right-0 top-0 md:mb-0 mb-[10%] `,
            children: [ae.jsx("img", {
                src: xee,
                alt: "Zain Pattern",
                className: `position absolute top-0 w:1/2 md:h-2/5 md:right-0
         md:max-h-none max-h-96 w-auto right-0`
            }), ae.jsx(Jo.img, {
                src: m9,
                alt: "Gen Z Group Photo",
                className: "lg:mx-10 w-full sm:justify-center rounded-2xl ",
                initial: {
                    opacity: 0,
                    y: -80
                },
                animate: {
                    opacity: 1,
                    y: 0
                },
                transition: {
                    type: Zu,
                    stiffness: 40,
                    damping: 25,
                    delay: 1.3,
                    duration: 1.5
                }
            }), ae.jsx(Jo.div, {
                className: "flex flex-row justify-center items-center mt-6",
                initial: {
                    opacity: 0,
                    y: 80
                },
                animate: {
                    opacity: 1,
                    y: 0
                },
                transition: {
                    type: Zu,
                    stiffness: 40,
                    damping: 25,
                    delay: 2.5
                }
            }), ae.jsx("div", {
                className: "absolute inset-0 overflow-hidden",
                children: [...Array(20)].map( (n, i) => ae.jsx("div", {
                    className: "absolute w-2 h-2 bg-white rounded-full opacity-20",
                    style: {
                        top: `${Math.random() * 100}%`,
                        left: `${Math.random() * 100}%`,
                        animation: `float ${3 + Math.random() * 4}s infinite ease-in-out`,
                        animationDelay: `${Math.random() * 2}s`
                    }
                }, i))
            })]
        })]
    })
}
  , Tee = () => {
    const r = de.useRef(null)
      , {scrollYProgress: e} = Mk({
        target: r,
        offset: ["start end", "end end"]
    })
      , t = wk(e, [0, 1], ["3deg", "0deg"]);
    return ae.jsxs("section", {
        className: " align-middle justify-center items-center m-5",
        children: [ae.jsx("h1", {
            className: `text-2xl text-[var(--blue-rgb)] font-bold md:text-4xl lg:text-5xl
             z-10 mb-6 pt-6 px-1 md:px-3 lg:px-5`,
            children: "About the Gen Z Program"
        }), ae.jsx(Jo.div, {
            ref: r,
            style: {
                rotate: t
            },
            className: "w-full flex flex-row-reverse rounded-xl py-1 shadow-[0_20px_45px_rgba(0,0,0,0.25)]  ",
            children: ae.jsx("p", {
                className: "justify-center items-center px-5 mb-4 text-lg xl:text-xl",
                children: "Since 2016, Zain has continuously supported youth development and shaped future leaders, an effort that gave rise to the Generation Z program. It is a development program aimed at identifying and assessing young graduates who innately possess leadership skills. This year marks the 10th anniversary of the program, and as part of Zain's wider 4WARD strategy, the program positions 6 high-potential young talents at the center of digital transformation efforts, developing critical capabilities in product innovation, agile delivery, leadership, and customer experience."
            })
        })]
    })
}
  , Eee = ({currentIndex: r, setCurrentIndex: e, maxStartIndex: t, onInteract: n}) => {
    const i = () => {
        n == null || n(),
        e(a => a > 0 ? a - 1 : t)
    }
    ;
    return ae.jsxs("button", {
        type: "button",
        "aria-label": "Previous slide",
        onClick: i,
        className: `absolute left-2 top-1/2 -translate-y-1/2 
      z-10 grid h-10 w-10 place-items-center rounded-full
     bg-black/30 text-white hover:bg-black/40 
     focus:outline-none focus:ring-2 focus:ring-white/60`,
        children: [ae.jsx(lF, {}), ae.jsx("span", {
            className: "sr-only",
            children: "Previous"
        })]
    })
}
  , wee = ({currentIndex: r, setCurrentIndex: e, maxStartIndex: t, onInteract: n}) => {
    const i = () => {
        n == null || n(),
        e(a => a < t ? a + 1 : 0)
    }
    ;
    return ae.jsxs("button", {
        type: "button",
        "aria-label": "Next slide",
        onClick: i,
        className: "absolute right-2 top-1/2 -translate-y-1/2 z-10 grid h-10 w-10 place-items-center rounded-full bg-black/30 text-white hover:bg-black/40 focus:outline-none focus:ring-2 focus:ring-white/60",
        children: [ae.jsx(uF, {}), ae.jsx("span", {
            className: "sr-only",
            children: "Next"
        })]
    })
}
  , Aee = ({images: r, width: e=350, height: t=300, renderDots: n=!0}) => {
    const i = ln.useRef(null)
      , a = typeof window < "u"
      , s = 24
      , l = typeof t == "number" ? t : parseInt(t, 10) || 300
      , u = Math.max(l - 16, 120)
      , f = a ? window.innerWidth : e
      , [d,g] = de.useState(f)
      , [v,y] = ln.useState(e * (f >= 1280 ? 3 : f >= 768 ? 2 : 1))
      , [S,T] = ln.useState(0)
      , [M,b] = ln.useState(!1);
    de.useEffect( () => {
        if (!a)
            return;
        const K = () => {
            g(window.innerWidth),
            i.current && y(i.current.clientWidth)
        }
        ;
        return K(),
        window.addEventListener("resize", K),
        () => window.removeEventListener("resize", K)
    }
    , [a]),
    de.useEffect( () => {
        i.current && y(i.current.clientWidth)
    }
    , [e]);
    const A = ln.useMemo( () => d >= 1280 ? 3 : d >= 768 ? 2 : 1, [d]);
    de.useEffect( () => {
        i.current && y(i.current.clientWidth)
    }
    , [A]);
    const C = v || e * A
      , R = A > 0 ? Math.max((C - s * (A - 1)) / A, 0) : C
      , O = R + s
      , L = Math.max(r.length - A, 0)
      , z = r.length > 0 ? r.length * R + s * (r.length - 1) : 0
      , I = ["bg-yellow", "bg-blue"]
      , N = "h-3 w-3 rounded-full transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-offset-2";
    de.useEffect( () => {
        S > L && T(L)
    }
    , [S, L]);
    const P = ln.useCallback( () => {
        b(!0)
    }
    , [])
      , Y = K => {
        const Z = Math.min(K, L);
        Z !== S && T(Z)
    }
      , V = K => {
        K.key === "ArrowLeft" ? (P(),
        T(Z => Z > 0 ? Z - 1 : L)) : K.key === "ArrowRight" && (P(),
        T(Z => Z < L ? Z + 1 : 0))
    }
    ;
    return ln.useEffect( () => {
        i.current && i.current.scrollTo({
            left: O * S,
            behavior: "smooth"
        })
    }
    , [S, O]),
    ln.useEffect( () => {
        if (M || L === 0)
            return;
        const K = window.setInterval( () => {
            T(Z => Z < L ? Z + 1 : 0)
        }
        , 3500);
        return () => window.clearInterval(K)
    }
    , [M, L]),
    ae.jsxs("div", {
        className: "flex flex-col items-center justify-center mb-1",
        role: "region",
        "aria-label": "Image carousel",
        tabIndex: 0,
        onKeyDown: V,
        children: [ae.jsxs("div", {
            className: "relative w-full",
            children: [ae.jsx(Eee, {
                currentIndex: S,
                setCurrentIndex: T,
                maxStartIndex: L,
                onInteract: P
            }), ae.jsx(wee, {
                currentIndex: S,
                setCurrentIndex: T,
                maxStartIndex: L,
                onInteract: P
            }), ae.jsx("div", {
                ref: i,
                className: "overflow-x-auto overflow-y-hidden snap-x snap-mandatory scrollbar-hide",
                style: {
                    minHeight: `${l}px`
                },
                "aria-roledescription": "carousel",
                "aria-label": "Images",
                children: ae.jsx("ul", {
                    className: "flex h-full m-0 p-0 list-none",
                    style: {
                        width: `${z}px`
                    },
                    children: r.map( (K, Z) => ae.jsx("li", {
                        className: "relative flex-shrink-0 snap-start snap-always flex items-center justify-center",
                        style: {
                            width: `${R}px`,
                            height: `${l}px`,
                            marginRight: Z === r.length - 1 ? 0 : `${s}px`
                        },
                        "aria-label": `Slide ${Z + 1} of ${r.length}`,
                        "aria-current": Z >= S && Z < S + A ? "true" : void 0,
                        children: ae.jsx("div", {
                            className: "w-full h-full rounded-xl p-2 flex items-center justify-center",
                            style: {
                                height: `${l}px`
                            },
                            children: ae.jsx("img", {
                                src: K.src,
                                alt: K.alt ?? "",
                                className: "w-full h-auto max-h-full object-contain rounded-lg select-none",
                                style: {
                                    maxHeight: `${u}px`
                                },
                                draggable: !1
                            })
                        })
                    }, Z))
                })
            })]
        }), n && ae.jsx("div", {
            className: "mt-4 flex items-center justify-center gap-2 mb-1",
            "aria-label": "Slide indicators",
            children: r.map( (K, Z) => ae.jsx("button", {
                type: "button",
                onClick: () => {
                    P(),
                    Y(Z)
                }
                ,
                "aria-label": `Go to slide ${Z + 1}`,
                "aria-current": Z >= S && Z < S + A ? "true" : void 0,
                className: Z >= S && Z < S + A ? `${N} ${I[(Z - S) % I.length]} opacity-100 ring-yellow/60` : `${N} bg-gray-400 opacity-40`
            }, Z))
        })]
    })
}
;
function Cee(r, e) {
    for (var t = 0; t < e.length; t++) {
        var n = e[t];
        n.enumerable = n.enumerable || !1,
        n.configurable = !0,
        "value"in n && (n.writable = !0),
        Object.defineProperty(r, n.key, n)
    }
}
function Ree(r, e, t) {
    return e && Cee(r.prototype, e),
    r
}
/*!
 * Observer 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
var ma, ES, xo, ch, fh, fg, bI, zd, fy, MI, Yc, Xl, TI, EI = function() {
    return ma || typeof window < "u" && (ma = window.gsap) && ma.registerPlugin && ma
}, wI = 1, ag = [], Xn = [], $u = [], hy = Date.now, Ow = function(e, t) {
    return t
}, Dee = function() {
    var e = fy.core
      , t = e.bridge || {}
      , n = e._scrollers
      , i = e._proxies;
    n.push.apply(n, Xn),
    i.push.apply(i, $u),
    Xn = n,
    $u = i,
    Ow = function(s, l) {
        return t[s](l)
    }
}, ph = function(e, t) {
    return ~$u.indexOf(e) && $u[$u.indexOf(e) + 1][t]
}, dy = function(e) {
    return !!~MI.indexOf(e)
}, os = function(e, t, n, i, a) {
    return e.addEventListener(t, n, {
        passive: i !== !1,
        capture: !!a
    })
}, ss = function(e, t, n, i) {
    return e.removeEventListener(t, n, !!i)
}, Zx = "scrollLeft", Kx = "scrollTop", Nw = function() {
    return Yc && Yc.isPressed || Xn.cache++
}, Fb = function(e, t) {
    var n = function i(a) {
        if (a || a === 0) {
            wI && (xo.history.scrollRestoration = "manual");
            var s = Yc && Yc.isPressed;
            a = i.v = Math.round(a) || (Yc && Yc.iOS ? 1 : 0),
            e(a),
            i.cacheID = Xn.cache,
            s && Ow("ss", a)
        } else
            (t || Xn.cache !== i.cacheID || Ow("ref")) && (i.cacheID = Xn.cache,
            i.v = e());
        return i.v + i.offset
    };
    return n.offset = 0,
    e && n
}, ms = {
    s: Zx,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: Fb(function(r) {
        return arguments.length ? xo.scrollTo(r, Ir.sc()) : xo.pageXOffset || ch[Zx] || fh[Zx] || fg[Zx] || 0
    })
}, Ir = {
    s: Kx,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: ms,
    sc: Fb(function(r) {
        return arguments.length ? xo.scrollTo(ms.sc(), r) : xo.pageYOffset || ch[Kx] || fh[Kx] || fg[Kx] || 0
    })
}, Hs = function(e, t) {
    return (t && t._ctx && t._ctx.selector || ma.utils.toArray)(e)[0] || (typeof e == "string" && ma.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null)
}, Uee = function(e, t) {
    for (var n = t.length; n--; )
        if (t[n] === e || t[n].contains(e))
            return !0;
    return !1
}, Sh = function(e, t) {
    var n = t.s
      , i = t.sc;
    dy(e) && (e = ch.scrollingElement || fh);
    var a = Xn.indexOf(e)
      , s = i === Ir.sc ? 1 : 2;
    !~a && (a = Xn.push(e) - 1),
    Xn[a + s] || os(e, "scroll", Nw);
    var l = Xn[a + s]
      , u = l || (Xn[a + s] = Fb(ph(e, n), !0) || (dy(e) ? i : Fb(function(f) {
        return arguments.length ? e[n] = f : e[n]
    })));
    return u.target = e,
    l || (u.smooth = ma.getProperty(e, "scrollBehavior") === "smooth"),
    u
}, Lw = function(e, t, n) {
    var i = e
      , a = e
      , s = hy()
      , l = s
      , u = t || 50
      , f = Math.max(500, u * 3)
      , d = function(S, T) {
        var M = hy();
        T || M - s > u ? (a = i,
        i = S,
        l = s,
        s = M) : n ? i += S : i = a + (S - a) / (M - l) * (s - l)
    }
      , g = function() {
        a = i = n ? 0 : i,
        l = s = 0
    }
      , v = function(S) {
        var T = l
          , M = a
          , b = hy();
        return (S || S === 0) && S !== i && d(S),
        s === l || b - l > f ? 0 : (i + (n ? M : -M)) / ((n ? b : s) - T) * 1e3
    };
    return {
        update: d,
        reset: g,
        getVelocity: v
    }
}, Av = function(e, t) {
    return t && !e._gsapAllow && e.preventDefault(),
    e.changedTouches ? e.changedTouches[0] : e
}, uN = function(e) {
    var t = Math.max.apply(Math, e)
      , n = Math.min.apply(Math, e);
    return Math.abs(t) >= Math.abs(n) ? t : n
}, AI = function() {
    fy = ma.core.globals().ScrollTrigger,
    fy && fy.core && Dee()
}, CI = function(e) {
    return ma = e || EI(),
    !ES && ma && typeof document < "u" && document.body && (xo = window,
    ch = document,
    fh = ch.documentElement,
    fg = ch.body,
    MI = [xo, ch, fh, fg],
    ma.utils.clamp,
    TI = ma.core.context || function() {}
    ,
    zd = "onpointerenter"in fg ? "pointer" : "mouse",
    bI = yr.isTouch = xo.matchMedia && xo.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart"in xo || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0,
    Xl = yr.eventTypes = ("ontouchstart"in fh ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown"in fh ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","),
    setTimeout(function() {
        return wI = 0
    }, 500),
    AI(),
    ES = 1),
    ES
};
ms.op = Ir;
Xn.cache = 0;
var yr = function() {
    function r(t) {
        this.init(t)
    }
    var e = r.prototype;
    return e.init = function(n) {
        ES || CI(ma) || console.warn("Please gsap.registerPlugin(Observer)"),
        fy || AI();
        var i = n.tolerance
          , a = n.dragMinimum
          , s = n.type
          , l = n.target
          , u = n.lineHeight
          , f = n.debounce
          , d = n.preventDefault
          , g = n.onStop
          , v = n.onStopDelay
          , y = n.ignore
          , S = n.wheelSpeed
          , T = n.event
          , M = n.onDragStart
          , b = n.onDragEnd
          , A = n.onDrag
          , C = n.onPress
          , R = n.onRelease
          , O = n.onRight
          , L = n.onLeft
          , z = n.onUp
          , I = n.onDown
          , N = n.onChangeX
          , P = n.onChangeY
          , Y = n.onChange
          , V = n.onToggleX
          , K = n.onToggleY
          , Z = n.onHover
          , oe = n.onHoverEnd
          , H = n.onMove
          , q = n.ignoreCheck
          , Q = n.isNormalizer
          , se = n.onGestureStart
          , B = n.onGestureEnd
          , W = n.onWheel
          , te = n.onEnable
          , fe = n.onDisable
          , pe = n.onClick
          , _e = n.scrollSpeed
          , ue = n.capture
          , ge = n.allowClicks
          , Te = n.lockAxis
          , Ze = n.onLockAxis;
        this.target = l = Hs(l) || fh,
        this.vars = n,
        y && (y = ma.utils.toArray(y)),
        i = i || 1e-9,
        a = a || 0,
        S = S || 1,
        _e = _e || 1,
        s = s || "wheel,touch,pointer",
        f = f !== !1,
        u || (u = parseFloat(xo.getComputedStyle(fg).lineHeight) || 22);
        var ot, tt, $e, re, Le, Ne, Oe, le = this, Pe = 0, He = 0, Ve = n.passive || !d && n.passive !== !1, De = Sh(l, ms), vt = Sh(l, Ir), J = De(), j = vt(), ve = ~s.indexOf("touch") && !~s.indexOf("pointer") && Xl[0] === "pointerdown", Be = dy(l), we = l.ownerDocument || ch, Ce = [0, 0, 0], it = [0, 0, 0], lt = 0, Mt = function() {
            return lt = hy()
        }, pt = function(Bt, Gt) {
            return (le.event = Bt) && y && Uee(Bt.target, y) || Gt && ve && Bt.pointerType !== "touch" || q && q(Bt, Gt)
        }, je = function() {
            le._vx.reset(),
            le._vy.reset(),
            tt.pause(),
            g && g(le)
        }, Ye = function() {
            var Bt = le.deltaX = uN(Ce)
              , Gt = le.deltaY = uN(it)
              , mt = Math.abs(Bt) >= i
              , Lt = Math.abs(Gt) >= i;
            Y && (mt || Lt) && Y(le, Bt, Gt, Ce, it),
            mt && (O && le.deltaX > 0 && O(le),
            L && le.deltaX < 0 && L(le),
            N && N(le),
            V && le.deltaX < 0 != Pe < 0 && V(le),
            Pe = le.deltaX,
            Ce[0] = Ce[1] = Ce[2] = 0),
            Lt && (I && le.deltaY > 0 && I(le),
            z && le.deltaY < 0 && z(le),
            P && P(le),
            K && le.deltaY < 0 != He < 0 && K(le),
            He = le.deltaY,
            it[0] = it[1] = it[2] = 0),
            (re || $e) && (H && H(le),
            $e && (M && $e === 1 && M(le),
            A && A(le),
            $e = 0),
            re = !1),
            Ne && !(Ne = !1) && Ze && Ze(le),
            Le && (W(le),
            Le = !1),
            ot = 0
        }, ct = function(Bt, Gt, mt) {
            Ce[mt] += Bt,
            it[mt] += Gt,
            le._vx.update(Bt),
            le._vy.update(Gt),
            f ? ot || (ot = requestAnimationFrame(Ye)) : Ye()
        }, _t = function(Bt, Gt) {
            Te && !Oe && (le.axis = Oe = Math.abs(Bt) > Math.abs(Gt) ? "x" : "y",
            Ne = !0),
            Oe !== "y" && (Ce[2] += Bt,
            le._vx.update(Bt, !0)),
            Oe !== "x" && (it[2] += Gt,
            le._vy.update(Gt, !0)),
            f ? ot || (ot = requestAnimationFrame(Ye)) : Ye()
        }, ut = function(Bt) {
            if (!pt(Bt, 1)) {
                Bt = Av(Bt, d);
                var Gt = Bt.clientX
                  , mt = Bt.clientY
                  , Lt = Gt - le.x
                  , zt = mt - le.y
                  , Wt = le.isDragging;
                le.x = Gt,
                le.y = mt,
                (Wt || (Lt || zt) && (Math.abs(le.startX - Gt) >= a || Math.abs(le.startY - mt) >= a)) && ($e = Wt ? 2 : 1,
                Wt || (le.isDragging = !0),
                _t(Lt, zt))
            }
        }, Ut = le.onPress = function(bt) {
            pt(bt, 1) || bt && bt.button || (le.axis = Oe = null,
            tt.pause(),
            le.isPressed = !0,
            bt = Av(bt),
            Pe = He = 0,
            le.startX = le.x = bt.clientX,
            le.startY = le.y = bt.clientY,
            le._vx.reset(),
            le._vy.reset(),
            os(Q ? l : we, Xl[1], ut, Ve, !0),
            le.deltaX = le.deltaY = 0,
            C && C(le))
        }
        , me = le.onRelease = function(bt) {
            if (!pt(bt, 1)) {
                ss(Q ? l : we, Xl[1], ut, !0);
                var Bt = !isNaN(le.y - le.startY)
                  , Gt = le.isDragging
                  , mt = Gt && (Math.abs(le.x - le.startX) > 3 || Math.abs(le.y - le.startY) > 3)
                  , Lt = Av(bt);
                !mt && Bt && (le._vx.reset(),
                le._vy.reset(),
                d && ge && ma.delayedCall(.08, function() {
                    if (hy() - lt > 300 && !bt.defaultPrevented) {
                        if (bt.target.click)
                            bt.target.click();
                        else if (we.createEvent) {
                            var zt = we.createEvent("MouseEvents");
                            zt.initMouseEvent("click", !0, !0, xo, 1, Lt.screenX, Lt.screenY, Lt.clientX, Lt.clientY, !1, !1, !1, !1, 0, null),
                            bt.target.dispatchEvent(zt)
                        }
                    }
                })),
                le.isDragging = le.isGesturing = le.isPressed = !1,
                g && Gt && !Q && tt.restart(!0),
                $e && Ye(),
                b && Gt && b(le),
                R && R(le, mt)
            }
        }
        , Ee = function(Bt) {
            return Bt.touches && Bt.touches.length > 1 && (le.isGesturing = !0) && se(Bt, le.isDragging)
        }, at = function() {
            return (le.isGesturing = !1) || B(le)
        }, Ct = function(Bt) {
            if (!pt(Bt)) {
                var Gt = De()
                  , mt = vt();
                ct((Gt - J) * _e, (mt - j) * _e, 1),
                J = Gt,
                j = mt,
                g && tt.restart(!0)
            }
        }, rt = function(Bt) {
            if (!pt(Bt)) {
                Bt = Av(Bt, d),
                W && (Le = !0);
                var Gt = (Bt.deltaMode === 1 ? u : Bt.deltaMode === 2 ? xo.innerHeight : 1) * S;
                ct(Bt.deltaX * Gt, Bt.deltaY * Gt, 0),
                g && !Q && tt.restart(!0)
            }
        }, Ge = function(Bt) {
            if (!pt(Bt)) {
                var Gt = Bt.clientX
                  , mt = Bt.clientY
                  , Lt = Gt - le.x
                  , zt = mt - le.y;
                le.x = Gt,
                le.y = mt,
                re = !0,
                g && tt.restart(!0),
                (Lt || zt) && _t(Lt, zt)
            }
        }, wt = function(Bt) {
            le.event = Bt,
            Z(le)
        }, Ot = function(Bt) {
            le.event = Bt,
            oe(le)
        }, Nt = function(Bt) {
            return pt(Bt) || Av(Bt, d) && pe(le)
        };
        tt = le._dc = ma.delayedCall(v || .25, je).pause(),
        le.deltaX = le.deltaY = 0,
        le._vx = Lw(0, 50, !0),
        le._vy = Lw(0, 50, !0),
        le.scrollX = De,
        le.scrollY = vt,
        le.isDragging = le.isGesturing = le.isPressed = !1,
        TI(this),
        le.enable = function(bt) {
            return le.isEnabled || (os(Be ? we : l, "scroll", Nw),
            s.indexOf("scroll") >= 0 && os(Be ? we : l, "scroll", Ct, Ve, ue),
            s.indexOf("wheel") >= 0 && os(l, "wheel", rt, Ve, ue),
            (s.indexOf("touch") >= 0 && bI || s.indexOf("pointer") >= 0) && (os(l, Xl[0], Ut, Ve, ue),
            os(we, Xl[2], me),
            os(we, Xl[3], me),
            ge && os(l, "click", Mt, !0, !0),
            pe && os(l, "click", Nt),
            se && os(we, "gesturestart", Ee),
            B && os(we, "gestureend", at),
            Z && os(l, zd + "enter", wt),
            oe && os(l, zd + "leave", Ot),
            H && os(l, zd + "move", Ge)),
            le.isEnabled = !0,
            le.isDragging = le.isGesturing = le.isPressed = re = $e = !1,
            le._vx.reset(),
            le._vy.reset(),
            J = De(),
            j = vt(),
            bt && bt.type && Ut(bt),
            te && te(le)),
            le
        }
        ,
        le.disable = function() {
            le.isEnabled && (ag.filter(function(bt) {
                return bt !== le && dy(bt.target)
            }).length || ss(Be ? we : l, "scroll", Nw),
            le.isPressed && (le._vx.reset(),
            le._vy.reset(),
            ss(Q ? l : we, Xl[1], ut, !0)),
            ss(Be ? we : l, "scroll", Ct, ue),
            ss(l, "wheel", rt, ue),
            ss(l, Xl[0], Ut, ue),
            ss(we, Xl[2], me),
            ss(we, Xl[3], me),
            ss(l, "click", Mt, !0),
            ss(l, "click", Nt),
            ss(we, "gesturestart", Ee),
            ss(we, "gestureend", at),
            ss(l, zd + "enter", wt),
            ss(l, zd + "leave", Ot),
            ss(l, zd + "move", Ge),
            le.isEnabled = le.isPressed = le.isDragging = !1,
            fe && fe(le))
        }
        ,
        le.kill = le.revert = function() {
            le.disable();
            var bt = ag.indexOf(le);
            bt >= 0 && ag.splice(bt, 1),
            Yc === le && (Yc = 0)
        }
        ,
        ag.push(le),
        Q && dy(l) && (Yc = le),
        le.enable(T)
    }
    ,
    Ree(r, [{
        key: "velocityX",
        get: function() {
            return this._vx.getVelocity()
        }
    }, {
        key: "velocityY",
        get: function() {
            return this._vy.getVelocity()
        }
    }]),
    r
}();
yr.version = "3.13.0";
yr.create = function(r) {
    return new yr(r)
}
;
yr.register = CI;
yr.getAll = function() {
    return ag.slice()
}
;
yr.getById = function(r) {
    return ag.filter(function(e) {
        return e.vars.id === r
    })[0]
}
;
EI() && ma.registerPlugin(yr);
/*!
 * ScrollTrigger 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
var Zt, Wm, Gn, Oi, yo, di, $C, Hb, $y, py, Bv, Qx, Na, VM, Pw, cs, cN, fN, Ym, RI, fE, DI, us, Bw, UI, OI, th, zw, eR, hg, tR, Vb, Iw, hE, Jx = 1, Pa = Date.now, dE = Pa(), al = 0, zv = 0, hN = function(e, t, n) {
    var i = go(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1);
    return n["_" + t + "Clamp"] = i,
    i ? e.substr(6, e.length - 7) : e
}, dN = function(e, t) {
    return t && (!go(e) || e.substr(0, 6) !== "clamp(") ? "clamp(" + e + ")" : e
}, Oee = function r() {
    return zv && requestAnimationFrame(r)
}, pN = function() {
    return VM = 1
}, mN = function() {
    return VM = 0
}, Fu = function(e) {
    return e
}, Iv = function(e) {
    return Math.round(e * 1e5) / 1e5 || 0
}, NI = function() {
    return typeof window < "u"
}, LI = function() {
    return Zt || NI() && (Zt = window.gsap) && Zt.registerPlugin && Zt
}, pp = function(e) {
    return !!~$C.indexOf(e)
}, PI = function(e) {
    return (e === "Height" ? tR : Gn["inner" + e]) || yo["client" + e] || di["client" + e]
}, BI = function(e) {
    return ph(e, "getBoundingClientRect") || (pp(e) ? function() {
        return DS.width = Gn.innerWidth,
        DS.height = tR,
        DS
    }
    : function() {
        return Wc(e)
    }
    )
}, Nee = function(e, t, n) {
    var i = n.d
      , a = n.d2
      , s = n.a;
    return (s = ph(e, "getBoundingClientRect")) ? function() {
        return s()[i]
    }
    : function() {
        return (t ? PI(a) : e["client" + a]) || 0
    }
}, Lee = function(e, t) {
    return !t || ~$u.indexOf(e) ? BI(e) : function() {
        return DS
    }
}, ju = function(e, t) {
    var n = t.s
      , i = t.d2
      , a = t.d
      , s = t.a;
    return Math.max(0, (n = "scroll" + i) && (s = ph(e, n)) ? s() - BI(e)()[a] : pp(e) ? (yo[n] || di[n]) - PI(i) : e[n] - e["offset" + i])
}, $x = function(e, t) {
    for (var n = 0; n < Ym.length; n += 3)
        (!t || ~t.indexOf(Ym[n + 1])) && e(Ym[n], Ym[n + 1], Ym[n + 2])
}, go = function(e) {
    return typeof e == "string"
}, za = function(e) {
    return typeof e == "function"
}, Fv = function(e) {
    return typeof e == "number"
}, Id = function(e) {
    return typeof e == "object"
}, Cv = function(e, t, n) {
    return e && e.progress(t ? 0 : 1) && n && e.pause()
}, pE = function(e, t) {
    if (e.enabled) {
        var n = e._ctx ? e._ctx.add(function() {
            return t(e)
        }) : t(e);
        n && n.totalTime && (e.callbackAnimation = n)
    }
}, Gm = Math.abs, zI = "left", II = "top", nR = "right", iR = "bottom", ap = "width", sp = "height", my = "Right", gy = "Left", vy = "Top", yy = "Bottom", Er = "padding", $o = "margin", Bg = "Width", rR = "Height", zr = "px", el = function(e) {
    return Gn.getComputedStyle(e)
}, Pee = function(e) {
    var t = el(e).position;
    e.style.position = t === "absolute" || t === "fixed" ? t : "relative"
}, gN = function(e, t) {
    for (var n in t)
        n in e || (e[n] = t[n]);
    return e
}, Wc = function(e, t) {
    var n = t && el(e)[Pw] !== "matrix(1, 0, 0, 1, 0, 0)" && Zt.to(e, {
        x: 0,
        y: 0,
        xPercent: 0,
        yPercent: 0,
        rotation: 0,
        rotationX: 0,
        rotationY: 0,
        scale: 1,
        skewX: 0,
        skewY: 0
    }).progress(1)
      , i = e.getBoundingClientRect();
    return n && n.progress(0).kill(),
    i
}, kb = function(e, t) {
    var n = t.d2;
    return e["offset" + n] || e["client" + n] || 0
}, FI = function(e) {
    var t = [], n = e.labels, i = e.duration(), a;
    for (a in n)
        t.push(n[a] / i);
    return t
}, Bee = function(e) {
    return function(t) {
        return Zt.utils.snap(FI(e), t)
    }
}, aR = function(e) {
    var t = Zt.utils.snap(e)
      , n = Array.isArray(e) && e.slice(0).sort(function(i, a) {
        return i - a
    });
    return n ? function(i, a, s) {
        s === void 0 && (s = .001);
        var l;
        if (!a)
            return t(i);
        if (a > 0) {
            for (i -= s,
            l = 0; l < n.length; l++)
                if (n[l] >= i)
                    return n[l];
            return n[l - 1]
        } else
            for (l = n.length,
            i += s; l--; )
                if (n[l] <= i)
                    return n[l];
        return n[0]
    }
    : function(i, a, s) {
        s === void 0 && (s = .001);
        var l = t(i);
        return !a || Math.abs(l - i) < s || l - i < 0 == a < 0 ? l : t(a < 0 ? i - e : i + e)
    }
}, zee = function(e) {
    return function(t, n) {
        return aR(FI(e))(t, n.direction)
    }
}, eS = function(e, t, n, i) {
    return n.split(",").forEach(function(a) {
        return e(t, a, i)
    })
}, Kr = function(e, t, n, i, a) {
    return e.addEventListener(t, n, {
        passive: !i,
        capture: !!a
    })
}, Zr = function(e, t, n, i) {
    return e.removeEventListener(t, n, !!i)
}, tS = function(e, t, n) {
    n = n && n.wheelHandler,
    n && (e(t, "wheel", n),
    e(t, "touchmove", n))
}, vN = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal"
}, nS = {
    toggleActions: "play",
    anticipatePin: 0
}, Gb = {
    top: 0,
    left: 0,
    center: .5,
    bottom: 1,
    right: 1
}, wS = function(e, t) {
    if (go(e)) {
        var n = e.indexOf("=")
          , i = ~n ? +(e.charAt(n - 1) + 1) * parseFloat(e.substr(n + 1)) : 0;
        ~n && (e.indexOf("%") > n && (i *= t / 100),
        e = e.substr(0, n - 1)),
        e = i + (e in Gb ? Gb[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
    }
    return e
}, iS = function(e, t, n, i, a, s, l, u) {
    var f = a.startColor
      , d = a.endColor
      , g = a.fontSize
      , v = a.indent
      , y = a.fontWeight
      , S = Oi.createElement("div")
      , T = pp(n) || ph(n, "pinType") === "fixed"
      , M = e.indexOf("scroller") !== -1
      , b = T ? di : n
      , A = e.indexOf("start") !== -1
      , C = A ? f : d
      , R = "border-color:" + C + ";font-size:" + g + ";color:" + C + ";font-weight:" + y + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    return R += "position:" + ((M || u) && T ? "fixed;" : "absolute;"),
    (M || u || !T) && (R += (i === Ir ? nR : iR) + ":" + (s + parseFloat(v)) + "px;"),
    l && (R += "box-sizing:border-box;text-align:left;width:" + l.offsetWidth + "px;"),
    S._isStart = A,
    S.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")),
    S.style.cssText = R,
    S.innerText = t || t === 0 ? e + "-" + t : e,
    b.children[0] ? b.insertBefore(S, b.children[0]) : b.appendChild(S),
    S._offset = S["offset" + i.op.d2],
    AS(S, 0, i, A),
    S
}, AS = function(e, t, n, i) {
    var a = {
        display: "block"
    }
      , s = n[i ? "os2" : "p2"]
      , l = n[i ? "p2" : "os2"];
    e._isFlipped = i,
    a[n.a + "Percent"] = i ? -100 : 0,
    a[n.a] = i ? "1px" : 0,
    a["border" + s + Bg] = 1,
    a["border" + l + Bg] = 0,
    a[n.p] = t + "px",
    Zt.set(e, a)
}, Hn = [], Fw = {}, e_, yN = function() {
    return Pa() - al > 34 && (e_ || (e_ = requestAnimationFrame(Kc)))
}, Xm = function() {
    (!us || !us.isPressed || us.startX > di.clientWidth) && (Xn.cache++,
    us ? e_ || (e_ = requestAnimationFrame(Kc)) : Kc(),
    al || gp("scrollStart"),
    al = Pa())
}, mE = function() {
    OI = Gn.innerWidth,
    UI = Gn.innerHeight
}, Hv = function(e) {
    Xn.cache++,
    (e === !0 || !Na && !DI && !Oi.fullscreenElement && !Oi.webkitFullscreenElement && (!Bw || OI !== Gn.innerWidth || Math.abs(Gn.innerHeight - UI) > Gn.innerHeight * .25)) && Hb.restart(!0)
}, mp = {}, Iee = [], HI = function r() {
    return Zr(jn, "scrollEnd", r) || qd(!0)
}, gp = function(e) {
    return mp[e] && mp[e].map(function(t) {
        return t()
    }) || Iee
}, mo = [], VI = function(e) {
    for (var t = 0; t < mo.length; t += 5)
        (!e || mo[t + 4] && mo[t + 4].query === e) && (mo[t].style.cssText = mo[t + 1],
        mo[t].getBBox && mo[t].setAttribute("transform", mo[t + 2] || ""),
        mo[t + 3].uncache = 1)
}, sR = function(e, t) {
    var n;
    for (cs = 0; cs < Hn.length; cs++)
        n = Hn[cs],
        n && (!t || n._ctx === t) && (e ? n.kill(1) : n.revert(!0, !0));
    Vb = !0,
    t && VI(t),
    t || gp("revert")
}, kI = function(e, t) {
    Xn.cache++,
    (t || !fs) && Xn.forEach(function(n) {
        return za(n) && n.cacheID++ && (n.rec = 0)
    }),
    go(e) && (Gn.history.scrollRestoration = eR = e)
}, fs, op = 0, _N, Fee = function() {
    if (_N !== op) {
        var e = _N = op;
        requestAnimationFrame(function() {
            return e === op && qd(!0)
        })
    }
}, GI = function() {
    di.appendChild(hg),
    tR = !us && hg.offsetHeight || Gn.innerHeight,
    di.removeChild(hg)
}, xN = function(e) {
    return $y(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(t) {
        return t.style.display = e ? "none" : "block"
    })
}, qd = function(e, t) {
    if (yo = Oi.documentElement,
    di = Oi.body,
    $C = [Gn, Oi, yo, di],
    al && !e && !Vb) {
        Kr(jn, "scrollEnd", HI);
        return
    }
    GI(),
    fs = jn.isRefreshing = !0,
    Xn.forEach(function(i) {
        return za(i) && ++i.cacheID && (i.rec = i())
    });
    var n = gp("refreshInit");
    RI && jn.sort(),
    t || sR(),
    Xn.forEach(function(i) {
        za(i) && (i.smooth && (i.target.style.scrollBehavior = "auto"),
        i(0))
    }),
    Hn.slice(0).forEach(function(i) {
        return i.refresh()
    }),
    Vb = !1,
    Hn.forEach(function(i) {
        if (i._subPinOffset && i.pin) {
            var a = i.vars.horizontal ? "offsetWidth" : "offsetHeight"
              , s = i.pin[a];
            i.revert(!0, 1),
            i.adjustPinSpacing(i.pin[a] - s),
            i.refresh()
        }
    }),
    Iw = 1,
    xN(!0),
    Hn.forEach(function(i) {
        var a = ju(i.scroller, i._dir)
          , s = i.vars.end === "max" || i._endClamp && i.end > a
          , l = i._startClamp && i.start >= a;
        (s || l) && i.setPositions(l ? a - 1 : i.start, s ? Math.max(l ? a : i.start + 1, a) : i.end, !0)
    }),
    xN(!1),
    Iw = 0,
    n.forEach(function(i) {
        return i && i.render && i.render(-1)
    }),
    Xn.forEach(function(i) {
        za(i) && (i.smooth && requestAnimationFrame(function() {
            return i.target.style.scrollBehavior = "smooth"
        }),
        i.rec && i(i.rec))
    }),
    kI(eR, 1),
    Hb.pause(),
    op++,
    fs = 2,
    Kc(2),
    Hn.forEach(function(i) {
        return za(i.vars.onRefresh) && i.vars.onRefresh(i)
    }),
    fs = jn.isRefreshing = !1,
    gp("refresh")
}, Hw = 0, CS = 1, _y, Kc = function(e) {
    if (e === 2 || !fs && !Vb) {
        jn.isUpdating = !0,
        _y && _y.update(0);
        var t = Hn.length
          , n = Pa()
          , i = n - dE >= 50
          , a = t && Hn[0].scroll();
        if (CS = Hw > a ? -1 : 1,
        fs || (Hw = a),
        i && (al && !VM && n - al > 200 && (al = 0,
        gp("scrollEnd")),
        Bv = dE,
        dE = n),
        CS < 0) {
            for (cs = t; cs-- > 0; )
                Hn[cs] && Hn[cs].update(0, i);
            CS = 1
        } else
            for (cs = 0; cs < t; cs++)
                Hn[cs] && Hn[cs].update(0, i);
        jn.isUpdating = !1
    }
    e_ = 0
}, Vw = [zI, II, iR, nR, $o + yy, $o + my, $o + vy, $o + gy, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], RS = Vw.concat([ap, sp, "boxSizing", "max" + Bg, "max" + rR, "position", $o, Er, Er + vy, Er + my, Er + yy, Er + gy]), Hee = function(e, t, n) {
    dg(n);
    var i = e._gsap;
    if (i.spacerIsNative)
        dg(i.spacerState);
    else if (e._gsap.swappedIn) {
        var a = t.parentNode;
        a && (a.insertBefore(e, t),
        a.removeChild(t))
    }
    e._gsap.swappedIn = !1
}, gE = function(e, t, n, i) {
    if (!e._gsap.swappedIn) {
        for (var a = Vw.length, s = t.style, l = e.style, u; a--; )
            u = Vw[a],
            s[u] = n[u];
        s.position = n.position === "absolute" ? "absolute" : "relative",
        n.display === "inline" && (s.display = "inline-block"),
        l[iR] = l[nR] = "auto",
        s.flexBasis = n.flexBasis || "auto",
        s.overflow = "visible",
        s.boxSizing = "border-box",
        s[ap] = kb(e, ms) + zr,
        s[sp] = kb(e, Ir) + zr,
        s[Er] = l[$o] = l[II] = l[zI] = "0",
        dg(i),
        l[ap] = l["max" + Bg] = n[ap],
        l[sp] = l["max" + rR] = n[sp],
        l[Er] = n[Er],
        e.parentNode !== t && (e.parentNode.insertBefore(t, e),
        t.appendChild(e)),
        e._gsap.swappedIn = !0
    }
}, Vee = /([A-Z])/g, dg = function(e) {
    if (e) {
        var t = e.t.style, n = e.length, i = 0, a, s;
        for ((e.t._gsap || Zt.core.getCache(e.t)).uncache = 1; i < n; i += 2)
            s = e[i + 1],
            a = e[i],
            s ? t[a] = s : t[a] && t.removeProperty(a.replace(Vee, "-$1").toLowerCase())
    }
}, rS = function(e) {
    for (var t = RS.length, n = e.style, i = [], a = 0; a < t; a++)
        i.push(RS[a], n[RS[a]]);
    return i.t = e,
    i
}, kee = function(e, t, n) {
    for (var i = [], a = e.length, s = n ? 8 : 0, l; s < a; s += 2)
        l = e[s],
        i.push(l, l in t ? t[l] : e[s + 1]);
    return i.t = e.t,
    i
}, DS = {
    left: 0,
    top: 0
}, SN = function(e, t, n, i, a, s, l, u, f, d, g, v, y, S) {
    za(e) && (e = e(u)),
    go(e) && e.substr(0, 3) === "max" && (e = v + (e.charAt(4) === "=" ? wS("0" + e.substr(3), n) : 0));
    var T = y ? y.time() : 0, M, b, A;
    if (y && y.seek(0),
    isNaN(e) || (e = +e),
    Fv(e))
        y && (e = Zt.utils.mapRange(y.scrollTrigger.start, y.scrollTrigger.end, 0, v, e)),
        l && AS(l, n, i, !0);
    else {
        za(t) && (t = t(u));
        var C = (e || "0").split(" "), R, O, L, z;
        A = Hs(t, u) || di,
        R = Wc(A) || {},
        (!R || !R.left && !R.top) && el(A).display === "none" && (z = A.style.display,
        A.style.display = "block",
        R = Wc(A),
        z ? A.style.display = z : A.style.removeProperty("display")),
        O = wS(C[0], R[i.d]),
        L = wS(C[1] || "0", n),
        e = R[i.p] - f[i.p] - d + O + a - L,
        l && AS(l, L, i, n - L < 20 || l._isStart && L > 20),
        n -= n - L
    }
    if (S && (u[S] = e || -.001,
    e < 0 && (e = 0)),
    s) {
        var I = e + n
          , N = s._isStart;
        M = "scroll" + i.d2,
        AS(s, I, i, N && I > 20 || !N && (g ? Math.max(di[M], yo[M]) : s.parentNode[M]) <= I + 1),
        g && (f = Wc(l),
        g && (s.style[i.op.p] = f[i.op.p] - i.op.m - s._offset + zr))
    }
    return y && A && (M = Wc(A),
    y.seek(v),
    b = Wc(A),
    y._caScrollDist = M[i.p] - b[i.p],
    e = e / y._caScrollDist * v),
    y && y.seek(T),
    y ? e : Math.round(e)
}, Gee = /(webkit|moz|length|cssText|inset)/i, bN = function(e, t, n, i) {
    if (e.parentNode !== t) {
        var a = e.style, s, l;
        if (t === di) {
            e._stOrig = a.cssText,
            l = el(e);
            for (s in l)
                !+s && !Gee.test(s) && l[s] && typeof a[s] == "string" && s !== "0" && (a[s] = l[s]);
            a.top = n,
            a.left = i
        } else
            a.cssText = e._stOrig;
        Zt.core.getCache(e).uncache = 1,
        t.appendChild(e)
    }
}, XI = function(e, t, n) {
    var i = t
      , a = i;
    return function(s) {
        var l = Math.round(e());
        return l !== i && l !== a && Math.abs(l - i) > 3 && Math.abs(l - a) > 3 && (s = l,
        n && n()),
        a = i,
        i = Math.round(s),
        i
    }
}, aS = function(e, t, n) {
    var i = {};
    i[t.p] = "+=" + n,
    Zt.set(e, i)
}, MN = function(e, t) {
    var n = Sh(e, t)
      , i = "_scroll" + t.p2
      , a = function s(l, u, f, d, g) {
        var v = s.tween
          , y = u.onComplete
          , S = {};
        f = f || n();
        var T = XI(n, f, function() {
            v.kill(),
            s.tween = 0
        });
        return g = d && g || 0,
        d = d || l - f,
        v && v.kill(),
        u[i] = l,
        u.inherit = !1,
        u.modifiers = S,
        S[i] = function() {
            return T(f + d * v.ratio + g * v.ratio * v.ratio)
        }
        ,
        u.onUpdate = function() {
            Xn.cache++,
            s.tween && Kc()
        }
        ,
        u.onComplete = function() {
            s.tween = 0,
            y && y.call(v)
        }
        ,
        v = s.tween = Zt.to(e, u),
        v
    };
    return e[i] = n,
    n.wheelHandler = function() {
        return a.tween && a.tween.kill() && (a.tween = 0)
    }
    ,
    Kr(e, "wheel", n.wheelHandler),
    jn.isTouch && Kr(e, "touchmove", n.wheelHandler),
    a
}, jn = function() {
    function r(t, n) {
        Wm || r.register(Zt) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
        zw(this),
        this.init(t, n)
    }
    var e = r.prototype;
    return e.init = function(n, i) {
        if (this.progress = this.start = 0,
        this.vars && this.kill(!0, !0),
        !zv) {
            this.update = this.refresh = this.kill = Fu;
            return
        }
        n = gN(go(n) || Fv(n) || n.nodeType ? {
            trigger: n
        } : n, nS);
        var a = n, s = a.onUpdate, l = a.toggleClass, u = a.id, f = a.onToggle, d = a.onRefresh, g = a.scrub, v = a.trigger, y = a.pin, S = a.pinSpacing, T = a.invalidateOnRefresh, M = a.anticipatePin, b = a.onScrubComplete, A = a.onSnapComplete, C = a.once, R = a.snap, O = a.pinReparent, L = a.pinSpacer, z = a.containerAnimation, I = a.fastScrollEnd, N = a.preventOverlaps, P = n.horizontal || n.containerAnimation && n.horizontal !== !1 ? ms : Ir, Y = !g && g !== 0, V = Hs(n.scroller || Gn), K = Zt.core.getCache(V), Z = pp(V), oe = ("pinType"in n ? n.pinType : ph(V, "pinType") || Z && "fixed") === "fixed", H = [n.onEnter, n.onLeave, n.onEnterBack, n.onLeaveBack], q = Y && n.toggleActions.split(" "), Q = "markers"in n ? n.markers : nS.markers, se = Z ? 0 : parseFloat(el(V)["border" + P.p2 + Bg]) || 0, B = this, W = n.onRefreshInit && function() {
            return n.onRefreshInit(B)
        }
        , te = Nee(V, Z, P), fe = Lee(V, Z), pe = 0, _e = 0, ue = 0, ge = Sh(V, P), Te, Ze, ot, tt, $e, re, Le, Ne, Oe, le, Pe, He, Ve, De, vt, J, j, ve, Be, we, Ce, it, lt, Mt, pt, je, Ye, ct, _t, ut, Ut, me, Ee, at, Ct, rt, Ge, wt, Ot;
        if (B._startClamp = B._endClamp = !1,
        B._dir = P,
        M *= 45,
        B.scroller = V,
        B.scroll = z ? z.time.bind(z) : ge,
        tt = ge(),
        B.vars = n,
        i = i || n.animation,
        "refreshPriority"in n && (RI = 1,
        n.refreshPriority === -9999 && (_y = B)),
        K.tweenScroll = K.tweenScroll || {
            top: MN(V, Ir),
            left: MN(V, ms)
        },
        B.tweenTo = Te = K.tweenScroll[P.p],
        B.scrubDuration = function(mt) {
            Ee = Fv(mt) && mt,
            Ee ? me ? me.duration(mt) : me = Zt.to(i, {
                ease: "expo",
                totalProgress: "+=0",
                inherit: !1,
                duration: Ee,
                paused: !0,
                onComplete: function() {
                    return b && b(B)
                }
            }) : (me && me.progress(1).kill(),
            me = 0)
        }
        ,
        i && (i.vars.lazy = !1,
        i._initted && !B.isReverted || i.vars.immediateRender !== !1 && n.immediateRender !== !1 && i.duration() && i.render(0, !0, !0),
        B.animation = i.pause(),
        i.scrollTrigger = B,
        B.scrubDuration(g),
        ut = 0,
        u || (u = i.vars.id)),
        R && ((!Id(R) || R.push) && (R = {
            snapTo: R
        }),
        "scrollBehavior"in di.style && Zt.set(Z ? [di, yo] : V, {
            scrollBehavior: "auto"
        }),
        Xn.forEach(function(mt) {
            return za(mt) && mt.target === (Z ? Oi.scrollingElement || yo : V) && (mt.smooth = !1)
        }),
        ot = za(R.snapTo) ? R.snapTo : R.snapTo === "labels" ? Bee(i) : R.snapTo === "labelsDirectional" ? zee(i) : R.directional !== !1 ? function(mt, Lt) {
            return aR(R.snapTo)(mt, Pa() - _e < 500 ? 0 : Lt.direction)
        }
        : Zt.utils.snap(R.snapTo),
        at = R.duration || {
            min: .1,
            max: 2
        },
        at = Id(at) ? py(at.min, at.max) : py(at, at),
        Ct = Zt.delayedCall(R.delay || Ee / 2 || .1, function() {
            var mt = ge()
              , Lt = Pa() - _e < 500
              , zt = Te.tween;
            if ((Lt || Math.abs(B.getVelocity()) < 10) && !zt && !VM && pe !== mt) {
                var Wt = (mt - re) / De, Ln = i && !Y ? i.totalProgress() : Wt, qt = Lt ? 0 : (Ln - Ut) / (Pa() - Bv) * 1e3 || 0, Pt = Zt.utils.clamp(-Wt, 1 - Wt, Gm(qt / 2) * qt / .185), un = Wt + (R.inertia === !1 ? 0 : Pt), $t, k, $ = R, Se = $.onStart, Ue = $.onInterrupt, Fe = $.onComplete;
                if ($t = ot(un, B),
                Fv($t) || ($t = un),
                k = Math.max(0, Math.round(re + $t * De)),
                mt <= Le && mt >= re && k !== mt) {
                    if (zt && !zt._initted && zt.data <= Gm(k - mt))
                        return;
                    R.inertia === !1 && (Pt = $t - Wt),
                    Te(k, {
                        duration: at(Gm(Math.max(Gm(un - Ln), Gm($t - Ln)) * .185 / qt / .05 || 0)),
                        ease: R.ease || "power3",
                        data: Gm(k - mt),
                        onInterrupt: function() {
                            return Ct.restart(!0) && Ue && Ue(B)
                        },
                        onComplete: function() {
                            B.update(),
                            pe = ge(),
                            i && !Y && (me ? me.resetTo("totalProgress", $t, i._tTime / i._tDur) : i.progress($t)),
                            ut = Ut = i && !Y ? i.totalProgress() : B.progress,
                            A && A(B),
                            Fe && Fe(B)
                        }
                    }, mt, Pt * De, k - mt - Pt * De),
                    Se && Se(B, Te.tween)
                }
            } else
                B.isActive && pe !== mt && Ct.restart(!0)
        }).pause()),
        u && (Fw[u] = B),
        v = B.trigger = Hs(v || y !== !0 && y),
        Ot = v && v._gsap && v._gsap.stRevert,
        Ot && (Ot = Ot(B)),
        y = y === !0 ? v : Hs(y),
        go(l) && (l = {
            targets: v,
            className: l
        }),
        y && (S === !1 || S === $o || (S = !S && y.parentNode && y.parentNode.style && el(y.parentNode).display === "flex" ? !1 : Er),
        B.pin = y,
        Ze = Zt.core.getCache(y),
        Ze.spacer ? vt = Ze.pinState : (L && (L = Hs(L),
        L && !L.nodeType && (L = L.current || L.nativeElement),
        Ze.spacerIsNative = !!L,
        L && (Ze.spacerState = rS(L))),
        Ze.spacer = ve = L || Oi.createElement("div"),
        ve.classList.add("pin-spacer"),
        u && ve.classList.add("pin-spacer-" + u),
        Ze.pinState = vt = rS(y)),
        n.force3D !== !1 && Zt.set(y, {
            force3D: !0
        }),
        B.spacer = ve = Ze.spacer,
        _t = el(y),
        Mt = _t[S + P.os2],
        we = Zt.getProperty(y),
        Ce = Zt.quickSetter(y, P.a, zr),
        gE(y, ve, _t),
        j = rS(y)),
        Q) {
            He = Id(Q) ? gN(Q, vN) : vN,
            le = iS("scroller-start", u, V, P, He, 0),
            Pe = iS("scroller-end", u, V, P, He, 0, le),
            Be = le["offset" + P.op.d2];
            var Nt = Hs(ph(V, "content") || V);
            Ne = this.markerStart = iS("start", u, Nt, P, He, Be, 0, z),
            Oe = this.markerEnd = iS("end", u, Nt, P, He, Be, 0, z),
            z && (wt = Zt.quickSetter([Ne, Oe], P.a, zr)),
            !oe && !($u.length && ph(V, "fixedMarkers") === !0) && (Pee(Z ? di : V),
            Zt.set([le, Pe], {
                force3D: !0
            }),
            je = Zt.quickSetter(le, P.a, zr),
            ct = Zt.quickSetter(Pe, P.a, zr))
        }
        if (z) {
            var bt = z.vars.onUpdate
              , Bt = z.vars.onUpdateParams;
            z.eventCallback("onUpdate", function() {
                B.update(0, 0, 1),
                bt && bt.apply(z, Bt || [])
            })
        }
        if (B.previous = function() {
            return Hn[Hn.indexOf(B) - 1]
        }
        ,
        B.next = function() {
            return Hn[Hn.indexOf(B) + 1]
        }
        ,
        B.revert = function(mt, Lt) {
            if (!Lt)
                return B.kill(!0);
            var zt = mt !== !1 || !B.enabled
              , Wt = Na;
            zt !== B.isReverted && (zt && (rt = Math.max(ge(), B.scroll.rec || 0),
            ue = B.progress,
            Ge = i && i.progress()),
            Ne && [Ne, Oe, le, Pe].forEach(function(Ln) {
                return Ln.style.display = zt ? "none" : "block"
            }),
            zt && (Na = B,
            B.update(zt)),
            y && (!O || !B.isActive) && (zt ? Hee(y, ve, vt) : gE(y, ve, el(y), pt)),
            zt || B.update(zt),
            Na = Wt,
            B.isReverted = zt)
        }
        ,
        B.refresh = function(mt, Lt, zt, Wt) {
            if (!((Na || !B.enabled) && !Lt)) {
                if (y && mt && al) {
                    Kr(r, "scrollEnd", HI);
                    return
                }
                !fs && W && W(B),
                Na = B,
                Te.tween && !zt && (Te.tween.kill(),
                Te.tween = 0),
                me && me.pause(),
                T && i && (i.revert({
                    kill: !1
                }).invalidate(),
                i.getChildren && i.getChildren(!0, !0, !1).forEach(function(Jt) {
                    return Jt.vars.immediateRender && Jt.render(0, !0, !0)
                })),
                B.isReverted || B.revert(!0, !0),
                B._subPinOffset = !1;
                var Ln = te(), qt = fe(), Pt = z ? z.duration() : ju(V, P), un = De <= .01 || !De, $t = 0, k = Wt || 0, $ = Id(zt) ? zt.end : n.end, Se = n.endTrigger || v, Ue = Id(zt) ? zt.start : n.start || (n.start === 0 || !v ? 0 : y ? "0 0" : "0 100%"), Fe = B.pinnedContainer = n.pinnedContainer && Hs(n.pinnedContainer, B), Ke = v && Math.max(0, Hn.indexOf(B)) || 0, yt = Ke, G, ce, ye, xe, ne, nt, We, st, ft, Tt, At, Et, Xt;
                for (Q && Id(zt) && (Et = Zt.getProperty(le, P.p),
                Xt = Zt.getProperty(Pe, P.p)); yt-- > 0; )
                    nt = Hn[yt],
                    nt.end || nt.refresh(0, 1) || (Na = B),
                    We = nt.pin,
                    We && (We === v || We === y || We === Fe) && !nt.isReverted && (Tt || (Tt = []),
                    Tt.unshift(nt),
                    nt.revert(!0, !0)),
                    nt !== Hn[yt] && (Ke--,
                    yt--);
                for (za(Ue) && (Ue = Ue(B)),
                Ue = hN(Ue, "start", B),
                re = SN(Ue, v, Ln, P, ge(), Ne, le, B, qt, se, oe, Pt, z, B._startClamp && "_startClamp") || (y ? -.001 : 0),
                za($) && ($ = $(B)),
                go($) && !$.indexOf("+=") && (~$.indexOf(" ") ? $ = (go(Ue) ? Ue.split(" ")[0] : "") + $ : ($t = wS($.substr(2), Ln),
                $ = go(Ue) ? Ue : (z ? Zt.utils.mapRange(0, z.duration(), z.scrollTrigger.start, z.scrollTrigger.end, re) : re) + $t,
                Se = v)),
                $ = hN($, "end", B),
                Le = Math.max(re, SN($ || (Se ? "100% 0" : Pt), Se, Ln, P, ge() + $t, Oe, Pe, B, qt, se, oe, Pt, z, B._endClamp && "_endClamp")) || -.001,
                $t = 0,
                yt = Ke; yt--; )
                    nt = Hn[yt],
                    We = nt.pin,
                    We && nt.start - nt._pinPush <= re && !z && nt.end > 0 && (G = nt.end - (B._startClamp ? Math.max(0, nt.start) : nt.start),
                    (We === v && nt.start - nt._pinPush < re || We === Fe) && isNaN(Ue) && ($t += G * (1 - nt.progress)),
                    We === y && (k += G));
                if (re += $t,
                Le += $t,
                B._startClamp && (B._startClamp += $t),
                B._endClamp && !fs && (B._endClamp = Le || -.001,
                Le = Math.min(Le, ju(V, P))),
                De = Le - re || (re -= .01) && .001,
                un && (ue = Zt.utils.clamp(0, 1, Zt.utils.normalize(re, Le, rt))),
                B._pinPush = k,
                Ne && $t && (G = {},
                G[P.a] = "+=" + $t,
                Fe && (G[P.p] = "-=" + ge()),
                Zt.set([Ne, Oe], G)),
                y && !(Iw && B.end >= ju(V, P)))
                    G = el(y),
                    xe = P === Ir,
                    ye = ge(),
                    it = parseFloat(we(P.a)) + k,
                    !Pt && Le > 1 && (At = (Z ? Oi.scrollingElement || yo : V).style,
                    At = {
                        style: At,
                        value: At["overflow" + P.a.toUpperCase()]
                    },
                    Z && el(di)["overflow" + P.a.toUpperCase()] !== "scroll" && (At.style["overflow" + P.a.toUpperCase()] = "scroll")),
                    gE(y, ve, G),
                    j = rS(y),
                    ce = Wc(y, !0),
                    st = oe && Sh(V, xe ? ms : Ir)(),
                    S ? (pt = [S + P.os2, De + k + zr],
                    pt.t = ve,
                    yt = S === Er ? kb(y, P) + De + k : 0,
                    yt && (pt.push(P.d, yt + zr),
                    ve.style.flexBasis !== "auto" && (ve.style.flexBasis = yt + zr)),
                    dg(pt),
                    Fe && Hn.forEach(function(Jt) {
                        Jt.pin === Fe && Jt.vars.pinSpacing !== !1 && (Jt._subPinOffset = !0)
                    }),
                    oe && ge(rt)) : (yt = kb(y, P),
                    yt && ve.style.flexBasis !== "auto" && (ve.style.flexBasis = yt + zr)),
                    oe && (ne = {
                        top: ce.top + (xe ? ye - re : st) + zr,
                        left: ce.left + (xe ? st : ye - re) + zr,
                        boxSizing: "border-box",
                        position: "fixed"
                    },
                    ne[ap] = ne["max" + Bg] = Math.ceil(ce.width) + zr,
                    ne[sp] = ne["max" + rR] = Math.ceil(ce.height) + zr,
                    ne[$o] = ne[$o + vy] = ne[$o + my] = ne[$o + yy] = ne[$o + gy] = "0",
                    ne[Er] = G[Er],
                    ne[Er + vy] = G[Er + vy],
                    ne[Er + my] = G[Er + my],
                    ne[Er + yy] = G[Er + yy],
                    ne[Er + gy] = G[Er + gy],
                    J = kee(vt, ne, O),
                    fs && ge(0)),
                    i ? (ft = i._initted,
                    fE(1),
                    i.render(i.duration(), !0, !0),
                    lt = we(P.a) - it + De + k,
                    Ye = Math.abs(De - lt) > 1,
                    oe && Ye && J.splice(J.length - 2, 2),
                    i.render(0, !0, !0),
                    ft || i.invalidate(!0),
                    i.parent || i.totalTime(i.totalTime()),
                    fE(0)) : lt = De,
                    At && (At.value ? At.style["overflow" + P.a.toUpperCase()] = At.value : At.style.removeProperty("overflow-" + P.a));
                else if (v && ge() && !z)
                    for (ce = v.parentNode; ce && ce !== di; )
                        ce._pinOffset && (re -= ce._pinOffset,
                        Le -= ce._pinOffset),
                        ce = ce.parentNode;
                Tt && Tt.forEach(function(Jt) {
                    return Jt.revert(!1, !0)
                }),
                B.start = re,
                B.end = Le,
                tt = $e = fs ? rt : ge(),
                !z && !fs && (tt < rt && ge(rt),
                B.scroll.rec = 0),
                B.revert(!1, !0),
                _e = Pa(),
                Ct && (pe = -1,
                Ct.restart(!0)),
                Na = 0,
                i && Y && (i._initted || Ge) && i.progress() !== Ge && i.progress(Ge || 0, !0).render(i.time(), !0, !0),
                (un || ue !== B.progress || z || T || i && !i._initted) && (i && !Y && (i._initted || ue || i.vars.immediateRender !== !1) && i.totalProgress(z && re < -.001 && !ue ? Zt.utils.normalize(re, Le, 0) : ue, !0),
                B.progress = un || (tt - re) / De === ue ? 0 : ue),
                y && S && (ve._pinOffset = Math.round(B.progress * lt)),
                me && me.invalidate(),
                isNaN(Et) || (Et -= Zt.getProperty(le, P.p),
                Xt -= Zt.getProperty(Pe, P.p),
                aS(le, P, Et),
                aS(Ne, P, Et - (Wt || 0)),
                aS(Pe, P, Xt),
                aS(Oe, P, Xt - (Wt || 0))),
                un && !fs && B.update(),
                d && !fs && !Ve && (Ve = !0,
                d(B),
                Ve = !1)
            }
        }
        ,
        B.getVelocity = function() {
            return (ge() - $e) / (Pa() - Bv) * 1e3 || 0
        }
        ,
        B.endAnimation = function() {
            Cv(B.callbackAnimation),
            i && (me ? me.progress(1) : i.paused() ? Y || Cv(i, B.direction < 0, 1) : Cv(i, i.reversed()))
        }
        ,
        B.labelToScroll = function(mt) {
            return i && i.labels && (re || B.refresh() || re) + i.labels[mt] / i.duration() * De || 0
        }
        ,
        B.getTrailing = function(mt) {
            var Lt = Hn.indexOf(B)
              , zt = B.direction > 0 ? Hn.slice(0, Lt).reverse() : Hn.slice(Lt + 1);
            return (go(mt) ? zt.filter(function(Wt) {
                return Wt.vars.preventOverlaps === mt
            }) : zt).filter(function(Wt) {
                return B.direction > 0 ? Wt.end <= re : Wt.start >= Le
            })
        }
        ,
        B.update = function(mt, Lt, zt) {
            if (!(z && !zt && !mt)) {
                var Wt = fs === !0 ? rt : B.scroll(), Ln = mt ? 0 : (Wt - re) / De, qt = Ln < 0 ? 0 : Ln > 1 ? 1 : Ln || 0, Pt = B.progress, un, $t, k, $, Se, Ue, Fe, Ke;
                if (Lt && ($e = tt,
                tt = z ? ge() : Wt,
                R && (Ut = ut,
                ut = i && !Y ? i.totalProgress() : qt)),
                M && y && !Na && !Jx && al && (!qt && re < Wt + (Wt - $e) / (Pa() - Bv) * M ? qt = 1e-4 : qt === 1 && Le > Wt + (Wt - $e) / (Pa() - Bv) * M && (qt = .9999)),
                qt !== Pt && B.enabled) {
                    if (un = B.isActive = !!qt && qt < 1,
                    $t = !!Pt && Pt < 1,
                    Ue = un !== $t,
                    Se = Ue || !!qt != !!Pt,
                    B.direction = qt > Pt ? 1 : -1,
                    B.progress = qt,
                    Se && !Na && (k = qt && !Pt ? 0 : qt === 1 ? 1 : Pt === 1 ? 2 : 3,
                    Y && ($ = !Ue && q[k + 1] !== "none" && q[k + 1] || q[k],
                    Ke = i && ($ === "complete" || $ === "reset" || $ in i))),
                    N && (Ue || Ke) && (Ke || g || !i) && (za(N) ? N(B) : B.getTrailing(N).forEach(function(ye) {
                        return ye.endAnimation()
                    })),
                    Y || (me && !Na && !Jx ? (me._dp._time - me._start !== me._time && me.render(me._dp._time - me._start),
                    me.resetTo ? me.resetTo("totalProgress", qt, i._tTime / i._tDur) : (me.vars.totalProgress = qt,
                    me.invalidate().restart())) : i && i.totalProgress(qt, !!(Na && (_e || mt)))),
                    y) {
                        if (mt && S && (ve.style[S + P.os2] = Mt),
                        !oe)
                            Ce(Iv(it + lt * qt));
                        else if (Se) {
                            if (Fe = !mt && qt > Pt && Le + 1 > Wt && Wt + 1 >= ju(V, P),
                            O)
                                if (!mt && (un || Fe)) {
                                    var yt = Wc(y, !0)
                                      , G = Wt - re;
                                    bN(y, di, yt.top + (P === Ir ? G : 0) + zr, yt.left + (P === Ir ? 0 : G) + zr)
                                } else
                                    bN(y, ve);
                            dg(un || Fe ? J : j),
                            Ye && qt < 1 && un || Ce(it + (qt === 1 && !Fe ? lt : 0))
                        }
                    }
                    R && !Te.tween && !Na && !Jx && Ct.restart(!0),
                    l && (Ue || C && qt && (qt < 1 || !hE)) && $y(l.targets).forEach(function(ye) {
                        return ye.classList[un || C ? "add" : "remove"](l.className)
                    }),
                    s && !Y && !mt && s(B),
                    Se && !Na ? (Y && (Ke && ($ === "complete" ? i.pause().totalProgress(1) : $ === "reset" ? i.restart(!0).pause() : $ === "restart" ? i.restart(!0) : i[$]()),
                    s && s(B)),
                    (Ue || !hE) && (f && Ue && pE(B, f),
                    H[k] && pE(B, H[k]),
                    C && (qt === 1 ? B.kill(!1, 1) : H[k] = 0),
                    Ue || (k = qt === 1 ? 1 : 3,
                    H[k] && pE(B, H[k]))),
                    I && !un && Math.abs(B.getVelocity()) > (Fv(I) ? I : 2500) && (Cv(B.callbackAnimation),
                    me ? me.progress(1) : Cv(i, $ === "reverse" ? 1 : !qt, 1))) : Y && s && !Na && s(B)
                }
                if (ct) {
                    var ce = z ? Wt / z.duration() * (z._caScrollDist || 0) : Wt;
                    je(ce + (le._isFlipped ? 1 : 0)),
                    ct(ce)
                }
                wt && wt(-Wt / z.duration() * (z._caScrollDist || 0))
            }
        }
        ,
        B.enable = function(mt, Lt) {
            B.enabled || (B.enabled = !0,
            Kr(V, "resize", Hv),
            Z || Kr(V, "scroll", Xm),
            W && Kr(r, "refreshInit", W),
            mt !== !1 && (B.progress = ue = 0,
            tt = $e = pe = ge()),
            Lt !== !1 && B.refresh())
        }
        ,
        B.getTween = function(mt) {
            return mt && Te ? Te.tween : me
        }
        ,
        B.setPositions = function(mt, Lt, zt, Wt) {
            if (z) {
                var Ln = z.scrollTrigger
                  , qt = z.duration()
                  , Pt = Ln.end - Ln.start;
                mt = Ln.start + Pt * mt / qt,
                Lt = Ln.start + Pt * Lt / qt
            }
            B.refresh(!1, !1, {
                start: dN(mt, zt && !!B._startClamp),
                end: dN(Lt, zt && !!B._endClamp)
            }, Wt),
            B.update()
        }
        ,
        B.adjustPinSpacing = function(mt) {
            if (pt && mt) {
                var Lt = pt.indexOf(P.d) + 1;
                pt[Lt] = parseFloat(pt[Lt]) + mt + zr,
                pt[1] = parseFloat(pt[1]) + mt + zr,
                dg(pt)
            }
        }
        ,
        B.disable = function(mt, Lt) {
            if (B.enabled && (mt !== !1 && B.revert(!0, !0),
            B.enabled = B.isActive = !1,
            Lt || me && me.pause(),
            rt = 0,
            Ze && (Ze.uncache = 1),
            W && Zr(r, "refreshInit", W),
            Ct && (Ct.pause(),
            Te.tween && Te.tween.kill() && (Te.tween = 0)),
            !Z)) {
                for (var zt = Hn.length; zt--; )
                    if (Hn[zt].scroller === V && Hn[zt] !== B)
                        return;
                Zr(V, "resize", Hv),
                Z || Zr(V, "scroll", Xm)
            }
        }
        ,
        B.kill = function(mt, Lt) {
            B.disable(mt, Lt),
            me && !Lt && me.kill(),
            u && delete Fw[u];
            var zt = Hn.indexOf(B);
            zt >= 0 && Hn.splice(zt, 1),
            zt === cs && CS > 0 && cs--,
            zt = 0,
            Hn.forEach(function(Wt) {
                return Wt.scroller === B.scroller && (zt = 1)
            }),
            zt || fs || (B.scroll.rec = 0),
            i && (i.scrollTrigger = null,
            mt && i.revert({
                kill: !1
            }),
            Lt || i.kill()),
            Ne && [Ne, Oe, le, Pe].forEach(function(Wt) {
                return Wt.parentNode && Wt.parentNode.removeChild(Wt)
            }),
            _y === B && (_y = 0),
            y && (Ze && (Ze.uncache = 1),
            zt = 0,
            Hn.forEach(function(Wt) {
                return Wt.pin === y && zt++
            }),
            zt || (Ze.spacer = 0)),
            n.onKill && n.onKill(B)
        }
        ,
        Hn.push(B),
        B.enable(!1, !1),
        Ot && Ot(B),
        i && i.add && !De) {
            var Gt = B.update;
            B.update = function() {
                B.update = Gt,
                Xn.cache++,
                re || Le || B.refresh()
            }
            ,
            Zt.delayedCall(.01, B.update),
            De = .01,
            re = Le = 0
        } else
            B.refresh();
        y && Fee()
    }
    ,
    r.register = function(n) {
        return Wm || (Zt = n || LI(),
        NI() && window.document && r.enable(),
        Wm = zv),
        Wm
    }
    ,
    r.defaults = function(n) {
        if (n)
            for (var i in n)
                nS[i] = n[i];
        return nS
    }
    ,
    r.disable = function(n, i) {
        zv = 0,
        Hn.forEach(function(s) {
            return s[i ? "kill" : "disable"](n)
        }),
        Zr(Gn, "wheel", Xm),
        Zr(Oi, "scroll", Xm),
        clearInterval(Qx),
        Zr(Oi, "touchcancel", Fu),
        Zr(di, "touchstart", Fu),
        eS(Zr, Oi, "pointerdown,touchstart,mousedown", pN),
        eS(Zr, Oi, "pointerup,touchend,mouseup", mN),
        Hb.kill(),
        $x(Zr);
        for (var a = 0; a < Xn.length; a += 3)
            tS(Zr, Xn[a], Xn[a + 1]),
            tS(Zr, Xn[a], Xn[a + 2])
    }
    ,
    r.enable = function() {
        if (Gn = window,
        Oi = document,
        yo = Oi.documentElement,
        di = Oi.body,
        Zt && ($y = Zt.utils.toArray,
        py = Zt.utils.clamp,
        zw = Zt.core.context || Fu,
        fE = Zt.core.suppressOverwrites || Fu,
        eR = Gn.history.scrollRestoration || "auto",
        Hw = Gn.pageYOffset || 0,
        Zt.core.globals("ScrollTrigger", r),
        di)) {
            zv = 1,
            hg = document.createElement("div"),
            hg.style.height = "100vh",
            hg.style.position = "absolute",
            GI(),
            Oee(),
            yr.register(Zt),
            r.isTouch = yr.isTouch,
            th = yr.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),
            Bw = yr.isTouch === 1,
            Kr(Gn, "wheel", Xm),
            $C = [Gn, Oi, yo, di],
            Zt.matchMedia ? (r.matchMedia = function(f) {
                var d = Zt.matchMedia(), g;
                for (g in f)
                    d.add(g, f[g]);
                return d
            }
            ,
            Zt.addEventListener("matchMediaInit", function() {
                return sR()
            }),
            Zt.addEventListener("matchMediaRevert", function() {
                return VI()
            }),
            Zt.addEventListener("matchMedia", function() {
                qd(0, 1),
                gp("matchMedia")
            }),
            Zt.matchMedia().add("(orientation: portrait)", function() {
                return mE(),
                mE
            })) : console.warn("Requires GSAP 3.11.0 or later"),
            mE(),
            Kr(Oi, "scroll", Xm);
            var n = di.hasAttribute("style"), i = di.style, a = i.borderTopStyle, s = Zt.core.Animation.prototype, l, u;
            for (s.revert || Object.defineProperty(s, "revert", {
                value: function() {
                    return this.time(-.01, !0)
                }
            }),
            i.borderTopStyle = "solid",
            l = Wc(di),
            Ir.m = Math.round(l.top + Ir.sc()) || 0,
            ms.m = Math.round(l.left + ms.sc()) || 0,
            a ? i.borderTopStyle = a : i.removeProperty("border-top-style"),
            n || (di.setAttribute("style", ""),
            di.removeAttribute("style")),
            Qx = setInterval(yN, 250),
            Zt.delayedCall(.5, function() {
                return Jx = 0
            }),
            Kr(Oi, "touchcancel", Fu),
            Kr(di, "touchstart", Fu),
            eS(Kr, Oi, "pointerdown,touchstart,mousedown", pN),
            eS(Kr, Oi, "pointerup,touchend,mouseup", mN),
            Pw = Zt.utils.checkPrefix("transform"),
            RS.push(Pw),
            Wm = Pa(),
            Hb = Zt.delayedCall(.2, qd).pause(),
            Ym = [Oi, "visibilitychange", function() {
                var f = Gn.innerWidth
                  , d = Gn.innerHeight;
                Oi.hidden ? (cN = f,
                fN = d) : (cN !== f || fN !== d) && Hv()
            }
            , Oi, "DOMContentLoaded", qd, Gn, "load", qd, Gn, "resize", Hv],
            $x(Kr),
            Hn.forEach(function(f) {
                return f.enable(0, 1)
            }),
            u = 0; u < Xn.length; u += 3)
                tS(Zr, Xn[u], Xn[u + 1]),
                tS(Zr, Xn[u], Xn[u + 2])
        }
    }
    ,
    r.config = function(n) {
        "limitCallbacks"in n && (hE = !!n.limitCallbacks);
        var i = n.syncInterval;
        i && clearInterval(Qx) || (Qx = i) && setInterval(yN, i),
        "ignoreMobileResize"in n && (Bw = r.isTouch === 1 && n.ignoreMobileResize),
        "autoRefreshEvents"in n && ($x(Zr) || $x(Kr, n.autoRefreshEvents || "none"),
        DI = (n.autoRefreshEvents + "").indexOf("resize") === -1)
    }
    ,
    r.scrollerProxy = function(n, i) {
        var a = Hs(n)
          , s = Xn.indexOf(a)
          , l = pp(a);
        ~s && Xn.splice(s, l ? 6 : 2),
        i && (l ? $u.unshift(Gn, i, di, i, yo, i) : $u.unshift(a, i))
    }
    ,
    r.clearMatchMedia = function(n) {
        Hn.forEach(function(i) {
            return i._ctx && i._ctx.query === n && i._ctx.kill(!0, !0)
        })
    }
    ,
    r.isInViewport = function(n, i, a) {
        var s = (go(n) ? Hs(n) : n).getBoundingClientRect()
          , l = s[a ? ap : sp] * i || 0;
        return a ? s.right - l > 0 && s.left + l < Gn.innerWidth : s.bottom - l > 0 && s.top + l < Gn.innerHeight
    }
    ,
    r.positionInViewport = function(n, i, a) {
        go(n) && (n = Hs(n));
        var s = n.getBoundingClientRect()
          , l = s[a ? ap : sp]
          , u = i == null ? l / 2 : i in Gb ? Gb[i] * l : ~i.indexOf("%") ? parseFloat(i) * l / 100 : parseFloat(i) || 0;
        return a ? (s.left + u) / Gn.innerWidth : (s.top + u) / Gn.innerHeight
    }
    ,
    r.killAll = function(n) {
        if (Hn.slice(0).forEach(function(a) {
            return a.vars.id !== "ScrollSmoother" && a.kill()
        }),
        n !== !0) {
            var i = mp.killAll || [];
            mp = {},
            i.forEach(function(a) {
                return a()
            })
        }
    }
    ,
    r
}();
jn.version = "3.13.0";
jn.saveStyles = function(r) {
    return r ? $y(r).forEach(function(e) {
        if (e && e.style) {
            var t = mo.indexOf(e);
            t >= 0 && mo.splice(t, 5),
            mo.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), Zt.core.getCache(e), zw())
        }
    }) : mo
}
;
jn.revert = function(r, e) {
    return sR(!r, e)
}
;
jn.create = function(r, e) {
    return new jn(r,e)
}
;
jn.refresh = function(r) {
    return r ? Hv(!0) : (Wm || jn.register()) && qd(!0)
}
;
jn.update = function(r) {
    return ++Xn.cache && Kc(r === !0 ? 2 : 0)
}
;
jn.clearScrollMemory = kI;
jn.maxScroll = function(r, e) {
    return ju(r, e ? ms : Ir)
}
;
jn.getScrollFunc = function(r, e) {
    return Sh(Hs(r), e ? ms : Ir)
}
;
jn.getById = function(r) {
    return Fw[r]
}
;
jn.getAll = function() {
    return Hn.filter(function(r) {
        return r.vars.id !== "ScrollSmoother"
    })
}
;
jn.isScrolling = function() {
    return !!al
}
;
jn.snapDirectional = aR;
jn.addEventListener = function(r, e) {
    var t = mp[r] || (mp[r] = []);
    ~t.indexOf(e) || t.push(e)
}
;
jn.removeEventListener = function(r, e) {
    var t = mp[r]
      , n = t && t.indexOf(e);
    n >= 0 && t.splice(n, 1)
}
;
jn.batch = function(r, e) {
    var t = [], n = {}, i = e.interval || .016, a = e.batchMax || 1e9, s = function(f, d) {
        var g = []
          , v = []
          , y = Zt.delayedCall(i, function() {
            d(g, v),
            g = [],
            v = []
        }).pause();
        return function(S) {
            g.length || y.restart(!0),
            g.push(S.trigger),
            v.push(S),
            a <= g.length && y.progress(1)
        }
    }, l;
    for (l in e)
        n[l] = l.substr(0, 2) === "on" && za(e[l]) && l !== "onRefreshInit" ? s(l, e[l]) : e[l];
    return za(a) && (a = a(),
    Kr(jn, "refresh", function() {
        return a = e.batchMax()
    })),
    $y(r).forEach(function(u) {
        var f = {};
        for (l in n)
            f[l] = n[l];
        f.trigger = u,
        t.push(jn.create(f))
    }),
    t
}
;
var TN = function(e, t, n, i) {
    return t > i ? e(i) : t < 0 && e(0),
    n > i ? (i - t) / (n - t) : n < 0 ? t / (t - n) : 1
}, vE = function r(e, t) {
    t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (yr.isTouch ? " pinch-zoom" : "") : "none",
    e === yo && r(di, t)
}, sS = {
    auto: 1,
    scroll: 1
}, Xee = function(e) {
    var t = e.event, n = e.target, i = e.axis, a = (t.changedTouches ? t.changedTouches[0] : t).target, s = a._gsap || Zt.core.getCache(a), l = Pa(), u;
    if (!s._isScrollT || l - s._isScrollT > 2e3) {
        for (; a && a !== di && (a.scrollHeight <= a.clientHeight && a.scrollWidth <= a.clientWidth || !(sS[(u = el(a)).overflowY] || sS[u.overflowX])); )
            a = a.parentNode;
        s._isScroll = a && a !== n && !pp(a) && (sS[(u = el(a)).overflowY] || sS[u.overflowX]),
        s._isScrollT = l
    }
    (s._isScroll || i === "x") && (t.stopPropagation(),
    t._gsapAllow = !0)
}, jI = function(e, t, n, i) {
    return yr.create({
        target: e,
        capture: !0,
        debounce: !1,
        lockAxis: !0,
        type: t,
        onWheel: i = i && Xee,
        onPress: i,
        onDrag: i,
        onScroll: i,
        onEnable: function() {
            return n && Kr(Oi, yr.eventTypes[0], wN, !1, !0)
        },
        onDisable: function() {
            return Zr(Oi, yr.eventTypes[0], wN, !0)
        }
    })
}, jee = /(input|label|select|textarea)/i, EN, wN = function(e) {
    var t = jee.test(e.target.tagName);
    (t || EN) && (e._gsapAllow = !0,
    EN = t)
}, Wee = function(e) {
    Id(e) || (e = {}),
    e.preventDefault = e.isNormalizer = e.allowClicks = !0,
    e.type || (e.type = "wheel,touch"),
    e.debounce = !!e.debounce,
    e.id = e.id || "normalizer";
    var t = e, n = t.normalizeScrollX, i = t.momentum, a = t.allowNestedScroll, s = t.onRelease, l, u, f = Hs(e.target) || yo, d = Zt.core.globals().ScrollSmoother, g = d && d.get(), v = th && (e.content && Hs(e.content) || g && e.content !== !1 && !g.smooth() && g.content()), y = Sh(f, Ir), S = Sh(f, ms), T = 1, M = (yr.isTouch && Gn.visualViewport ? Gn.visualViewport.scale * Gn.visualViewport.width : Gn.outerWidth) / Gn.innerWidth, b = 0, A = za(i) ? function() {
        return i(l)
    }
    : function() {
        return i || 2.8
    }
    , C, R, O = jI(f, e.type, !0, a), L = function() {
        return R = !1
    }, z = Fu, I = Fu, N = function() {
        u = ju(f, Ir),
        I = py(th ? 1 : 0, u),
        n && (z = py(0, ju(f, ms))),
        C = op
    }, P = function() {
        v._gsap.y = Iv(parseFloat(v._gsap.y) + y.offset) + "px",
        v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(v._gsap.y) + ", 0, 1)",
        y.offset = y.cacheID = 0
    }, Y = function() {
        if (R) {
            requestAnimationFrame(L);
            var Q = Iv(l.deltaY / 2)
              , se = I(y.v - Q);
            if (v && se !== y.v + y.offset) {
                y.offset = se - y.v;
                var B = Iv((parseFloat(v && v._gsap.y) || 0) - y.offset);
                v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + B + ", 0, 1)",
                v._gsap.y = B + "px",
                y.cacheID = Xn.cache,
                Kc()
            }
            return !0
        }
        y.offset && P(),
        R = !0
    }, V, K, Z, oe, H = function() {
        N(),
        V.isActive() && V.vars.scrollY > u && (y() > u ? V.progress(1) && y(u) : V.resetTo("scrollY", u))
    };
    return v && Zt.set(v, {
        y: "+=0"
    }),
    e.ignoreCheck = function(q) {
        return th && q.type === "touchmove" && Y() || T > 1.05 && q.type !== "touchstart" || l.isGesturing || q.touches && q.touches.length > 1
    }
    ,
    e.onPress = function() {
        R = !1;
        var q = T;
        T = Iv((Gn.visualViewport && Gn.visualViewport.scale || 1) / M),
        V.pause(),
        q !== T && vE(f, T > 1.01 ? !0 : n ? !1 : "x"),
        K = S(),
        Z = y(),
        N(),
        C = op
    }
    ,
    e.onRelease = e.onGestureStart = function(q, Q) {
        if (y.offset && P(),
        !Q)
            oe.restart(!0);
        else {
            Xn.cache++;
            var se = A(), B, W;
            n && (B = S(),
            W = B + se * .05 * -q.velocityX / .227,
            se *= TN(S, B, W, ju(f, ms)),
            V.vars.scrollX = z(W)),
            B = y(),
            W = B + se * .05 * -q.velocityY / .227,
            se *= TN(y, B, W, ju(f, Ir)),
            V.vars.scrollY = I(W),
            V.invalidate().duration(se).play(.01),
            (th && V.vars.scrollY >= u || B >= u - 1) && Zt.to({}, {
                onUpdate: H,
                duration: se
            })
        }
        s && s(q)
    }
    ,
    e.onWheel = function() {
        V._ts && V.pause(),
        Pa() - b > 1e3 && (C = 0,
        b = Pa())
    }
    ,
    e.onChange = function(q, Q, se, B, W) {
        if (op !== C && N(),
        Q && n && S(z(B[2] === Q ? K + (q.startX - q.x) : S() + Q - B[1])),
        se) {
            y.offset && P();
            var te = W[2] === se
              , fe = te ? Z + q.startY - q.y : y() + se - W[1]
              , pe = I(fe);
            te && fe !== pe && (Z += pe - fe),
            y(pe)
        }
        (se || Q) && Kc()
    }
    ,
    e.onEnable = function() {
        vE(f, n ? !1 : "x"),
        jn.addEventListener("refresh", H),
        Kr(Gn, "resize", H),
        y.smooth && (y.target.style.scrollBehavior = "auto",
        y.smooth = S.smooth = !1),
        O.enable()
    }
    ,
    e.onDisable = function() {
        vE(f, !0),
        Zr(Gn, "resize", H),
        jn.removeEventListener("refresh", H),
        O.kill()
    }
    ,
    e.lockAxis = e.lockAxis !== !1,
    l = new yr(e),
    l.iOS = th,
    th && !y() && y(1),
    th && Zt.ticker.add(Fu),
    oe = l._dc,
    V = Zt.to(l, {
        ease: "power4",
        paused: !0,
        inherit: !1,
        scrollX: n ? "+=0.1" : "+=0",
        scrollY: "+=0.1",
        modifiers: {
            scrollY: XI(y, y(), function() {
                return V.pause()
            })
        },
        onUpdate: Kc,
        onComplete: oe.vars.onComplete
    }),
    l
};
jn.sort = function(r) {
    if (za(r))
        return Hn.sort(r);
    var e = Gn.pageYOffset || 0;
    return jn.getAll().forEach(function(t) {
        return t._sortY = t.trigger ? e + t.trigger.getBoundingClientRect().top : t.start + Gn.innerHeight
    }),
    Hn.sort(r || function(t, n) {
        return (t.vars.refreshPriority || 0) * -1e6 + (t.vars.containerAnimation ? 1e6 : t._sortY) - ((n.vars.containerAnimation ? 1e6 : n._sortY) + (n.vars.refreshPriority || 0) * -1e6)
    }
    )
}
;
jn.observe = function(r) {
    return new yr(r)
}
;
jn.normalizeScroll = function(r) {
    if (typeof r > "u")
        return us;
    if (r === !0 && us)
        return us.enable();
    if (r === !1) {
        us && us.kill(),
        us = r;
        return
    }
    var e = r instanceof yr ? r : Wee(r);
    return us && us.target === e.target && us.kill(),
    pp(e.target) && (us = e),
    e
}
;
jn.core = {
    _getVelocityProp: Lw,
    _inputObserver: jI,
    _scrollers: Xn,
    _proxies: $u,
    bridge: {
        ss: function() {
            al || gp("scrollStart"),
            al = Pa()
        },
        ref: function() {
            return Na
        }
    }
};
LI() && Zt.registerPlugin(jn);
const Yee = ({children: r}) => ae.jsxs("div", {
    className: "relative w-full min-h-screen",
    children: [ae.jsxs(XC, {
        style: {
            position: "fixed",
            top: 400,
            left: 0,
            width: "100vw",
            height: "100vh",
            pointerEvents: "none"
        },
        gl: {
            antialias: !0,
            alpha: !0
        },
        camera: {
            position: [0, 0, 8],
            fov: 65
        },
        children: [ae.jsx("color", {
            attach: "background",
            args: [""]
        }), ae.jsx("ambientLight", {
            intensity: .45
        }), ae.jsx("directionalLight", {
            position: [4, 8, 6],
            intensity: .9
        }), ae.jsx("directionalLight", {
            position: [-6, -8, -4],
            intensity: .35
        }), ae.jsx(SI, {
            preset: "city"
        })]
    }), ae.jsx("div", {
        className: "relative z-10",
        children: r
    })]
});
function qee(r) {
    return Vr({
        attr: {
            viewBox: "0 0 640 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M160 64c0-35.3 28.7-64 64-64L576 0c35.3 0 64 28.7 64 64l0 288c0 35.3-28.7 64-64 64l-239.2 0c-11.8-25.5-29.9-47.5-52.4-64l99.6 0 0-32c0-17.7 14.3-32 32-32l64 0c17.7 0 32 14.3 32 32l0 32 64 0 0-288L224 64l0 49.1C205.2 102.2 183.3 96 160 96l0-32zm0 64a96 96 0 1 1 0 192 96 96 0 1 1 0-192zM133.3 352l53.3 0C260.3 352 320 411.7 320 485.3c0 14.7-11.9 26.7-26.7 26.7L26.7 512C11.9 512 0 500.1 0 485.3C0 411.7 59.7 352 133.3 352z"
            },
            child: []
        }]
    })(r)
}
function Zee(r) {
    return Vr({
        attr: {
            viewBox: "0 0 640 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M323.4 85.2l-96.8 78.4c-16.1 13-19.2 36.4-7 53.1c12.9 17.8 38 21.3 55.3 7.8l99.3-77.2c7-5.4 17-4.2 22.5 2.8s4.2 17-2.8 22.5l-20.9 16.2L512 316.8 512 128l-.7 0-3.9-2.5L434.8 79c-15.3-9.8-33.2-15-51.4-15c-21.8 0-43 7.5-60 21.2zm22.8 124.4l-51.7 40.2C263 274.4 217.3 268 193.7 235.6c-22.2-30.5-16.6-73.1 12.7-96.8l83.2-67.3c-11.6-4.9-24.1-7.4-36.8-7.4C234 64 215.7 69.6 200 80l-72 48 0 224 28.2 0 91.4 83.4c19.6 17.9 49.9 16.5 67.8-3.1c5.5-6.1 9.2-13.2 11.1-20.6l17 15.6c19.5 17.9 49.9 16.6 67.8-2.9c4.5-4.9 7.8-10.6 9.9-16.5c19.4 13 45.8 10.3 62.1-7.5c17.9-19.5 16.6-49.9-2.9-67.8l-134.2-123zM16 128c-8.8 0-16 7.2-16 16L0 352c0 17.7 14.3 32 32 32l32 0c17.7 0 32-14.3 32-32l0-224-80 0zM48 320a16 16 0 1 1 0 32 16 16 0 1 1 0-32zM544 128l0 224c0 17.7 14.3 32 32 32l32 0c17.7 0 32-14.3 32-32l0-208c0-8.8-7.2-16-16-16l-80 0zm32 208a16 16 0 1 1 32 0 16 16 0 1 1 -32 0z"
            },
            child: []
        }]
    })(r)
}
function Kee(r) {
    return Vr({
        attr: {
            viewBox: "0 0 576 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M264.5 5.2c14.9-6.9 32.1-6.9 47 0l218.6 101c8.5 3.9 13.9 12.4 13.9 21.8s-5.4 17.9-13.9 21.8l-218.6 101c-14.9 6.9-32.1 6.9-47 0L45.9 149.8C37.4 145.8 32 137.3 32 128s5.4-17.9 13.9-21.8L264.5 5.2zM476.9 209.6l53.2 24.6c8.5 3.9 13.9 12.4 13.9 21.8s-5.4 17.9-13.9 21.8l-218.6 101c-14.9 6.9-32.1 6.9-47 0L45.9 277.8C37.4 273.8 32 265.3 32 256s5.4-17.9 13.9-21.8l53.2-24.6 152 70.2c23.4 10.8 50.4 10.8 73.8 0l152-70.2zm-152 198.2l152-70.2 53.2 24.6c8.5 3.9 13.9 12.4 13.9 21.8s-5.4 17.9-13.9 21.8l-218.6 101c-14.9 6.9-32.1 6.9-47 0L45.9 405.8C37.4 401.8 32 393.3 32 384s5.4-17.9 13.9-21.8l53.2-24.6 152 70.2c23.4 10.8 50.4 10.8 73.8 0z"
            },
            child: []
        }]
    })(r)
}
function Qee(r) {
    return Vr({
        attr: {
            viewBox: "0 0 384 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M272 384c9.6-31.9 29.5-59.1 49.2-86.2c0 0 0 0 0 0c5.2-7.1 10.4-14.2 15.4-21.4c19.8-28.5 31.4-63 31.4-100.3C368 78.8 289.2 0 192 0S16 78.8 16 176c0 37.3 11.6 71.9 31.4 100.3c5 7.2 10.2 14.3 15.4 21.4c0 0 0 0 0 0c19.8 27.1 39.7 54.4 49.2 86.2l160 0zM192 512c44.2 0 80-35.8 80-80l0-16-160 0 0 16c0 44.2 35.8 80 80 80zM112 176c0 8.8-7.2 16-16 16s-16-7.2-16-16c0-61.9 50.1-112 112-112c8.8 0 16 7.2 16 16s-7.2 16-16 16c-44.2 0-80 35.8-80 80z"
            },
            child: []
        }]
    })(r)
}
function Jee(r) {
    return Vr({
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M78.6 5C69.1-2.4 55.6-1.5 47 7L7 47c-8.5 8.5-9.4 22-2.1 31.6l80 104c4.5 5.9 11.6 9.4 19 9.4l54.1 0 109 109c-14.7 29-10 65.4 14.3 89.6l112 112c12.5 12.5 32.8 12.5 45.3 0l64-64c12.5-12.5 12.5-32.8 0-45.3l-112-112c-24.2-24.2-60.6-29-89.6-14.3l-109-109 0-54.1c0-7.5-3.5-14.5-9.4-19L78.6 5zM19.9 396.1C7.2 408.8 0 426.1 0 444.1C0 481.6 30.4 512 67.9 512c18 0 35.3-7.2 48-19.9L233.7 374.3c-7.8-20.9-9-43.6-3.6-65.1l-61.7-61.7L19.9 396.1zM512 144c0-10.5-1.1-20.7-3.2-30.5c-2.4-11.2-16.1-14.1-24.2-6l-63.9 63.9c-3 3-7.1 4.7-11.3 4.7L352 176c-8.8 0-16-7.2-16-16l0-57.4c0-4.2 1.7-8.3 4.7-11.3l63.9-63.9c8.1-8.1 5.2-21.8-6-24.2C388.7 1.1 378.5 0 368 0C288.5 0 224 64.5 224 144l0 .8 85.3 85.3c36-9.1 75.8 .5 104 28.7L429 274.5c49-23 83-72.8 83-130.5zM56 432a24 24 0 1 1 48 0 24 24 0 1 1 -48 0z"
            },
            child: []
        }]
    })(r)
}
function $ee(r) {
    return Vr({
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M0 416c0 17.7 14.3 32 32 32l54.7 0c12.3 28.3 40.5 48 73.3 48s61-19.7 73.3-48L480 448c17.7 0 32-14.3 32-32s-14.3-32-32-32l-246.7 0c-12.3-28.3-40.5-48-73.3-48s-61 19.7-73.3 48L32 384c-17.7 0-32 14.3-32 32zm128 0a32 32 0 1 1 64 0 32 32 0 1 1 -64 0zM320 256a32 32 0 1 1 64 0 32 32 0 1 1 -64 0zm32-80c-32.8 0-61 19.7-73.3 48L32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l246.7 0c12.3 28.3 40.5 48 73.3 48s61-19.7 73.3-48l54.7 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-54.7 0c-12.3-28.3-40.5-48-73.3-48zM192 128a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm73.3-64C253 35.7 224.8 16 192 16s-61 19.7-73.3 48L32 64C14.3 64 0 78.3 0 96s14.3 32 32 32l86.7 0c12.3 28.3 40.5 48 73.3 48s61-19.7 73.3-48L480 128c17.7 0 32-14.3 32-32s-14.3-32-32-32L265.3 64z"
            },
            child: []
        }]
    })(r)
}
function ete(r) {
    return Vr({
        attr: {
            viewBox: "0 0 576 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M384 64c0-17.7 14.3-32 32-32l128 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-96 0 0 96c0 17.7-14.3 32-32 32l-96 0 0 96c0 17.7-14.3 32-32 32l-96 0 0 96c0 17.7-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32s14.3-32 32-32l96 0 0-96c0-17.7 14.3-32 32-32l96 0 0-96c0-17.7 14.3-32 32-32l96 0 0-96z"
            },
            child: []
        }]
    })(r)
}
function tte(r) {
    return Vr({
        attr: {
            viewBox: "0 0 640 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M96 128a128 128 0 1 1 256 0A128 128 0 1 1 96 128zM0 482.3C0 383.8 79.8 304 178.3 304l91.4 0C368.2 304 448 383.8 448 482.3c0 16.4-13.3 29.7-29.7 29.7L29.7 512C13.3 512 0 498.7 0 482.3zM609.3 512l-137.8 0c5.4-9.4 8.6-20.3 8.6-32l0-8c0-60.7-27.1-115.2-69.8-151.8c2.4-.1 4.7-.2 7.1-.2l61.4 0C567.8 320 640 392.2 640 481.3c0 17-13.8 30.7-30.7 30.7zM432 256c-31 0-59-12.6-79.3-32.9C372.4 196.5 384 163.6 384 128c0-26.8-6.6-52.1-18.3-74.3C384.3 40.1 407.2 32 432 32c61.9 0 112 50.1 112 112s-50.1 112-112 112z"
            },
            child: []
        }]
    })(r)
}
function nte(r) {
    return Vr({
        attr: {
            viewBox: "0 0 640 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M144 0a80 80 0 1 1 0 160A80 80 0 1 1 144 0zM512 0a80 80 0 1 1 0 160A80 80 0 1 1 512 0zM0 298.7C0 239.8 47.8 192 106.7 192l42.7 0c15.9 0 31 3.5 44.6 9.7c-1.3 7.2-1.9 14.7-1.9 22.3c0 38.2 16.8 72.5 43.3 96c-.2 0-.4 0-.7 0L21.3 320C9.6 320 0 310.4 0 298.7zM405.3 320c-.2 0-.4 0-.7 0c26.6-23.5 43.3-57.8 43.3-96c0-7.6-.7-15-1.9-22.3c13.6-6.3 28.7-9.7 44.6-9.7l42.7 0C592.2 192 640 239.8 640 298.7c0 11.8-9.6 21.3-21.3 21.3l-213.3 0zM224 224a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zM128 485.3C128 411.7 187.7 352 261.3 352l117.3 0C452.3 352 512 411.7 512 485.3c0 14.7-11.9 26.7-26.7 26.7l-330.7 0c-14.7 0-26.7-11.9-26.7-26.7z"
            },
            child: []
        }]
    })(r)
}
const Xb = ({extraStyling: r="w-full md:w-1/2 lg:w-1/3", children: e}) => ae.jsx("div", {
    className: `flex flex-col overflow-hidden
        rounded-2xl 
        justify-center align-center items-center
        max-w-full ${r}`,
    children: e
})
  , WI = ({items: r=[], renderItem: e, className: t="", itemClassName: n="", gapClassName: i="gap-6"}) => {
    const a = ln.useRef(null)
      , s = ln.useMemo( () => e ?? (d => d), [e])
      , l = TD(a, {
        amount: .1,
        once: !1
    });
    ln.useEffect( () => {
        console.log(l ? "entered view" : "left view")
    }
    , [l]);
    const u = TD(a, {
        amount: .05,
        margin: "0px 0px 50% 0px",
        once: !1
    })
      , f = {
        hidden: {
            opacity: 0,
            y: 60
        },
        visible: {
            opacity: 1,
            y: 0
        }
    };
    return ae.jsx(Jo.div, {
        ref: a,
        className: `w-full ${t}`,
        variants: f,
        initial: "hidden",
        animate: u ? "visible" : "hidden",
        transition: {
            duration: .6,
            ease: "easeOut"
        },
        children: ae.jsx("div", {
            className: `flex overflow-x-auto snap-x snap-mandatory ${i} pb-4`,
            role: "list",
            children: r.map( (d, g) => ae.jsx(Jo.div, {
                className: `flex-shrink-0 snap-center ${n}`,
                initial: {
                    opacity: .5,
                    y: 50
                },
                whileInView: {
                    opacity: 1,
                    y: 0
                },
                viewport: {
                    amount: .6,
                    once: !0
                },
                transition: {
                    duration: .5,
                    ease: "easeOut"
                },
                role: "listitem",
                children: s(d, g)
            }, d.id ?? g))
        })
    })
}
  , ite = () => {
    const r = [{
        icon: ae.jsx(Qee, {
            className: "text-[var(--light-blue-rgb)] text-2xl"
        }),
        title: "Digital Innovation",
        description: ae.jsx("p", {
            className: "text-white mx-2 text-center max-w-full break-words text-lg",
            children: "An intensive three-week full-stack workshop at Coded was completed, providing exposure to modern development practices and a ship-fast mindset. This toolkit has since been applied to build the Gen Z portfolio site and event-launch microsites, turning ideas into live, measurable products."
        })
    }, {
        icon: ae.jsx(tte, {
            className: "text-[var(--light-blue-rgb)] text-2xl"
        }),
        title: "Customer Centricity",
        description: ae.jsx("p", {
            className: "text-white mx-2 text-center max-w-full break-words text-lg",
            children: "User-driven solutions are designed across Zains digital channels, including Red Bull Mobile and the main digital platform. Feedback, analytics, and rapid iteration are used to reduce friction and deliver intuitive, personal, and dependable experiences at scale."
        })
    }, {
        icon: ae.jsx(Kee, {
            className: "text-[var(--light-blue-rgb)] text-2xl"
        }),
        title: "Agile Mindset",
        description: ae.jsx("p", {
            className: "text-white mx-2 text-center max-w-full break-words text-lg",
            children: "All six team members are Scrum PSM-certified, and Agile practices are applied in day-to-day work. This enables value to be delivered incrementally, rapid responses to change, and the maintenance of clear ownership, transparency, and measurable outcomes across every shipped project."
        })
    }, {
        icon: ae.jsx(ete, {
            className: "text-[var(--light-blue-rgb)] text-2xl"
        }),
        title: "Digital Leadership",
        description: ae.jsx("p", {
            className: "text-white mx-2 text-center max-w-full break-words text-lg",
            children: "Leadership capabilities are being developed through targeted Coursera courses, including UX Design, Project Management, Back-End Applications with Next.js & Express, Excel, Social Impact Strategy, Corporate Communications, and People & Soft Skills."
        })
    }, {
        icon: ae.jsx(Jee, {
            className: "text-[var(--light-blue-rgb)] text-2xl"
        }),
        title: "Technical Excellence",
        description: ae.jsx("p", {
            className: "text-white mx-2 text-center max-w-full break-words text-lg",
            children: "Branded websites showcasing the teams efforts at Zain are actively created, and internal know-how is shared across the organization. This includes the Lean Startup workshop delivered to the digital and commercial teams, through which best practices are turned into repeatable patterns that other teams can adopt."
        })
    }, {
        icon: ae.jsx(Zee, {
            className: "text-[var(--light-blue-rgb)] text-2xl"
        }),
        title: "Collaborative Growth",
        description: ae.jsx("p", {
            className: "text-white mx-2 text-center max-w-full break-words text-lg",
            children: "People are united through workshops, external speakers, and cross-Zain mentorship. Diverse placements enable perspectives to be exchanged, relationships to be strengthened, and collective growth to be achieved in order to deliver better outcomes for users and the organization."
        })
    }];
    return ae.jsxs("section", {
        className: "align-middle justify-center items-center m-5 pb-5",
        children: [ae.jsx("span", {
            children: ae.jsx("h1", {
                className: `text-2xl text-[var(--blue-text)] font-bold md:text-4xl lg:text-5xl
             z-10 px-1 md:px-3 lg:px-5 mb-6 pt-6`,
                children: "10th Edition Program Pillars"
            })
        }), ae.jsx(WI, {
            items: r,
            className: "mt-8",
            itemClassName: "w-3/4 md:w-2/3 lg:w-2/3 max-w-xl",
            renderItem: e => ae.jsxs(Xb, {
                extraStyling: ["h-full w-full justify-start items-center", "bg-[var(--blue-rgb)] px-6 py-8 gap-5 text-center", "shadow-[0_20px_45px_rgba(0,0,0,0.25)]"].join(" "),
                children: [ae.jsx("div", {
                    className: "bg-white rounded-full w-14 h-14 flex items-center justify-center",
                    children: e.icon
                }), ae.jsx("h3", {
                    className: "text-[var(--yellow-rgb)] text-xl font-semibold",
                    children: e.title
                }), ae.jsx("p", {
                    children: e.description
                })]
            })
        })]
    })
}
  , rte = () => {
    const r = [{
        icon: ae.jsx(nte, {
            className: "text-[var(--light-blue-rgb)] text-2xl"
        }),
        title: "Senior Leadership Collaboration",
        description: "Direct collaboration with senior leaders and digital factory squads on strategic initiatives"
    }, {
        icon: ae.jsx(oF, {
            className: "text-[var(--light-blue-rgb)] text-2xl"
        }),
        title: "Real Product Development",
        description: "Hands-on work with Zain's live products and platforms, making meaningful contributions"
    }, {
        icon: ae.jsx($ee, {
            className: "text-[var(--light-blue-rgb)] text-2xl"
        }),
        title: "Intensive Training",
        description: "Participation in high-impact workshops including Agile, Lean Startup, and UI/UX Design"
    }, {
        icon: ae.jsx(qee, {
            className: "text-[var(--light-blue-rgb)] text-2xl"
        }),
        title: "Executive Mentorship",
        description: "Receive direct mentorship from Zains executive team to support your growth and career development"
    }];
    return ae.jsxs("section", {
        id: "targets",
        className: "align-middle justify-center items-center m-5 pb-5",
        children: [ae.jsx("h1", {
            className: `text-2xl text-[var(--blue-text)] font-bold md:text-4xl lg:text-5xl
             z-10 px-1 md:px-3 lg:px-5 mb-6 pt-6`,
            children: "10th Edition Program Targets"
        }), ae.jsx("div", {
            className: "block md:hidden",
            children: ae.jsx(WI, {
                items: r,
                className: "mt-8",
                itemClassName: "w-3/4 md:w-2/3 lg:w-2/3 max-w-xl",
                renderItem: e => ae.jsxs(Xb, {
                    extraStyling: ["h-full w-full text-white justify-start items-center", "bg-[var(--blue-rgb)] px-6 py-8 gap-5 text-center", "shadow-[0_20px_45px_rgba(0,0,0,0.25)]"].join(" "),
                    children: [ae.jsx("div", {
                        className: "bg-white rounded-full w-14 h-14 flex items-center justify-center",
                        children: e.icon
                    }), ae.jsx("h3", {
                        className: "text-[var(--yellow-rgb)] text-2xl font-semibold",
                        children: e.title
                    }), e.description]
                })
            })
        }), ae.jsx("div", {
            className: "hidden md:grid grid-cols-2 gap-6 justify-items-center mt-8 w-full max-w-5xl mx-auto",
            children: r.map( (e, t) => ae.jsxs(Xb, {
                extraStyling: ["h-full w-full text-white justify-start items-center", "bg-[var(--blue-rgb)] px-6 py-8 gap-5 text-center", "shadow-[0_20px_45px_rgba(0,0,0,0.25)]"].join(" "),
                children: [ae.jsx("div", {
                    className: "bg-white rounded-full w-14 h-14 flex items-center justify-center",
                    children: e.icon
                }), ae.jsx("h3", {
                    className: "text-[var(--yellow-rgb)] text-lg font-semibold",
                    children: e.title
                }), e.description]
            }, t))
        })]
    })
}
  , w_ = () => ae.jsxs("div", {
    className: `bottom-0 bg-gradient-to-b w-full
      from-[var(--footer-gradient-start)] 
      to-[var(--footer-gradient-end)] 
      text-[var(--footer-text)] 
      z-50
      
      px-6 py-5`,
    children: [ae.jsxs("div", {
        className: `"max-w-6xl mx-auto flex flex-col 
        md:flex-row justify-between items-start gap-6`,
        children: [ae.jsxs("div", {
            children: [ae.jsx("h4", {
                className: "text-lg font-semibold mb-4",
                children: "Connect with us"
            }), ae.jsxs("div", {
                className: "flex gap-5 text-2xl",
                children: [ae.jsx("a", {
                    href: "https://www.instagram.com/zaingroup?igsh=eWxkYjQ0Y2RqeHV4",
                    target: "_blank",
                    "aria-label": "Instagram",
                    children: ae.jsx(fF, {})
                }), ae.jsx("a", {
                    href: "https://www.facebook.com/share/1EXa4ZBDDN/?mibextid=wwXIfr",
                    "aria-label": "Facebook",
                    target: "_blank",
                    children: ae.jsx(cF, {})
                }), ae.jsx("a", {
                    href: "https://youtube.com/@zain?si=omZkiNzgaiWCR5eM",
                    "aria-label": "YouTube",
                    target: "_blank",
                    children: ae.jsx(dF, {})
                })]
            })]
        }), ae.jsx("div", {
            className: "flex flex-col gap-4 md:items-end w-full md:w-auto"
        })]
    }), ae.jsx("hr", {
        className: "border-gray-100 w-full my-4"
    }), ae.jsx("p", {
        className: "text-center sm:text-left ",
        children: "Copyright  2025 Zain. All Rights Reserved"
    })]
});
function ate({href: r}) {
    const e = de.useRef(null);
    T_( (n, i) => {
        const a = e.current;
        a && (a.rotation.x += i * .8,
        a.rotation.y += i * .6)
    }
    );
    const t = de.useCallback( () => {
        r && window.location.assign(r)
    }
    , [r]);
    return ae.jsx(pI, {
        speed: 1.8,
        rotationIntensity: .4,
        floatIntensity: .9,
        children: ae.jsxs("mesh", {
            ref: e,
            role: "link",
            tabIndex: 0,
            castShadow: !0,
            onClick: n => {
                n.stopPropagation(),
                t()
            }
            ,
            onKeyDown: n => {
                (n.key === "Enter" || n.key === " ") && (n.preventDefault(),
                t())
            }
            ,
            onPointerOver: n => {
                n.stopPropagation(),
                document.body.style.cursor = "pointer"
            }
            ,
            onPointerOut: n => {
                n.stopPropagation(),
                document.body.style.cursor = ""
            }
            ,
            children: [ae.jsx("boxGeometry", {
                args: [1.6, 1.6, 1.6]
            }), ae.jsx("meshStandardMaterial", {
                color: "#f6eb69",
                emissive: "#f6eb69",
                roughness: .3,
                metalness: .3
            })]
        })
    })
}
function ste({href: r="/fun", label: e="Try something fun"}) {
    return ae.jsxs("div", {
        className: "floating-cube-shell m-5 relative h-[40vh] min-h-[320px]",
        children: [ae.jsxs(XC, {
            style: {
                position: "absolute",
                inset: 0
            },
            shadows: !0,
            camera: {
                position: [0, 0, 6],
                fov: 60
            },
            children: [ae.jsx("color", {
                attach: "background",
                args: ["transparent"]
            }), ae.jsx("ambientLight", {
                intensity: .4
            }), ae.jsx("directionalLight", {
                position: [4, 6, 4],
                intensity: 1.2,
                castShadow: !0,
                "shadow-mapSize-width": 1024,
                "shadow-mapSize-height": 1024
            }), ae.jsx("pointLight", {
                position: [-3, -4, -2],
                intensity: .4
            }), ae.jsx(ate, {
                href: r
            }), ae.jsx("mesh", {
                rotation: [-Math.PI / 2, 0, 0],
                position: [0, -2, 0],
                receiveShadow: !0,
                children: ae.jsx("shadowMaterial", {
                    transparent: !0,
                    opacity: .25
                })
            })]
        }), ae.jsx("div", {
            className: "absolute inset-x-0 bottom-4 text-center",
            children: ae.jsx("a", {
                href: r,
                className: "inline-block rounded-full border border-light-blue px-4 py-2 text-sm font-medium  hover:bg-light-blue transition",
                children: e
            })
        })]
    })
}
const YI = "/assets/Group%20Photo%20with%20Javier%20at%20ZINC-DbxcvEj4.JPG"
  , qI = "/assets/Group%20Picnic%20Photo%201-BX4sHaFd.JPG"
  , ZI = "/assets/Rawan%20RBM-BFzufDOR.jpeg"
  , KI = "/assets/CODED%20Ghabga-8QgJfL_a.JPG"
  , QI = "/assets/Us%20Working-DIFE7b5f.JPG"
  , JI = "/assets/Work-life%20balance%20group%20photo%20w%20Sarah%20AlAjmi-C562kNoe.JPG"
  , $I = "/assets/0485b7ee-7d49-4719-9e55-88a63adbd840-Ct8wuf2m.JPG"
  , ote = () => {
    const r = [{
        src: YI,
        alt: "Group Photo with Javier at ZINC"
    }, {
        src: qI,
        alt: "Group Picnic Photo"
    }, {
        src: ZI,
        alt: "Rawan at RB Flying Day"
    }, {
        src: KI,
        alt: "CODED Ghabga"
    }, {
        src: QI,
        alt: "Us working"
    }, {
        src: JI,
        alt: "Work life balance group photo"
    }, {
        src: $I,
        alt: "Candid redbull presentation"
    }];
    return ae.jsxs("section", {
        className: "align-middle justify-center items-center m-5 pb-5",
        children: [ae.jsx("h2", {
            className: `text-2xl text-[var(--blue-text)] font-bold md:text-4xl lg:text-5xl
             z-10 px-1 md:px-3 lg:px-5 mb-6 pt-6`,
            children: "Gallery"
        }), ae.jsx(Aee, {
            images: r
        })]
    })
}
  , lte = () => ae.jsxs(Yee, {
    children: [ae.jsx(Mee, {}), ae.jsx(Tee, {}), ae.jsx(ite, {}), ae.jsx(ste, {
        href: "/fun"
    }), ae.jsx(rte, {}), ae.jsx(ote, {}), ae.jsx(w_, {})]
})
  , ute = "/assets/Sama-ajIzXsnq.jpeg"
  , cte = "/assets/Sami-B8uvx83W.jpeg"
  , fte = "/assets/Sara-DLfTTodB.jpeg"
  , hte = "/assets/Ayah-BOiCucFb.jpeg"
  , dte = "/assets/Nourah-BuM1bHsW.jpeg"
  , pte = "/assets/Rawan-D95hYr1A.jpeg"
  , mte = () => {
    const r = [{
        name: "Sama Arrar",
        degree: "Bachelor of Business Management",
        pictureSrc: ute,
        role: "UX/UI Designer",
        quote: "World"
    }, {
        name: "Rawan Jeraq",
        degree: "Bachelor of Software Engineering",
        pictureSrc: pte,
        role: "Developer",
        quote: "I've spent almost 2600 hours playing The Sims 4"
    }, {
        name: "Sami AlQaddoumi",
        degree: "Bachelor of Aerospace Engineering",
        pictureSrc: cte,
        role: "Product Owner",
        quote: "World"
    }, {
        name: "Nourah AlAyoub",
        degree: "Bachelor of Mechanical Engineering",
        pictureSrc: dte,
        role: "Zain INSURE Apprentice",
        quote: "World"
    }, {
        name: "Ayah AlBahar",
        degree: ae.jsxs(ae.Fragment, {
            children: ["Bachelor of International Relations ", ae.jsx("br", {}), "Master of Prosperity, Innovation and Entrepreneurship"]
        }),
        pictureSrc: hte,
        role: "Digital Performance Apprentice",
        quote: "World"
    }, {
        name: "Sara AlAwwad",
        degree: ae.jsxs(ae.Fragment, {
            children: ["Bachelor of International Relations ", ae.jsx("br", {}), "Master of Diplomacy and Foreign Policy"]
        }),
        pictureSrc: fte,
        role: "Scrum Master | Project Manager",
        quote: "World"
    }];
    return ae.jsx("div", {
        className: "flex flex-wrap gap-3 justify-center",
        children: r.map( (e, t) => ae.jsxs("div", {
            className: `flex flex-col 
            w-1/2 md:w-1/3 lg:w-1/4 p-4
            justify-center items-center mb-3 h-1/2`,
            children: [ae.jsx("img", {
                src: e.pictureSrc,
                alt: e.name,
                className: "w-full rounded-full"
            }), ae.jsx("h2", {
                className: "text-2xl text-center text-[var(--blue-text)]",
                children: e.name
            }), ae.jsx("p", {
                className: "text-center font-bold",
                children: e.role
            }), ae.jsx("p", {
                className: "text-center",
                children: e.degree
            })]
        }, t))
    })
}
  , gte = "/assets/gen_z_2024.original-nt-XkkJl.webp"
  , vte = "/assets/GenZ_23-1.original-2-BlwMBsMq.webp"
  , yte = "/assets/Genz2022.original-DPaVZIhk.webp"
  , _te = "/assets/gen_z_2021-CDN-EkHC.webp"
  , xte = "/assets/gen_z_2020.png__600x384_q85_crop-center_subsampling-2.original-C9x3VqTt.webp"
  , Ste = "/assets/genz2019ambassador-new.original-BpLPb1rF.webp"
  , bte = "/assets/genz2018newambassador.original-2-BNZoEgpJ.webp"
  , Mte = "/assets/genz2017.original-3-Bnv6c156.webp"
  , Tte = "/assets/genz_16_new.original-2-D0QSVvPi.webp"
  , Ete = () => {
    const r = [{
        year: "2024",
        image: gte,
        desc: "",
        achievement: "Focused on supercharging leadership skills and training based on 4 modules: Speak Up and Pitch Up; Strategic Innovation; Green Skills; and Digital World."
    }, {
        year: "2023",
        image: vte,
        desc: "",
        achievement: "Focused on cultivating entrepreneurial mindset that supports Zains 4Sight strategy."
    }, {
        year: "2022",
        image: yte,
        desc: "",
        achievement: "Geared towards cultivating internal entrepreneurs, innovators, and new thinkers who already possess a mindset capable of supporting Zains strategic goals."
    }, {
        year: "2021",
        image: _te,
        desc: "",
        achievement: "Focused on developing digital skills for future data analysts. Addressed the topics of big data, artificial intelligence, and sustainable innovation."
    }, {
        year: "2020",
        image: xte,
        desc: "",
        achievement: "This cycle incorporated three themes: corporate culture, leadership styles, and future trends."
    }, {
        year: "2019",
        image: Ste,
        desc: "",
        achievement: "Enhancing corporate culture and teamwork when managing projects were the main focus of this edition."
    }, {
        year: "2018",
        image: bte,
        desc: "",
        achievement: "Enhancing digital skills such as coding and agile project management in addition to a focus on self-growth and development"
    }, {
        year: "2017",
        image: Mte,
        desc: "",
        achievement: "Centered on establishing a business, gaining entrepreneurial skills, and studying innovative trends in the market"
    }, {
        year: "2016",
        image: Tte,
        desc: "",
        achievement: "Focused on a rotation in different departments throughout Zain Group with an emphasis on conducting research on various digital verticals"
    }]
      , [e,t] = ln.useState(0);
    return ln.useRef(null),
    ln.useRef(null),
    ae.jsxs("div", {
        className: "w-full max-w-full overflow-x-hidden px-4",
        children: [ae.jsx("h1", {
            className: `text-3xl text-[var(--blue-text)] font-bold md:text-5xl lg:text-6xl
             z-10 mb-6 pt-6 px-1 md:px-3 lg:px-5`,
            children: "The Previous Gen Zs"
        }), ae.jsx("div", {
            className: "flex overflow-x-auto gap-3 snap-x snap-mandatory",
            children: r.map( (n, i) => ae.jsxs("div", {
                className: "mb-12 p-6 w-80 flex-shrink-0 snap-center rounded-lg shadow-lg",
                children: [ae.jsxs("h2", {
                    className: "text-2xl font-semibold mb-4",
                    children: ["Gen Z ", n.year]
                }), ae.jsx("div", {
                    className: "mb-4 w-full h-52 md:h-60 lg:h-64 rounded bg-white flex items-center justify-center overflow-hidden",
                    children: ae.jsx("img", {
                        src: n.image,
                        alt: `Gen Z ${n.year}`,
                        className: "max-h-full max-w-full object-contain"
                    })
                }), ae.jsx("p", {
                    className: "text-lg mb-2",
                    children: n.desc
                }), ae.jsxs("p", {
                    className: "text-md font-medium text-blue text-center",
                    children: ["What Made Us Different", " "]
                }), n.achievement && ae.jsx("p", {
                    className: "text-md ",
                    children: n.achievement
                })]
            }, i))
        })]
    })
}
  , wte = () => ae.jsxs("section", {
    className: "flex flex-col justify-center items-center overflow-x-hidden",
    children: [ae.jsx("h1", {
        className: `text-3xl text-[var(--blue-text)] font-bold md:text-5xl lg:text-6xl
             z-10 mb-6 pt-6`,
        children: "Gen Z 2025"
    }), ae.jsx(mte, {}), ae.jsx(Ete, {}), ae.jsx(w_, {})]
})
  , AN = ({extraStyling: r="", imgSrc: e="", imgAlt: t="", imgBgColor: n, children: i}) => {
    const [a,s] = ln.useState(n || "#fff")
      , l = ln.useRef(null)
      , u = ln.useCallback( () => {
        if (!(!l.current || n))
            try {
                const d = l.current
                  , g = document.createElement("canvas")
                  , v = g.getContext("2d");
                if (!v)
                    return;
                const y = 16;
                g.width = y,
                g.height = y,
                v.drawImage(d, 0, 0, y, y);
                const {data: S} = v.getImageData(0, 0, y, y);
                let T = 0
                  , M = 0
                  , b = 0
                  , A = 0;
                for (let C = 0; C < S.length; C += 4)
                    S[C + 3] !== 0 && (T += S[C],
                    M += S[C + 1],
                    b += S[C + 2],
                    A += 1);
                A > 0 && s(`rgb(${Math.round(T / A)}, ${Math.round(M / A)}, ${Math.round(b / A)})`)
            } catch {}
    }
    , [n]);
    return ae.jsxs(Xb, {
        extraStyling: `bg-[var(--white)]  flex flex-col w-full overflow-hidden ${r}`,
        children: [ae.jsx("div", {
            className: "w-full h-[220px] overflow-hidden flex-shrink-0 flex items-center justify-center border border-gray-200 rounded-t-2xl",
            style: {
                backgroundColor: a
            },
            children: ae.jsx("img", {
                ref: l,
                onLoad: u,
                className: "max-h-full max-w-full object-contain",
                src: e,
                alt: t
            })
        }), ae.jsx("div", {
            className: "flex-1 justify-center w-full px-4 py-2 overflow-hidden text-left flex flex-col",
            children: i
        })]
    })
}
  , Ate = ({item: r, onClose: e}) => {
    const t = r.highlights
      , n = r.skills
      , i = ln.useRef();
    ln.useEffect( () => {
        const s = document.body.style.overflow;
        return document.body.style.overflow = "hidden",
        () => {
            document.body.style.overflow = s
        }
    }
    , [e]);
    const a = s => {
        i.current && !i.current.contains(s.target) && e()
    }
    ;
    return ae.jsx("div", {
        className: "fixed px-4 inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50",
        onMouseDown: a,
        "data-lenis-prevent": !0,
        children: ae.jsxs("div", {
            className: "relative bg-white w-full max-w-2xl rounded-2xl shadow-lg p-8 overflow-y-auto max-h-[90vh]",
            ref: i,
            onMouseDown: s => s.stopPropagation(),
            children: [ae.jsx("button", {
                type: "button",
                "aria-label": "Close modal",
                onClick: e,
                className: "absolute top-3 right-3 text-gray-500 hover:text-gray-700",
                children: ae.jsx(NN, {
                    className: "h-6 w-6"
                })
            }), ae.jsx("h2", {
                className: "text-2xl font-bold text-gray-900 mb-2",
                children: r.title
            }), ae.jsxs("div", {
                className: "flex items-center align-baseline text-md text-gray-600 mb-4",
                children: [ae.jsx(kw, {
                    className: "mr-1"
                }), " ", r.dates, ae.jsx("span", {
                    className: "mx-2",
                    children: "|"
                }), ae.jsx(Gw, {
                    className: "mr-1"
                }), " ", r.location]
            }), ae.jsx("p", {
                className: "text-gray-800 text-lg mb-6",
                children: r.description
            }), t && ae.jsxs(ae.Fragment, {
                children: [ae.jsx("h3", {
                    className: "font-semibold text-xl mb-2",
                    children: "Key Highlights:"
                }), ae.jsx("ul", {
                    className: "text-lg list-disc list-inside text-gray-800 mb-6 space-y-1",
                    children: t.map(s => ae.jsx("li", {
                        children: s
                    }))
                })]
            }), ae.jsx("div", {
                className: "grid grid-cols-1 md:grid-cols-2 gap-4 text-sm",
                children: n && n.map(s => ae.jsxs("div", {
                    children: [ae.jsxs("h4", {
                        className: "font-bold text-xl flex items-center mb-2",
                        children: [ae.jsx("span", {
                            className: "mr-2 text-xl",
                            children: s.icon
                        }), " ", s.label]
                    }), ae.jsx("div", {
                        className: "flex flex-wrap gap-2 mb-1",
                        children: s.tools.map(l => ae.jsx("span", {
                            className: "bg-gray-200 px-2 py-1 rounded-full text-md",
                            children: l
                        }))
                    }), ae.jsx("p", {
                        className: "text-gray-700 text-lg",
                        children: s.implementation
                    })]
                }, s.label))
            }), ae.jsx("button", {
                onClick: e,
                className: "mt-6 w-full py-2 bg-[var(--turquoise-rgb)] text-white rounded-xl font-bold",
                children: "Close"
            })]
        })
    })
}
  , Cte = "/assets/codedGroupPhoto-p9sqwvKy.jpg"
  , Rte = "/assets/NOVAGroup-CVO--fmj.jpeg"
  , Dte = "/assets/RBMZGroup--boG80X-.jpeg"
  , Ute = "/assets/a12ed465-63ee-448c-8de1-fed688647d66-DfwE_R7C.JPG"
  , Ote = "/assets/Toastmasters1-BfbOuF19.png"
  , Nte = "/assets/Toastmasters2-D1uLTe6K.png"
  , Lte = "/assets/Toastmasters3-5udUYEQm.png"
  , Pte = "/assets/Speakers2-BvnbOZgJ.jpg"
  , Bte = "/assets/Speakers3-BGZgv1S0.jpg"
  , zte = "/assets/Speakers4-BTO0nITq.jpg"
  , Ite = "/assets/Campllong-CoOpvJ0N.jpg"
  , Fte = "/assets/Huawei-Dq9jOlCy.JPG"
  , Hte = () => {
    const r = [{
        imgSrc: Ite,
        imgAlt: "Group photo of us sitting on the ground of the forest of Spain",
        title: "Gen Z Mental Toughness Challenge in Campllong, Spain",
        dates: "September 15-21 2025",
        location: "Campllong, Spain",
        purpose: "An immersive Mental Toughness Challenge at Campllong designed to push Generation Z participants out of their comfort zones, build resilience, and strengthen teamwork in a demanding natural environment.",
        key_learnings: ["Strengthening trust, teamwork, and communication under pressure.", "Practicing resilience and adaptability in unfamiliar settings.", "Disconnecting from distractions to focus on self-reflection and growth.", "Translating our mental toughness findings into our work at Zain to drive innovation, collaboration, and measurable progress under Zains 4WARD Progress with Purpose corporate strategy strategy."]
    }, {
        imgSrc: Fte,
        imgAlt: "Group photo of the team at Huawei campus",
        title: "Huawei Intensive Training",
        dates: "October 18-25 2025",
        location: "Shenzen, China",
        purpose: "The trip focused on exploring new technologies shaping the future of connectivity. Through Huaweis 4WARD Inspiring Training Program, the Gen Z team learned about AI, cloud computing, and 6G innovation while experiencing Huaweis ecosystem firsthand.",
        key_learnings: ["Learned about Huaweis DeepSeek large model and its role in advancing AI.", "Gained insights into cloud computing and real-world development applications.", "Explored 6G technology and its potential impact on the ICT industry.", "Experienced Huaweis innovation-driven culture through site visits and discussions.", "Reflected on how these global learnings can be applied to support Zains digital transformation journey."]
    }];
    return ae.jsxs("div", {
        className: "relative flex flex-col pt-6 justify-center items-center",
        children: [ae.jsx("h1", {
            className: `text-3xl text-[var(--blue-text)] font-bold md:text-5xl lg:text-6xl
             z-10 mb-6`,
            children: "Our Experiences"
        }), ae.jsxs("div", {
            relative: !0,
            "w-full": !0,
            "max-w-7xl": !0,
            children: [ae.jsx("div", {
                className: "absolute left-[41.7%] top-32 bottom-0 w-0.5 bg-[var(--yellow-rgb)] hidden md:block -translate-x-1/2"
            }), ae.jsx("div", {
                class: "absolute left-[41.1%] top-32 w-4 h-4 rounded-full bg-blue hidden md:block"
            }), r.map( (e, t) => ae.jsxs("section", {
                className: "flex md:flex-row p-1 mb-3 justify-center items-center flex-col",
                children: [ae.jsx("img", {
                    src: e.imgSrc,
                    alt: e.imgAlt,
                    className: "w-full hidden md:w-1/3 h-auto rounded-lg mb-4 md:block"
                }), ae.jsx("div", {
                    class: "flex flex-col items-end mx-8",
                    children: ae.jsx("div", {
                        class: "hidden z-10 w-4 h-4 rounded-full bg-blue"
                    })
                }), ae.jsxs("div", {
                    className: "bg-white w-full md:w-1/2 max-w-2xl rounded-2xl shadow-lg px-3 overflow-y-auto",
                    children: [ae.jsxs("div", {
                        className: "flex items-start gap-1",
                        children: [ae.jsx(kw, {
                            className: "inline text-yellow"
                        }), ae.jsx("p", {
                            className: "text-gray-500 mb-2",
                            children: e.dates
                        })]
                    }), ae.jsx("h2", {
                        className: "text-[var(--blue-rgb)] text-2xl font-bold mb-4",
                        children: e.title
                    }), ae.jsxs("div", {
                        className: "flex items-start gap-1",
                        children: [ae.jsx(Gw, {
                            className: "inline text-yellow"
                        }), ae.jsx("p", {
                            className: "text-gray-500 mb-2",
                            children: e.location
                        })]
                    }), ae.jsx("img", {
                        src: e.imgSrc,
                        alt: e.imgAlt,
                        className: "w-full block md:hidden h-auto rounded-lg mb-4"
                    }), ae.jsx("h3", {
                        className: "text-[var(--blue-rgb)]  font-bold mb-2",
                        children: "Purpose:"
                    }), ae.jsx("p", {
                        className: "text-gray-600 mb-4",
                        children: e.purpose
                    }), ae.jsx("h3", {
                        className: "text-[var(--blue-rgb)]  font-bold mb-2",
                        children: "Key Learnings:"
                    }), ae.jsx("ul", {
                        className: "marker:text-yellow text-gray-600 list-disc list-inside",
                        children: e.key_learnings.map( (n, i) => ae.jsx("li", {
                            className: "text-gray-600",
                            children: n
                        }, i))
                    })]
                }, t)]
            }))]
        }), ae.jsx(w_, {})]
    })
}
  , Vte = () => {
    const r = [{
        imgSrc: Cte,
        title: "CODED: Gen Z Training Program",
        miniDate: "January  February, 2025",
        miniLocation: "CODED",
        dates: "January 12  February 2, 2025",
        location: "CODED, Kuwait",
        description: "Completed an intensive 3-week coding and innovation program at CODED as part of Zains Generation Z initiative. Focused on developing practical skills in web development, Agile methodologies, and UI/UX design to support corporate innovation and digital transformation projects.",
        highlights: ["Gained hands-on experience in HTML, CSS, and JavaScript web development.", "Learned and applied Agile and SCRUM project management methodologies.", "Designed and prototyped user interfaces using Figma.", "Conducted user experience (UX) research and testing.", "Completed a real-world capstone project focused on redesigning and improving the Zain website experience.", "Presented learnings and project outcomes to Zain leadership."],
        skills: [{
            icon: "",
            label: "Website Development",
            tools: ["HTML", "CSS", "JavaScript"],
            implementation: "Built functional websites using core coding languages."
        }, {
            icon: "",
            label: "UI/UX Design",
            tools: ["Figma", "Wireframing Tools"],
            implementation: "Designed user interfaces, created wireframes, and prototyped experiences."
        }, {
            icon: "",
            label: "Project Management",
            tools: ["Agile Methodology", "SCRUM Framework"],
            implementation: "Applied Agile and SCRUM for project planning, sprints, and stand-ups."
        }, {
            icon: "",
            label: "Capstone Project",
            tools: ["Website Redesign for Zain"],
            implementation: "Real-world project focused on improving user experience and accessibility."
        }]
    }, {
        imgSrc: Ute,
        title: "The Lean Startup: Facilitating a Workshop",
        miniDate: "February 19th, 2025",
        miniLocation: "Zain HQ",
        dates: "February 19th, 2025",
        location: "Zain HQ, Kuwait",
        description: "One of the first events that we had launched as a team was the Lean Startup Workshop. It was based on the Lean Startup book, by Eric Ries which details how to successfully launch your own startup by tapping into the creative and practical entreprneurial mindset behavior. As a team, we had organized a 90 minute workshop dedicated to the members who make up the digital and commerical teams, or the digital factory team at Zain Kuwait.",
        highlights: ["We adapted Lean Startup concepts into a condensed, practical format suited for a corporate environment.", "We incorporated exercises on validated learning and continuous iteration.", "Examples from Zains digital channels were used to bring the ideas to life.", "The workshop encouraged open dialogue, with both sides learning from one another.", "Participants explored how to apply the concepts in real projects."],
        skills: [{
            icon: "",
            label: "Technical Presentation Design",
            tools: ["Microsoft PowerPoint", "Miro"],
            implementation: "Created a strong, visually engaging presentation that helped participants grasp concepts without reading the book."
        }, {
            icon: "",
            label: "Interactive Workshop Facilitation",
            tools: ["Mentimeter", "In-person Brainstorming"],
            implementation: "Designed and led interactive activities that kept the session dynamic and participatory."
        }, {
            icon: "",
            label: "Strategic Content Alignment",
            tools: ["Case Studies", "Product Management Processes"],
            implementation: "Linked the books concepts to Zains product management processes to ensure direct relevance."
        }, {
            icon: "",
            label: "Communication & Storytelling",
            tools: ["Simplified Theories", "Relatable Examples"],
            implementation: "Simplified complex theories into relatable examples while fostering collaboration through breakout discussions and idea-sharing."
        }, {
            icon: "",
            label: "Relationship Building",
            tools: ["Collaboration", "Trust-building Activities"],
            implementation: "Built trust and strengthened relationships with participants by combining technical and strategic approaches."
        }]
    }, {
        imgSrc: Rte,
        title: "WE 2030: Women Empowerment Event",
        miniDate: "April 27, 2025",
        miniLocation: "Four Seasons Hotel",
        dates: "April 27, 2025",
        location: "Four Seasons Hotel, Kuwait",
        description: "Planned and executed the Women Empowerment 2030 event for Zain, advancing the companys commitment to gender equality and leadership. Managed event branding, website creation, speaker engagement, and digital campaigns to foster an inclusive and empowering experience.",
        highlights: ["Developed event branding, visual identity, and messaging.", "Designed and managed the official event website.", "Coordinated speaker outreach and event logistics.", "Created and executed social media and media coverage plans.", "Integrated accessibility and inclusive design principles."],
        skills: [{
            icon: "",
            label: "Website Creation and Deployment",
            tools: ["HTML", "CSS"],
            implementation: "Created a website using HTML and CSS for event details and deployed it for the first time, sharing it with Zain Chiefs and CEOs."
        }, {
            icon: "",
            label: "Design & Branding",
            tools: ["Canva", "Adobe Express", "AI Image Generation"],
            implementation: "Used for creating floral and background designs."
        }, {
            icon: "",
            label: "Event Management",
            tools: ["Custom Registration Form", "Internal Zain Tools"],
            implementation: "Manual registration system integrated with website."
        }, {
            icon: "",
            label: "Social Media",
            tools: ["Internal Zain Tools", "Manual Content Creation"],
            implementation: "No external social media management tools used."
        }]
    }, {
        imgSrc: Dte,
        title: "Red Bull Mobile by Zain: Customer Acquisition Plan",
        miniDate: "March 2025 - Present",
        miniLocation: "Zain HQ",
        dates: "March 2025 - Present",
        location: "Zain HQ, Kuwait",
        highlights: ["Conducted a full UX/UI audit of RBMZs digital platforms (app + web), identifying friction points.", "Proposed quick-win features to boost customer satisfaction (e.g., gamified rewards).", "Presented data-backed recommendations to Zains digital team and Red Bulls Austria team, aligning with Gen Z expectations."],
        skills: [{
            icon: "",
            label: "Digital Platform Optimization",
            tools: ["UX/UI Audit", "Wireframing Tools", "Data Analysis"],
            implementation: "Designed disruptive, data-driven campaigns to boost engagement, including vending machines, beach activations, treasure hunts, and pop-up booths."
        }, {
            icon: "",
            label: "Event Activation & Community Building",
            tools: ["Event Coordination", "Community Engagement"],
            implementation: "Contributed to Red Bull Flugtag, testing RBMZs community-building potential and amplifying brand presence through high-energy public events."
        }, {
            icon: "",
            label: "Marketing Strategy & Campaign Design",
            tools: ["Survey Design", "Data Analytics", "Marketing Strategy"],
            implementation: "Surveyed 500+ users to identify engagement gaps and developed disruptive marketing campaigns, including vending machines at Red Bull events, beach culture summer activations, campus treasure hunts, and interactive pop-up booths."
        }]
    }]
      , e = [{
        images: [Pte, Bte, zte],
        title: "Hosting External Speakers",
        description: "Through sessions on politics and wealth disparity, work-life balance, and the science of happiness at work, the speakers equipped the team with holistic insights that advance their development into corporate athletes: professionals who balance well-being, resilience, and critical thinking to perform at their best."
    }, {
        images: [Ote, Nte, Lte],
        title: "Toastmasters Zain Kuwait",
        description: "Launched in June 2025, Zains Toastmasters Club fosters confident, collaborative leaders through clear communication, active listening, and constructive feedback. With 4 sessions and 15+ active members, the club has hosted guest speakers on storytelling and public speaking, creating a safe space for personal and professional growth."
    }]
      , [t,n] = ln.useState(null);
    function i(u) {
        n(u)
    }
    function a() {
        n(null)
    }
    const [s,l] = ln.useState();
    return ln.useEffect( () => {
        const u = () => {
            l({
                width: window.innerWidth,
                height: window.innerHeight
            })
        }
        ;
        return u(),
        window.addEventListener("reHeight", u),
        () => window.removeEventListener("reHeight", u)
    }
    , []),
    ae.jsxs("section", {
        style: {
            minHeight: s ? s.height : "100vh"
        },
        className: "flex flex-1 h-full flex-col justify-center items-center min-h-full",
        children: [ae.jsx("h1", {
            className: `text-3xl text-[var(--blue-text)] font-bold md:text-5xl lg:text-6xl
             z-10 mb-6 pt-6`,
            children: "Our Projects"
        }), ae.jsx("p", {
            className: "px-1 lg:px-6 text-center text-m md:text-l lg:text-xl justify-center w-2/3 ",
            children: "Explore our journey through intensive training and impactful initiatives that showcase our growth and contributions to Zain's digital transformation."
        }), ae.jsx("div", {
            className: "flex flex-wrap md:flex-row gap-4 justify-center items-center mx-4",
            children: r.map( (u, f) => ae.jsxs(ae.Fragment, {
                children: [t && ae.jsx(Ate, {
                    item: t,
                    onClose: a
                }), ae.jsxs(AN, {
                    extraStyling: "pb-2 shadow-md h-[380px] xl-[350px] md:mx-0 sm:w-1/2 lg:w-1/3",
                    imgSrc: u.imgSrc,
                    children: [ae.jsx("p", {
                        className: "text-gray-700 font-semibold text-lg ml-1",
                        children: u.title
                    }), ae.jsxs("div", {
                        className: "flex justify-between gap-3 w-full",
                        children: [ae.jsxs("div", {
                            className: "flex flex-col justify-between gap-3",
                            children: [ae.jsxs("span", {
                                className: "flex align-middle mx-2",
                                children: [ae.jsx(kw, {
                                    className: "text-light-blue text-2xl"
                                }), ae.jsx("p", {
                                    className: "text-m ml-1 font-regular  text-slate-700",
                                    children: u.miniDate
                                })]
                            }), ae.jsxs("span", {
                                className: "flex items-center mx-2",
                                children: [ae.jsx(Gw, {
                                    className: "text-light-blue text-2xl"
                                }), ae.jsx("p", {
                                    className: "text-m ml-1 font-regular  text-slate-700",
                                    children: u.miniLocation
                                })]
                            })]
                        }), ae.jsx(RP, {
                            textColorVar: "--white-text",
                            extraStyling: "bg-[var(--turquoise-rgb)] text-md",
                            onClick: () => i(u),
                            children: "Learn More"
                        })]
                    })]
                }, f)]
            }))
        }), ae.jsx("h2", {
            className: `text-xl text-[var(--blue-text)] font-bold md:text-5xl lg:text-6xl
             z-10 mb-6 pt-6`,
            children: "Our Initiatives"
        }), ae.jsx("div", {
            className: "flex flex-wrap md:flex-row gap-4 justify-center items-center mx-4 mb-3",
            children: e.map( (u, f) => ae.jsxs(AN, {
                extraStyling: "shadow-[0_20px_45px_rgba(0,0,0,0.25)] md:h-[420px] lg:h-[380px] pb-2 w-full  md:basis-[48%] md:max-w-[48%] lg:w-1/3 ",
                imgSrc: u.images[0],
                children: [ae.jsx("p", {
                    className: "text-turquoise font-semibold text-xl ml-1 px-1",
                    children: u.title
                }), ae.jsx("p", {
                    className: "text-gray-700 text-sm font-regular ml-1 px-1",
                    children: u.description
                })]
            }, f))
        }), ae.jsx(w_, {})]
    })
}
  , kte = "/assets/Zain%20Logo%20Colour-cB8vi0qM.jpg"
  , Gte = ({card: r, handleChoice: e, flipped: t, disabled: n}) => {
    const i = () => {
        n || e(r)
    }
    ;
    return ae.jsxs("div", {
        className: "bg-white rounded-lg shadow-md p-4 flex flex-col items-center justify-center",
        children: [ae.jsx("img", {
            src: kte,
            alt: "Front of Card",
            className: `object-fill rounded-lg  ${t ? "hidden" : ""}`,
            onClick: i
        }), ae.jsx("img", {
            src: r.src,
            alt: `Back of Card: ${r.alt}`,
            className: `object-fill rounded-lg  ${t ? "" : "hidden"}`,
            onClick: i
        })]
    }, r.id)
}
;
var yE, CN;
function Xte() {
    if (CN)
        return yE;
    CN = 1;
    var r = {
        linear: function(e, t, n, i) {
            var a = n - t;
            return a * e / i + t
        },
        easeInQuad: function(e, t, n, i) {
            var a = n - t;
            return a * (e /= i) * e + t
        },
        easeOutQuad: function(e, t, n, i) {
            var a = n - t;
            return -a * (e /= i) * (e - 2) + t
        },
        easeInOutQuad: function(e, t, n, i) {
            var a = n - t;
            return (e /= i / 2) < 1 ? a / 2 * e * e + t : -a / 2 * (--e * (e - 2) - 1) + t
        },
        easeInCubic: function(e, t, n, i) {
            var a = n - t;
            return a * (e /= i) * e * e + t
        },
        easeOutCubic: function(e, t, n, i) {
            var a = n - t;
            return a * ((e = e / i - 1) * e * e + 1) + t
        },
        easeInOutCubic: function(e, t, n, i) {
            var a = n - t;
            return (e /= i / 2) < 1 ? a / 2 * e * e * e + t : a / 2 * ((e -= 2) * e * e + 2) + t
        },
        easeInQuart: function(e, t, n, i) {
            var a = n - t;
            return a * (e /= i) * e * e * e + t
        },
        easeOutQuart: function(e, t, n, i) {
            var a = n - t;
            return -a * ((e = e / i - 1) * e * e * e - 1) + t
        },
        easeInOutQuart: function(e, t, n, i) {
            var a = n - t;
            return (e /= i / 2) < 1 ? a / 2 * e * e * e * e + t : -a / 2 * ((e -= 2) * e * e * e - 2) + t
        },
        easeInQuint: function(e, t, n, i) {
            var a = n - t;
            return a * (e /= i) * e * e * e * e + t
        },
        easeOutQuint: function(e, t, n, i) {
            var a = n - t;
            return a * ((e = e / i - 1) * e * e * e * e + 1) + t
        },
        easeInOutQuint: function(e, t, n, i) {
            var a = n - t;
            return (e /= i / 2) < 1 ? a / 2 * e * e * e * e * e + t : a / 2 * ((e -= 2) * e * e * e * e + 2) + t
        },
        easeInSine: function(e, t, n, i) {
            var a = n - t;
            return -a * Math.cos(e / i * (Math.PI / 2)) + a + t
        },
        easeOutSine: function(e, t, n, i) {
            var a = n - t;
            return a * Math.sin(e / i * (Math.PI / 2)) + t
        },
        easeInOutSine: function(e, t, n, i) {
            var a = n - t;
            return -a / 2 * (Math.cos(Math.PI * e / i) - 1) + t
        },
        easeInExpo: function(e, t, n, i) {
            var a = n - t;
            return e == 0 ? t : a * Math.pow(2, 10 * (e / i - 1)) + t
        },
        easeOutExpo: function(e, t, n, i) {
            var a = n - t;
            return e == i ? t + a : a * (-Math.pow(2, -10 * e / i) + 1) + t
        },
        easeInOutExpo: function(e, t, n, i) {
            var a = n - t;
            return e === 0 ? t : e === i ? t + a : (e /= i / 2) < 1 ? a / 2 * Math.pow(2, 10 * (e - 1)) + t : a / 2 * (-Math.pow(2, -10 * --e) + 2) + t
        },
        easeInCirc: function(e, t, n, i) {
            var a = n - t;
            return -a * (Math.sqrt(1 - (e /= i) * e) - 1) + t
        },
        easeOutCirc: function(e, t, n, i) {
            var a = n - t;
            return a * Math.sqrt(1 - (e = e / i - 1) * e) + t
        },
        easeInOutCirc: function(e, t, n, i) {
            var a = n - t;
            return (e /= i / 2) < 1 ? -a / 2 * (Math.sqrt(1 - e * e) - 1) + t : a / 2 * (Math.sqrt(1 - (e -= 2) * e) + 1) + t
        },
        easeInElastic: function(e, t, n, i) {
            var a = n - t, s, l, u;
            return u = 1.70158,
            l = 0,
            s = a,
            e === 0 ? t : (e /= i) === 1 ? t + a : (l || (l = i * .3),
            s < Math.abs(a) ? (s = a,
            u = l / 4) : u = l / (2 * Math.PI) * Math.asin(a / s),
            -(s * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * i - u) * (2 * Math.PI) / l)) + t)
        },
        easeOutElastic: function(e, t, n, i) {
            var a = n - t, s, l, u;
            return u = 1.70158,
            l = 0,
            s = a,
            e === 0 ? t : (e /= i) === 1 ? t + a : (l || (l = i * .3),
            s < Math.abs(a) ? (s = a,
            u = l / 4) : u = l / (2 * Math.PI) * Math.asin(a / s),
            s * Math.pow(2, -10 * e) * Math.sin((e * i - u) * (2 * Math.PI) / l) + a + t)
        },
        easeInOutElastic: function(e, t, n, i) {
            var a = n - t, s, l, u;
            return u = 1.70158,
            l = 0,
            s = a,
            e === 0 ? t : (e /= i / 2) === 2 ? t + a : (l || (l = i * (.3 * 1.5)),
            s < Math.abs(a) ? (s = a,
            u = l / 4) : u = l / (2 * Math.PI) * Math.asin(a / s),
            e < 1 ? -.5 * (s * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * i - u) * (2 * Math.PI) / l)) + t : s * Math.pow(2, -10 * (e -= 1)) * Math.sin((e * i - u) * (2 * Math.PI) / l) * .5 + a + t)
        },
        easeInBack: function(e, t, n, i, a) {
            var s = n - t;
            return a === void 0 && (a = 1.70158),
            s * (e /= i) * e * ((a + 1) * e - a) + t
        },
        easeOutBack: function(e, t, n, i, a) {
            var s = n - t;
            return a === void 0 && (a = 1.70158),
            s * ((e = e / i - 1) * e * ((a + 1) * e + a) + 1) + t
        },
        easeInOutBack: function(e, t, n, i, a) {
            var s = n - t;
            return a === void 0 && (a = 1.70158),
            (e /= i / 2) < 1 ? s / 2 * (e * e * (((a *= 1.525) + 1) * e - a)) + t : s / 2 * ((e -= 2) * e * (((a *= 1.525) + 1) * e + a) + 2) + t
        },
        easeInBounce: function(e, t, n, i) {
            var a = n - t, s;
            return s = r.easeOutBounce(i - e, 0, a, i),
            a - s + t
        },
        easeOutBounce: function(e, t, n, i) {
            var a = n - t;
            return (e /= i) < 1 / 2.75 ? a * (7.5625 * e * e) + t : e < 2 / 2.75 ? a * (7.5625 * (e -= 1.5 / 2.75) * e + .75) + t : e < 2.5 / 2.75 ? a * (7.5625 * (e -= 2.25 / 2.75) * e + .9375) + t : a * (7.5625 * (e -= 2.625 / 2.75) * e + .984375) + t
        },
        easeInOutBounce: function(e, t, n, i) {
            var a = n - t, s;
            return e < i / 2 ? (s = r.easeInBounce(e * 2, 0, a, i),
            s * .5 + t) : (s = r.easeOutBounce(e * 2 - i, 0, a, i),
            s * .5 + a * .5 + t)
        }
    };
    return yE = r,
    yE
}
var jte = Xte();
function Wte(r) {
    return r * Math.PI / 180
}
function po(r, e) {
    return r + Math.random() * (e - r)
}
function Yte(r, e) {
    return Math.floor(r + Math.random() * (e - r + 1))
}
var xy;
(function(r) {
    r[r.Circle = 0] = "Circle",
    r[r.Square = 1] = "Square",
    r[r.Strip = 2] = "Strip"
}
)(xy || (xy = {}));
var ih;
(function(r) {
    r[r.Positive = 1] = "Positive",
    r[r.Negative = -1] = "Negative"
}
)(ih || (ih = {}));
const qte = 1e3 / 60;
class Zte {
    constructor(e, t, n, i) {
        this.getOptions = t;
        const {colors: a, initialVelocityX: s, initialVelocityY: l} = this.getOptions();
        this.context = e,
        this.x = n,
        this.y = i,
        this.w = po(5, 20),
        this.h = po(5, 20),
        this.radius = po(5, 10),
        this.vx = typeof s == "number" ? po(-s, s) : po(s.min, s.max),
        this.vy = typeof l == "number" ? po(-l, 0) : po(l.min, l.max),
        this.shape = Yte(0, 2),
        this.angle = Wte(po(0, 360)),
        this.angularSpin = po(-.2, .2),
        this.color = a[Math.floor(Math.random() * a.length)],
        this.rotateY = po(0, 1),
        this.rotationDirection = po(0, 1) ? ih.Positive : ih.Negative
    }
    update(e) {
        const {gravity: t, wind: n, friction: i, opacity: a, drawShape: s} = this.getOptions()
          , l = e / qte;
        this.x += this.vx * l,
        this.y += this.vy * l,
        this.vy += t * l,
        this.vx += n * l,
        this.vx *= i ** l,
        this.vy *= i ** l,
        this.rotateY >= 1 && this.rotationDirection === ih.Positive ? this.rotationDirection = ih.Negative : this.rotateY <= -1 && this.rotationDirection === ih.Negative && (this.rotationDirection = ih.Positive);
        const u = .1 * this.rotationDirection * l;
        if (this.rotateY += u,
        this.angle += this.angularSpin,
        this.context.save(),
        this.context.translate(this.x, this.y),
        this.context.rotate(this.angle),
        this.context.scale(1, this.rotateY),
        this.context.rotate(this.angle),
        this.context.beginPath(),
        this.context.fillStyle = this.color,
        this.context.strokeStyle = this.color,
        this.context.globalAlpha = a,
        this.context.lineCap = "round",
        this.context.lineWidth = 2,
        s && typeof s == "function")
            s.call(this, this.context);
        else
            switch (this.shape) {
            case xy.Circle:
                {
                    this.context.beginPath(),
                    this.context.arc(0, 0, this.radius, 0, 2 * Math.PI),
                    this.context.fill();
                    break
                }
            case xy.Square:
                {
                    this.context.fillRect(-this.w / 2, -this.h / 2, this.w, this.h);
                    break
                }
            case xy.Strip:
                {
                    this.context.fillRect(-this.w / 6, -this.h / 2, this.w / 3, this.h);
                    break
                }
            }
        this.context.closePath(),
        this.context.restore()
    }
}
class Kte {
    constructor(e, t) {
        this.x = 0,
        this.y = 0,
        this.w = 0,
        this.h = 0,
        this.lastNumberOfPieces = 0,
        this.tweenProgress = 0,
        this.tweenFrom = 0,
        this.particles = [],
        this.particlesGenerated = 0,
        this.removeParticleAt = i => {
            this.particles.splice(i, 1)
        }
        ,
        this.getParticle = () => {
            const i = po(this.x, this.w + this.x)
              , a = po(this.y, this.h + this.y);
            return new Zte(this.context,this.getOptions,i,a)
        }
        ,
        this.animate = i => {
            const {canvas: a, context: s, particlesGenerated: l, lastNumberOfPieces: u} = this
              , {run: f, recycle: d, numberOfPieces: g, debug: v, tweenFunction: y, tweenDuration: S} = this.getOptions();
            if (!f)
                return !1;
            const T = this.particles.length
              , M = d ? T : l;
            if (M < g) {
                u !== g && (this.tweenProgress = 0,
                this.tweenFrom = M,
                this.lastNumberOfPieces = g),
                this.tweenProgress = Math.min(S, Math.max(0, this.tweenProgress + i));
                const b = y(this.tweenProgress, this.tweenFrom, g, S)
                  , A = Math.round(b - M);
                for (let C = 0; C < A; C++)
                    this.particles.push(this.getParticle());
                this.particlesGenerated += A
            }
            v && (s.font = "12px sans-serif",
            s.fillStyle = "#333",
            s.textAlign = "right",
            s.fillText(`Particles: ${T}`, a.width - 10, a.height - 20));
            for (let b = this.particles.length - 1; b >= 0; b--) {
                const A = this.particles[b];
                A.update(i),
                (A.y > a.height || A.y < -100 || A.x > a.width + 100 || A.x < -100) && (d && M <= g ? this.particles[b] = this.getParticle() : this.removeParticleAt(b))
            }
            return T > 0 || M < g
        }
        ,
        this.canvas = e;
        const n = this.canvas.getContext("2d");
        if (!n)
            throw new Error("Could not get canvas context");
        this.context = n,
        this.getOptions = t
    }
}
const oR = {
    width: typeof window < "u" ? window.innerWidth : 300,
    height: typeof window < "u" ? window.innerHeight : 200,
    numberOfPieces: 200,
    friction: .99,
    wind: 0,
    gravity: .1,
    initialVelocityX: 4,
    initialVelocityY: 10,
    colors: ["#f44336", "#e91e63", "#9c27b0", "#673ab7", "#3f51b5", "#2196f3", "#03a9f4", "#00bcd4", "#009688", "#4CAF50", "#8BC34A", "#CDDC39", "#FFEB3B", "#FFC107", "#FF9800", "#FF5722", "#795548"],
    opacity: 1,
    debug: !1,
    tweenFunction: jte.easeInOutQuad,
    tweenDuration: 5e3,
    recycle: !0,
    run: !0
};
class Qte {
    constructor(e, t) {
        this.lastFrameTime = 0,
        this.setOptionsWithDefaults = i => {
            const a = {
                confettiSource: {
                    x: 0,
                    y: 0,
                    w: this.canvas.width,
                    h: 0
                }
            };
            this._options = {
                ...a,
                ...oR,
                ...i
            },
            Object.assign(this, i.confettiSource)
        }
        ,
        this.update = (i=0) => {
            const {options: {run: a, onConfettiComplete: s, frameRate: l}, canvas: u, context: f} = this
              , d = Math.min(i - this.lastFrameTime, 50);
            if (l && d < 1e3 / l) {
                this.rafId = requestAnimationFrame(this.update);
                return
            }
            this.lastFrameTime = i - (l ? d % l : 0),
            a && (f.fillStyle = "white",
            f.clearRect(0, 0, u.width, u.height)),
            this.generator.animate(d) ? this.rafId = requestAnimationFrame(this.update) : (s && typeof s == "function" && this.generator.particlesGenerated > 0 && s.call(this, this),
            this._options.run = !1)
        }
        ,
        this.reset = () => {
            this.generator && this.generator.particlesGenerated > 0 && (this.generator.particlesGenerated = 0,
            this.generator.particles = [],
            this.generator.lastNumberOfPieces = 0)
        }
        ,
        this.stop = () => {
            this.options = {
                run: !1
            },
            this.rafId && (cancelAnimationFrame(this.rafId),
            this.rafId = void 0)
        }
        ,
        this.canvas = e;
        const n = this.canvas.getContext("2d");
        if (!n)
            throw new Error("Could not get canvas context");
        this.context = n,
        this.generator = new Kte(this.canvas, () => this.options),
        this.options = t,
        this.update()
    }
    get options() {
        return this._options
    }
    set options(e) {
        var i, a;
        const t = (i = this._options) == null ? void 0 : i.run
          , n = (a = this._options) == null ? void 0 : a.recycle;
        this.setOptionsWithDefaults(e),
        this.generator && (Object.assign(this.generator, this.options.confettiSource),
        typeof e.recycle == "boolean" && e.recycle && n === !1 && (this.generator.lastNumberOfPieces = this.generator.particles.length)),
        typeof e.run == "boolean" && e.run && t === !1 && this.update()
    }
}
const Jte = ln.createRef();
class lR extends ln.Component {
    constructor(e) {
        super(e),
        this.canvas = ln.createRef(),
        this.canvas = e.canvasRef || Jte
    }
    componentDidMount() {
        if (this.canvas.current) {
            const e = _E(this.props)[0];
            this.confetti = new Qte(this.canvas.current,e)
        }
    }
    componentDidUpdate() {
        const e = _E(this.props)[0];
        this.confetti && (this.confetti.options = e)
    }
    componentWillUnmount() {
        this.confetti && this.confetti.stop(),
        this.confetti = void 0
    }
    render() {
        const [e,t] = _E(this.props)
          , n = {
            zIndex: 2,
            position: "absolute",
            pointerEvents: "none",
            top: 0,
            left: 0,
            bottom: 0,
            right: 0,
            ...t.style
        };
        return ae.jsx("canvas", {
            width: e.width,
            height: e.height,
            ref: this.canvas,
            ...t,
            style: n
        })
    }
}
lR.defaultProps = {
    ...oR
};
lR.displayName = "ReactConfetti";
function _E(r) {
    const e = {}
      , t = {}
      , n = {}
      , i = [...Object.keys(oR), "confettiSource", "drawShape", "onConfettiComplete", "frameRate"]
      , a = ["canvasRef"];
    for (const s in r) {
        const l = r[s];
        i.includes(s) ? e[s] = l : a.includes(s) ? a[s] = l : n[s] = l
    }
    return [e, n, t]
}
const $te = ln.forwardRef( (r, e) => ae.jsx(lR, {
    canvasRef: e,
    ...r
}))
  , ene = () => {
    const r = [{
        src: YI,
        alt: "Group Photo with Javier at ZINC",
        matched: !1
    }, {
        src: qI,
        alt: "Group Picnic Photo",
        matched: !1
    }, {
        src: ZI,
        alt: "Rawan at RB Flying Day",
        matched: !1
    }, {
        src: KI,
        alt: "CODED Ghabga",
        matched: !1
    }, {
        src: QI,
        alt: "Us working",
        matched: !1
    }, {
        src: JI,
        alt: "Work life balance group photo",
        matched: !1
    }, {
        src: $I,
        alt: "Candid redbull presentation",
        matched: !1
    }]
      , [e,t] = ln.useState([])
      , [n,i] = ln.useState(0)
      , [a,s] = ln.useState(null)
      , [l,u] = ln.useState(null)
      , [f,d] = ln.useState(!1)
      , [g,v] = ln.useState(!1)
      , [y,S] = ln.useState({
        width: 0,
        height: 0
    });
    ln.useEffect( () => {
        const b = () => {
            S({
                width: window.innerWidth,
                height: window.innerHeight
            })
        }
        ;
        return b(),
        window.addEventListener("resize", b),
        () => window.removeEventListener("resize", b)
    }
    , []);
    const T = b => {
        a !== null ? u(b) : s(b)
    }
      , M = ln.useCallback( () => {
        const A = [...r.sort( () => Math.random() - .5)].slice(0, 5)
          , C = [...A, ...A].sort( () => Math.random() - .5).map(R => ({
            ...R,
            id: Math.random()
        }));
        t(C),
        i(0),
        s(null),
        u(null),
        v(!1)
    }
    , []);
    return ln.useEffect( () => {
        M()
    }
    , []),
    ln.useEffect( () => {
        const b = () => {
            i(n + 1),
            s(null),
            u(null),
            d(!1)
        }
        ;
        a && l && (d(!0),
        a.src === l.src && (t(A => A.map(C => C.src === a.src ? {
            ...C,
            matched: !0
        } : C)),
        e.every(A => A.matched) && (v(!0),
        setTimeout( () => {
            M(),
            v(!1)
        }
        , 3e3))),
        setTimeout( () => b(), 1e3))
    }
    , [a, l]),
    ln.useEffect( () => {
        e.length > 0 && e.every(b => b.matched) && (v(!0),
        setTimeout( () => {
            M()
        }
        , 5e3))
    }
    , [e]),
    ae.jsxs("div", {
        className: "flex flex-col justify-center items-center mb-3",
        children: [g && ae.jsx($te, {
            width: y.width,
            height: y.height
        }), ae.jsx("h1", {
            className: `text-2xl text-[var(--blue-text)] font-bold md:text-3xl
             z-10 mb-6 pt-6 text-center`,
            children: "Have some fun and check out our journey as Gen Zs!"
        }), ae.jsx(RP, {
            bgColorVar: "--yellow-rgb",
            textColorVar: "--black-text",
            onClick: M,
            children: ae.jsx("p", {
                className: "font-normal text-xl text-gray-700",
                children: "New Game"
            })
        }), ae.jsxs("div", {
            className: "flex",
            children: [ae.jsxs("h2", {
                className: `text-xl  md:text-5xl lg:text-6xl
             z-10 mb-6 pt-6 text-center`,
                children: [" ", "Turns: ", "     "]
            }), ae.jsxs("h2", {
                className: `text-xl  md:text-5xl lg:text-6xl
             z-10 mb-6 pt-6 text-center text-[var(--blue-rgb)]`,
                children: [" ", n, " "]
            })]
        }), ae.jsx("div", {
            className: "grid grid-cols-2 md:grid-cols-5 gap-3 mx-2",
            children: e.map( (b, A) => ae.jsx(Gte, {
                card: b,
                handleChoice: T,
                flipped: b === a || b === l || b.matched,
                disabled: f
            }, A))
        }), ae.jsx(w_, {})]
    })
}
;
var tne = "1.3.14";
function e5(r, e, t) {
    return Math.max(r, Math.min(e, t))
}
function nne(r, e, t) {
    return (1 - t) * r + t * e
}
function ine(r, e, t, n) {
    return nne(r, e, 1 - Math.exp(-t * n))
}
function rne(r, e) {
    return (r % e + e) % e
}
var ane = class {
    constructor() {
        rn(this, "isRunning", !1);
        rn(this, "value", 0);
        rn(this, "from", 0);
        rn(this, "to", 0);
        rn(this, "currentTime", 0);
        rn(this, "lerp");
        rn(this, "duration");
        rn(this, "easing");
        rn(this, "onUpdate")
    }
    advance(r) {
        var t;
        if (!this.isRunning)
            return;
        let e = !1;
        if (this.duration && this.easing) {
            this.currentTime += r;
            const n = e5(0, this.currentTime / this.duration, 1);
            e = n >= 1;
            const i = e ? 1 : this.easing(n);
            this.value = this.from + (this.to - this.from) * i
        } else
            this.lerp ? (this.value = ine(this.value, this.to, this.lerp * 60, r),
            Math.round(this.value) === this.to && (this.value = this.to,
            e = !0)) : (this.value = this.to,
            e = !0);
        e && this.stop(),
        (t = this.onUpdate) == null || t.call(this, this.value, e)
    }
    stop() {
        this.isRunning = !1
    }
    fromTo(r, e, {lerp: t, duration: n, easing: i, onStart: a, onUpdate: s}) {
        this.from = this.value = r,
        this.to = e,
        this.lerp = t,
        this.duration = n,
        this.easing = i,
        this.currentTime = 0,
        this.isRunning = !0,
        a == null || a(),
        this.onUpdate = s
    }
}
;
function sne(r, e) {
    let t;
    return function(...n) {
        let i = this;
        clearTimeout(t),
        t = setTimeout( () => {
            t = void 0,
            r.apply(i, n)
        }
        , e)
    }
}
var one = class {
    constructor(r, e, {autoResize: t=!0, debounce: n=250}={}) {
        rn(this, "width", 0);
        rn(this, "height", 0);
        rn(this, "scrollHeight", 0);
        rn(this, "scrollWidth", 0);
        rn(this, "debouncedResize");
        rn(this, "wrapperResizeObserver");
        rn(this, "contentResizeObserver");
        rn(this, "resize", () => {
            this.onWrapperResize(),
            this.onContentResize()
        }
        );
        rn(this, "onWrapperResize", () => {
            this.wrapper instanceof Window ? (this.width = window.innerWidth,
            this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth,
            this.height = this.wrapper.clientHeight)
        }
        );
        rn(this, "onContentResize", () => {
            this.wrapper instanceof Window ? (this.scrollHeight = this.content.scrollHeight,
            this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight,
            this.scrollWidth = this.wrapper.scrollWidth)
        }
        );
        this.wrapper = r,
        this.content = e,
        t && (this.debouncedResize = sne(this.resize, n),
        this.wrapper instanceof Window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize),
        this.wrapperResizeObserver.observe(this.wrapper)),
        this.contentResizeObserver = new ResizeObserver(this.debouncedResize),
        this.contentResizeObserver.observe(this.content)),
        this.resize()
    }
    destroy() {
        var r, e;
        (r = this.wrapperResizeObserver) == null || r.disconnect(),
        (e = this.contentResizeObserver) == null || e.disconnect(),
        this.wrapper === window && this.debouncedResize && window.removeEventListener("resize", this.debouncedResize, !1)
    }
    get limit() {
        return {
            x: this.scrollWidth - this.width,
            y: this.scrollHeight - this.height
        }
    }
}
  , t5 = class {
    constructor() {
        rn(this, "events", {})
    }
    emit(r, ...e) {
        var n;
        let t = this.events[r] || [];
        for (let i = 0, a = t.length; i < a; i++)
            (n = t[i]) == null || n.call(t, ...e)
    }
    on(r, e) {
        var t;
        return (t = this.events[r]) != null && t.push(e) || (this.events[r] = [e]),
        () => {
            var n;
            this.events[r] = (n = this.events[r]) == null ? void 0 : n.filter(i => e !== i)
        }
    }
    off(r, e) {
        var t;
        this.events[r] = (t = this.events[r]) == null ? void 0 : t.filter(n => e !== n)
    }
    destroy() {
        this.events = {}
    }
}
  , RN = 100 / 6
  , Jf = {
    passive: !1
}
  , lne = class {
    constructor(r, e={
        wheelMultiplier: 1,
        touchMultiplier: 1
    }) {
        rn(this, "touchStart", {
            x: 0,
            y: 0
        });
        rn(this, "lastDelta", {
            x: 0,
            y: 0
        });
        rn(this, "window", {
            width: 0,
            height: 0
        });
        rn(this, "emitter", new t5);
        rn(this, "onTouchStart", r => {
            const {clientX: e, clientY: t} = r.targetTouches ? r.targetTouches[0] : r;
            this.touchStart.x = e,
            this.touchStart.y = t,
            this.lastDelta = {
                x: 0,
                y: 0
            },
            this.emitter.emit("scroll", {
                deltaX: 0,
                deltaY: 0,
                event: r
            })
        }
        );
        rn(this, "onTouchMove", r => {
            const {clientX: e, clientY: t} = r.targetTouches ? r.targetTouches[0] : r
              , n = -(e - this.touchStart.x) * this.options.touchMultiplier
              , i = -(t - this.touchStart.y) * this.options.touchMultiplier;
            this.touchStart.x = e,
            this.touchStart.y = t,
            this.lastDelta = {
                x: n,
                y: i
            },
            this.emitter.emit("scroll", {
                deltaX: n,
                deltaY: i,
                event: r
            })
        }
        );
        rn(this, "onTouchEnd", r => {
            this.emitter.emit("scroll", {
                deltaX: this.lastDelta.x,
                deltaY: this.lastDelta.y,
                event: r
            })
        }
        );
        rn(this, "onWheel", r => {
            let {deltaX: e, deltaY: t, deltaMode: n} = r;
            const i = n === 1 ? RN : n === 2 ? this.window.width : 1
              , a = n === 1 ? RN : n === 2 ? this.window.height : 1;
            e *= i,
            t *= a,
            e *= this.options.wheelMultiplier,
            t *= this.options.wheelMultiplier,
            this.emitter.emit("scroll", {
                deltaX: e,
                deltaY: t,
                event: r
            })
        }
        );
        rn(this, "onWindowResize", () => {
            this.window = {
                width: window.innerWidth,
                height: window.innerHeight
            }
        }
        );
        this.element = r,
        this.options = e,
        window.addEventListener("resize", this.onWindowResize, !1),
        this.onWindowResize(),
        this.element.addEventListener("wheel", this.onWheel, Jf),
        this.element.addEventListener("touchstart", this.onTouchStart, Jf),
        this.element.addEventListener("touchmove", this.onTouchMove, Jf),
        this.element.addEventListener("touchend", this.onTouchEnd, Jf)
    }
    on(r, e) {
        return this.emitter.on(r, e)
    }
    destroy() {
        this.emitter.destroy(),
        window.removeEventListener("resize", this.onWindowResize, !1),
        this.element.removeEventListener("wheel", this.onWheel, Jf),
        this.element.removeEventListener("touchstart", this.onTouchStart, Jf),
        this.element.removeEventListener("touchmove", this.onTouchMove, Jf),
        this.element.removeEventListener("touchend", this.onTouchEnd, Jf)
    }
}
  , DN = r => Math.min(1, 1.001 - Math.pow(2, -10 * r))
  , une = class {
    constructor({wrapper: r=window, content: e=document.documentElement, eventsTarget: t=r, smoothWheel: n=!0, syncTouch: i=!1, syncTouchLerp: a=.075, touchInertiaExponent: s=1.7, duration: l, easing: u, lerp: f=.1, infinite: d=!1, orientation: g="vertical", gestureOrientation: v=g === "horizontal" ? "both" : "vertical", touchMultiplier: y=1, wheelMultiplier: S=1, autoResize: T=!0, prevent: M, virtualScroll: b, overscroll: A=!0, autoRaf: C=!1, anchors: R=!1, autoToggle: O=!1, allowNestedScroll: L=!1, __experimental__naiveDimensions: z=!1}={}) {
        rn(this, "_isScrolling", !1);
        rn(this, "_isStopped", !1);
        rn(this, "_isLocked", !1);
        rn(this, "_preventNextNativeScrollEvent", !1);
        rn(this, "_resetVelocityTimeout", null);
        rn(this, "__rafID", null);
        rn(this, "isTouching");
        rn(this, "time", 0);
        rn(this, "userData", {});
        rn(this, "lastVelocity", 0);
        rn(this, "velocity", 0);
        rn(this, "direction", 0);
        rn(this, "options");
        rn(this, "targetScroll");
        rn(this, "animatedScroll");
        rn(this, "animate", new ane);
        rn(this, "emitter", new t5);
        rn(this, "dimensions");
        rn(this, "virtualScroll");
        rn(this, "onScrollEnd", r => {
            r instanceof CustomEvent || (this.isScrolling === "smooth" || this.isScrolling === !1) && r.stopPropagation()
        }
        );
        rn(this, "dispatchScrollendEvent", () => {
            this.options.wrapper.dispatchEvent(new CustomEvent("scrollend",{
                bubbles: this.options.wrapper === window,
                detail: {
                    lenisScrollEnd: !0
                }
            }))
        }
        );
        rn(this, "onTransitionEnd", r => {
            if (r.propertyName.includes("overflow")) {
                const e = this.isHorizontal ? "overflow-x" : "overflow-y"
                  , t = getComputedStyle(this.rootElement)[e];
                ["hidden", "clip"].includes(t) ? this.internalStop() : this.internalStart()
            }
        }
        );
        rn(this, "onClick", r => {
            const t = r.composedPath().find(n => {
                var i;
                return n instanceof HTMLAnchorElement && ((i = n.getAttribute("href")) == null ? void 0 : i.includes("#"))
            }
            );
            if (t) {
                const n = t.getAttribute("href");
                if (n) {
                    const i = typeof this.options.anchors == "object" && this.options.anchors ? this.options.anchors : void 0
                      , a = `#${n.split("#")[1]}`;
                    this.scrollTo(a, i)
                }
            }
        }
        );
        rn(this, "onPointerDown", r => {
            r.button === 1 && this.reset()
        }
        );
        rn(this, "onVirtualScroll", r => {
            if (typeof this.options.virtualScroll == "function" && this.options.virtualScroll(r) === !1)
                return;
            const {deltaX: e, deltaY: t, event: n} = r;
            if (this.emitter.emit("virtual-scroll", {
                deltaX: e,
                deltaY: t,
                event: n
            }),
            n.ctrlKey || n.lenisStopPropagation)
                return;
            const i = n.type.includes("touch")
              , a = n.type.includes("wheel");
            this.isTouching = n.type === "touchstart" || n.type === "touchmove";
            const s = e === 0 && t === 0;
            if (this.options.syncTouch && i && n.type === "touchstart" && s && !this.isStopped && !this.isLocked) {
                this.reset();
                return
            }
            const u = this.options.gestureOrientation === "vertical" && t === 0 || this.options.gestureOrientation === "horizontal" && e === 0;
            if (s || u)
                return;
            let f = n.composedPath();
            f = f.slice(0, f.indexOf(this.rootElement));
            const d = this.options.prevent;
            if (f.find(M => {
                var b, A, C;
                return M instanceof HTMLElement && (typeof d == "function" && (d == null ? void 0 : d(M)) || ((b = M.hasAttribute) == null ? void 0 : b.call(M, "data-lenis-prevent")) || i && ((A = M.hasAttribute) == null ? void 0 : A.call(M, "data-lenis-prevent-touch")) || a && ((C = M.hasAttribute) == null ? void 0 : C.call(M, "data-lenis-prevent-wheel")) || this.options.allowNestedScroll && this.checkNestedScroll(M, {
                    deltaX: e,
                    deltaY: t
                }))
            }
            ))
                return;
            if (this.isStopped || this.isLocked) {
                n.cancelable && n.preventDefault();
                return
            }
            if (!(this.options.syncTouch && i || this.options.smoothWheel && a)) {
                this.isScrolling = "native",
                this.animate.stop(),
                n.lenisStopPropagation = !0;
                return
            }
            let v = t;
            this.options.gestureOrientation === "both" ? v = Math.abs(t) > Math.abs(e) ? t : e : this.options.gestureOrientation === "horizontal" && (v = e),
            (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && this.limit > 0 && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && t > 0 || this.animatedScroll === this.limit && t < 0)) && (n.lenisStopPropagation = !0),
            n.cancelable && n.preventDefault();
            const y = i && this.options.syncTouch
              , T = i && n.type === "touchend";
            T && (v = Math.sign(this.velocity) * Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent)),
            this.scrollTo(this.targetScroll + v, {
                programmatic: !1,
                ...y ? {
                    lerp: T ? this.options.syncTouchLerp : 1
                } : {
                    lerp: this.options.lerp,
                    duration: this.options.duration,
                    easing: this.options.easing
                }
            })
        }
        );
        rn(this, "onNativeScroll", () => {
            if (this._resetVelocityTimeout !== null && (clearTimeout(this._resetVelocityTimeout),
            this._resetVelocityTimeout = null),
            this._preventNextNativeScrollEvent) {
                this._preventNextNativeScrollEvent = !1;
                return
            }
            if (this.isScrolling === !1 || this.isScrolling === "native") {
                const r = this.animatedScroll;
                this.animatedScroll = this.targetScroll = this.actualScroll,
                this.lastVelocity = this.velocity,
                this.velocity = this.animatedScroll - r,
                this.direction = Math.sign(this.animatedScroll - r),
                this.isStopped || (this.isScrolling = "native"),
                this.emit(),
                this.velocity !== 0 && (this._resetVelocityTimeout = setTimeout( () => {
                    this.lastVelocity = this.velocity,
                    this.velocity = 0,
                    this.isScrolling = !1,
                    this.emit()
                }
                , 400))
            }
        }
        );
        rn(this, "raf", r => {
            const e = r - (this.time || r);
            this.time = r,
            this.animate.advance(e * .001),
            this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf))
        }
        );
        window.lenisVersion = tne,
        (!r || r === document.documentElement) && (r = window),
        typeof l == "number" && typeof u != "function" ? u = DN : typeof u == "function" && typeof l != "number" && (l = 1),
        this.options = {
            wrapper: r,
            content: e,
            eventsTarget: t,
            smoothWheel: n,
            syncTouch: i,
            syncTouchLerp: a,
            touchInertiaExponent: s,
            duration: l,
            easing: u,
            lerp: f,
            infinite: d,
            gestureOrientation: v,
            orientation: g,
            touchMultiplier: y,
            wheelMultiplier: S,
            autoResize: T,
            prevent: M,
            virtualScroll: b,
            overscroll: A,
            autoRaf: C,
            anchors: R,
            autoToggle: O,
            allowNestedScroll: L,
            __experimental__naiveDimensions: z
        },
        this.dimensions = new one(r,e,{
            autoResize: T
        }),
        this.updateClassName(),
        this.targetScroll = this.animatedScroll = this.actualScroll,
        this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1),
        this.options.wrapper.addEventListener("scrollend", this.onScrollEnd, {
            capture: !0
        }),
        this.options.anchors && this.options.wrapper === window && this.options.wrapper.addEventListener("click", this.onClick, !1),
        this.options.wrapper.addEventListener("pointerdown", this.onPointerDown, !1),
        this.virtualScroll = new lne(t,{
            touchMultiplier: y,
            wheelMultiplier: S
        }),
        this.virtualScroll.on("scroll", this.onVirtualScroll),
        this.options.autoToggle && this.rootElement.addEventListener("transitionend", this.onTransitionEnd, {
            passive: !0
        }),
        this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf))
    }
    destroy() {
        this.emitter.destroy(),
        this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1),
        this.options.wrapper.removeEventListener("scrollend", this.onScrollEnd, {
            capture: !0
        }),
        this.options.wrapper.removeEventListener("pointerdown", this.onPointerDown, !1),
        this.options.anchors && this.options.wrapper === window && this.options.wrapper.removeEventListener("click", this.onClick, !1),
        this.virtualScroll.destroy(),
        this.dimensions.destroy(),
        this.cleanUpClassName(),
        this.__rafID && cancelAnimationFrame(this.__rafID)
    }
    on(r, e) {
        return this.emitter.on(r, e)
    }
    off(r, e) {
        return this.emitter.off(r, e)
    }
    setScroll(r) {
        this.isHorizontal ? this.options.wrapper.scrollTo({
            left: r,
            behavior: "instant"
        }) : this.options.wrapper.scrollTo({
            top: r,
            behavior: "instant"
        })
    }
    resize() {
        this.dimensions.resize(),
        this.animatedScroll = this.targetScroll = this.actualScroll,
        this.emit()
    }
    emit() {
        this.emitter.emit("scroll", this)
    }
    reset() {
        this.isLocked = !1,
        this.isScrolling = !1,
        this.animatedScroll = this.targetScroll = this.actualScroll,
        this.lastVelocity = this.velocity = 0,
        this.animate.stop()
    }
    start() {
        if (this.isStopped) {
            if (this.options.autoToggle) {
                this.rootElement.style.removeProperty("overflow");
                return
            }
            this.internalStart()
        }
    }
    internalStart() {
        this.isStopped && (this.reset(),
        this.isStopped = !1,
        this.emit())
    }
    stop() {
        if (!this.isStopped) {
            if (this.options.autoToggle) {
                this.rootElement.style.setProperty("overflow", "clip");
                return
            }
            this.internalStop()
        }
    }
    internalStop() {
        this.isStopped || (this.reset(),
        this.isStopped = !0,
        this.emit())
    }
    scrollTo(r, {offset: e=0, immediate: t=!1, lock: n=!1, duration: i=this.options.duration, easing: a=this.options.easing, lerp: s=this.options.lerp, onStart: l, onComplete: u, force: f=!1, programmatic: d=!0, userData: g}={}) {
        if (!((this.isStopped || this.isLocked) && !f)) {
            if (typeof r == "string" && ["top", "left", "start", "#"].includes(r))
                r = 0;
            else if (typeof r == "string" && ["bottom", "right", "end"].includes(r))
                r = this.limit;
            else {
                let v;
                if (typeof r == "string" ? (v = document.querySelector(r),
                v || (r === "#top" ? r = 0 : console.warn("Lenis: Target not found", r))) : r instanceof HTMLElement && (r != null && r.nodeType) && (v = r),
                v) {
                    if (this.options.wrapper !== window) {
                        const S = this.rootElement.getBoundingClientRect();
                        e -= this.isHorizontal ? S.left : S.top
                    }
                    const y = v.getBoundingClientRect();
                    r = (this.isHorizontal ? y.left : y.top) + this.animatedScroll
                }
            }
            if (typeof r == "number") {
                if (r += e,
                r = Math.round(r),
                this.options.infinite) {
                    if (d) {
                        this.targetScroll = this.animatedScroll = this.scroll;
                        const v = r - this.animatedScroll;
                        v > this.limit / 2 ? r = r - this.limit : v < -this.limit / 2 && (r = r + this.limit)
                    }
                } else
                    r = e5(0, r, this.limit);
                if (r === this.targetScroll) {
                    l == null || l(this),
                    u == null || u(this);
                    return
                }
                if (this.userData = g ?? {},
                t) {
                    this.animatedScroll = this.targetScroll = r,
                    this.setScroll(this.scroll),
                    this.reset(),
                    this.preventNextNativeScrollEvent(),
                    this.emit(),
                    u == null || u(this),
                    this.userData = {},
                    requestAnimationFrame( () => {
                        this.dispatchScrollendEvent()
                    }
                    );
                    return
                }
                d || (this.targetScroll = r),
                typeof i == "number" && typeof a != "function" ? a = DN : typeof a == "function" && typeof i != "number" && (i = 1),
                this.animate.fromTo(this.animatedScroll, r, {
                    duration: i,
                    easing: a,
                    lerp: s,
                    onStart: () => {
                        n && (this.isLocked = !0),
                        this.isScrolling = "smooth",
                        l == null || l(this)
                    }
                    ,
                    onUpdate: (v, y) => {
                        this.isScrolling = "smooth",
                        this.lastVelocity = this.velocity,
                        this.velocity = v - this.animatedScroll,
                        this.direction = Math.sign(this.velocity),
                        this.animatedScroll = v,
                        this.setScroll(this.scroll),
                        d && (this.targetScroll = v),
                        y || this.emit(),
                        y && (this.reset(),
                        this.emit(),
                        u == null || u(this),
                        this.userData = {},
                        requestAnimationFrame( () => {
                            this.dispatchScrollendEvent()
                        }
                        ),
                        this.preventNextNativeScrollEvent())
                    }
                })
            }
        }
    }
    preventNextNativeScrollEvent() {
        this._preventNextNativeScrollEvent = !0,
        requestAnimationFrame( () => {
            this._preventNextNativeScrollEvent = !1
        }
        )
    }
    checkNestedScroll(r, {deltaX: e, deltaY: t}) {
        const n = Date.now()
          , i = r._lenis ?? (r._lenis = {});
        let a, s, l, u, f, d, g, v;
        const y = this.options.gestureOrientation;
        if (n - (i.time ?? 0) > 2e3) {
            i.time = Date.now();
            const O = window.getComputedStyle(r);
            i.computedStyle = O;
            const L = O.overflowX
              , z = O.overflowY;
            if (a = ["auto", "overlay", "scroll"].includes(L),
            s = ["auto", "overlay", "scroll"].includes(z),
            i.hasOverflowX = a,
            i.hasOverflowY = s,
            !a && !s || y === "vertical" && !s || y === "horizontal" && !a)
                return !1;
            f = r.scrollWidth,
            d = r.scrollHeight,
            g = r.clientWidth,
            v = r.clientHeight,
            l = f > g,
            u = d > v,
            i.isScrollableX = l,
            i.isScrollableY = u,
            i.scrollWidth = f,
            i.scrollHeight = d,
            i.clientWidth = g,
            i.clientHeight = v
        } else
            l = i.isScrollableX,
            u = i.isScrollableY,
            a = i.hasOverflowX,
            s = i.hasOverflowY,
            f = i.scrollWidth,
            d = i.scrollHeight,
            g = i.clientWidth,
            v = i.clientHeight;
        if (!a && !s || !l && !u || y === "vertical" && (!s || !u) || y === "horizontal" && (!a || !l))
            return !1;
        let S;
        if (y === "horizontal")
            S = "x";
        else if (y === "vertical")
            S = "y";
        else {
            const O = e !== 0
              , L = t !== 0;
            O && a && l && (S = "x"),
            L && s && u && (S = "y")
        }
        if (!S)
            return !1;
        let T, M, b, A, C;
        if (S === "x")
            T = r.scrollLeft,
            M = f - g,
            b = e,
            A = a,
            C = l;
        else if (S === "y")
            T = r.scrollTop,
            M = d - v,
            b = t,
            A = s,
            C = u;
        else
            return !1;
        return (b > 0 ? T < M : T > 0) && A && C
    }
    get rootElement() {
        return this.options.wrapper === window ? document.documentElement : this.options.wrapper
    }
    get limit() {
        return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
    }
    get isHorizontal() {
        return this.options.orientation === "horizontal"
    }
    get actualScroll() {
        const r = this.options.wrapper;
        return this.isHorizontal ? r.scrollX ?? r.scrollLeft : r.scrollY ?? r.scrollTop
    }
    get scroll() {
        return this.options.infinite ? rne(this.animatedScroll, this.limit) : this.animatedScroll
    }
    get progress() {
        return this.limit === 0 ? 1 : this.scroll / this.limit
    }
    get isScrolling() {
        return this._isScrolling
    }
    set isScrolling(r) {
        this._isScrolling !== r && (this._isScrolling = r,
        this.updateClassName())
    }
    get isStopped() {
        return this._isStopped
    }
    set isStopped(r) {
        this._isStopped !== r && (this._isStopped = r,
        this.updateClassName())
    }
    get isLocked() {
        return this._isLocked
    }
    set isLocked(r) {
        this._isLocked !== r && (this._isLocked = r,
        this.updateClassName())
    }
    get isSmooth() {
        return this.isScrolling === "smooth"
    }
    get className() {
        let r = "lenis";
        return this.options.autoToggle && (r += " lenis-autoToggle"),
        this.isStopped && (r += " lenis-stopped"),
        this.isLocked && (r += " lenis-locked"),
        this.isScrolling && (r += " lenis-scrolling"),
        this.isScrolling === "smooth" && (r += " lenis-smooth"),
        r
    }
    updateClassName() {
        this.cleanUpClassName(),
        this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim()
    }
    cleanUpClassName() {
        this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, "").trim()
    }
}
;
bg.registerPlugin(jn);
const cne = de.createContext()
  , fne = ({children: r}) => {
    const e = de.useRef(null);
    return de.useEffect( () => (e.current = new une({
        duration: 1.2,
        easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
        direction: "vertical",
        smoothWheel: !0,
        smoothTouch: !1,
        touchMultiplier: 2
    }),
    e.current.on("scroll", jn.update),
    bg.ticker.add(t => {
        e.current.raf(t * 1e3)
    }
    ),
    bg.ticker.lagSmoothing(0),
    () => {
        e == null || e.current.destroy()
    }
    ), []),
    ae.jsx(cne.Provider, {
        value: {
            lenis: e.current
        },
        children: r
    })
}
  , hne = () => ae.jsxs(ae.Fragment, {
    children: [ae.jsx(e7, {}), ae.jsxs(_G, {
        children: [ae.jsx(jm, {
            path: "/",
            element: ae.jsx(lte, {})
        }), ae.jsx(jm, {
            path: "/team",
            element: ae.jsx(wte, {})
        }), ae.jsx(jm, {
            path: "/projects",
            element: ae.jsx(Vte, {})
        }), ae.jsx(jm, {
            path: "/experience",
            element: ae.jsx(Hte, {})
        }), ae.jsx(jm, {
            path: "/fun",
            element: ae.jsx(ene, {})
        })]
    })]
})
  , dne = () => ae.jsx(fne, {
    children: ae.jsx(GG, {
        children: ae.jsx(hne, {})
    })
});
$5.createRoot(document.getElementById("root")).render(ae.jsx(dne, {}));
